
ASEM-51 V1.3                              Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 1





       MCS-51 Family Macro Assembler   A S E M - 5 1   V 1.3
       =====================================================



	Source File:	tb51a.asm
	Object File:	tb51a.hex
	List File:	tb51a.lst



 Line  I  Addr  Code            Source

    1:				;	$MOD52
    2:					$NODEBUG
    3:		N      0078		$PAGEWIDTH	(120)
    4:		N      0042		$PAGELENGTH	(66)
    5:					$TITLE          (Tiny-Basic51 - Modified for Metalink ASM51)
    6:
    7:					$NOMOD51
    8:					$INCLUDE (80515.MCU)
    9: 1			;   80515 processor definition file
   10: 1			;   ===============================
   11: 1
   12: 1	N	 80	P0	DATA	080H
   13: 1	N	 81	SP	DATA	081H
   14: 1	N	 82	DPL	DATA	082H
   15: 1	N	 83	DPH	DATA	083H
   16: 1	N	 87	PCON	DATA	087H
   17: 1	N	 88	TCON	DATA	088H
   18: 1	N	 89	TMOD	DATA	089H
   19: 1	N	 8A	TL0	DATA	08AH
   20: 1	N	 8B	TL1	DATA	08BH
   21: 1	N	 8C	TH0	DATA	08CH
   22: 1	N	 8D	TH1	DATA	08DH
   23: 1	N	 90	P1	DATA	090H
   24: 1	N	 98	SCON	DATA	098H
   25: 1	N	 99	SBUF	DATA	099H
   26: 1	N	 A0	P2	DATA	0A0H
   27: 1	N	 A8	IEN0	DATA	0A8H
   28: 1	N	 A9	IP0	DATA	0A9H
   29: 1	N	 B0	P3	DATA	0B0H
   30: 1	N	 B8	IEN1	DATA	0B8H
   31: 1	N	 B9	IP1	DATA	0B9H
   32: 1	N	 C0	IRCON	DATA	0C0H
   33: 1	N	 C1	CCEN	DATA	0C1H
   34: 1	N	 C2	CCL1	DATA	0C2H
   35: 1	N	 C3	CCH1	DATA	0C3H
   36: 1	N	 C4	CCL2	DATA	0C4H
   37: 1	N	 C5	CCH2	DATA	0C5H
   38: 1	N	 C6	CCL3	DATA	0C6H
   39: 1	N	 C7	CCH3	DATA	0C7H
   40: 1	N	 C8	T2CON	DATA	0C8H
   41: 1	N	 CA	CRCL	DATA	0CAH
   42: 1	N	 CB	CRCH	DATA	0CBH
   43: 1	N	 CC	TL2	DATA	0CCH
   44: 1	N	 CD	TH2	DATA	0CDH
   45: 1	N	 D0	PSW	DATA	0D0H

ASEM-51 V1.3                              Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 2



 Line  I  Addr  Code            Source

   46: 1	N	 D8	ADCON	DATA	0D8H
   47: 1	N	 D9	ADDAT	DATA	0D9H
   48: 1	N	 DA	DAPR	DATA	0DAH
   49: 1	N	 E0	ACC	DATA	0E0H
   50: 1	N	 E8	P4	DATA	0E8H
   51: 1	N	 F0	B	DATA	0F0H
   52: 1	N	 F8	P5	DATA	0F8H
   53: 1
   54: 1	N	 88	IT0	BIT	088H
   55: 1	N	 89	IE0	BIT	089H
   56: 1	N	 8A	IT1	BIT	08AH
   57: 1	N	 8B	IE1	BIT	08BH
   58: 1	N	 8C	TR0	BIT	08CH
   59: 1	N	 8D	TF0	BIT	08DH
   60: 1	N	 8E	TR1	BIT	08EH
   61: 1	N	 8F	TF1	BIT	08FH
   62: 1	N	 90	INT3CC0	BIT	090H
   63: 1	N	 91	INT4CC1	BIT	091H
   64: 1	N	 92	INT5CC2	BIT	092H
   65: 1	N	 93	INT6CC3	BIT	093H
   66: 1	N	 94	INT2	BIT	094H
   67: 1	N	 95	T2EX	BIT	095H
   68: 1	N	 96	CLKOUT	BIT	096H
   69: 1	N	 97	T2	BIT	097H
   70: 1	N	 98	RI	BIT	098H
   71: 1	N	 99	TI	BIT	099H
   72: 1	N	 9A	RB8	BIT	09AH
   73: 1	N	 9B	TB8	BIT	09BH
   74: 1	N	 9C	REN	BIT	09CH
   75: 1	N	 9D	SM2	BIT	09DH
   76: 1	N	 9E	SM1	BIT	09EH
   77: 1	N	 9F	SM0	BIT	09FH
   78: 1	N	 A8	EX0	BIT	0A8H
   79: 1	N	 A9	ET0	BIT	0A9H
   80: 1	N	 AA	EX1	BIT	0AAH
   81: 1	N	 AB	ET1	BIT	0ABH
   82: 1	N	 AC	ES	BIT	0ACH
   83: 1	N	 AD	ET2	BIT	0ADH
   84: 1	N	 AE	WDT	BIT	0AEH
   85: 1	N	 AF	EAL	BIT	0AFH
   86: 1	N	 B0	RXD	BIT	0B0H
   87: 1	N	 B1	TXD	BIT	0B1H
   88: 1	N	 B2	INT0	BIT	0B2H
   89: 1	N	 B3	INT1	BIT	0B3H
   90: 1	N	 B4	T0	BIT	0B4H
   91: 1	N	 B5	T1	BIT	0B5H
   92: 1	N	 B6	WR	BIT	0B6H
   93: 1	N	 B7	RD	BIT	0B7H
   94: 1	N	 B8	EADC	BIT	0B8H
   95: 1	N	 B9	EX2	BIT	0B9H
   96: 1	N	 BA	EX3	BIT	0BAH
   97: 1	N	 BB	EX4	BIT	0BBH
   98: 1	N	 BC	EX5	BIT	0BCH
   99: 1	N	 BD	EX6	BIT	0BDH
  100: 1	N	 BE	SWDT	BIT	0BEH
  101: 1	N	 BF	EXEN2	BIT	0BFH
  102: 1	N	 C0	IADC	BIT	0C0H
  103: 1	N	 C1	IEX2	BIT	0C1H

ASEM-51 V1.3                              Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 3



 Line  I  Addr  Code            Source

  104: 1	N	 C2	IEX3	BIT	0C2H
  105: 1	N	 C3	IEX4	BIT	0C3H
  106: 1	N	 C4	IEX5	BIT	0C4H
  107: 1	N	 C5	IEX6	BIT	0C5H
  108: 1	N	 C6	TF2	BIT	0C6H
  109: 1	N	 C7	EXF2	BIT	0C7H
  110: 1	N	 C8	T2I0	BIT	0C8H
  111: 1	N	 C9	T2I1	BIT	0C9H
  112: 1	N	 CA	T2CM	BIT	0CAH
  113: 1	N	 CB	T2R0	BIT	0CBH
  114: 1	N	 CC	T2R1	BIT	0CCH
  115: 1	N	 CD	I2FR	BIT	0CDH
  116: 1	N	 CE	I3FR	BIT	0CEH
  117: 1	N	 CF	T2PS	BIT	0CFH
  118: 1	N	 D0	P	BIT	0D0H
  119: 1	N	 D1	F1	BIT	0D1H
  120: 1	N	 D2	OV	BIT	0D2H
  121: 1	N	 D3	RS0	BIT	0D3H
  122: 1	N	 D4	RS1	BIT	0D4H
  123: 1	N	 D5	F0	BIT	0D5H
  124: 1	N	 D6	AC	BIT	0D6H
  125: 1	N	 D7	CY	BIT	0D7H
  126: 1	N	 D8	MX0	BIT	0D8H
  127: 1	N	 D9	MX1	BIT	0D9H
  128: 1	N	 DA	MX2	BIT	0DAH
  129: 1	N	 DB	ADM	BIT	0DBH
  130: 1	N	 DC	BSY	BIT	0DCH
  131: 1	N	 DE	CLK	BIT	0DEH
  132: 1	N	 DF	BD	BIT	0DFH
  133: 1
  134: 1	N      0000	RESET	CODE	000H
  135: 1	N      0003	EXTI0	CODE	003H
  136: 1	N      000B	TIMER0	CODE	00BH
  137: 1	N      0013	EXTI1	CODE	013H
  138: 1	N      001B	TIMER1	CODE	01BH
  139: 1	N      0023	SINT	CODE	023H
  140: 1	N      002B	TIMER2	CODE	02BH
  141: 1	N      0043	ADCONV	CODE	043H
  142: 1	N      004B	EXTI2	CODE	04BH
  143: 1	N      0053	EXTI3	CODE	053H
  144: 1	N      005B	EXTI4	CODE	05BH
  145: 1	N      0063	EXTI5	CODE	063H
  146: 1	N      006B	EXTI6	CODE	06BH
  147:
  148:				LIT_    MACRO   K
  149:					CALL	LIT
  150:					DB	K
  151:					ENDM
  152:
  153:				TSTV_   MACRO   LBL
  154:				        CALL    TSTV
  155:				        JNC     LBL
  156:				        ENDM
  157:
  158:				TSTN_   MACRO   LBL
  159:				        CALL    TSTN
  160:				        JNC     LBL
  161:				        ENDM

ASEM-51 V1.3                              Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 4



 Line  I  Addr  Code            Source

  162:
  163:				TSTL_   MACRO   LBL
  164:				        CALL    TSTN
  165:				        JNC     LBL
  166:				        ENDM
  167:
  168:				TSTS_   MACRO   LBL
  169:				        CALL    TSTS
  170:				        JC      LBL
  171:				        ENDM
  172:
  173:				IFDONE_ MACRO   LBL
  174:				        CALL    IFDONE
  175:				        JNC     LBL
  176:				        ENDM
  177:
  178:				LINIT_  MACRO
  179:				        CALL   L_INIT
  180:				        JC      ERRENT
  181:				        ENDM
  182:
  183:				COND_   MACRO   LBL
  184:				        CALL   COND
  185:				        JNC    LBL
  186:				        ENDM
  187:
  188:				NEXT_LOOP_       MACRO   LBL
  189:				        CALL   LOOP
  190:				        JC     LBL
  191:				        ENDM
  192:
  193:				IJMP_   MACRO   LBL
  194:				        JMP     LBL
  195:				        ENDM
  196:
  197:				HOP_    MACRO   LBL
  198:				        SJMP    LBL
  199:				        ENDM
  200:
  201:				ICALL_  MACRO   LBL
  202:				        CALL    LBL
  203:				        ENDM
  204:
  205:				MLCALL_ MACRO
  206:				        CALL    MLCALL
  207:				        ANL     PSW,#11100111B
  208:				        ENDM
  209:
  210:
  211:				;$ERRORPRINT TITLE(MCS-51(TM) TINY BASIC INTERPRETER 8/26/80)
  212:				;
  213:				;	TINY BASIC INTERPRETER PROGRAM  (CREATED 3/10/80   JHW)
  214:				;	==============================
  215:				;
  216:				;	INSITE ORDER NO. BF10
  217:				;
  218:		N      0023	VERS    EQU     23H
  219:				;

ASEM-51 V1.3                              Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 5



 Line  I  Addr  Code            Source

  220:				; Known Update History:
  221:				; Modified from 2.1 to 2.2 by lss 4 jan 1983 to fix errors in the divide routine; and th
				e random number generator.
  222:				; Updated: Jim Lum/CompTech Systems, Inc. 04/25/92  V2.3  Converted to Metalink ASM51
  223:				;
  224:				;
  225:				;	STATUS:
  226:				;	======
  227:				;
  228:				;
  229:				;	NEW FEATURES/GIMMICKS TO BE CONSIDERED:
  230:				;
  231:				;	On power-up, system should adapt itself to whatever RAM it can
  232:				;	find off-chip.
  233:				;	Should allow for and/or identify multiple baud rates for serial link.
  234:				;	Should allow other physical devices (software serial I/O, etc.).
  235:				;
  236:				;	Amount of RAM consumed by BASIC variables should be user-alterable.
  237:				;	16-bit variable array handling should be provided when external RAM
  238:				;	is available.
  239:				;	Program buffering in internal RAM and/or line buffering in external RAM
  240:				;	(when available/not available) might be nice.
  241:				;
  242:				;	INNUM could be changed to allow line editing and expression input.
  243:				;
  244:				;	Interrupt handlers should be provided for, and supported by strapping
  245:				;	options so that CRT is not required.
  246:				;
  247:				;	Symbolically-accessable 8-bit pseudo CPU-registers, ports,
  248:				;	etc. desired to support ML debug.
  249:				;	During CALL, pseudo-registers should be loaded/saved.
  250:				;
  251:				;	Capability to load and dump programs to MDS or twin system desired.
  252:				;	Download command desired compatible with ISIS hex file format.
  253:				;	Line buffering should ignore initial line-feed to be compatible
  254:				;	with down-load or cross-load, and terminate on <cntrl-Z>.
  255:				;
  256:				;	Expression evaluation algorithm should be changed to use less stack
  257:				;	and allow more precedence levels.
  258:				;	Since EXPR recursive, hardware stack can overflow (not checked).
  259:				;
  260:				;	NEXT command should verify that a valid loop record is on the AES
  261:				;	as opposed to GOSUB return address, and vice-versa.
  262:				;	STEP values other than +1 should be considered.
  263:				;
  264:				;	Error reporting could re-type line and indicate error point.
  265:				;	Error numbers (if retained) should make some sense.
  266:				;	Might be indices for error message strings.
  267:				;
  268:				;	TRACE mode could aid BASIC debug by typing each source line # executed.
  269:				;
  270:				;	RND number seed should be easily alterable for games, etc.
  271:				;
  272:				;$EJECT
  273:				;
  274:				;	AESTHETIC IMPROVEMENTS DESIRED:
  275:				;
  276:				;	Disallow 0 and >7FFFH line numbers.

ASEM-51 V1.3                              Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 6



 Line  I  Addr  Code            Source

  277:				;
  278:				;	Source modules could be re-grouped to be more readable
  279:				;	and re-ordered to minimize use of LJMPs and LCALLs.
  280:				;	Linkage jumps might be created in second 2K page to provide efficient
  281:				;	access to first 2K.
  282:				;
  283:				;	PRN could insert zeros before leading Hex digits.
  284:				;
  285:				;	IDIV uses variable storage inefficiently (TMP0-TMP4).
  286:				;	Should be modified to make use of actual stack variables.
  287:				;
  288:				;	TST could use optimized algorithm for single character token tests.
  289:				;	String tests should skip over unsearched strings more efficiently.
  290:				;
  291:				;	Program buffer searching could be speeded by giving line length
  292:				;	before text string and computing branch over undesired lines.
  293:				;
  294:				;	Math and AES operations might be optimized by dedicating R1 as AESP
  295:				;	to be loaded and saved only on entering/leaving execution mode.
  296:				;
  297:				;	Input radix should be determined by 'H' suffix presence.
  298:				;	Otherwise labels (GOTO destinations) should always be decimal.
  299:				;
  300:				;	Space between GO and TO might be forgiven.
  301:				;
  302:				;	Certain commands might be disallowed in each operating mode:
  303:				;	No LIST in execution, no INPUT in interactive, for instance.
  304:				;	Some commands (FOR, GOTO, RETURN, etc.) must be last command in line.
  305:				;
  306:				;	GETLN could be made somewhat more abstract, so that L_INIT and READ_C
  307:				;	return characters from edited line buffer in interactive mode and
  308:				;	code buffer in execution mode.  Dual execution loops in main IL program
  309:				;	can then be combined.  (Line insertion should default when no keyword
  310:				;	tokens would be detected during parsing.)
  311:				;
  312:				;	Get rid of LIST and FNDLBL kludge which falsely sets RUNFLG to fool
  313:				;	READ_C subroutine.
  314:				;
  315:				;	Sequential string testing (command parsing, operator recognition, etc.)
  316:				;	could be made table-driven, eliminating repeated "CALL TST"s.
  317:				;
  318:				;	All data structures need to be better defined in listing.
  319:				;	It would be a wise exercize to gather each
  320:				;	data-structure definition/declaration/accessing-routine set
  321:				;	into isolated functional modules (like objects),
  322:				;	with communication only via global variables.
  323:
  324:				;
  325:				;$EJECT
  326:				;
  327:				;	GLOBAL VARIABLE AND DATA STRUCTURE DECLARATIONS:
  328:				;	====== ======== === ==== ========= ============
  329:				;
  330:				;	Intended System Configuration Constants:
  331:				;
  332:		N      9034	EXTRAM		EQU	2034H+7000H		;External program buffer begins after 26
				 vars.
  333:		N      A000	RAMLIM		EQU	3000H+7000H		;Allowance made for 4K RAM buffer.

ASEM-51 V1.3                              Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 7



 Line  I  Addr  Code            Source

  334:		N      C080	EXTROM		EQU	9080H+3000H		;Start of external ROM space.
  335:		N      0008	TABSIZ		EQU	8			;Formatted column spacing.
  336:		N      0024	AESLEN		EQU	36			;AES Length.
  337:				;
  338:				;	Working Register Definitions.
  339:				;
  340:		R	 R0	PNTR_L		EQU	R0			;Program buffer pointer.
  341:		R	 R1	DEST_L		EQU	R1			;Destination pointer for line insertion.
  342:		R	 R2	PNTR_H		EQU	R2			;High-order pointer byte (temp. cursor)
  343:		R	 R3	DEST_H		EQU	R3
  344:		R	 R4	CHAR		EQU	R4			;BASIC source string character being par
				sed.
  345:		R	 R5	LP_CNT		EQU	R5
  346:		R	 R6	TOS_L		EQU	R6
  347:		R	 R7	TOS_H		EQU	R7			;Variable popped from stack for math rou
				tines.
  348:				;
  349:					DSEG
  350:
  351:		N	 20		ORG 20H
  352:	    20	N	 01	MODE:		DS	1		;Operating mode bits.
  353:		B	 00	EXTVAR		BIT	MODE.0		;Set when BASIC variables in external RAM.
  354:		B	 01	ROMMOD		BIT	MODE.1		;Set when BASIC programs executed from ROM.
  355:		B	 02	EXTMOD		BIT	MODE.2		;Set when BASIC programs fetched externally.
  356:		B	 03	RUNMOD		BIT	MODE.3		;Set when stored BASIC program is running.
  357:		B	 04	HEXMOD		BIT	MODE.4		;Set when operations should use HEX radix.
  358:				;
  359:	    21	N	 01	FLAGS:		DS	1		;Interroutine communication flags.
  360:		B	 08	ZERSUP		BIT	FLAGS.0		;If set, suppress printing leading zeroes.
  361:		B	 09	CHAR_FLG  	BIT	FLAGS.1		;Set when CHAR has not been processed.
  362:		B	 0A	SGN_FLG		BIT	FLAGS.2		;Keeps track of operand(s) sign during math.
  363:		B	 0B	SEQ_FLG		BIT	FLAGS.3		;
  364:		B	 0C	MOD_FLG		BIT	FLAGS.4		;Set if divide routine should return MOD value.
  365:		B	 0D	H_FLG		BIT	FLAGS.5		;Used to sense allow 'H' suffix in HEX mode.
  366:				;
  367:		N	 30		ORG	30H
  368:				;
  369:				;	Temporary variables used by IDIV routine.
  370:				;
  371:	    30	N	 01	TMP0:		DS	1
  372:	    31	N	 01	TMP1:		DS	1
  373:	    32	N	 01	TMP2:		DS	1
  374:	    33	N	 01	TMP3:		DS	1
  375:	    34	N	 01	TMP4:		DS	1
  376:				;
  377:				;	Random number key.
  378:				;
  379:	    35	N	 01	SEED_L:		DS	1
  380:	    36	N	 01	SEED_H:		DS	1
  381:				;
  382:				;
  383:	    37	N	 01	STRLEN:		DS	1			;Length of text string in L_BUF.
  384:				;
  385:				;US_VAR		User Variable (A,B,...) Array:
  386:				;
  387:		N      000C	NO_VAR		EQU	12			;Allow 12 internal variables A - L.
  388:	    38	N	 18	US_VAR:		DS	2*NO_VAR	;Allocate variable storage space.
  389:				;

ASEM-51 V1.3                              Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 8



 Line  I  Addr  Code            Source

  390:
  391:				;AES	Arithmetic Expression Stack.
  392:				;
  393:	    50	N	 01	AESP:		DS	1			;AES Stack Pointer
  394:	    51	N	 24	AES:		DS	AESLEN		;Buffer allocation.
  395:				;
  396:				;
  397:				;	Line Buffer Variables:
  398:	    75	N	 01	L_CURS:		DS	1			;Cursor for line buffer.
  399:				;
  400:	    76	N	 01	TABCNT:		DS	1			;Column formatting count.
  401:				;
  402:				;CURSOR	Source line cursor.
  403:	    77	N	 01	CURS_L:		DS	1
  404:	    78	N	 01	CURS_H:		DS	1
  405:	    79	N	 01	C_SAVE:		DS	1			;CHAR saved during SAVE_PNTR.
  406:				;
  407:	    7A	N	 01	LABL_L:		DS	1			;BASIC program source line counter.
  408:	    7B	N	 01	LABL_H:		DS	1			;  "       "       "     high byte.
  409:				;
  410:		N      007F	SP_BASE	EQU	7FH				;Initialization value for hardware SP.
  411:				;
  412:		N      000D	CR			EQU	0DH			;ASCII CODE FOR <CARRIAGE RETURN
				>.
  413:		N      000A	LF			EQU	0AH			;  "    "    "  <LINE FEED>.
  414:		N      0007	BEL			EQU	07H			;  "    "    "  <BELL>.
  415:				;
  416:				;$EJECT
  417:				;$SAVE NOGEN
  418:				;
  419:					CSEG
  420:		N      8000		ORG	8000H
  421:	  8000	02 80 03		JMP	S_INIT		;Jump to system initialization routine.
  422:				;
  423:				;	Interrupt routine expansion hooks:
  424:				;	REMOVED
  425:
  426:				;	CONSOLE I/O ROUTINES AND DRIVERS:
  427:				;	======= === ======== === =======
  428:				;
  429:	  8003			S_INIT:
  430:	  8003	E4			CLR		A
  431:	  8004	F5 D0			MOV		PSW,A
  432:	  8006	F5 36			MOV		SEED_H,A
  433:	  8008	F5 35			MOV		SEED_L,A
  434:	  800A	75 81 7F		MOV		SP,#SP_BASE			;Re-initialize hardware stack.
  435:	  800D	12 86 E8		CALL	RAM_INIT			;Clear-out variable RAM.
  436:	  8010			SP_INI:
  437:				;	JNB		RXD, RUNROM
  438:				;	CLR		TR1
  439:				;	MOV		SCON, #01011010B	;TI set indicates transmitter ready.
  440:				;	MOV		TMOD, #00100001B	;Timer 1 is set to auto-reload timer mod
				e.
  441:				;	MOV		TH1, #0				;Assume fastest rate.
  442:				;	MOV		R0, #144
  443:				;	JB		RXD, $
  444:	  8010			BAUDID:
  445:				;	DJNZ	R0,$

ASEM-51 V1.3                              Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 9



 Line  I  Addr  Code            Source

  446:				;	DEC		TH1
  447:				;	MOV		R0, #94
  448:				;	JNB		RXD, BAUDID
  449:				;	JB		RXD, $		;Hang-up here until space char. over.
  450:				;	JNB		RXD, $
  451:				;	SETB	TR1
  452:	  8010	12 80 BF		CALL	STROUT
  453:	  8013	0D 4D 43 53		DB      CR,'MCS-51 TINY BASIC/Metalink-Compatible Source V'
	  8017	2D 35 31 20
	  801B	54 49 4E 59
	  801F	20 42 41 53
	  8023	49 43 2F 4D
	  8027	65 74 61 6C
	  802B	69 6E 6B 2D
	  802F	43 6F 6D 70
	  8033	61 74 69 62
	  8037	6C 65 20 53
	  803B	6F 75 72 63
	  803F	65 20 56
  454:	  8042	32 2E 33 8D		DB      ('0'+VERS/10H),'.',('0'+(VERS AND 0FH)),(CR OR 80H)
  455:	  8046	02 88 2F		JMP		START
  456:				;
  457:	  8049			RUNROM:
  458:	  8049	D2 02			SETB	EXTMOD
  459:				;	SETB	ROMMOD
  460:	  804B	C2 01			CLR	ROMMOD
  461:	  804D	02 88 50		JMP		XEC
  462:				;
  463:				;=======
  464:				;
  465:	  8050			C_IN:
  466:				;	Console character input routine.
  467:				;	Waits for next input from console device and returns with character
  468:				;	code in accumulator.
  469:				;	If character is <CNTRL-C> process syntax error.
  470:				;	Adjust lower-case alphabetics to upper case.
  471:				;
  472:	  8050			DD005:
  473:	  8050	30 98 FD		JNB     RI,$            ;Wait until character received.
  474:	  8053	E5 99			MOV     A,SBUF          ;Read input character.
  475:	  8055	C2 98			CLR		RI				;Clear reception flag.
  476:	  8057	54 7F			ANL		A,#7FH			;Mask off data bits.
  477:	  8059	B4 03 03		CJNE	A,#03H,C_IN_2	;Test for CNTRL-C code.
  478:	  805C	02 80 E8		JMP		SYN_ER			;Abort if detected.
  479:				;
  480:	  805F			C_IN_2:
  481:	  805F	B4 61 00		CJNE	A,#'a',$+3		;Check for lower-case alphabetics.
  482:	  8062	40 07			JC		C_IN_1
  483:	  8064	B4 7B 00		CJNE	A,#'z'+1,$+3
  484:	  8067	50 02			JNC		C_IN_1
  485:	  8069	54 DF			ANL		A,#11011111B	;Force upper-case code.
  486:	  806B			C_IN_1:
  487:	  806B	22			RET						;Return to calling routine.
  488:				;
  489:				;=======
  490:				;
  491:				;
  492:	  806C			NLINE:

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 10



 Line  I  Addr  Code            Source

  493:				;	Transmit <CR><LF> sequence to console device.
  494:				;
  495:	  806C	74 0D			MOV	A,#CR
  496:	  806E			C_OUT:
  497:				;	Console character output routine.
  498:				;	Outputs character received in accumulator to console output device.
  499:				;
  500:	  806E			DD006:
  501:	  806E	30 99 FD		JNB     TI,$            ;Wait until transmission completed.
  502:	  8071			DD007:
  503:	  8071	C2 99			CLR     TI              ;Clear interrupt flag.
  504:	  8073	F5 99			MOV		SBUF,A			;Write out character.
  505:	  8075	B4 0D 0A		CJNE	A,#CR,COUT_2
  506:	  8078			DD008:
  507:	  8078	30 99 FD		JNB     TI,$
  508:	  807B			DD009:
  509:	  807B	C2 99			CLR     TI
  510:	  807D	75 99 0A		MOV		SBUF,#LF		;Output linefeed.
  511:	  8080	80 04			SJMP	COUT_3
  512:				;
  513:	  8082	C3		COUT_2:	CLR	C
  514:	  8083	D5 76 04		DJNZ	TABCNT,COUT_1	;Monitor output field position.
  515:	  8086	75 76 08	COUT_3:	MOV	TABCNT,#TABSIZ	;Reload field counter.
  516:	  8089	D3			SETB	C
  517:	  808A	22		COUT_1:	RET
  518:				;
  519:				;=======
  520:				;
  521:				;
  522:	  808B			CNTRL:
  523:	  808B	30 98 0A		JNB		RI,CNTRET		;Poll whether character has been typed.
  524:	  808E	11 50			CALL	C_IN
  525:	  8090	B4 13 05		CJNE	A,#13H,CNTRET	;Check if char. is <CNTRL-S>.
  526:	  8093			CNTR_2:
  527:	  8093	11 50			CALL	C_IN			;If so, hang up...
  528:	  8095	B4 11 FB		CJNE	A,#11H,CNTR_2	;    ...until <CNTRL-Q> received.
  529:	  8098			CNTRET:
  530:	  8098	22			RET
  531:				;
  532:				;=======
  533:				;
  534:				;
  535:	  8099			SPC:
  536:				;	Transmit one or more space characters to console to move console
  537:				;	cursor to start of next field.
  538:				;
  539:	  8099	74 20			MOV		A,#' '			;Load ASCII code for space character.
  540:	  809B	11 6E			CALL	C_OUT
  541:	  809D	50 FA			JNC		SPC				;Repeat until at TAB boundary.
  542:	  809F	22			RET
  543:				;
  544:				;===============
  545:				;
  546:				;NIBOUT
  547:				;	If low-order nibble in Acc. is non-zero or ZERSUP flag is cleared,
  548:				;	output the corresponding ASCII value and clear ZERSUP flag.
  549:				;	Otherwise return without affecting output or ZERSUP.
  550:				;

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 11



 Line  I  Addr  Code            Source

  551:	  80A0	54 0F		NIBOUT:	ANL	A,#0FH		;Mask out low-order bits.
  552:	  80A2	70 03			JNZ	NIBO_2		;Output ASCII code for Acc contents.
  553:	  80A4	20 08 07		JB	ZERSUP,NIBO_3
  554:	  80A7	C2 08		NIBO_2:	CLR	ZERSUP		;Mark that non-zero character encountered.
  555:	  80A9	24 03			ADD	A,#(ASCTBL-(NIBO_1+1))	;Offset to start of table.
  556:	  80AB	83		NIBO_1:	MOVC	A,@A+PC		;Look up corresponding code.
  557:	  80AC	11 6E			CALL	C_OUT		;Output character.
  558:	  80AE	22		NIBO_3:	RET
  559:				;
  560:	  80AF	30 31 32 33	ASCTBL:	DB	'0123456789ABCDEF'
	  80B3	34 35 36 37
	  80B7	38 39 41 42
	  80BB	43 44 45 46
  561:				;
  562:				;=======
  563:				;
  564:				;STROUT
  565:				;	Copy in-line character string to console output device.
  566:				;
  567:	  80BF	D0 83		STROUT:	POP	DPH		;Access in-line string.
  568:	  80C1	D0 82			POP	DPL
  569:	  80C3	E4		STRO_1:	CLR	A
  570:	  80C4	93			MOVC	A,@A+DPTR	;Read next byte.
  571:	  80C5	A3			INC	DPTR		;Bump pointer.
  572:	  80C6	10 E7 04		JBC	ACC.7,STRO_2	;Escape after last character.
  573:	  80C9	11 6E			CALL	C_OUT		;Output character.
  574:	  80CB	80 F6			SJMP	STRO_1		;Loop until done.
  575:				;
  576:	  80CD	11 6E		STRO_2:	CALL	C_OUT		;Output character.
  577:	  80CF	E4			CLR	A
  578:	  80D0	73			JMP	@A+DPTR		;Return to program.
  579:				;
  580:				;=======
  581:				;$EJECT
  582:	  80D1			ERROUT:
  583:				;	Error handling routine common entry point.
  584:				;	(Could retype bad line, etc.)
  585:				;
  586:	  80D1	02 88 32		JMP	ERRENT		;Return to executive.
  587:				;
  588:				;=======
  589:				;
  590:				;EXP_ER	Expression evaluation error.
  591:	  80D4	11 BF		EXP_ER:	CALL	STROUT		;Output error message.
  592:	  80D6	48 4F 57 3F	        DB      'HOW?',(CR OR 80H)
	  80DA	8D
  593:	  80DB	80 F4			JMP	ERROUT		;Return to executive.
  594:				;
  595:				;=======
  596:				;
  597:				;AES_ER	Arithmetic expression stack error handling routine.
  598:	  80DD	11 BF		AES_ER:	CALL	STROUT		;Output error message.
  599:	  80DF	53 4F 52 52	        DB      'SORRY!',(CR OR 80H)
	  80E3	59 21 8D
  600:	  80E6	80 E9			JMP	ERROUT		;Return to executive.
  601:				;
  602:				;
  603:				;=======

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 12



 Line  I  Addr  Code            Source

  604:				;
  605:				;SYN_ER	Syntax error handling routine.
  606:	  80E8	11 BF		SYN_ER:	CALL	STROUT		;Output error message.
  607:	  80EA	0D 57 48 41	        DB      CR,'WHAT?',(CR OR 80H)
	  80EE	54 3F 8D
  608:	  80F1	80 DE			JMP	ERROUT		;Process error.
  609:				;
  610:				;=======
  611:				;$EJECT
  612:
  613:				;
  614:				;	ARITHMETIC SUBROUTINE PACKAGE  (8/12/80)
  615:				;
  616:				;=======
  617:				;
  618:	  80F3			POP_TOS:
  619:				;	Verify that stack holds at least one (16-bit) entry.
  620:				;	(Call AES_ER otherwise.)
  621:				;	Pop TOS into registers TOS_H and TOS_L,
  622:				;	update AESP,
  623:				;	and return with R1 pointing to low-order byte of previous NOS.
  624:				;	Do not affect accumulator contents.
  625:				;
  626:	  80F3	A9 50			MOV	R1,AESP
  627:	  80F5	B9 52 00		CJNE	R1,#AES+1,$+3	;Compare pointer with min. legal level.
  628:	  80F8	40 21			JC	STK_ER
  629:	  80FA	FE			MOV	TOS_L,A
  630:	  80FB	E7			MOV	A,@R1
  631:	  80FC	FF			MOV	TOS_H,A
  632:	  80FD	19			DEC	R1
  633:	  80FE	E7			MOV	A,@R1
  634:	  80FF	CE			XCH	A,TOS_L		;Store byte and reload ACC.
  635:	  8100	19			DEC	R1
  636:	  8101	89 50			MOV	AESP,R1
  637:	  8103	19			DEC	R1
  638:	  8104	22			RET
  639:				;
  640:				;=======
  641:				;
  642:	  8105			POP_ACC:
  643:				;	Pop TOS into accumulator and update AESP.
  644:				;
  645:	  8105	A9 50			MOV	R1,AESP
  646:	  8107	E7			MOV	A,@R1
  647:	  8108	15 50			DEC	AESP
  648:	  810A	22			RET
  649:				;
  650:				;=======
  651:				;
  652:	  810B			PUSH_TOS:
  653:				;	Verify that the AES is not full,
  654:				;	push registers TOS_H and TOS_L onto AES,
  655:				;	and update AESP.
  656:				;
  657:	  810B	A9 50			MOV	R1,AESP
  658:	  810D	B9 73 00		CJNE	R1,#AES+AESLEN-2,$+3	;Compare pointer with max. legal level.
  659:	  8110	50 09			JNC	STK_ER
  660:	  8112	09			INC	R1

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 13



 Line  I  Addr  Code            Source

  661:	  8113	EE			MOV	A,TOS_L		;Push low-order byte.
  662:	  8114	F7			MOV	@R1,A
  663:	  8115	09			INC	R1
  664:	  8116	EF			MOV	A,TOS_H		;Push high-order byte.
  665:	  8117	F7			MOV	@R1,A
  666:	  8118	89 50			MOV	AESP,R1
  667:	  811A	22			RET
  668:				;
  669:	  811B	11 DD		STK_ER:	CALL	AES_ER
  670:	  811D	0F			DB	0FH
  671:				;
  672:				;=======
  673:				;
  674:				;
  675:	  811E			DUPL:
  676:				;	Verify that the AES is not full,
  677:				;	then duplicate the top element and update AESP.
  678:				;
  679:	  811E	A9 50			MOV	R1,AESP
  680:	  8120	B9 73 00		CJNE	R1,#AES+AESLEN-2,$+3	;Compare pointer with max. legal level.
  681:	  8123	50 F6			JNC	STK_ER
  682:	  8125	19			DEC	R1
  683:	  8126	E7			MOV	A,@R1
  684:	  8127	09			INC	R1
  685:	  8128	87 F0			MOV	B,@R1
  686:	  812A	09			INC	R1
  687:	  812B	F7			MOV	@R1,A			;Push low-order byte.
  688:	  812C	09			INC	R1
  689:	  812D	A7 F0			MOV	@R1,B
  690:	  812F	89 50			MOV	AESP,R1
  691:	  8131	22			RET
  692:				;
  693:				;=======
  694:				;
  695:				;LIT	(K)
  696:				;	Report error if arithmetic expression stack is full.
  697:				;	Otherwise push the one-byte constant K onto AES.
  698:				;	Return with carry=1, since LIT marks a successful match.
  699:				;
  700:	  8132	D0 83		LIT:	POP	DPH		;Get parameter address.
  701:	  8134	D0 82			POP	DPL
  702:	  8136	E4			CLR	A
  703:	  8137	93			MOVC	A,@A+DPTR	;Read literal value.
  704:	  8138	05 50			INC	AESP		;Reserve storage on top of AES.
  705:	  813A	A9 50			MOV	R1,AESP		;Point to free entry on stack.
  706:	  813C	B9 75 02		CJNE	R1,#AES+AESLEN,LIT_1
  707:	  813F	80 9C			JMP	AES_ER
  708:				;
  709:	  8141	F7		LIT_1:	MOV	@R1,A		;Store literal.
  710:	  8142	74 01			MOV	A,#1		;Branch over constant on return.
  711:	  8144	D3			SETB	C
  712:	  8145	73			JMP	@A+DPTR		;Return to IL program.
  713:				;
  714:				;=======
  715:				;$EJECT
  716:				;
  717:				;	BASIC VARIABLE ACCESSING OPERATIONS  (8/20/80)
  718:				;	===== ======== ========= ==========

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 14



 Line  I  Addr  Code            Source

  719:				;
  720:				;
  721:				;	Direct address mode emulation tables:
  722:				;
  723:	  8146	80		SFRTBL:	DB	80H
  724:	  8147	90			DB	90H
  725:	  8148	A0			DB	0A0H
  726:	  8149	B0			DB	0B0H
  727:	  814A	88			DB	88H
  728:	  814B	98			DB	98H
  729:	  814C	A8			DB	0A8H
  730:	  814D	B8			DB	0B8H
  731:	  814E	89			DB	89H
  732:	  814F	8A			DB	8AH
  733:	  8150	8B			DB	8BH
  734:	  8151	8C			DB	8CH
  735:	  8152	8D			DB	8DH
  736:	  8153	99			DB	99H
  737:		N      000E	NO_SFR	EQU	$-SFRTBL
  738:				;
  739:				;===
  740:				;
  741:	  8154	8E 80		STRTBL:	MOV	80H,TOS_L
  742:	  8156	22			RET
  743:	  8157	8E 90			MOV	90H,TOS_L
  744:	  8159	22			RET
  745:	  815A	8E A0			MOV	0A0H,TOS_L
  746:	  815C	22			RET
  747:	  815D	8E B0			MOV	0B0H,TOS_L
  748:	  815F	22			RET
  749:	  8160	8E 88			MOV	88H,TOS_L
  750:	  8162	22			RET
  751:	  8163	8E 98			MOV	98H,TOS_L
  752:	  8165	22			RET
  753:	  8166	8E A8			MOV	0A8H,TOS_L
  754:	  8168	22			RET
  755:	  8169	8E B8			MOV	0B8H,TOS_L
  756:	  816B	22			RET
  757:	  816C	8E 89			MOV	89H,TOS_L
  758:	  816E	22			RET
  759:	  816F	8E 8A			MOV	8AH,TOS_L
  760:	  8171	22			RET
  761:	  8172	8E 8B			MOV	8BH,TOS_L
  762:	  8174	22			RET
  763:	  8175	8E 8C			MOV	8CH,TOS_L
  764:	  8177	22			RET
  765:	  8178	8E 8D			MOV	8DH,TOS_L
  766:	  817A	22			RET
  767:	  817B	8E 99			MOV	99H,TOS_L
  768:	  817D	22			RET
  769:				;
  770:				;===
  771:				;
  772:	  817E	E5 80		INDTBL:	MOV	A,80H
  773:	  8180	22			RET
  774:	  8181	E5 90			MOV	A,90H
  775:	  8183	22			RET
  776:	  8184	E5 A0			MOV	A,0A0H

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 15



 Line  I  Addr  Code            Source

  777:	  8186	22			RET
  778:	  8187	E5 B0			MOV	A,0B0H
  779:	  8189	22			RET
  780:	  818A	E5 88			MOV	A,88H
  781:	  818C	22			RET
  782:	  818D	E5 98			MOV	A,98H
  783:	  818F	22			RET
  784:	  8190	E5 A8			MOV	A,0A8H
  785:	  8192	22			RET
  786:	  8193	E5 B8			MOV	A,0B8H
  787:	  8195	22			RET
  788:	  8196	E5 89			MOV	A,89H
  789:	  8198	22			RET
  790:	  8199	E5 8A			MOV	A,8AH
  791:	  819B	22			RET
  792:	  819C	E5 8B			MOV	A,8BH
  793:	  819E	22			RET
  794:	  819F	E5 8C			MOV	A,8CH
  795:	  81A1	22			RET
  796:	  81A2	E5 8D			MOV	A,8DH
  797:	  81A4	22			RET
  798:	  81A5	E5 99			MOV	A,99H
  799:	  81A7	22			RET
  800:				;
  801:				;$EJECT
  802:	  81A8			SFR_ID:
  803:				;	Identify which SFR is indicated by the contents of R1.
  804:				;	Return with acc holding (Index of said register)*3.
  805:				;	Call error routine if register number not found.
  806:				;
  807:	  81A8	90 81 46		MOV	DPTR,#SFRTBL
  808:	  81AB	E4			CLR	A
  809:	  81AC	FD			MOV	LP_CNT,A
  810:	  81AD	ED		SFID_1:	MOV	A,LP_CNT
  811:	  81AE	93			MOVC	A,@A+DPTR
  812:	  81AF	69			XRL	A,R1
  813:	  81B0	70 04			JNZ	SFID_2
  814:	  81B2	ED			MOV	A,LP_CNT
  815:	  81B3	23			RL	A
  816:	  81B4	2D			ADD	A,LP_CNT
  817:	  81B5	22			RET
  818:				;
  819:	  81B6	0D		SFID_2:	INC	LP_CNT
  820:	  81B7	ED			MOV	A,LP_CNT
  821:	  81B8	B4 0E F2		CJNE	A,#NO_SFR,SFID_1
  822:	  81BB	01 D4		ADR_ER:	JMP	EXP_ER
  823:				;
  824:				;=======
  825:				;
  826:	  81BD			STRDIR:
  827:				;	Store data byte in ACC into direct on-chip RAM address held in R1.
  828:				;
  829:	  81BD	FE			MOV	TOS_L,A
  830:	  81BE	E9			MOV	A,R1
  831:	  81BF	20 E7 03		JB	ACC.7,STRSFR	;Direct addresses above 7FH are SFRs.
  832:	  81C2	EE			MOV	A,TOS_L
  833:	  81C3	F7			MOV	@R1,A		;Store low-order byte in RAM.
  834:	  81C4	22			RET

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 16



 Line  I  Addr  Code            Source

  835:				;
  836:	  81C5	31 A8		STRSFR:	CALL	SFR_ID
  837:	  81C7	90 81 54		MOV	DPTR,#STRTBL
  838:	  81CA	73			JMP	@A+DPTR		;Jump into store sequence.
  839:				;
  840:				;=======
  841:				;
  842:	  81CB			FETDIR:
  843:				;	Fetch on-chip directly addressed byte indicated by R1 into Acc.
  844:				;	and return.
  845:				;
  846:	  81CB	E9			MOV	A,R1
  847:	  81CC	20 E7 02		JB	ACC.7,FETSFR
  848:	  81CF	E7			MOV	A,@R1
  849:	  81D0	22			RET
  850:				;
  851:	  81D1	31 A8		FETSFR:	CALL	SFR_ID
  852:	  81D3	90 81 7E		MOV	DPTR,#INDTBL
  853:	  81D6	73			JMP	@A+DPTR
  854:				;
  855:				;=======
  856:				;
  857:	  81D7			SPLIT_DBA:
  858:				;	Called with TOS_L containing a direct on-chip bit address.
  859:				;	Return the direct &byte& address of encompassing
  860:				;	register in R1, and load B with a mask containing a single 1
  861:				;	corresponding to the bit's position in a field of zeroes.
  862:				;
  863:	  81D7	EE			MOV	A,TOS_L
  864:	  81D8	54 F8			ANL	A,#11111000B
  865:	  81DA	20 E7 04		JB	ACC.7,SPLSFR
  866:	  81DD	23			RL	A
  867:	  81DE	C4			SWAP	A
  868:	  81DF	24 20			ADD	A,#20H		;Address of bit-address space.
  869:	  81E1	F9		SPLSFR:	MOV	R1,A
  870:	  81E2	EE			MOV	A,TOS_L
  871:	  81E3	54 07			ANL	A,#07H		;Mask off bit-displacement field.
  872:	  81E5	24 03			ADD	A,#MSKTBL-MSK_PC
  873:	  81E7	83			MOVC	A,@A+PC		;Read mask byte.
  874:	  81E8			MSK_PC:
  875:	  81E8	F5 F0			MOV	B,A
  876:	  81EA	22			RET
  877:				;
  878:	  81EB	01		MSKTBL:	DB	00000001B
  879:	  81EC	02			DB	00000010B
  880:	  81ED	04			DB	00000100B
  881:	  81EE	08			DB	00001000B
  882:	  81EF	10			DB	00010000B
  883:	  81F0	20			DB	00100000B
  884:	  81F1	40			DB	01000000B
  885:	  81F2	80			DB	10000000B
  886:				;
  887:				;=======
  888:				;
  889:				;
  890:	  81F3			SEQ_STORE:
  891:				;	Same as STORE, below, except that index is retained
  892:				;	rather than being popped.

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 17



 Line  I  Addr  Code            Source

  893:	  81F3	D2 0B			SETB	SEQ_FLG
  894:	  81F5	80 02			SJMP	STOR_0
  895:				;
  896:				;
  897:	  81F7			STORE:
  898:				;	When STORE is called, AES contains
  899:				;	(TOS:)	2 byte VALUE to be stored,
  900:				;		2 byte INDEX of destination variable,
  901:				;		1 byte TYPE code for variable space.
  902:				;			(0=BASIC variable,
  903:				;			 1=DBYTE,
  904:				;			 2=RBIT,
  905:				;			 3=XBYTE,
  906:				;			 4=CBYTE.)
  907:				;	Store (VAR_1) into appropriate variable memory at location of (INDEX).
  908:				;
  909:	  81F7	C2 0B			CLR	SEQ_FLG
  910:	  81F9	11 F3		STOR_0:	CALL	POP_TOS
  911:	  81FB	8E 30			MOV	TMP0,TOS_L
  912:	  81FD	8F 31			MOV	TMP1,TOS_H
  913:	  81FF	11 F3			CALL	POP_TOS
  914:	  8201	31 05			CALL	POP_ACC		;Load TYPE code.
  915:	  8203	30 0B 06		JNB	SEQ_FLG,STOR_1	;Jump forward if simple store.
  916:	  8206	05 50			INC	AESP
  917:	  8208	05 50			INC	AESP
  918:	  820A	05 50			INC	AESP
  919:	  820C	90 82 11	STOR_1:	MOV	DPTR,#STRJTB
  920:	  820F	93			MOVC	A,@A+DPTR
  921:	  8210	73			JMP	@A+DPTR
  922:				;
  923:	  8211	05		STRJTB:	DB	STRVAR-STRJTB
  924:	  8212	23			DB	STRDBY-STRJTB
  925:	  8213	29			DB	STRRBI-STRJTB
  926:	  8214	3E			DB	STRXBY-STRJTB
  927:	  8215	3E			DB	STRCBY-STRJTB
  928:				;
  929:				;=======
  930:				;
  931:				;	All of the following routines are called with
  932:				;	TOS_L holding the low-order address of the destination,
  933:				;	TOS_H holding the high-order address (if necessary),
  934:				;	and <TMP1><TMP0> holding the 8- or 16-bit data to be stored.
  935:				;
  936:	  8216	EE		STRVAR:	MOV	A,TOS_L
  937:	  8217	23			RL	A		;Multiply by two for 2 byte variables.
  938:	  8218	20 00 0D		JB	EXTVAR,STREXT	;Branch if vars in external RAM.
  939:	  821B	24 38			ADD	A,#US_VAR	;Offset for variable array.
  940:	  821D	F9			MOV	R1,A
  941:	  821E	24 B1			ADD	A,#-(US_VAR+2*NO_VAR-1)	;Compare with maximum legal address.
  942:	  8220	40 99			JC	ADR_ER
  943:	  8222	A7 30			MOV	@R1,TMP0
  944:	  8224	09			INC	R1
  945:	  8225	A7 31			MOV	@R1,TMP1
  946:	  8227	22			RET
  947:				;
  948:	  8228	F9		STREXT:	MOV	R1,A
  949:	  8229	75 A0 90	DD001:  MOV     P2,#HIGH(EXTRAM)
  950:	  822C	E5 30		        MOV     A,TMP0

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 18



 Line  I  Addr  Code            Source

  951:	  822E	F3			MOVX	@R1,A
  952:	  822F	09			INC	R1		;Bump pointers.
  953:	  8230	E5 31			MOV	A,TMP1		;Move high-order byte into variable array.
  954:	  8232	F3			MOVX	@R1,A
  955:	  8233	22			RET
  956:				;
  957:				;===
  958:				;
  959:	  8234	EE		STRDBY:	MOV	A,TOS_L		;Load acc. with low-order dest. addr.
  960:	  8235	F9			MOV	R1,A
  961:	  8236	E5 30			MOV	A,TMP0
  962:	  8238	80 83			JMP	STRDIR
  963:				;
  964:				;===
  965:				;
  966:	  823A	31 D7		STRRBI:	CALL	SPLIT_DBA
  967:	  823C	31 CB			CALL	FETDIR
  968:	  823E	FE			MOV	TOS_L,A
  969:	  823F	E5 30			MOV	A,TMP0
  970:	  8241	20 E0 06		JB	ACC.0,SETRBI
  971:				;
  972:				;	Clear RBIT.
  973:				;
  974:	  8244	E5 F0			MOV	A,B
  975:	  8246	F4			CPL	A
  976:	  8247	5E			ANL	A,TOS_L
  977:	  8248	21 BD			JMP	STRDIR
  978:				;
  979:	  824A	E5 F0		SETRBI:	MOV	A,B
  980:	  824C	4E			ORL	A,TOS_L
  981:	  824D	21 BD			JMP	STRDIR
  982:				;
  983:				;===
  984:				;
  985:	  824F			STRXBY:
  986:	  824F	8F A0		STRCBY:	MOV	P2,TOS_H
  987:	  8251	EE			MOV	A,TOS_L
  988:	  8252	F9			MOV	R1,A
  989:	  8253	E5 30			MOV	A,TMP0
  990:	  8255	F3			MOVX	@R1,A
  991:	  8256	22			RET
  992:				;
  993:				;===============
  994:				;
  995:				;
  996:	  8257			SEQ_FETCH:
  997:				;	Same as FETCH, below, except that index is retained
  998:				;	rather than being popped.
  999:	  8257	D2 0B			SETB	SEQ_FLG
 1000:	  8259	80 02			SJMP	FET_0
 1001:				;
 1002:				;
 1003:	  825B			FETCH:
 1004:				;	When FETCH is called, AES contains
 1005:				;	(TOS:)	2 byte INDEX of source variable,
 1006:				;		1 byte TYPE code for variable space.
 1007:				;			(0=BASIC variable,
 1008:				;			 1=DBYTE,

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 19



 Line  I  Addr  Code            Source

 1009:				;			 2=RBIT,
 1010:				;			 3=XBYTE,
 1011:				;			 4=CBYTE.)
 1012:				;	Read 8- or 16-bit variable from the appropriate variable
 1013:				;	memory at location of (INDEX) and return on AES.
 1014:				;
 1015:	  825B	C2 0B			CLR	SEQ_FLG
 1016:	  825D	11 F3		FET_0:	CALL	POP_TOS
 1017:	  825F	31 05			CALL	POP_ACC
 1018:	  8261	30 0B 06		JNB	SEQ_FLG,FET_1	;Jump forward if simple store.
 1019:	  8264	05 50			INC	AESP
 1020:	  8266	05 50			INC	AESP
 1021:	  8268	05 50			INC	AESP
 1022:	  826A	90 82 6F	FET_1:	MOV	DPTR,#FETJTB
 1023:	  826D	93			MOVC	A,@A+DPTR
 1024:	  826E	73			JMP	@A+DPTR
 1025:				;
 1026:	  826F	05		FETJTB:	DB	FETVAR-FETJTB
 1027:	  8270	25			DB	FETDBY-FETJTB
 1028:	  8271	2B			DB	FETRBI-FETJTB
 1029:	  8272	37			DB	FETXBY-FETJTB
 1030:	  8273	3E			DB	FETCBY-FETJTB
 1031:				;
 1032:				;=======
 1033:				;
 1034:				;	All of the following routines are called with
 1035:				;	TOS_L holding the low-order index of the desired variable,
 1036:				;	and TOS_H holding the high-order index (if necessary).
 1037:				;
 1038:	  8274	EE		FETVAR:	MOV	A,TOS_L
 1039:	  8275	23			RL	A		;Correct for double-byte entries.
 1040:	  8276	20 00 0E		JB	EXTVAR,FETEXT
 1041:	  8279	24 38			ADD	A,#US_VAR	;Offset for variable array.
 1042:	  827B	F9			MOV	R1,A		;Index to variable storage array.
 1043:	  827C	24 B1			ADD	A,#-(US_VAR+2*NO_VAR-1)
 1044:	  827E	40 12			JC	FETERR
 1045:	  8280	E7			MOV	A,@R1		;Load low-order byte of variable.
 1046:	  8281	FE			MOV	TOS_L,A		;And store on AES.
 1047:	  8282	09			INC	R1		;Bump pointer.
 1048:	  8283	E7			MOV	A,@R1		;Transfer high-order byte of variable.
 1049:	  8284	FF			MOV	TOS_H,A
 1050:	  8285	21 0B			JMP	PUSH_TOS
 1051:				;
 1052:				;===
 1053:				;
 1054:	  8287	F9		FETEXT:	MOV	R1,A		;Index to variable storage array.
 1055:	  8288	75 A0 90	DD002:  MOV     P2,#HIGH(EXTRAM)
 1056:	  828B	E3		        MOVX    A,@R1           ;Load low-order byte of variable.
 1057:	  828C	FE			MOV	TOS_L,A		;And store on AES.
 1058:	  828D	09			INC	R1		;Bump pointers.
 1059:	  828E	E3			MOVX	A,@R1		;Transfer high-order byte of variable.
 1060:	  828F	FF			MOV	TOS_H,A
 1061:	  8290	21 0B			JMP	PUSH_TOS
 1062:				;
 1063:	  8292	21 BB		FETERR:	JMP	ADR_ER
 1064:				;
 1065:				;===
 1066:				;

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 20



 Line  I  Addr  Code            Source

 1067:	  8294	EE		FETDBY:	MOV	A,TOS_L
 1068:	  8295	F9			MOV	R1,A
 1069:	  8296	31 CB			CALL	FETDIR
 1070:	  8298	80 19			SJMP	FETBDN		;Byte fetch done.
 1071:				;
 1072:				;===
 1073:				;
 1074:	  829A	31 D7		FETRBI:	CALL	SPLIT_DBA
 1075:	  829C	31 CB			CALL	FETDIR
 1076:	  829E	55 F0			ANL	A,B
 1077:	  82A0	24 FF			ADD	A,#0FFH
 1078:	  82A2	E4			CLR	A
 1079:	  82A3	33			RLC	A
 1080:	  82A4	80 0D			SJMP	FETBDN
 1081:				;
 1082:				;===
 1083:				;
 1084:	  82A6	8F A0		FETXBY:	MOV	P2,TOS_H
 1085:	  82A8	EE			MOV	A,TOS_L
 1086:	  82A9	F9			MOV	R1,A
 1087:	  82AA	E3			MOVX	A,@R1
 1088:	  82AB	80 06			SJMP	FETBDN
 1089:				;
 1090:				;===
 1091:				;
 1092:	  82AD	8F 83		FETCBY:	MOV	DPH,TOS_H
 1093:	  82AF	8E 82			MOV	DPL,TOS_L
 1094:	  82B1	E4			CLR	A
 1095:	  82B2	93			MOVC	A,@A+DPTR
 1096:	  82B3	7F 00		FETBDN:	MOV	TOS_H,#00H	;FETCH sequence for Bytes Done.
 1097:	  82B5	FE			MOV	TOS_L,A		;FETCH sequence for words done.
 1098:	  82B6	21 0B			JMP	PUSH_TOS
 1099:				;
 1100:				;=======
 1101:				;$EJECT
 1102:				;
 1103:				;CREATE
 1104:				;	Test the contents of Acc.
 1105:				;	If CHAR holds the ASCII code for a legitimate decimal digit,
 1106:				;	create a two-byte entry in <TOS_H><TOS_L> holding low-order ACC nibble
 1107:				;	and return with CY set.
 1108:				;	Otherwise, return with CY cleared.
 1109:				;
 1110:	  82B8	24 D0		CREATE:	ADD	A,#-'0'		;Correct for ASCII digit offset.
 1111:	  82BA	B4 0A 00		CJNE	A,#10,$+3	;Compare to maximum legal digit.
 1112:	  82BD	50 05			JNC	CREA_1		;Abort if first char is not decimal digit.
 1113:	  82BF	FE			MOV	TOS_L,A		;Save initial digit read.
 1114:	  82C0	7F 00			MOV	TOS_H,#0	;Clear high-order bits.
 1115:	  82C2	C2 0D			CLR	H_FLG
 1116:	  82C4	22		CREA_1:	RET
 1117:				;
 1118:				;===============
 1119:				;
 1120:				;APPEND
 1121:				;	Test ASCII code in Acc.
 1122:				;	If it is a legal digit in the current radix,
 1123:				;	modify <TOS_H><TOS_L> to include this digit and return with CY set.
 1124:				;	Otherwise leave AES and CHAR unchanged and return with CY cleared.

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 21



 Line  I  Addr  Code            Source

 1125:				;	Operating mode determined by HEXMOD flag (1=Hex).
 1126:				;
 1127:	  82C5	20 0D 3E	APPEND:	JB	H_FLG,APND_2	;Nothing allowed after trailing 'H' received.
 1128:	  82C8	24 D0			ADD	A,#-'0'		;Correct for ASCII offset.
 1129:	  82CA	B4 0A 00		CJNE	A,#10,$+3	;Verify whether legal digit.
 1130:	  82CD	40 13			JC	APND_1		;Insert decimal digit as is.
 1131:	  82CF	30 04 34		JNB	HEXMOD,APND_2	;If in decimal mode, character isn't legal.
 1132:	  82D2	24 EF			ADD	A,#'0'-'A'	;Acc now equals 0 if 'A' received.
 1133:	  82D4	B4 06 00		CJNE	A,#6,$+3
 1134:	  82D7	40 07			JC	APND_4		;Process Hex digit.
 1135:				;
 1136:				;	Char was not hexidecimal digit, but if it was the first 'H', that's OK.
 1137:				;
 1138:	  82D9	B4 07 2A		CJNE	A,#'H'-'A',APND_2	;Compare original input with 'H'.
 1139:	  82DC	D2 0D			SETB	H_FLG		;Mark that 'H' was detected but don't process.
 1140:	  82DE	D3			SETB	C
 1141:	  82DF	22			RET
 1142:				;
 1143:	  82E0	24 0A		APND_4:	ADD	A,#10		;Value of lowest hex digit.
 1144:	  82E2	CE		APND_1:	XCH	A,TOS_L		;Save nibble to be appended.
 1145:	  82E3	75 F0 0A		MOV	B,#10		;(Assuming radix=decimal.)
 1146:	  82E6	30 04 03		JNB	HEXMOD,XRAD_1	;Skip ahead if assumption correct.
 1147:	  82E9	75 F0 10		MOV	B,#16		;If mode is actually hex.
 1148:	  82EC	C0 F0		XRAD_1:	PUSH	B		;Save for re-use.
 1149:	  82EE	A4			MUL	AB		;Multiply by radix.
 1150:	  82EF	2E			ADD	A,TOS_L		;Append new digit.
 1151:	  82F0	FE			MOV	TOS_L,A		;Save low-order shifted value.
 1152:	  82F1	E4			CLR	A
 1153:	  82F2	35 F0			ADDC	A,B		;Incremented high-order product if carry.
 1154:	  82F4	CF			XCH	A,TOS_H
 1155:	  82F5	D0 F0			POP	B
 1156:	  82F7	A4			MUL	AB
 1157:	  82F8	2F			ADD	A,TOS_H
 1158:	  82F9	FF			MOV	TOS_H,A
 1159:	  82FA	72 E7			ORL	C,ACC.7		;Detect if most significant bit set.
 1160:	  82FC	E5 F0			MOV	A,B
 1161:	  82FE	34 FF			ADDC	A,#0FFH		;Simulate "ORL	C,NZ" instruction.
 1162:	  8300	B0 04			ANL	C,/HEXMOD	;Overflow only relevent in decimal mode.
 1163:	  8302	40 04			JC	APN_ER		;Error if bit 7 overflow occurred.
 1164:	  8304	D3			SETB	C		;CHAR processed as legal character.
 1165:	  8305	22			RET
 1166:				;
 1167:	  8306	C3		APND_2:	CLR	C
 1168:	  8307	22			RET
 1169:				;
 1170:				;
 1171:	  8308	11 D4		APN_ER:	CALL	EXP_ER		;Indicate illegal entry.
 1172:	  830A	02			DB	2
 1173:				;
 1174:				;$EJECT
 1175:				;
 1176:	  830B			OV_TST:
 1177:				;	If OV is set and operation is BCD mode then call EXP_ER routine.
 1178:				;
 1179:	  830B	A2 D2			MOV	C,OV
 1180:	  830D	B0 04			ANL	C,/HEXMOD
 1181:	  830F	40 01			JC	EXP_OV
 1182:	  8311	22			RET

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 22



 Line  I  Addr  Code            Source

 1183:				;
 1184:	  8312	11 D4		EXP_OV:	CALL	EXP_ER
 1185:	  8314	06			DB	6
 1186:				;
 1187:				;=======
 1188:				;
 1189:	  8315	E7		ADD_16:	MOV	A,@R1		;Add low-order bytes.
 1190:	  8316	2E			ADD	A,TOS_L
 1191:	  8317	F7			MOV	@R1,A		;Save sum.
 1192:	  8318	09			INC	R1
 1193:	  8319	E7			MOV	A,@R1		;Add high-order bytes.
 1194:	  831A	3F			ADDC	A,TOS_H
 1195:	  831B	F7			MOV	@R1,A		;Save sum.
 1196:	  831C	22			RET
 1197:				;
 1198:				;=======
 1199:				;
 1200:				;
 1201:	  831D			IADD:
 1202:				;	Pop VAR from AES (two bytes).
 1203:				;	TOS <= TOS + VAR
 1204:				;
 1205:	  831D	11 F3			CALL	POP_TOS
 1206:	  831F	71 15			CALL	ADD_16
 1207:	  8321	80 E8			JMP	OV_TST
 1208:				;
 1209:				;===============
 1210:				;
 1211:				;ISUB
 1212:				;	Pop VAR from AES (two bytes).
 1213:				;	TOS <= TOS - VAR
 1214:				;
 1215:				;
 1216:	  8323	11 F3		ISUB:	ACALL	POP_TOS
 1217:	  8325	C3			CLR	C		;Set up for subtraction with borrow.
 1218:	  8326	E7			MOV	A,@R1		;Subtract low-order bytes.
 1219:	  8327	9E			SUBB	A,TOS_L
 1220:	  8328	F7			MOV	@R1,A		;Save difference.
 1221:	  8329	09			INC	R1		;Bump pointers.
 1222:	  832A	E7			MOV	A,@R1		;Subtract high-order bytes.
 1223:	  832B	9F			SUBB	A,TOS_H
 1224:	  832C	F7			MOV	@R1,A		;Save difference.
 1225:	  832D	80 DC			JMP	OV_TST
 1226:				;
 1227:				;=======
 1228:				;
 1229:				;
 1230:	  832F			IAND:
 1231:				;	Pop VAR from AES (two bytes).
 1232:				;	TOS <= TOS AND VAR
 1233:				;
 1234:	  832F	11 F3			CALL	POP_TOS
 1235:	  8331	E7			MOV	A,@R1		;AND low-order bytes.
 1236:	  8332	5E			ANL	A,TOS_L
 1237:	  8333	F7			MOV	@R1,A		;Save result.
 1238:	  8334	09			INC	R1
 1239:	  8335	E7			MOV	A,@R1		;AND high-order bytes.
 1240:	  8336	5F			ANL	A,TOS_H

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 23



 Line  I  Addr  Code            Source

 1241:	  8337	F7			MOV	@R1,A		;Save result.
 1242:	  8338	22			RET
 1243:				;
 1244:				;=======
 1245:				;
 1246:				;
 1247:	  8339			IOR:
 1248:				;	Pop VAR from AES (two bytes).
 1249:				;	TOS <= TOS OR VAR
 1250:				;
 1251:	  8339	11 F3			CALL	POP_TOS
 1252:	  833B	E7			MOV	A,@R1		;OR low-order bytes.
 1253:	  833C	4E			ORL	A,TOS_L
 1254:	  833D	F7			MOV	@R1,A		;Save result.
 1255:	  833E	09			INC	R1
 1256:	  833F	E7			MOV	A,@R1		;OR high-order bytes.
 1257:	  8340	4F			ORL	A,TOS_H
 1258:	  8341	F7			MOV	@R1,A		;Save result.
 1259:	  8342	22			RET
 1260:				;
 1261:				;=======
 1262:				;
 1263:				;
 1264:	  8343			IXOR:
 1265:				;	Pop VAR from AES (two bytes).
 1266:				;	TOS <= TOS XOR VAR
 1267:				;
 1268:	  8343	11 F3			CALL	POP_TOS
 1269:	  8345	E7			MOV	A,@R1		;XOR low-order bytes.
 1270:	  8346	6E			XRL	A,TOS_L
 1271:	  8347	F7			MOV	@R1,A		;Save result.
 1272:	  8348	09			INC	R1
 1273:	  8349	E7			MOV	A,@R1		;XOR high-order bytes.
 1274:	  834A	6F			XRL	A,TOS_H
 1275:	  834B	F7			MOV	@R1,A		;Save result.
 1276:	  834C	22			RET
 1277:				;
 1278:				;===============
 1279:				;
 1280:				;
 1281:	  834D			NEG:
 1282:				;	TOS <= -TOS
 1283:				;
 1284:	  834D	C3			CLR	C
 1285:	  834E	B2 0A			CPL	SGN_FLG
 1286:	  8350	A9 50		NEG_0:	MOV	R1,AESP		;Compute variable address.
 1287:	  8352	19			DEC	R1		;Index for low-order byte of VAR_1.
 1288:	  8353	E4			CLR	A		;Subtract VAR_1 from 0000H.
 1289:	  8354	97			SUBB	A,@R1
 1290:	  8355	F7			MOV	@R1,A		;Save difference.
 1291:	  8356	09			INC	R1		;Bump pointer.
 1292:	  8357	E4			CLR	A
 1293:	  8358	97			SUBB	A,@R1		;Subtract high-order byte.
 1294:	  8359	F7			MOV	@R1,A		;Save difference.
 1295:	  835A	80 AF			JMP	OV_TST
 1296:				;
 1297:				;=======
 1298:				;

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 24



 Line  I  Addr  Code            Source

 1299:				;
 1300:	  835C			ICPL:
 1301:				;	TOS <= /TOS  (ones complement)
 1302:	  835C	D3			SETB	C
 1303:	  835D	80 F1			SJMP	NEG_0
 1304:				;
 1305:				;===============
 1306:				;
 1307:				;
 1308:	  835F			IABS:
 1309:				;	If in decimal mode and TOS < 0
 1310:				;	then complement SGN_FLG and negate TOS.
 1311:				;
 1312:	  835F	A9 50			MOV	R1,AESP
 1313:	  8361	E7			MOV	A,@R1
 1314:	  8362	A2 E7			MOV	C,ACC.7
 1315:	  8364	B0 04			ANL	C,/HEXMOD
 1316:	  8366	40 E5			JC	NEG
 1317:	  8368	22			RET
 1318:				;
 1319:				;=======
 1320:				;
 1321:	  8369			NEG_IF_NEG:
 1322:				;	If SGN_FLG is set then negate TOS and complement SGN_FLG,
 1323:				;	else return with TOS unchanged.
 1324:	  8369	20 0A E1		JB	SGN_FLG,NEG
 1325:	  836C	22			RET
 1326:				;
 1327:				;=======
 1328:				;
 1329:				;
 1330:	  836D			IINC:
 1331:				;	TOS <= TOS+1
 1332:				;
 1333:	  836D	A9 50			MOV	R1,AESP		;Compute variable address.
 1334:	  836F	19			DEC	R1		;Index for low-order byte of VAR_1.
 1335:	  8370	07			INC	@R1
 1336:	  8371	B7 00 02		CJNE	@R1,#00,IINC_1
 1337:	  8374	09			INC	R1		;Bump pointer.
 1338:	  8375	07			INC	@R1
 1339:	  8376	22		IINC_1:	RET
 1340:				;
 1341:				;=======
 1342:				;
 1343:	  8377			MUL_16:
 1344:				;	Multiply unsigned 16-bit quantity in <TOS_H><TOS_L> by entry
 1345:				;	on top of stack, and return with product on stack.
 1346:				;	If product exceeds 16-bits, set OV flag.
 1347:				;
 1348:	  8377	C2 D5			CLR	F0		;Initialize overflow flag.
 1349:	  8379	A9 50			MOV	R1,AESP		;Point to MSB of NOS.
 1350:	  837B	E7			MOV	A,@R1
 1351:	  837C	60 05			JZ	IMUL_1		;High-order byte of either param. must be 0.
 1352:	  837E	EF			MOV	A,TOS_H
 1353:	  837F	60 02			JZ	IMUL_1
 1354:	  8381	D2 D5			SETB	F0		;Mark that both parameters exceed 255.
 1355:	  8383	19		IMUL_1:	DEC	R1		;Index low-order NOS.
 1356:	  8384	E7			MOV	A,@R1

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 25



 Line  I  Addr  Code            Source

 1357:	  8385	8F F0			MOV	B,TOS_H
 1358:	  8387	A4			MUL	AB		;Low-order product.
 1359:	  8388	30 D2 02		JNB	OV,IMUL_2
 1360:	  838B	D2 D5			SETB	F0
 1361:	  838D	09		IMUL_2:	INC	R1
 1362:	  838E	C7			XCH	A,@R1		;Save low-order prod. and load high-order NOS.
 1363:	  838F	8E F0			MOV	B,TOS_L
 1364:	  8391	A4			MUL	AB
 1365:	  8392	30 D2 02		JNB	OV,IMUL_3	;Mark if overflow.
 1366:	  8395	D2 D5			SETB	F0
 1367:	  8397	27		IMUL_3:	ADD	A,@R1
 1368:	  8398	F7			MOV	@R1,A		;Save high-order sum.
 1369:	  8399	72 D5			ORL	C,F0
 1370:	  839B	92 D5			MOV	F0,C
 1371:	  839D	19			DEC	R1		;Address low-order NOS.
 1372:	  839E	E7			MOV	A,@R1
 1373:	  839F	8E F0			MOV	B,TOS_L
 1374:	  83A1	A4			MUL	AB
 1375:	  83A2	F7			MOV	@R1,A
 1376:	  83A3	E5 F0			MOV	A,B
 1377:	  83A5	09			INC	R1
 1378:	  83A6	27			ADD	A,@R1
 1379:	  83A7	F7			MOV	@R1,A		;Save high-order product.
 1380:	  83A8	72 D5			ORL	C,F0		;Check if carry or sign-bit set.
 1381:	  83AA	72 E7			ORL	C,ACC.7		;Check if sign-bit set.
 1382:	  83AC	92 D2			MOV	OV,C
 1383:	  83AE	22			RET
 1384:				;
 1385:				;=======
 1386:				;
 1387:				;
 1388:	  83AF			IMUL:
 1389:				;	Pop VAR from AES (two bytes).
 1390:				;	TOS <= TOS * VAR
 1391:				;
 1392:	  83AF	C2 0A			CLR	SGN_FLG		;Initialize sign monitor flag.
 1393:	  83B1	71 5F			CALL	IABS		;Take absolute value of TOS.
 1394:	  83B3	11 F3			CALL	POP_TOS		;Pop top entry.
 1395:	  83B5	71 5F			CALL	IABS		;Take absolute value of NOS.
 1396:	  83B7	71 77			CALL	MUL_16
 1397:	  83B9	71 0B			CALL	OV_TST		;Check if OV relevent.
 1398:	  83BB	71 69			CALL	NEG_IF_NEG
 1399:	  83BD	22			RET
 1400:				;
 1401:				;===============
 1402:				;
 1403:				;
 1404:	  83BE	D2 0C		IMOD:	SETB	MOD_FLG		;Indicate modulo entry point.
 1405:	  83C0	80 02			SJMP	IDIV_0
 1406:				;
 1407:				;=======
 1408:				;
 1409:				;
 1410:	  83C2			IDIV:
 1411:				;	Pop VAR from AES (two bytes).
 1412:				;	TOS <= TOS / VAR
 1413:				;	If divide-by-zero attempted report error.
 1414:				;

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 26



 Line  I  Addr  Code            Source

 1415:	  83C2	C2 0C			CLR	MOD_FLG		;Indicate division entry point.
 1416:	  83C4	D2 0A		IDIV_0:	SETB	SGN_FLG		;Initialize sign monitor flag.
 1417:	  83C6	71 5F			CALL	IABS
 1418:	  83C8	71 4D			CALL	NEG
 1419:	  83CA	11 F3			CALL	POP_TOS
 1420:				;???
 1421:				; The next line of code added by lss 21-dec-1982
 1422:				;???
 1423:	  83CC	EE			mov	a,tos_l
 1424:	  83CD	4F			ORL	A,TOS_H
 1425:	  83CE	60 4D			JZ	DIV_NG
 1426:	  83D0	A2 0A			MOV	C,SGN_FLG
 1427:	  83D2	B0 0C			ANL	C,/MOD_FLG	;Clear SGN_FLG if MOD funtion being done.
 1428:	  83D4	92 0A			MOV	SGN_FLG,C
 1429:	  83D6	71 5F			CALL	IABS
 1430:	  83D8	F5 31			MOV	TMP1,A
 1431:	  83DA	19			DEC	R1
 1432:	  83DB	E7			MOV	A,@R1
 1433:	  83DC	F5 30			MOV	TMP0,A
 1434:	  83DE	E4			CLR	A
 1435:	  83DF	F5 33			MOV	TMP3,A
 1436:	  83E1	F5 32			MOV	TMP2,A
 1437:	  83E3	7D 11			MOV	LP_CNT,#17
 1438:	  83E5	C3			CLR	C
 1439:	  83E6	80 17			SJMP	DIV_RP
 1440:				;
 1441:	  83E8	E5 32		DIV_LP:	MOV	A,TMP2
 1442:	  83EA	33			RLC	A
 1443:	  83EB	F5 32			MOV	TMP2,A
 1444:	  83ED	C5 33			XCH	A,TMP3
 1445:	  83EF	33			RLC	A
 1446:	  83F0	C5 33			XCH	A,TMP3
 1447:	  83F2	2E			ADD	A,TOS_L
 1448:	  83F3	F5 34			MOV	TMP4,A
 1449:	  83F5	E5 33			MOV	A,TMP3
 1450:	  83F7	3F			ADDC	A,TOS_H
 1451:	  83F8	50 05			JNC	DIV_RP
 1452:	  83FA	85 34 32		MOV	TMP2,TMP4
 1453:	  83FD	F5 33			MOV	TMP3,A
 1454:	  83FF	E5 30		DIV_RP:	MOV	A,TMP0
 1455:	  8401	33			RLC	A
 1456:	  8402	F5 30			MOV	TMP0,A
 1457:	  8404	E5 31			MOV	A,TMP1
 1458:	  8406	33			RLC	A
 1459:	  8407	F5 31			MOV	TMP1,A
 1460:	  8409	DD DD			DJNZ	LP_CNT,DIV_LP
 1461:	  840B	20 0C 07		JB	MOD_FLG,DIV_1
 1462:	  840E	A7 30			MOV	@R1,TMP0
 1463:	  8410	09			INC	R1
 1464:	  8411	A7 31			MOV	@R1,TMP1
 1465:	  8413	80 05			SJMP	DIV_2
 1466:				;
 1467:	  8415	A7 32		DIV_1:	MOV	@R1,TMP2
 1468:	  8417	09			INC	R1
 1469:	  8418	A7 33			MOV	@R1,TMP3
 1470:	  841A	71 69		DIV_2:	CALL	NEG_IF_NEG
 1471:	  841C	22			RET
 1472:				;

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 27



 Line  I  Addr  Code            Source

 1473:	  841D	61 12		DIV_NG:	AJMP	EXP_OV		;Report expression overflow.
 1474:				;
 1475:				;===============
 1476:				;
 1477:				;$EJECT
 1478:				;
 1479:				;
 1480:	  841F			RND:
 1481:				;	Generate a new 16-bit random number from RND_KEY,
 1482:				;	and push onto the AES.
 1483:	  841F	AE 35			MOV	TOS_L,SEED_L
 1484:	  8421	AF 36			MOV	TOS_H,SEED_H
 1485:	  8423	31 0B			CALL	PUSH_TOS
 1486:	  8425	7E 55		        MOV     TOS_L,#LOW(25173)
 1487:	  8427	7F 62		        MOV     TOS_H,#HIGH(25173)
 1488:	  8429	71 77			CALL	MUL_16
 1489:	  842B	7E 19		        MOV     TOS_L,#LOW(13849)
 1490:	  842D	7F 36		        MOV     TOS_H,#HIGH(13849)
 1491:	  842F	A9 50			MOV	R1,AESP
 1492:	  8431	19			DEC	R1
 1493:	  8432	71 15			CALL	ADD_16
 1494:	  8434	11 F3			CALL	POP_TOS
 1495:				;
 1496:				;???
 1497:				; The code from here to label no_problem added by lss 21 dec 1982
 1498:				; to cure a extraneous overflow if seed=8000h.
 1499:				;???
 1500:				;
 1501:	  8436	BE 00 07		cjne	tos_l,#0,no_problem
 1502:	  8439	BF 80 04		cjne	tos_h,#80h,no_problem
 1503:	  843C			big_problem:				   ; tos=8000h will generate an overflow
 1504:	  843C	7E 2A			mov	tos_l,#low(12586)          ; when control gets to iabs.
 1505:	  843E	7F 31			mov	tos_h,#high(12586)         ; Load the precalculated seed.
 1506:	  8440			no_problem:
 1507:	  8440	8E 35			MOV	SEED_L,TOS_L
 1508:	  8442	8F 36			MOV	SEED_H,TOS_H
 1509:	  8444	31 0B			CALL	PUSH_TOS
 1510:	  8446	22			RET
 1511:				;
 1512:				;===============
 1513:				;
 1514:				;
 1515:	  8447			CMPR:
 1516:				;	When CMPR is called, AES contains:
 1517:				;	(TOS:)	VAR_2 (two bytes),
 1518:				;		C_CODE (one byte),
 1519:				;		VAR_1 (two bytes).
 1520:				;	Pop all 5 bytes from stack and test relation between VAR_1 and VAR_2.
 1521:				;	    If C_CODE=010 then test whether (VAR_1) =  (VAR_2)
 1522:				;	    If C_CODE=100 then test whether (VAR_1) <  (VAR_2)
 1523:				;	    If C_CODE=110 then test whether (VAR_1) <= (VAR_2)
 1524:				;	    If C_CODE=101 then test whether (VAR_1) <> (VAR_2)
 1525:				;	    If C_CODE=001 then test whether (VAR_1) >  (VAR_2)
 1526:				;	    If C_CODE=011 then test whether (VAR_1) >= (VAR_2)
 1527:				;	If true then return 0001H on AES;
 1528:				;	otherwise return 0000H.
 1529:				;
 1530:	  8447	11 F3			CALL	POP_TOS

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 28



 Line  I  Addr  Code            Source

 1531:	  8449	31 05			CALL	POP_ACC
 1532:	  844B	F5 F0			MOV	B,A
 1533:	  844D	A9 50			MOV	R1,AESP
 1534:	  844F	19			DEC	R1
 1535:	  8450	C3			CLR	C		;...in preparation for string subtract.
 1536:	  8451	E7			MOV	A,@R1		;Compare low-order parameter bytes.
 1537:	  8452	9E			SUBB	A,TOS_L
 1538:	  8453	09			INC	R1		;Bump pointer.
 1539:	  8454	C7			XCH	A,@R1		;Save difference.
 1540:	  8455	20 04 06		JB	HEXMOD,CMPR_4
 1541:	  8458	64 80			XRL	A,#80H		;Offset variable by 80H for unsigned compare.
 1542:	  845A	CF			XCH	A,TOS_H
 1543:	  845B	64 80			XRL	A,#80H
 1544:	  845D	CF			XCH	A,TOS_H
 1545:	  845E	9F		CMPR_4:	SUBB	A,TOS_H
 1546:	  845F	47			ORL	A,@R1		;Add any non-zero high-order bits to acc.
 1547:	  8460	70 04			JNZ	CMPR_1		;Jump ahead VAR_1 <> VAR_2.
 1548:				;
 1549:				;	VAR_1 = VAR_2:
 1550:				;
 1551:	  8462	A2 F1			MOV	C,B.1		;Load VAR_1 = VAR_2 test flag.
 1552:	  8464	80 08			SJMP	PUSH_C
 1553:				;
 1554:	  8466	40 04		CMPR_1:	JC	CMPR_2		;Jump ahead if VAR_1 < VAR_2.
 1555:				;
 1556:				;	VAR_1 > VAR_2:
 1557:				;
 1558:	  8468	A2 F0			MOV	C,B.0		;Load VAR_1 > VAR_2 test flag.
 1559:	  846A	80 02			SJMP	PUSH_C
 1560:				;
 1561:				;	VAR_1 < VAR_2:
 1562:				;
 1563:	  846C	A2 F2		CMPR_2:	MOV	C,B.2		;Load VAR_1 < VAR_2 test flag.
 1564:	  846E	E4		PUSH_C:	CLR	A
 1565:	  846F	F7			MOV	@R1,A
 1566:	  8470	33			RLC	A
 1567:	  8471	19			DEC	R1
 1568:	  8472	F7			MOV	@R1,A
 1569:	  8473	22			RET
 1570:				;
 1571:				;$EJECT
 1572:
 1573:				;	BASIC SOURCE PROGRAM LINE ACCESSING ROUTINES:
 1574:				;	===== ====== ======= ==== ======= ==========
 1575:				;
 1576:				;	The general methodology of the various parsing routines is as follows:
 1577:				;	The POINTER (PNTR_L, PNTR_H) is used to indicate the next BASIC
 1578:				;	source character or string to be parsed
 1579:				;	by routines TST, TSTV, TSTN, TSTL, and TSTS.
 1580:				;	GET_C reads the indicated character from the appropriate
 1581:				;	program buffer space into acc. and returns.
 1582:				;	READ_CHAR reads the character into CHAR as well as acc. and
 1583:				;	increments the 16-bit pointer.
 1584:				;	When done, each routine calls D_BLANK to remove any trailing spaces,
 1585:				;	and leaves READ_CHAR ready to fetch the next non-blank character.
 1586:				;
 1587:				;=======
 1588:				;

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 29



 Line  I  Addr  Code            Source

 1589:				;REWIND
 1590:				;	Reset Cursor to start of current program buffer space.
 1591:				;
 1592:	  8474	C2 09		REWIND:	CLR	CHAR_FLG
 1593:	  8476	20 01 05		JB	ROMMOD,REWROM
 1594:	  8479	7A 90		        MOV     PNTR_H,#HIGH(EXTRAM)
 1595:	  847B	78 34		        MOV     PNTR_L,#LOW(EXTRAM)
 1596:	  847D	22			RET
 1597:				;
 1598:	  847E	20 02 05	REWROM:	JB	EXTMOD,RWXROM
 1599:	  8481	7A 8B		        MOV     PNTR_H,#HIGH(INTROM)
 1600:	  8483	78 F0		        MOV     PNTR_L,#LOW(INTROM)
 1601:	  8485	22			RET
 1602:				;
 1603:	  8486	7A C0		RWXROM: MOV     PNTR_H,#HIGH(EXTROM)
 1604:	  8488	78 80		        MOV     PNTR_L,#LOW(EXTROM)
 1605:	  848A	22			RET
 1606:				;
 1607:				;=======
 1608:				;
 1609:	  848B			SAVE_PNTR:
 1610:				;	Save PNTR variables in cursor.
 1611:				;
 1612:	  848B	88 77			MOV	CURS_L,PNTR_L
 1613:	  848D	8A 78			MOV	CURS_H,PNTR_H
 1614:	  848F	8C 79			MOV	C_SAVE,CHAR
 1615:	  8491	22			RET
 1616:				;
 1617:				;=======
 1618:				;
 1619:	  8492			LOAD_PNTR:
 1620:				;	Reload pointer with value saved earlier by SAVE_PNTR.
 1621:				;
 1622:	  8492	AA 78			MOV	PNTR_H,CURS_H
 1623:	  8494	A8 77			MOV	PNTR_L,CURS_L
 1624:	  8496	AC 79			MOV	CHAR,C_SAVE
 1625:	  8498	22			RET
 1626:				;
 1627:				;=======
 1628:				;
 1629:	  8499			GET_C:
 1630:				;	Read character from logical buffer space into A and return.
 1631:				;
 1632:	  8499	20 03 02		JB	RUNMOD,GET_BUF
 1633:	  849C	E6			MOV	A,@PNTR_L
 1634:	  849D	22			RET
 1635:				;
 1636:	  849E			GET_BUF:
 1637:				;	Read character from active program buffer space into A and return.
 1638:	  849E	20 01 04		JB	ROMMOD,GETROM
 1639:	  84A1	8A A0		DD003:  MOV     P2,PNTR_H               ;Select variable storage page.
 1640:	  84A3	E2		        MOVX    A,@PNTR_L               ;Read from external address space.
 1641:	  84A4	22			RET
 1642:				;
 1643:	  84A5	E8		GETROM:	MOV	A,PNTR_L
 1644:	  84A6	C5 82			XCH	A,DPL
 1645:	  84A8	CA			XCH	A,PNTR_H
 1646:	  84A9	C5 83			XCH	A,DPH

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 30



 Line  I  Addr  Code            Source

 1647:	  84AB	F8			MOV	PNTR_L,A
 1648:	  84AC	E4			CLR	A
 1649:	  84AD	93			MOVC	A,@A+DPTR
 1650:	  84AE	C8			XCH	A,PNTR_L		;Save char. and load old DPH.
 1651:	  84AF	C5 83			XCH	A,DPH
 1652:	  84B1	CA			XCH	A,PNTR_H
 1653:	  84B2	C5 82			XCH	A,DPL
 1654:	  84B4	C8			XCH	A,PNTR_L		;Store DPL and reload byte read.
 1655:	  84B5	22			RET
 1656:				;
 1657:				;=======
 1658:				;
 1659:	  84B6			READ_CHAR:
 1660:				;	READ_CHAR first tests the state of CHAR_FLG.
 1661:				;	If it is still cleared, the character most recently read from the line
 1662:				;	buffer or program buffer has been processed, so read the next
 1663:				;	character, bump the buffer pointer, and return with the character
 1664:				;	in both Acc. and CHAR and the CHAR_FLG cleared.
 1665:				;	If CHAR_FLG has been set by the parsing routines,
 1666:				;	then CHAR still holds a previously read character which has
 1667:				;	not yet been processed.  Read this character into Acc. and return
 1668:				;	with CHAR_FLG again cleared.
 1669:				;
 1670:	  84B6	10 09 09		JBC	CHAR_FLG,REREAD
 1671:	  84B9	91 99			CALL	GET_C
 1672:	  84BB	FC			MOV	CHAR,A
 1673:	  84BC	08			INC	PNTR_L
 1674:	  84BD	B8 00 01		CJNE	PNTR_L,#00,RDCHDN
 1675:	  84C0	0A			INC	PNTR_H
 1676:	  84C1	22		RDCHDN:	RET
 1677:				;
 1678:	  84C2	EC		REREAD:	MOV	A,CHAR
 1679:	  84C3	22			RET
 1680:				;
 1681:				;=======
 1682:				;
 1683:	  84C4			PUT_BUF:
 1684:				;	Put the contents of the acc. into program buffer space
 1685:				;	currently active at the address held in <DEST_H><DEST_L>.
 1686:				;
 1687:	  84C4	20 01 04		JB	ROMMOD,PUTROM
 1688:	  84C7	8B A0		DD004:  MOV     P2,DEST_H
 1689:	  84C9	F3		        MOVX    @DEST_L,A
 1690:	  84CA	22			RET
 1691:				;
 1692:	  84CB	01 D4		PUTROM:	JMP	EXP_ER
 1693:				;
 1694:				;=======
 1695:				;
 1696:	  84CD			WRITE_CHAR:
 1697:				;	Converse of READ_CHAR.
 1698:				;	Write contents of acc. into appropriate memory space (@DEST),
 1699:				;	increment DEST, and return.
 1700:				;
 1701:	  84CD	91 C4			CALL	PUT_BUF
 1702:	  84CF	09			INC	DEST_L
 1703:	  84D0	B9 00 01		CJNE	DEST_L,#00H,WRCH_1
 1704:	  84D3	0B			INC	DEST_H

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 31



 Line  I  Addr  Code            Source

 1705:	  84D4	22		WRCH_1:	RET
 1706:				;
 1707:				;=======
 1708:				;
 1709:	  84D5			D_BLNK:
 1710:				;	Remove leading blanks from BASIC source line, update cursor,
 1711:				;	load first non-blank character into CHAR,
 1712:				;	and leave pointer loaded with its address.
 1713:				;	(This routine is jumped to by parsing routines when successful,
 1714:				;	so set C before returning to original routines.)
 1715:				;
 1716:	  84D5	91 B6			CALL	READ_CHAR
 1717:	  84D7	64 20			XRL	A,#' '		;Verify that it is non-blank.
 1718:	  84D9	60 FA			JZ	D_BLNK		;Loop until non-blank leading character.
 1719:	  84DB	D2 09			SETB	CHAR_FLG
 1720:	  84DD	D3			SETB	C
 1721:	  84DE	22			RET			;Return to scanning code.
 1722:				;
 1723:				;=======
 1724:				;
 1725:				;SKPLIN
 1726:				;	Skip Cursor over entire BASIC source line, leaving
 1727:				;	cursor pointing to character after terminating <CR>.
 1728:				;SKPTXT
 1729:				;	Skip remainder of line in progress, assuming line number
 1730:				;	has already been passed over.
 1731:				;	(Note that either byte of binary line number could be
 1732:				;	mis-interpreted as a CR.)
 1733:				;
 1734:				;
 1735:	  84DF	91 B6		SKPLIN:	CALL	READ_CHAR
 1736:	  84E1	91 B6			CALL	READ_CHAR
 1737:	  84E3	91 B6		SKPTXT:	CALL	READ_CHAR
 1738:	  84E5	B4 0D FB		CJNE	A,#CR,SKPTXT	;Verify that it is non-<CR>.
 1739:	  84E8	22			RET			;Return to scanning code.
 1740:				;
 1741:				;=======
 1742:				;$EJECT
 1743:				;
 1744:				;	Token recognition and processing routines.
 1745:				;
 1746:				;
 1747:	  84E9			TST:
 1748:				;	If "TEMPLATE" matches the BASIC character string read by
 1749:				;	READ_CHAR then move pointer over string and any trailing blanks
 1750:				;	and continue with the following IL instruction.
 1751:				;	Otherwise leave pointer unchanged and branch to IL instruction at LBL.
 1752:				;
 1753:	  84E9	D0 83			POP	DPH		;Get in-line parameter base address from stack.
 1754:	  84EB	D0 82			POP	DPL
 1755:	  84ED	91 B6			CALL	READ_CHAR
 1756:	  84EF	91 8B			CALL	SAVE_PNTR
 1757:	  84F1	E4		TST_1:	CLR	A
 1758:	  84F2	93			MOVC	A,@A+DPTR	;Read next character from template string.
 1759:	  84F3	A2 E7			MOV	C,ACC.7		;Save terminator bit.
 1760:	  84F5	54 7F			ANL	A,#7FH		;Mask off terminator.
 1761:	  84F7	6C			XRL	A,CHAR		;Compare with template.
 1762:	  84F8	70 12			JNZ	T_BAD		;Abort if first characters miscompare.

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 32



 Line  I  Addr  Code            Source

 1763:	  84FA	A3			INC	DPTR		;Pass over template character just checked.
 1764:	  84FB	40 0B			JC	T_GOOD		;Done if template character bit 7 set.
 1765:	  84FD	91 B6			CALL	READ_CHAR	;Fetch next character for test.
 1766:	  84FF	BC 2E EF		CJNE	CHAR,#'.',TST_1	;Done if input string abbreviated at this point
 1767:	  8502	E4		TST_2:	CLR	A		;Fetch template characters until end of string
 1768:	  8503	93			MOVC	A,@A+DPTR
 1769:	  8504	A3			INC	DPTR
 1770:	  8505	30 E7 FA		JNB	ACC.7,TST_2	;Loop until last character detected.
 1771:	  8508	91 D5		T_GOOD:	CALL	D_BLNK
 1772:	  850A	E4			CLR	A
 1773:	  850B	73			JMP	@A+DPTR		;Return to next IL instruction
 1774:				;
 1775:				;	Strings do not match.  Leave cursor at start of string.
 1776:				;
 1777:	  850C	E4		T_BAD:	CLR	A
 1778:	  850D	93			MOVC	A,@A+DPTR	;Search for final template character.
 1779:	  850E	A3			INC	DPTR
 1780:	  850F	30 E7 FA		JNB	ACC.7,T_BAD	;Loop until terminator found.
 1781:	  8512	91 92			CALL	LOAD_PNTR
 1782:	  8514	D2 09			SETB	CHAR_FLG
 1783:	  8516	C3			CLR	C		;Mark string not found.
 1784:	  8517	E4			CLR	A
 1785:	  8518	73			JMP	@A+DPTR		;Return to mismatch branch instruction.
 1786:				;
 1787:				;===============
 1788:				;
 1789:				;TSTV	(LBL)
 1790:				;
 1791:				;
 1792:	  8519			TSTV:
 1793:				;	Test if first non-blank string is a legal variable symbol.
 1794:				;	If so, move cursor over string and any trailing blanks,
 1795:				;	compute variable index value,
 1796:				;	push onto arithmetic expression stack,
 1797:				;	and continue with following IL instruction.
 1798:				;	Otherwise branch to IL instruction at LBL with cursor unaffected.
 1799:				;
 1800:	  8519	91 B6			CALL	READ_CHAR
 1801:	  851B	24 BF			ADD	A,#-'A'		;Subtract offset for base variable.
 1802:	  851D	FE			MOV	TOS_L,A		;Save index in case needed later.
 1803:	  851E	24 E6			ADD	A,#-26
 1804:	  8520	50 04			JNC	ALPHAB		;First character is alphabetic if C=0.
 1805:	  8522	D2 09			SETB	CHAR_FLG
 1806:	  8524	C3			CLR	C
 1807:	  8525	22			RET
 1808:				;
 1809:	  8526	91 8B		ALPHAB:	CALL	SAVE_PNTR	;In case variable name not found.
 1810:	  8528	91 B6			CALL	READ_CHAR	;Verify that next character is not alphabetic.
 1811:	  852A	24 BF			ADD	A,#-'A'		;Alphabetic characters now <= 25.
 1812:	  852C	24 E6			ADD	A,#-26		;Non-alphabetics cause overflow.
 1813:	  852E	50 03			JNC	NOTVAR		;Alphabetic character means illegal var. name.
 1814:	  8530	BC 2E 40		CJNE	CHAR,#'.',TSTV_1	;Period indicates abbreviated keyword.
 1815:	  8533	91 92		NOTVAR:	CALL	LOAD_PNTR
 1816:	  8535	D2 09			SETB	CHAR_FLG
 1817:				;*        %TST    (TSTRBI,DBYTE)  ;Test if direct byte token.
 1818:	  8537	91 E9		        call   tst
 1819:	  8539	44 42 59 54	        db      'DBYT',('E' OR 80H)
	  853D	C5

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 33



 Line  I  Addr  Code            Source

 1820:	  853E	50 05		        jnc     tstrbi
 1821:				        LIT_    1
 1822+ 1  8540	31 32			CALL	LIT
 1823+ 1  8542	01			DB	1
 1824:	  8543	80 27			SJMP	INDEX
 1825:				;
 1826:				;*TSTRBI: %TST    (TSTXBY,RBIT)
 1827:	  8545	91 E9		tstrbi: call   tst
 1828:	  8547	52 42 49 D4	        db      'RBI',('T' OR 80H)
 1829:	  854B	50 05		        jnc     tstxby
 1830:				        LIT_    2
 1831+ 1  854D	31 32			CALL	LIT
 1832+ 1  854F	02			DB	2
 1833:	  8550	80 1A			SJMP	INDEX
 1834:				;
 1835:				;*TSTXBY: %TST    (TSTCBY,XBYTE)  ;Test if expansion RAM byte token.
 1836:	  8552	91 E9		tstxby: call   tst
 1837:	  8554	58 42 59 54	        db      'XBYT',('E' OR 80H)
	  8558	C5
 1838:	  8559	50 05		        jnc     tstcby
 1839:				        LIT_    3
 1840+ 1  855B	31 32			CALL	LIT
 1841+ 1  855D	03			DB	3
 1842:	  855E	80 0C			SJMP	INDEX
 1843:				;
 1844:				;*TSTCBY: %TST    (NOTSYM,CBYTE)  ;Test if program memory byte token.
 1845:	  8560	91 E9		tstcby: call   tst
 1846:	  8562	43 42 59 54	        db      'CBYT',('E' OR 80H)
	  8566	C5
 1847:	  8567	50 08		        jnc     notsym
 1848:				        LIT_    4
 1849+ 1  8569	31 32			CALL	LIT
 1850+ 1  856B	04			DB	4
 1851:	  856C	12 8B 5E	INDEX:	CALL	VAR
 1852:	  856F	D3			SETB	C
 1853:	  8570	22			RET
 1854:				;
 1855:	  8571	C3		NOTSYM:	CLR	C		;Indicate that condition tested wasn't true.
 1856:	  8572	22			RET
 1857:				;
 1858:				;	BASIC Variable name is legitimate (A-Z).
 1859:				;
 1860:	  8573			TSTV_1:	LIT_	0
 1861+ 1  8573	31 32			CALL	LIT
 1862+ 1  8575	00			DB	0
 1863:	  8576	7F 00			MOV	TOS_H,#0
 1864:	  8578	31 0B			CALL	PUSH_TOS
 1865:	  857A	D2 09			SETB	CHAR_FLG
 1866:	  857C	81 D5			JMP	D_BLNK		;Remove leading blanks from source line.
 1867:				;
 1868:				;===============
 1869:				;
 1870:				;TSTN	(LBL)
 1871:				;	Test if indicated string is an unsigned number.
 1872:				;	If so, move cursor over string and trailing blanks,
 1873:				;	compute number's binary value,
 1874:				;	push onto arithmetic expression stack, and continue with
 1875:				;	following IL instruction.

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 34



 Line  I  Addr  Code            Source

 1876:				;	Otherwise restore cursor and branch to IL instruction at LBL.
 1877:				;
 1878:				;
 1879:	  857E	91 B6		TSTN:	CALL	READ_CHAR
 1880:	  8580	51 B8			CALL	CREATE		;Create entry on AES if legit. digit.
 1881:	  8582	40 03			JC	TSTN_1		;Abort if CHAR is not decimal digit.
 1882:	  8584	D2 09			SETB	CHAR_FLG
 1883:	  8586	22			RET
 1884:				;
 1885:	  8587	91 B6		TSTN_1:	CALL	READ_CHAR	;Move over matched character.
 1886:	  8589	51 C5			CALL	APPEND		;Append new digit to entry on TOS.
 1887:	  858B	40 FA			JC	TSTN_1		;Continue processing while legal characters.
 1888:	  858D	31 0B			CALL	PUSH_TOS
 1889:	  858F	D2 09			SETB	CHAR_FLG
 1890:	  8591	81 D5			JMP	D_BLNK		;Remove leading blank characters.
 1891:				;
 1892:				;===============
 1893:				;
 1894:				;TSTL	(LBL)
 1895:				;	Test if first non-blank string is a BASIC source line number.
 1896:				;	If so, move cursor over string and following blanks,
 1897:				;	compute number's binary value,
 1898:				;	push onto arithmetic expression stack,
 1899:				;	and continue with next IL instruction.
 1900:				;	If invalid source line number report syntax error.
 1901:				;	If line number not present restore cursor
 1902:				;	and branch to IL instruction at LBL.
 1903:				;
 1904:				;
 1905:				;===============
 1906:				;
 1907:				;TSTS	(LBL)
 1908:				;	Test if first character is a quote.
 1909:				;	If so, print characters from the BASIC source program to the console
 1910:				;	until a (closing) quote is encountered,
 1911:				;	pass over any trailing blanks,
 1912:				;	leave source cursor pointing to first non-blank character,
 1913:				;	and branch to IL instruction at location (LBL).
 1914:				;	(Report syntax error if <CR> encountered before quote.)
 1915:				;	If first character is not a quote, return to next
 1916:				;	sequential IL instruction with cursor unchanged.
 1917:				;
 1918:				;
 1919:	  8593	91 B6		TSTS:	CALL	READ_CHAR
 1920:	  8595	F5 30			MOV	TMP0,A
 1921:	  8597	64 22			XRL	A,#'"'
 1922:	  8599	60 08			JZ	TSTS_1
 1923:	  859B	64 05			XRL	A,#'''' XOR '"'
 1924:	  859D	60 04			JZ	TSTS_1
 1925:	  859F	C3			CLR	C
 1926:	  85A0	D2 09			SETB	CHAR_FLG
 1927:	  85A2	22			RET
 1928:				;
 1929:	  85A3	91 B6		TSTS_1:	CALL	READ_CHAR	;Read next string character.
 1930:	  85A5	B5 30 02		CJNE	A,TMP0,TSTS_2
 1931:	  85A8	81 D5			JMP	D_BLNK
 1932:				;
 1933:	  85AA	11 6E		TSTS_2:	CALL	C_OUT		;Call output routine.

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 35



 Line  I  Addr  Code            Source

 1934:	  85AC	B4 0D F4		CJNE	A,#CR,TSTS_1	;<CR> before closing quote is illegal.
 1935:	  85AF	01 E8			JMP	SYN_ER		;Transmit error message.
 1936:				;
 1937:				;===============
 1938:				;
 1939:				;DONE
 1940:				;	Delete leading blanks from the BASIC source line.
 1941:				;	Return with the cursor positioned over the first non-blank
 1942:				;	character, which must be a colon or <CR> in the source line.
 1943:				;	If any other characters are encountered report a syntax error.
 1944:				;
 1945:				;
 1946:				;
 1947:	  85B1	91 B6		DONE:	CALL	READ_CHAR
 1948:	  85B3	BC 3A 03		CJNE	CHAR,#':',DONE_1	;Colon indicates resume interpretation.
 1949:	  85B6	22			RET			;Return to IL.
 1950:				;
 1951:	  85B7	91 B6		LNDONE:	CALL	READ_CHAR
 1952:	  85B9	BC 0D 01	DONE_1:	CJNE	CHAR,#CR,DONE_2	;Any non-colon, non-CR characters are illegal.
 1953:	  85BC	22			RET
 1954:				;
 1955:	  85BD	D2 09		DONE_2:	SETB	CHAR_FLG
 1956:	  85BF	01 E8			JMP	SYN_ER		;Process syntax error if so.
 1957:				;
 1958:				;=======
 1959:				;
 1960:				;IFDONE	(LBL)
 1961:				;	If the first non-blank character is a colon or <CR> in the source line
 1962:				;	then branch to the IL instruction specified by (LBL).
 1963:				;	If any other characters are encountered
 1964:				;	then continue with next IL instruction.
 1965:				;
 1966:				;
 1967:	  85C1	91 B6		IFDONE:	CALL	READ_CHAR
 1968:	  85C3	BC 3A 01		CJNE	CHAR,#':',IFDN_1	;Colon indicates resume interpretation.
 1969:	  85C6	22			RET			;Return to IL.
 1970:				;
 1971:	  85C7	BC 0D 01	IFDN_1:	CJNE	CHAR,#CR,IFDN_2	;Any non-colon, non-CR characters are illegal.
 1972:	  85CA	22			RET
 1973:				;
 1974:	  85CB	D2 09		IFDN_2:	SETB	CHAR_FLG
 1975:	  85CD	D3			SETB	C
 1976:	  85CE	22			RET
 1977:				;
 1978:				;=======
 1979:
 1980:				;$EJECT
 1981:	  85CF			READ_LABEL:
 1982:				;	Read next two characters from program buffer into <LABL_H><LABL_L>.
 1983:				;	Return with carry set if bit 15 of LABL is set (indicating EOF).
 1984:				;
 1985:	  85CF	91 B6			CALL	READ_CHAR
 1986:	  85D1	F5 7B			MOV	LABL_H,A
 1987:	  85D3	91 B6			CALL	READ_CHAR
 1988:	  85D5	F5 7A			MOV	LABL_L,A
 1989:	  85D7	E5 7B			MOV	A,LABL_H
 1990:	  85D9	A2 E7			MOV	C,ACC.7
 1991:	  85DB	22			RET

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 36



 Line  I  Addr  Code            Source

 1992:				;
 1993:				;=======
 1994:				;
 1995:				;
 1996:	  85DC			L_INIT:
 1997:				;	Initialize for execution of new BASIC source line.
 1998:				;	If none present, or if not in sequential execution mode,
 1999:				;	then return to line collection operation.
 2000:				;
 2001:	  85DC	30 03 02		JNB	RUNMOD,LINI_1	;Determine operating mode.
 2002:	  85DF	80 EE			JMP	READ_LABEL
 2003:				;
 2004:	  85E1	D3		LINI_1:	SETB	C
 2005:	  85E2	22			RET
 2006:				;
 2007:				;=======
 2008:				;
 2009:				;
 2010:				;
 2011:	  85E3			NL_NXT:
 2012:				;	Output a <CR><LF> and continue with NXT routine.
 2013:				;
 2014:	  85E3	11 6C			CALL	NLINE
 2015:				;
 2016:	  85E5			NXT:
 2017:				;	A colon or carriage return has been previously READ_CHARed.
 2018:				;	If CHAR holds a colon,
 2019:				;	continue interpretation of source line in current mode
 2020:				;	from IL program instruction "TOKEN".
 2021:				;	Otherwise CHAR is a <CR>, and line has been completed.
 2022:				;	Resume execution from IL instruction "STMT".
 2023:				;
 2024:	  85E5	BC 3A 05		CJNE	CHAR,#':',NXT_1	;Skip ahead unless colon detected.
 2025:	  85E8	91 D5			CALL	D_BLNK
 2026:	  85EA	02 88 58		JMP	TOKEN		;Continue with interpretation.
 2027:				;
 2028:	  85ED	02 88 53	NXT_1:	JMP	STMT
 2029:				;
 2030:				;=======
 2031:				;
 2032:				;$EJECT
 2033:				;
 2034:				;
 2035:	  85F0			GETLN:
 2036:				;	Input a line from console input device and put in line buffer
 2037:				;	in internal RAM.
 2038:				;
 2039:	  85F0	E5 50			MOV	A,AESP
 2040:	  85F2	24 04			ADD	A,#4
 2041:	  85F4	F5 30			MOV	TMP0,A
 2042:	  85F6	A8 30		GETL_0:	MOV	R0,TMP0		;Point to beginning of line buffer.
 2043:	  85F8	11 BF			CALL	STROUT
 2044:	  85FA	BE		        DB      ('>' OR 80H)
 2045:	  85FB	11 50		GETL_1:	CALL	C_IN		;Get next character from console.
 2046:	  85FD	B4 12 12		CJNE	A,#12H,GETL_5	;Re-type line on <CNTRL-R>.
 2047:	  8600	11 BF			CALL	STROUT
 2048:	  8602	8D		        DB      (CR OR 80H)     ;Newline.
 2049:	  8603	88 77			MOV	CURS_L,R0	;Save old value of cursor.

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 37



 Line  I  Addr  Code            Source

 2050:	  8605	A8 30			MOV	R0,TMP0		;Start at beginning of line buffer.
 2051:	  8607	E8		GETL_6:	MOV	A,R0		;Check if re-write done.
 2052:	  8608	65 77			XRL	A,CURS_L
 2053:	  860A	60 EF			JZ	GETL_1		;Continue with line input.
 2054:	  860C	E6			MOV	A,@R0		;Load character to re-write.
 2055:	  860D	11 6E			CALL	C_OUT
 2056:	  860F	08			INC	R0
 2057:	  8610	80 F5			SJMP	GETL_6		;Continue until done.
 2058:				;
 2059:	  8612	B4 18 06	GETL_5:	CJNE	A,#18H,GETL_7	;Cancel whole line on <CNTRL-X>.
 2060:	  8615	11 BF			CALL	STROUT
 2061:	  8617	23 8D		        DB      '#',(CR OR 80H) ;Advance to next line.
 2062:	  8619	80 DB			SJMP	GETL_0
 2063:				;
 2064:	  861B	B4 7F 11	GETL_7:	CJNE	A,#7FH,GETL_3
 2065:	  861E	E8			MOV	A,R0
 2066:	  861F	B5 30 05		CJNE	A,TMP0,GETL_4	;Delete previous character (if any).
 2067:	  8622	11 BF			CALL	STROUT
 2068:	  8624	87		        DB      (BEL OR 80H)    ;Echo <BEL>.
 2069:	  8625	80 D4			SJMP	GETL_1		;Ignore rubouts at beginning of line
 2070:				;
 2071:	  8627	11 BF		GETL_4:	CALL	STROUT
 2072:	  8629	08 20 88		DB	08H,' ',88H	;BKSP,SPC,BKSP
 2073:	  862C	18			DEC	R0		;Wipeout last char.
 2074:	  862D	80 CC			SJMP	GETL_1
 2075:				;
 2076:	  862F	B8 74 05	GETL_3:	CJNE	R0,#AES+AESLEN-1,GETL_2	;Test if buffer full.
 2077:	  8632	11 BF			CALL	STROUT		;Echo <BEL>.
 2078:	  8634	87		        DB      (BEL OR 80H)
 2079:	  8635	80 C4			SJMP	GETL_1		;If so, override character received.
 2080:				;
 2081:	  8637	F6		GETL_2:	MOV	@R0,A		;Store into line buffer.
 2082:	  8638	11 6E			CALL	C_OUT		;Echo character.
 2083:	  863A	08			INC	R0		;Bump pointer.
 2084:	  863B	B4 0D BD		CJNE	A,#CR,GETL_1	;Repeat for next character.
 2085:	  863E	A8 30			MOV	PNTR_L,TMP0	;Point cursor to beginning of line buffer.
 2086:	  8640	C2 09			CLR	CHAR_FLG
 2087:	  8642	22			RET
 2088:				;
 2089:				;===============
 2090:				;
 2091:				;
 2092:	  8643			PRN:
 2093:				;	Pop top of arithmetic expression stack (AES),
 2094:				;	convert to decimal number,
 2095:				;	and print to console output device, suppressing leading zeroes.
 2096:				;
 2097:	  8643	C2 0A			CLR	SGN_FLG
 2098:	  8645	71 5F			CALL	IABS
 2099:	  8647	11 F3			CALL	POP_TOS
 2100:	  8649	D2 08		PRNTOS:	SETB	ZERSUP		;Set zero suppression flag.
 2101:	  864B	E4			CLR	A
 2102:	  864C	F5 30			MOV	TMP0,A
 2103:	  864E	7D 10			MOV	LP_CNT,#16	;Conversion precision.
 2104:	  8650	20 04 1D		JB	HEXMOD,PRNHEX
 2105:	  8653	30 0A 03		JNB	SGN_FLG,PRN_1	;Skip ahead if positive number.
 2106:	  8656	11 BF			CALL	STROUT		;Output minus sign if negative.
 2107:	  8658	AD		        DB      ('-' OR 80H)

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 38



 Line  I  Addr  Code            Source

 2108:	  8659	CE		PRN_1:	XCH	A,TOS_L
 2109:	  865A	33			RLC	A
 2110:	  865B	CE			XCH	A,TOS_L
 2111:	  865C	CF			XCH	A,TOS_H
 2112:	  865D	33			RLC	A
 2113:	  865E	CF			XCH	A,TOS_H
 2114:	  865F	C5 30			XCH	A,TMP0
 2115:	  8661	35 E0			ADDC	A,ACC
 2116:	  8663	D4			DA	A
 2117:	  8664	C5 30			XCH	A,TMP0
 2118:	  8666	35 E0			ADDC	A,ACC
 2119:	  8668	D4			DA	A
 2120:	  8669	DD EE			DJNZ	LP_CNT,PRN_1
 2121:	  866B	FF			MOV	TOS_H,A
 2122:	  866C	EE			MOV	A,TOS_L
 2123:	  866D	33			RLC	A
 2124:	  866E	AE 30			MOV	TOS_L,TMP0
 2125:	  8670	11 A0		PRNHEX:	CALL	NIBOUT
 2126:	  8672	EF			MOV	A,TOS_H
 2127:	  8673	C4			SWAP	A
 2128:	  8674	11 A0			CALL	NIBOUT		;Print second digit.
 2129:	  8676	EF			MOV	A,TOS_H
 2130:	  8677	11 A0			CALL	NIBOUT		;Print third digit.
 2131:	  8679	30 04 02		JNB	HEXMOD,PRNH_1
 2132:	  867C	C2 08			CLR	ZERSUP		;Print out last two chars. (at least) in hex.
 2133:	  867E	EE		PRNH_1:	MOV	A,TOS_L		;Read into Acc.
 2134:	  867F	C4			SWAP	A		;Interchange nibbles.
 2135:	  8680	11 A0			CALL	NIBOUT		;Print fourth digit.
 2136:	  8682	C2 08			CLR	ZERSUP
 2137:	  8684	EE			MOV	A,TOS_L		;Reload byte.
 2138:	  8685	11 A0			CALL	NIBOUT		;Print last digit.
 2139:	  8687	30 04 03		JNB	HEXMOD,PRNRET
 2140:	  868A	11 BF			CALL	STROUT		;Print trailing "H".
 2141:	  868C	C8		        DB      ('H' OR 80H)
 2142:	  868D	22		PRNRET:	RET
 2143:				;
 2144:				;===============
 2145:				;
 2146:	  868E			LSTLIN:
 2147:				;	Check Label of Program line pointed to by Cursor.
 2148:				;	If legal, print line number, source line, and <CR><LF> to console,
 2149:				;	adjust Cursor to start of next line,
 2150:				;	and return with carry set.
 2151:				;	Else return with carry cleared.
 2152:				;
 2153:	  868E	B1 CF			CALL	READ_LABEL
 2154:	  8690	40 12			JC	LSTL_1
 2155:	  8692	AF 7B			MOV	TOS_H,LABL_H
 2156:	  8694	AE 7A			MOV	TOS_L,LABL_L
 2157:	  8696	C2 0A			CLR	SGN_FLG
 2158:	  8698	D1 49			CALL	PRNTOS
 2159:	  869A	11 BF			CALL	STROUT		;Insert space before user's source line.
 2160:	  869C	A0		        DB      (' ' OR 80H)
 2161:	  869D	91 B6		LSTL_2:	CALL	READ_CHAR
 2162:	  869F	11 6E			CALL	C_OUT
 2163:	  86A1	B4 0D F9		CJNE	A,#CR,LSTL_2
 2164:	  86A4	22		LSTL_1:	RET
 2165:				;

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 39



 Line  I  Addr  Code            Source

 2166:				;===============
 2167:				;
 2168:				;LST
 2169:				;	List the contents of the program memory area.
 2170:				;
 2171:				;
 2172:	  86A5	D2 03		LST:	SETB	RUNMOD
 2173:	  86A7	91 74			CALL	REWIND		;Point to first char of external buffer.
 2174:	  86A9	11 8B		LST_1:	CALL	CNTRL
 2175:	  86AB	40 04			JC	LSTRET
 2176:	  86AD	D1 8E			CALL	LSTLIN		;Print out current line if present.
 2177:	  86AF	50 F8			JNC	LST_1		;Repeat if successful.
 2178:	  86B1	C2 03		LSTRET:	CLR	RUNMOD
 2179:	  86B3	22			RET
 2180:				;
 2181:				;===============
 2182:				;
 2183:				;
 2184:	  86B4			INNUM:
 2185:				;	Read a numeric character string from the console input device.
 2186:				;	Convert to binary value and push onto arithmetic expression stack.
 2187:				;	Report error if illegal characters read.
 2188:				;
 2189:	  86B4	C2 0A			CLR	SGN_FLG		;Assume number will be positive.
 2190:	  86B6	11 BF			CALL	STROUT
 2191:	  86B8	3A A0		        DB      ':',(' ' OR 80H);Print input prompt.
 2192:	  86BA	11 50		INUM_0:	CALL	C_IN
 2193:	  86BC	11 6E			CALL	C_OUT		;Echo input
 2194:	  86BE	B4 20 02		CJNE	A,#' ',INUM_3
 2195:	  86C1	80 F7			SJMP	INUM_0
 2196:				;
 2197:	  86C3	B4 2B 02	INUM_3:	CJNE	A,#'+',INUM_4
 2198:	  86C6	80 F2			SJMP	INUM_0
 2199:				;
 2200:	  86C8	B4 2D 04	INUM_4:	CJNE	A,#'-',INUM_5
 2201:	  86CB	B2 0A			CPL	SGN_FLG
 2202:	  86CD	80 EB			SJMP	INUM_0
 2203:				;
 2204:	  86CF	51 B8		INUM_5:	CALL	CREATE		;Create value on stack if legal decimal digit.
 2205:	  86D1	50 07			JNC	INUM_2		;Abort if first character received not legal.
 2206:	  86D3	11 50		INUM_1:	CALL	C_IN		;Get additional characters.
 2207:	  86D5	11 6E			CALL	C_OUT		;Echo input.
 2208:	  86D7	B4 7F 06		CJNE	A,#7FH,INUM_6	;Start over if delete char detected.
 2209:	  86DA	11 BF		INUM_2:	CALL	STROUT
 2210:	  86DC	23 8D		        DB      '#',(CR OR 80H)
 2211:	  86DE	80 D4			SJMP	INNUM
 2212:				;
 2213:	  86E0	51 C5		INUM_6:	CALL	APPEND		;Incorporate into stack entry.
 2214:	  86E2	40 EF			JC	INUM_1		;Loop while legal characters arrive.
 2215:	  86E4	31 0B			CALL	PUSH_TOS
 2216:	  86E6	61 69			JMP	NEG_IF_NEG
 2217:				;
 2218:				;===============
 2219:				;$EJECT
 2220:	  86E8			RAM_INIT:
 2221:	  86E8	E4			CLR	A		;Many bytes to be cleared...
 2222:	  86E9	F5 20			MOV	MODE,A		;Interactive mode, decimal radix.
 2223:	  86EB	F5 21			MOV	FLAGS,A		;Interroutine flags.

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 40



 Line  I  Addr  Code            Source

 2224:	  86ED	75 A0 90	DD010:  MOV     P2,#HIGH(EXTRAM);Select first External RAM page.
 2225:	  86F0	F8		        MOV     R0,A
 2226:	  86F1	74 5A			MOV	A,#5AH		;Random bit pattern.
 2227:	  86F3	F2			MOVX	@R0,A
 2228:	  86F4	E2			MOVX	A,@R0
 2229:	  86F5	64 5A			XRL	A,#5AH
 2230:	  86F7	60 0A			JZ	EXTINI
 2231:	  86F9	E4			CLR	A
 2232:	  86FA	78 38			MOV	R0,#US_VAR	;Clear variable array.
 2233:	  86FC	F6		INIT_1:	MOV	@R0,A
 2234:	  86FD	08			INC	R0
 2235:	  86FE	B8 50 FB		CJNE	R0,#US_VAR+2*NO_VAR,INIT_1	;Loop until all vars cleared.
 2236:	  8701	80 09			SJMP	INIT_3
 2237:				;
 2238:	  8703	D2 00		EXTINI:	SETB	EXTVAR
 2239:	  8705	E4			CLR	A
 2240:	  8706	F8			MOV	R0,A		;Clear variable array.
 2241:	  8707	F2		INIT_2:	MOVX	@R0,A
 2242:	  8708	08			INC	R0
 2243:	  8709	B8 34 FB		CJNE	R0,#2*26,INIT_2	;Loop until all vars cleared.
 2244:	  870C	22		INIT_3:	RET
 2245:				;
 2246:				;========
 2247:				;
 2248:				;INIT
 2249:				;	Perform global initialization:
 2250:				;	Clear program memory, empty all I/O buffers, reset all stack
 2251:				;	pointers, etc.
 2252:				;
 2253:				;
 2254:	  870D	D1 E8		INIT:	CALL	RAM_INIT
 2255:	  870F	78 34		        MOV     R0,#LOW(EXTRAM)
 2256:	  8711	74 FF			MOV	A,#0FFH
 2257:	  8713	F2			MOVX	@R0,A
 2258:	  8714	22			RET
 2259:				;
 2260:				;===============
 2261:				;
 2262:				;$EJECT
 2263:				;
 2264:				;	BASIC PROGRAM LINE SEQUENCE CONTROL MACROS:
 2265:				;	===== ======= ==== ======== ======= ======
 2266:				;
 2267:				;XINIT
 2268:				;	Perform initialization needed before starting sequential execution.
 2269:				;	Empty stacks, set BASIC line number to 1, etc.
 2270:				;
 2271:				;
 2272:	  8715	75 50 50	XINIT:	MOV	AESP,#AES-1	;Initialize AE Stack.
 2273:	  8718	91 74			CALL	REWIND
 2274:	  871A	D2 03			SETB	RUNMOD
 2275:	  871C	22			RET			;Begin execution.
 2276:				;
 2277:				;===============
 2278:				;
 2279:	  871D			FNDLBL:
 2280:				;	Search program buffer for line with label passed on AES (Pop AES).
 2281:				;	If found, return with CURSOR pointing to start of line (before label)

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 41



 Line  I  Addr  Code            Source

 2282:				;	and carry cleared.
 2283:				;	If not found return with carry set and pointer at start of first
 2284:				;	line with a greater label value (possible EOF).
 2285:				;
 2286:	  871D	D2 03			SETB	RUNMOD		;Kludge to make GET_C fetch from prog. buffer.
 2287:	  871F	91 74			CALL	REWIND
 2288:	  8721	11 F3			CALL	POP_TOS
 2289:	  8723	91 8B		FND_1:	CALL	SAVE_PNTR	;Store position of beginning of line.
 2290:	  8725	B1 CF			CALL	READ_LABEL
 2291:	  8727	40 12			JC	FNDDON
 2292:	  8729	EE			MOV	A,TOS_L
 2293:	  872A	95 7A			SUBB	A,LABL_L
 2294:	  872C	F5 7A			MOV	LABL_L,A	;Save non-zero bits.
 2295:	  872E	EF			MOV	A,TOS_H
 2296:	  872F	95 7B			SUBB	A,LABL_H
 2297:	  8731	45 7A			ORL	A,LABL_L	;Test for non-zero bits.
 2298:	  8733	60 06			JZ	FNDDON
 2299:	  8735	40 04			JC	FNDDON		;Carry=1 if a greater label value found.
 2300:	  8737	91 E3			CALL	SKPTXT		;Skip over remaining text portion of line.
 2301:	  8739	80 E8			SJMP	FND_1
 2302:				;
 2303:	  873B	81 92		FNDDON:	JMP	LOAD_PNTR
 2304:				;
 2305:				;=======
 2306:				;
 2307:	  873D			KILL_L:
 2308:				;	Kill (delete) line from code buffer indicated by pointer.
 2309:				;	When called, CURSOR and POINTER hold the address of first LABEL byte of
 2310:				;	line to be deleted.
 2311:				;
 2312:	  873D	A9 77			MOV	DEST_L,CURS_L
 2313:	  873F	AB 78			MOV	DEST_H,CURS_H
 2314:	  8741	91 DF			CALL	SKPLIN		;Pass pointer over full text line.
 2315:				;
 2316:				;	Pointer now indicates first label byte of following line.
 2317:				;	Cursor and DEST still indicate first label byte of obsolete line.
 2318:				;
 2319:	  8743	91 B6		KILL_2:	CALL	READ_CHAR	;Copy down first label byte.
 2320:	  8745	91 CD			CALL	WRITE_CHAR	;Transfer first byte of label number.
 2321:	  8747	20 E7 0D		JB	ACC.7,KILL_9	;Quit when End of Code sentinel reached.
 2322:	  874A	91 B6			CALL	READ_CHAR	;Copy down second label byte.
 2323:	  874C	91 CD			CALL	WRITE_CHAR	;Store second byte of label number.
 2324:	  874E	91 B6		KILL_3:	CALL	READ_CHAR	;Transfer text character.
 2325:	  8750	91 CD			CALL	WRITE_CHAR
 2326:	  8752	B4 0D F9		CJNE	A,#CR,KILL_3	;Loop until full line moved.
 2327:	  8755	80 EC			SJMP	KILL_2		;Continue until all code moved forward.
 2328:				;
 2329:	  8757	22		KILL_9:	RET			;Full line now deleted.
 2330:				;
 2331:				;=======
 2332:				;
 2333:	  8758			OPEN_L:
 2334:				;	Open space for new line in code buffer starting at Cursor.
 2335:				;
 2336:	  8758	91 92			CALL	LOAD_PNTR	;Load address of point for insertion.
 2337:	  875A	C2 09			CLR	CHAR_FLG
 2338:	  875C	91 B6		OPEN_3:	CALL	READ_CHAR	;Test first label byte of following line.
 2339:	  875E	20 E7 09		JB	ACC.7,OPEN_4

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 42



 Line  I  Addr  Code            Source

 2340:	  8761	91 B6			CALL	READ_CHAR	;Pass over next LABEL byte.
 2341:	  8763	91 B6		OPEN_5:	CALL	READ_CHAR
 2342:	  8765	B4 0D FB		CJNE	A,#CR,OPEN_5
 2343:	  8768	80 F2			SJMP	OPEN_3
 2344:				;
 2345:				;	Pointer now indicates end-of-buffer sentinel.
 2346:				;
 2347:	  876A	E5 37		OPEN_4:	MOV	A,STRLEN	;Number of bytes needed for BASIC text.
 2348:	  876C	24 03			ADD	A,#3		;Space needed for for label and <CR>.
 2349:	  876E	28			ADD	A,R0		;Low-order byte of old pointer.
 2350:	  876F	F9			MOV	DEST_L,A
 2351:	  8770	E4			CLR	A
 2352:	  8771	3A			ADDC	A,PNTR_H
 2353:	  8772	FB			MOV	DEST_H,A
 2354:	  8773	B4 A0 02	        CJNE    A,#HIGH(RAMLIM),OPEN_1
 2355:	  8776	01 DD			JMP	AES_ER
 2356:				;
 2357:				;	Transfer characters from source back to destination
 2358:				;	until pointer at original CURSOR value.
 2359:				;
 2360:	  8778	91 9E		OPEN_1:	CALL	GET_BUF		;Move back next character.
 2361:	  877A	91 C4			CALL	PUT_BUF
 2362:	  877C	E8			MOV	A,PNTR_L
 2363:	  877D	B5 77 05		CJNE	A,CURS_L,OPEN_2
 2364:	  8780	EA			MOV	A,PNTR_H
 2365:	  8781	B5 78 01		CJNE	A,CURS_H,OPEN_2
 2366:				;
 2367:				;	All bytes have been moved back.
 2368:				;
 2369:	  8784	22			RET
 2370:				;
 2371:	  8785			OPEN_2:
 2372:				;	Decrement src. and dest. pointers and repeat.
 2373:				;
 2374:	  8785	18			DEC	PNTR_L
 2375:	  8786	B8 FF 01		CJNE	PNTR_L,#0FFH,OPEN_6
 2376:	  8789	1A			DEC	PNTR_H
 2377:	  878A	19		OPEN_6:	DEC	DEST_L
 2378:	  878B	B9 FF EA		CJNE	DEST_L,#0FFH,OPEN_1
 2379:	  878E	1B			DEC	DEST_H
 2380:	  878F	80 E7			SJMP	OPEN_1		;Repeat for next character.
 2381:				;
 2382:				;=======
 2383:				;
 2384:	  8791			INSR_L:
 2385:				;	Insert program line label (still held in <TOS_H><TOS_L> from earlier
 2386:				;	call to FNDLBL)
 2387:				;	and character string in line buffer (pointed at by L_CURS)
 2388:				;	into program buffer gap created by OPEN_L routine
 2389:				;	(still pointed at by CURSOR).
 2390:				;
 2391:	  8791	A9 77			MOV	DEST_L,CURS_L
 2392:	  8793	AB 78			MOV	DEST_H,CURS_H
 2393:	  8795	EF			MOV	A,TOS_H
 2394:	  8796	91 CD			CALL	WRITE_CHAR
 2395:	  8798	EE			MOV	A,TOS_L
 2396:	  8799	91 CD			CALL	WRITE_CHAR
 2397:	  879B	A8 75			MOV	PNTR_L,L_CURS

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 43



 Line  I  Addr  Code            Source

 2398:	  879D	E6		INSL_1:	MOV	A,@PNTR_L
 2399:	  879E	91 CD			CALL	WRITE_CHAR
 2400:	  87A0	08			INC	PNTR_L
 2401:	  87A1	B4 0D F9		CJNE	A,#CR,INSL_1
 2402:	  87A4	22			RET
 2403:				;
 2404:				;=======
 2405:				;
 2406:				;
 2407:	  87A5			INSRT:
 2408:				;	Pop line number from top of arithmetic expression stack.
 2409:				;	Search BASIC source program for corresponding line number.
 2410:				;	If found, delete old line.
 2411:				;	Otherwise position cursor before next sequential line number.
 2412:				;	If line buffer is not empty then insert line number, contents of
 2413:				;	line buffer, and line terminator.
 2414:				;
 2415:	  87A5	18			DEC	PNTR_L		;Since previous D_BLNK passed over first char.
 2416:	  87A6	88 75			MOV	L_CURS,PNTR_L
 2417:	  87A8	F1 1D			CALL	FNDLBL
 2418:	  87AA	40 02			JC	INSR_1
 2419:	  87AC	F1 3D			CALL	KILL_L		;Delete line iff label found in buffer.
 2420:	  87AE	A9 75		INSR_1:	MOV	R1,L_CURS
 2421:	  87B0	19			DEC	R1
 2422:	  87B1	09		INSR_2:	INC	R1
 2423:	  87B2	E7			MOV	A,@R1
 2424:	  87B3	B4 0D FB		CJNE	A,#CR,INSR_2
 2425:	  87B6	E9			MOV	A,R1
 2426:	  87B7	C3			CLR	C
 2427:	  87B8	95 75			SUBB	A,L_CURS
 2428:	  87BA	F5 37			MOV	STRLEN,A
 2429:	  87BC	60 04			JZ	INSR_4
 2430:	  87BE	F1 58			CALL	OPEN_L
 2431:	  87C0	F1 91			CALL	INSR_L
 2432:	  87C2	C2 03		INSR_4:	CLR	RUNMOD
 2433:	  87C4	22			RET
 2434:				;
 2435:				;===============
 2436:				;
 2437:				;
 2438:	  87C5	11 F3		COND:	CALL	POP_TOS
 2439:	  87C7	EE			MOV	A,TOS_L
 2440:	  87C8	13			RRC	A
 2441:	  87C9	22			RET
 2442:				;
 2443:				;=======
 2444:				;
 2445:				;XFER
 2446:				;	Pop the value from the top of the arithmetic expression stack (AES).
 2447:				;	Position cursor at beginning of the BASIC source program line
 2448:				;	with that label and begin source interpretation.
 2449:				;	(Report error if corresponding source line not found.)
 2450:				;
 2451:				;
 2452:	  87CA	F1 1D		XFER:	CALL	FNDLBL
 2453:	  87CC	40 03			JC	XFERNG
 2454:	  87CE	02 88 53		JMP	STMT		;Begin execution of source line.
 2455:				;

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 44



 Line  I  Addr  Code            Source

 2456:	  87D1	01 D4		XFERNG:	JMP	EXP_ER
 2457:				;
 2458:				;===============
 2459:				;
 2460:				;
 2461:	  87D3			SAV:
 2462:				;	Push BASIC line number of current source line onto AES.
 2463:				;
 2464:	  87D3	AF 7B			MOV	TOS_H,LABL_H
 2465:	  87D5	AE 7A			MOV	TOS_L,LABL_L
 2466:	  87D7	21 0B			JMP	PUSH_TOS
 2467:				;
 2468:				;===============
 2469:				;
 2470:				;
 2471:	  87D9			RSTR:
 2472:				;	If AES is empty report a nesting error.
 2473:				;	Otherwise, pop AES into current BASIC souce program line number.
 2474:				;
 2475:	  87D9	F1 1D			CALL	FNDLBL
 2476:	  87DB	91 DF			CALL	SKPLIN		;Pass over statement initiating transfer.
 2477:	  87DD	02 88 53		JMP	STMT
 2478:				;
 2479:				;===============
 2480:				;
 2481:				;
 2482:	  87E0			LOOP:
 2483:				;	LOOP is called with the AES holding:
 2484:				;	(TOS:)	2 byte VALUE of variable after being incremented,
 2485:				;		2 byte INDEX of variable being incremented,
 2486:				;		1 byte TYPE of variable code,
 2487:				;		2 byte LABEL of line initiating FOR loop,
 2488:				;		2 byte LIMIT specified by FOR statement,
 2489:				;		2 byte INDEX of variable used by FOR loop,
 2490:				;		1 byte TYPE of variable code.
 2491:				;	If indices disagree, then generate syntax error.
 2492:				;	Otherwise, store incremented value in variable popping both from AES.
 2493:				;	If the incremented value <= LIMIT then return with carry set.
 2494:				;	If incr. val. > LIMIT looping is done, so return with carry not set.
 2495:				;
 2496:				;	Compare all three bytes of variable index.
 2497:	  87E0	E8			MOV	A,R0
 2498:	  87E1	C0 E0			PUSH	ACC
 2499:	  87E3	E5 50			MOV	A,AESP
 2500:	  87E5	24 FE			ADD	A,#-2
 2501:	  87E7	F9			MOV	R1,A
 2502:	  87E8	24 F9			ADD	A,#-7
 2503:	  87EA	F8			MOV	R0,A
 2504:	  87EB	7D 03			MOV	LP_CNT,#3	;Set to test three bytes.
 2505:	  87ED	E7		LOOP_0:	MOV	A,@R1
 2506:	  87EE	66			XRL	A,@R0
 2507:	  87EF	70 1F			JNZ	LOOP_1
 2508:	  87F1	18			DEC	R0
 2509:	  87F2	19			DEC	R1
 2510:	  87F3	DD F8			DJNZ	LP_CNT,LOOP_0
 2511:				;
 2512:				;	All three bytes of variable code match.
 2513:	  87F5	D0 E0			POP	ACC

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 45



 Line  I  Addr  Code            Source

 2514:	  87F7	F8			MOV	R0,A
 2515:	  87F8	31 F7			CALL	STORE
 2516:	  87FA	E5 50			MOV	A,AESP
 2517:	  87FC	24 FD			ADD	A,#-3
 2518:	  87FE	F9			MOV	R1,A
 2519:	  87FF	C3			CLR	C
 2520:	  8800	E7			MOV	A,@R1
 2521:	  8801	95 30			SUBB	A,TMP0
 2522:	  8803	09			INC	R1
 2523:	  8804	E7			MOV	A,@R1
 2524:	  8805	20 04 05		JB	HEXMOD,LOOP_2	;Branch forward if unsigned compare correct.
 2525:	  8808	64 80			XRL	A,#80H		;Adjust sign bits so signed compare valid.
 2526:	  880A	63 31 80		XRL	TMP1,#80H
 2527:	  880D	95 31		LOOP_2:	SUBB	A,TMP1
 2528:	  880F	22			RET
 2529:				;
 2530:				;	Indices don't match.
 2531:				;
 2532:	  8810	D0 E0		LOOP_1:	POP	ACC
 2533:	  8812	F8			MOV	R0,A
 2534:	  8813	02 80 E8		JMP	SYN_ER
 2535:				;
 2536:				;=======
 2537:				;
 2538:				;FIN
 2539:				;	Return to line collection routine.
 2540:				;
 2541:				;
 2542:	  8816	C2 03		FIN:	CLR	RUNMOD
 2543:	  8818	02 88 3A		JMP	CONT		;Return to line collection mode.
 2544:				;
 2545:				;===============
 2546:				;
 2547:				;$EJECT
 2548:				;
 2549:				;	IL SEQUENCE CONTROL INSTRUCTIONS:
 2550:				;	== ======== ======= ============
 2551:				;
 2552:				;IJMP	(LBL)
 2553:				;	Jump to the (potentially distant) IL instruction at location LBL.
 2554:				;Note:	In this implementation IL addresses are equivalent to machine
 2555:				;	language addresses, so IJMP performs a generic JMP.
 2556:				;
 2557:				;
 2558:				;===============
 2559:				;
 2560:				;HOP	(LBL)
 2561:				;	Perform a branch to the IL instruction at (nearby) location LBL.
 2562:				;Note:	In this implementation IL addresses are equivalent to machine
 2563:				;	language addresses, so HOP performs a simple relative SJMP.
 2564:				;
 2565:				;
 2566:				;===============
 2567:				;
 2568:				;ICALL	(LBL)
 2569:				;	Call the IL subroutine starting at instruction LBL.
 2570:				;	Save the location of the next IL instruction on the control stack.
 2571:				;Note:	In this implementation, IL addresses are identical with

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 46



 Line  I  Addr  Code            Source

 2572:				;	machine language addresses, and are saved on the MCS-51 hardware stack.
 2573:				;
 2574:				;
 2575:				;===============
 2576:				;
 2577:				;IRET
 2578:				;	Return from IL subroutine to location on top of control stack.
 2579:				;Note:	In this implementation, IL addresses are identical with machine
 2580:				;	language addresses, which are saved on the hardware stack.
 2581:				;
 2582:				;
 2583:				;===============
 2584:				;
 2585:				;MLCALL
 2586:				;	Call the ML subroutine starting at the address on top of AES.
 2587:				;
 2588:				;
 2589:	  881B	A9 50		MLCALL:	MOV	R1,AESP
 2590:	  881D	87 F0			MOV	B,@R1
 2591:	  881F	19			DEC	R1
 2592:	  8820	E7			MOV	A,@R1
 2593:	  8821	19			DEC	R1
 2594:	  8822	89 50			MOV	AESP,R1
 2595:	  8824	C0 E0			PUSH	ACC
 2596:	  8826	C0 F0			PUSH	B
 2597:	  8828	43 D0 18		ORL	PSW,#00011000B	;Select RB3.
 2598:	  882B	22			RET			;Branch to user routine.
 2599:				;
 2600:				;=======
 2601:				;$EJECT
 2602:				;$RESTORE
 2603:				;
 2604:				;	STATEMENT EXECUTOR WRITTEN IN IL (INTERPRETIVE LANGUAGE)
 2605:				;	OPERATIONS IMPLEMENTED BY ASM51 MPL MACRO PROCESSING LANGUAGE
 2606:				;			(8/11/80)
 2607:				;
 2608:	  882C	02 80 E8	CMD_NG:	JMP	SYN_ER
 2609:				;
 2610:	  882F	12 87 0D	START:  CALL    INIT
 2611:	  8832	C2 03		ERRENT:	CLR	RUNMOD
 2612:	  8834	75 81 7F		MOV	SP,#SP_BASE	;Re-initialize hardware stack.
 2613:	  8837	75 50 50		MOV	AESP,#AES-1	;Initialize AES pointer.
 2614:	  883A	12 80 BF	CONT:	CALL	STROUT
 2615:	  883D	4F 4B 8D	        DB      'OK',(CR OR 80H)
 2616:	  8840	12 85 F0	CONT_1: CALL    GETLN          ;Receive interactive command line.
 2617:	  8843	12 84 D5		CALL	D_BLNK
 2618:				        TSTL_   TOKEN
 2619+ 1  8846	12 85 7E	        CALL    TSTN
 2620+ 1  8849	50 0D		        JNC     TOKEN
 2621:	  884B	12 87 A5	        CALL    INSRT
 2622:				        HOP_    CONT_1
 2623+ 1  884E	80 F0		        SJMP    CONT_1
 2624:				;
 2625:				;=======
 2626:				;
 2627:	  8850	12 87 15	XEC:    CALL    XINIT          ;Initialize for sequential execution.
 2628:	  8853			STMT:   LINIT_          ;Initialize for line execution.
 2629+ 1  8853	12 85 DC	        CALL   L_INIT

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 47



 Line  I  Addr  Code            Source

 2630+ 1  8856	40 DA		        JC      ERRENT
 2631:	  8858	12 80 8B	TOKEN:	CALL	CNTRL
 2632:	  885B	12 84 D5		CALL	D_BLNK
 2633:				        TSTV_   S0            ;Parse implied LET command.
 2634+ 1  885E	12 85 19	        CALL    TSTV
 2635+ 1  8861	50 08		        JNC     S0
 2636:				;*        %TST    (SE4,=)
 2637:	  8863	12 84 E9	        call   tst
 2638:	  8866	BD		        db      ('=' OR 80H)
 2639:	  8867	50 2F		        jnc     se4
 2640:				        HOP_    SE3
 2641+ 1  8869	80 13		        SJMP    SE3
 2642:				;
 2643:				;*S0:     %TST    (S1,LET)                ;Parse explicit LET command.
 2644:	  886B	12 84 E9	s0:     call   tst
 2645:	  886E	4C 45 D4	        db      'LE',('T' OR 80H)
 2646:	  8871	50 31		        jnc     s1
 2647:				        TSTV_   CMD_NG
 2648+ 1  8873	12 85 19	        CALL    TSTV
 2649+ 1  8876	50 B4		        JNC     CMD_NG
 2650:				;*        %TST    (CMD_NG,=)
 2651:	  8878	12 84 E9	        call   tst
 2652:	  887B	BD		        db      ('=' OR 80H)
 2653:	  887C	50 AE		        jnc     cmd_ng
 2654:	  887E			SE3:    ICALL_  EXPR
 2655+ 1  887E	12 8A B3	        CALL    EXPR
 2656:				;*        %TST    (SE3A,%1,)
 2657:	  8881	12 84 E9	        call   tst
 2658:	  8884	AC		        db      (',' OR 80H)            ;to match tb51.lst
 2659:	  8885	50 08		        jnc     se3a
 2660:	  8887	12 81 F3	        CALL    SEQ_STORE
 2661:	  888A	12 83 6D		CALL	IINC
 2662:				        HOP_    SE3
 2663+ 1  888D	80 EF		        SJMP    SE3
 2664:				;
 2665:	  888F	12 85 B1	SE3A:   CALL    DONE
 2666:	  8892	12 81 F7		CALL	STORE
 2667:	  8895	02 85 E5	        JMP     NXT
 2668:				;
 2669:	  8898	12 85 B1	SE4:    CALL    DONE           ;Process implied PRINT command.
 2670:	  889B	12 82 5B		CALL	FETCH
 2671:	  889E	12 86 43	        CALL    PRN
 2672:	  88A1	02 85 E3	        JMP     NL_NXT
 2673:				;
 2674:				;=======
 2675:				;
 2676:				;*S1:     %TST    (S2,GOTO)               ;Parse GOTO command.
 2677:	  88A4	12 84 E9	s1:     call   tst
 2678:	  88A7	47 4F 54 CF	        db      'GOT',('O' OR 80H)
 2679:	  88AB	50 09		        jnc     s2
 2680:				        ICALL_  EXPR
 2681+ 1  88AD	12 8A B3	        CALL    EXPR
 2682:	  88B0	12 85 B7	        CALL    LNDONE
 2683:	  88B3	02 87 CA	        JMP     XFER
 2684:				;
 2685:				;=======
 2686:				;
 2687:				;*S2:     %TST    (S3,GOSUB)              ;Parse GOSUB command.

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 48



 Line  I  Addr  Code            Source

 2688:	  88B6	12 84 E9	s2:     call   tst
 2689:	  88B9	47 4F 53 55	        db      'GOSU',('B' OR 80H)
	  88BD	C2
 2690:	  88BE	50 0C		        jnc     s3
 2691:	  88C0	12 87 D3	        CALL    SAV
 2692:				        ICALL_  EXPR
 2693+ 1  88C3	12 8A B3	        CALL    EXPR
 2694:	  88C6	12 85 B7	        CALL    LNDONE
 2695:	  88C9	02 87 CA	        JMP     XFER
 2696:				;
 2697:				;=======
 2698:				;
 2699:				;*S3:     %TST    (S8,PRINT)              ;Parse PRINT command.
 2700:	  88CC	12 84 E9	s3:     call   tst
 2701:	  88CF	50 52 49 4E	        db      'PRIN',('T' OR 80H)
	  88D3	D4
 2702:	  88D4	50 44		        jnc     s8
 2703:				        IFDONE_ S6B
 2704+ 1  88D6	12 85 C1	        CALL    IFDONE
 2705+ 1  88D9	50 39		        JNC     S6B
 2706:				;*S3A:    %TST    (S3B,;)
 2707:	  88DB	12 84 E9	s3a:    call   tst
 2708:	  88DE	BB		        db      (';' OR 80H)
 2709:	  88DF	50 02		        jnc     s3b
 2710:				        HOP_    S3A
 2711+ 1  88E1	80 F8		        SJMP    S3A
 2712:				;
 2713:				;*S3B:    %TST    (S3C,%1,)
 2714:	  88E3	12 84 E9	s3b:    call   tst
 2715:	  88E6	AC		        db      (',' OR 80H)            ;to match TB51.LST
 2716:	  88E7	50 05		        jnc     s3c
 2717:	  88E9	12 80 99	        CALL    SPC
 2718:				        HOP_    S3A
 2719+ 1  88EC	80 ED		        SJMP    S3A
 2720:				;
 2721:	  88EE			S3C:    IFDONE_ S6A
 2722+ 1  88EE	12 85 C1	        CALL    IFDONE
 2723+ 1  88F1	50 24		        JNC     S6A
 2724:				        TSTS_   S5
 2725+ 1  88F3	12 85 93	        CALL    TSTS
 2726+ 1  88F6	40 06		        JC      S5
 2727:				        ICALL_  EXPR
 2728+ 1  88F8	12 8A B3	        CALL    EXPR
 2729:	  88FB	12 86 43	        CALL    PRN
 2730:				;*S5:     %TST    (S5A,%1,)
 2731:	  88FE	12 84 E9	s5:     call   tst
 2732:	  8901	AC		        db      (',' OR 80H)            ;to match TB51.LST
 2733:	  8902	50 05		        jnc     s5a
 2734:	  8904	12 80 99	        CALL    SPC
 2735:				        HOP_    S3A
 2736+ 1  8907	80 D2		        SJMP    S3A
 2737:				;
 2738:				;*S5A:    %TST    (S6,;)
 2739:	  8909	12 84 E9	s5a:    call   tst
 2740:	  890C	BB		        db      (';' OR 80H)
 2741:	  890D	50 02		        jnc     s6
 2742:				        HOP_    S3A
 2743+ 1  890F	80 CA		        SJMP    S3A

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 49



 Line  I  Addr  Code            Source

 2744:				;
 2745:	  8911	12 85 B1	S6:     CALL    DONE
 2746:	  8914	02 85 E3	S6B:    JMP     NL_NXT
 2747:				;
 2748:	  8917	02 85 E5	S6A:    JMP     NXT
 2749:				;
 2750:				;=======
 2751:				;
 2752:				;*S8:     %TST    (S9,IF)         ;Parse IF command.
 2753:	  891A	12 84 E9	s8:     call   tst
 2754:	  891D	49 C6		        db      'I',('F' OR 80H)
 2755:	  891F	50 18		        jnc     s9
 2756:				        ICALL_  EXPR
 2757+ 1  8921	12 8A B3	        CALL    EXPR
 2758:				;*        %TST    (S8A,THEN)
 2759:	  8924	12 84 E9	        call   tst
 2760:	  8927	54 48 45 CE	        db      'THE',('N' OR 80H)
 2761:	  892B	50 00		        jnc     s8a
 2762:	  892D			S8A:    COND_   S8B
 2763+ 1  892D	12 87 C5	        CALL   COND
 2764+ 1  8930	50 02		        JNC    S8B
 2765:				        IJMP_   TOKEN         ;Continue parsing command.
 2766+ 1  8932	01 58		        JMP     TOKEN
 2767:				;
 2768:	  8934	12 84 E3	S8B:    CALL    SKPTXT
 2769:				        IJMP_   STMT
 2770+ 1  8937	01 53		        JMP     STMT
 2771:				;
 2772:				;=======
 2773:				;
 2774:				;*S9:     %TST    (S12,INPUT)             ;Parse INPUT command.
 2775:	  8939	12 84 E9	s9:     call   tst
 2776:	  893C	49 4E 50 55	        db      'INPU',('T' OR 80H)
	  8940	D4
 2777:	  8941	50 2C		        jnc     s12
 2778:	  8943			S10:    TSTS_   S10B
 2779+ 1  8943	12 85 93	        CALL    TSTS
 2780+ 1  8946	40 0B		        JC      S10B
 2781:				        TSTV_   S10D
 2782+ 1  8948	12 85 19	        CALL    TSTV
 2783+ 1  894B	50 19		        JNC     S10D
 2784:	  894D	12 86 B4	        CALL    INNUM
 2785:	  8950	12 81 F7		CALL	STORE
 2786:				;*S10B:   %TST    (S10C,;)
 2787:	  8953	12 84 E9	s10b:   call   tst
 2788:	  8956	BB		        db      (';' OR 80H)
 2789:	  8957	50 02		        jnc     s10c
 2790:				        HOP_    S10
 2791+ 1  8959	80 E8		        SJMP    S10
 2792:				;
 2793:				;*S10C:   %TST    (S11,%1,)
 2794:	  895B	12 84 E9	s10c:   call   tst
 2795:	  895E	AC		        db      (',' OR 80H)            ;to match TB51.LST
 2796:	  895F	50 08		        jnc     s11
 2797:	  8961	12 80 99	        CALL    SPC
 2798:				        HOP_    S10
 2799+ 1  8964	80 DD		        SJMP    S10
 2800:				;

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 50



 Line  I  Addr  Code            Source

 2801:	  8966			S10D:   IJMP_   SYN_NG
 2802+ 1  8966	02 8B A3	        JMP     SYN_NG
 2803:				;
 2804:	  8969	12 85 B1	S11:    CALL    DONE
 2805:	  896C	02 85 E3	        JMP     NL_NXT
 2806:				;
 2807:				;=======
 2808:				;
 2809:				;*S12:    %TST    (S13,RETURN)            ;Parse RETURN command.
 2810:	  896F	12 84 E9	s12:    call   tst
 2811:	  8972	52 45 54 55	        db      'RETUR',('N' OR 80H)
	  8976	52 CE
 2812:	  8978	50 06		        jnc     s13
 2813:	  897A	12 85 B7	        CALL    LNDONE
 2814:	  897D	02 87 D9	        JMP     RSTR
 2815:				;
 2816:				;=======
 2817:				;
 2818:				;*S13:    %TST    (S13A,CALL)             ;Machine language CALL.
 2819:	  8980	12 84 E9	s13:    call   tst
 2820:	  8983	43 41 4C CC	        db      'CAL',('L' OR 80H)
 2821:	  8987	50 0E		        jnc     s13a
 2822:				        ICALL_  EXPR
 2823+ 1  8989	12 8A B3	        CALL    EXPR
 2824:	  898C	12 85 B7	        CALL    LNDONE
 2825:				        MLCALL_
 2826+ 1  898F	11 1B		        CALL    MLCALL
 2827+ 1  8991	53 D0 E7	        ANL     PSW,#11100111B
 2828:	  8994	02 85 E5	        JMP     NXT
 2829:				;
 2830:				;=======
 2831:				;
 2832:				;*S13A:   %TST    (S13B,FOR)
 2833:	  8997	12 84 E9	s13a:   call   tst
 2834:	  899A	46 4F D2	        db      'FO',('R' OR 80H)
 2835:	  899D	50 24		        jnc     s13b
 2836:				        TSTV_   FOR_ER
 2837+ 1  899F	12 85 19	        CALL    TSTV
 2838+ 1  89A2	50 50		        JNC     FOR_ER
 2839:				;*        %TST    (FOR_ER,=)
 2840:	  89A4	12 84 E9	        call   tst
 2841:	  89A7	BD		        db      ('=' OR 80H)
 2842:	  89A8	50 4A		        jnc     for_er
 2843:				        ICALL_  EXPR
 2844+ 1  89AA	12 8A B3	        CALL    EXPR
 2845:	  89AD	12 81 F3		CALL	SEQ_STORE
 2846:				;*        %TST    (FOR_ER,TO)
 2847:	  89B0	12 84 E9	        call   tst
 2848:	  89B3	54 CF		        db      'T',('O' OR 80H)
 2849:	  89B5	50 3D		        jnc     for_er
 2850:				        ICALL_  EXPR
 2851+ 1  89B7	12 8A B3	        CALL    EXPR
 2852:	  89BA	12 85 B7	        CALL    LNDONE
 2853:	  89BD	12 87 D3	        CALL    SAV
 2854:	  89C0	02 85 E5	        JMP     NXT
 2855:				;
 2856:				;=======
 2857:				;

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 51



 Line  I  Addr  Code            Source

 2858:				;*S13B:   %TST    (S13C,NEXT)
 2859:	  89C3	12 84 E9	s13b:   call   tst
 2860:	  89C6	4E 45 58 D4	        db      'NEX',('T' OR 80H)
 2861:	  89CA	50 2A		        jnc     s13c
 2862:				        TSTV_   FOR_ER
 2863+ 1  89CC	12 85 19	        CALL    TSTV
 2864+ 1  89CF	50 23		        JNC     FOR_ER
 2865:	  89D1	12 85 B1	        CALL    DONE
 2866:	  89D4	12 82 57		CALL	SEQ_FETCH
 2867:	  89D7	12 83 6D		CALL	IINC
 2868:				        NEXT_LOOP_      FORDON
 2869+ 1  89DA	12 87 E0	        CALL   LOOP
 2870+ 1  89DD	40 06		        JC     FORDON
 2871:	  89DF	12 81 1E		CALL	DUPL
 2872:	  89E2	02 87 D9	        JMP     RSTR
 2873:				;
 2874:	  89E5	12 80 F3	FORDON:	CALL	POP_TOS
 2875:	  89E8	12 80 F3		CALL	POP_TOS
 2876:	  89EB	12 80 F3		CALL	POP_TOS
 2877:	  89EE	12 81 05		CALL	POP_ACC
 2878:	  89F1	02 85 E5	        JMP     NXT
 2879:				;
 2880:				;=======
 2881:				;
 2882:	  89F4			FOR_ER: IJMP_   CMD_NG
 2883+ 1  89F4	01 2C		        JMP     CMD_NG
 2884:				;
 2885:				;=======
 2886:				;
 2887:				;*S13C:   %TST    (S14,END)               ;Parse END command.
 2888:	  89F6	12 84 E9	s13c:   call   tst
 2889:	  89F9	45 4E C4	        db      'EN',('D' OR 80H)
 2890:	  89FC	50 05		        jnc     s14
 2891:	  89FE	12 85 B7	        CALL    LNDONE
 2892:	  8A01	01 16		        JMP     FIN
 2893:				;
 2894:				;=======
 2895:				;
 2896:				;*S14:    %TST    (S15,LIST)              ;Parse LIST command.
 2897:	  8A03	12 84 E9	s14:    call   tst
 2898:	  8A06	4C 49 53 D4	        db      'LIS',('T' OR 80H)
 2899:	  8A0A	50 15		        jnc     s15
 2900:				        IFDONE_ S14B
 2901+ 1  8A0C	12 85 C1	        CALL    IFDONE
 2902+ 1  8A0F	50 0B		        JNC     S14B
 2903:				        ICALL_  EXPR
 2904+ 1  8A11	12 8A B3	        CALL    EXPR
 2905:	  8A14	12 87 1D		CALL	FNDLBL
 2906:	  8A17	12 86 A9		CALL	LST_1
 2907:				        IJMP_   CONT
 2908+ 1  8A1A	01 3A		        JMP     CONT
 2909:				;
 2910:	  8A1C	12 86 A5	S14B:   CALL    LST
 2911:				        IJMP_   CONT
 2912+ 1  8A1F	01 3A		        JMP     CONT
 2913:				;
 2914:				;=======
 2915:				;

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 52



 Line  I  Addr  Code            Source

 2916:				;*S15:    %TST    (S16,RUN)               ;Parse LIST command.
 2917:	  8A21	12 84 E9	s15:    call   tst
 2918:	  8A24	52 55 CE	        db      'RU',('N' OR 80H)
 2919:	  8A27	50 05		        jnc     s16
 2920:	  8A29	12 85 B7	        CALL    LNDONE
 2921:				        IJMP_   XEC
 2922+ 1  8A2C	01 50		        JMP     XEC
 2923:				;
 2924:				;=======
 2925:				;
 2926:				;*S16:    %TST    (S16A,NEW)
 2927:	  8A2E	12 84 E9	s16:    call   tst
 2928:	  8A31	4E 45 D7	        db      'NE',('W' OR 80H)
 2929:	  8A34	50 05		        jnc     s16a
 2930:	  8A36	12 85 B1	        CALL    DONE
 2931:				        IJMP_   START
 2932+ 1  8A39	01 2F		        JMP     START
 2933:				;
 2934:				;=======
 2935:				;*S16A:   %TST    (S17,RESET)
 2936:	  8A3B	12 84 E9	s16a:   call   tst
 2937:	  8A3E	52 45 53 45	        db      'RESE',('T' OR 80H)
	  8A42	D4
 2938:	  8A43	50 06		        jnc     s17
 2939:	  8A45	12 85 B1	        CALL    DONE
 2940:	  8A48	02 00 00		JMP	0000H
 2941:				;
 2942:				;=======
 2943:				;
 2944:				;*S17:    %TST    (S17A,ROM)
 2945:	  8A4B	12 84 E9	s17:    call   tst
 2946:	  8A4E	52 4F CD	        db      'RO',('M' OR 80H)
 2947:	  8A51	50 0A		        jnc     s17a
 2948:	  8A53	12 85 B1	        CALL    DONE
 2949:	  8A56	D2 01			SETB	ROMMOD
 2950:	  8A58	C2 02			CLR	EXTMOD
 2951:	  8A5A	02 85 E5	        JMP     NXT
 2952:				;
 2953:				;*S17A:   %TST    (S17B,RAM)
 2954:	  8A5D	12 84 E9	s17a:   call   tst
 2955:	  8A60	52 41 CD	        db      'RA',('M' OR 80H)
 2956:	  8A63	50 08		        jnc     s17b
 2957:	  8A65	12 85 B1	        CALL    DONE
 2958:	  8A68	C2 01			CLR	ROMMOD
 2959:	  8A6A	02 85 E5	        JMP     NXT
 2960:				;
 2961:				;*S17B:   %TST    (S17C,PROM)
 2962:	  8A6D	12 84 E9	s17b:   call   tst
 2963:	  8A70	50 52 4F CD	        db      'PRO',('M' OR 80H)
 2964:	  8A74	50 0A		        jnc     s17c
 2965:	  8A76	12 85 B1	        CALL    DONE
 2966:	  8A79	D2 01			SETB	ROMMOD
 2967:	  8A7B	D2 02			SETB	EXTMOD
 2968:	  8A7D	02 85 E5	        JMP     NXT
 2969:				;
 2970:				;*S17C:   %TST    (S18,HEX)
 2971:	  8A80	12 84 E9	s17c:   call   tst
 2972:	  8A83	48 45 D8	        db      'HE',('X' OR 80H)

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 53



 Line  I  Addr  Code            Source

 2973:	  8A86	50 08		        jnc     s18
 2974:	  8A88	12 85 B1	        CALL    DONE
 2975:	  8A8B	D2 04			SETB	HEXMOD
 2976:	  8A8D	02 85 E5	        JMP     NXT
 2977:				;
 2978:				;*S18:    %TST    (S19,DECIMAL)
 2979:	  8A90	12 84 E9	s18:    call   tst
 2980:	  8A93	44 45 43 49	        db      'DECIMA',('L' OR 80H)
	  8A97	4D 41 CC
 2981:	  8A9A	50 08		        jnc     s19
 2982:	  8A9C	12 85 B1	        CALL    DONE
 2983:	  8A9F	C2 04			CLR	HEXMOD
 2984:	  8AA1	02 85 E5	        JMP     NXT
 2985:				;
 2986:				;*S19:    %TST    (S20,REM)
 2987:	  8AA4	12 84 E9	s19:    call   tst
 2988:	  8AA7	52 45 CD	        db      'RE',('M' OR 80H)
 2989:	  8AAA	50 05		        jnc     s20
 2990:	  8AAC	12 84 E3	        CALL    SKPTXT
 2991:				        IJMP_   STMT
 2992+ 1  8AAF	01 53		        JMP     STMT
 2993:				;
 2994:	  8AB1			S20:    IJMP_   CMD_NG
 2995+ 1  8AB1	01 2C		        JMP     CMD_NG
 2996:				;
 2997:				;$EJECT
 2998:				;
 2999:				;	INTERPRETIVE LANGUAGE SUBROUTINES:
 3000:				;	============ ======== ===========
 3001:				;
 3002:	  8AB3			EXPR:   ICALL_  AR_EXP
 3003+ 1  8AB3	12 8A C3	        CALL    AR_EXP
 3004:	  8AB6			E0:     ICALL_  RELOP
 3005+ 1  8AB6	12 8B A5	        CALL    RELOP
 3006:	  8AB9	50 46			JNC	E5
 3007:				        ICALL_  AR_EXP
 3008+ 1  8ABB	12 8A C3	        CALL    AR_EXP
 3009:	  8ABE	12 84 47	        CALL    CMPR
 3010:				        HOP_    E0
 3011+ 1  8AC1	80 F3		        SJMP    E0
 3012:				;
 3013:	  8AC3			AR_EXP: ICALL_  TERM
 3014+ 1  8AC3	12 8B 02	        CALL    TERM
 3015:				;*E1:     %TST    (E2,+)
 3016:	  8AC6	12 84 E9	e1:     call   tst
 3017:	  8AC9	AB		        db      ('+' OR 80H)
 3018:	  8ACA	50 08		        jnc     e2
 3019:				        ICALL_  TERM
 3020+ 1  8ACC	12 8B 02	        CALL    TERM
 3021:	  8ACF	12 83 1D		CALL	IADD
 3022:				        HOP_    E1
 3023+ 1  8AD2	80 F2		        SJMP    E1
 3024:				;
 3025:				;*E2:     %TST    (E3,-)
 3026:	  8AD4	12 84 E9	e2:     call   tst
 3027:	  8AD7	AD		        db      ('-' OR 80H)
 3028:	  8AD8	50 08		        jnc     e3
 3029:				        ICALL_  TERM

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 54



 Line  I  Addr  Code            Source

 3030+ 1  8ADA	12 8B 02	        CALL    TERM
 3031:	  8ADD	12 83 23		CALL	ISUB
 3032:				        HOP_    E1
 3033+ 1  8AE0	80 E4		        SJMP    E1
 3034:				;
 3035:				;*E3:     %TST    (E4,OR)
 3036:	  8AE2	12 84 E9	e3:     call   tst
 3037:	  8AE5	4F D2		        db      'O',('R' OR 80H)
 3038:	  8AE7	50 08		        jnc     e4
 3039:				        ICALL_  TERM
 3040+ 1  8AE9	12 8B 02	        CALL    TERM
 3041:	  8AEC	12 83 39		CALL	IOR
 3042:				        HOP_    E1
 3043+ 1  8AEF	80 D5		        SJMP    E1
 3044:				;
 3045:				;*E4:     %TST    (E5,XOR)
 3046:	  8AF1	12 84 E9	e4:     call   tst
 3047:	  8AF4	58 4F D2	        db      'XO',('R' OR 80H)
 3048:	  8AF7	50 08		        jnc     e5
 3049:				        ICALL_  TERM
 3050+ 1  8AF9	12 8B 02	        CALL    TERM
 3051:	  8AFC	12 83 43		CALL	IXOR
 3052:				        HOP_    E1
 3053+ 1  8AFF	80 C5		        SJMP    E1
 3054:				;
 3055:	  8B01	22		E5:     RET
 3056:				;
 3057:				;=======
 3058:				;
 3059:	  8B02			TERM:   ICALL_  FACT
 3060+ 1  8B02	12 8B 42	        CALL    FACT
 3061:				;*TERM_0: %TST    (TERM_1,*)
 3062:	  8B05	12 84 E9	term_0: call   tst
 3063:	  8B08	AA		        db      ('*' OR 80H)
 3064:	  8B09	50 08		        jnc     term_1
 3065:				        ICALL_  FACT
 3066+ 1  8B0B	12 8B 42	        CALL    FACT
 3067:	  8B0E	12 83 AF		CALL	IMUL
 3068:				        HOP_    TERM_0
 3069+ 1  8B11	80 F2		        SJMP    TERM_0
 3070:				;
 3071:				;*TERM_1: %TST    (TERM_2,/)
 3072:	  8B13	12 84 E9	term_1: call   tst
 3073:	  8B16	AF		        db      ('/' OR 80H)
 3074:	  8B17	50 08		        jnc     term_2
 3075:				        ICALL_  FACT
 3076+ 1  8B19	12 8B 42	        CALL    FACT
 3077:	  8B1C	12 83 C2		CALL	IDIV
 3078:				        HOP_    TERM_0
 3079+ 1  8B1F	80 E4		        SJMP    TERM_0
 3080:				;
 3081:				;*TERM_2: %TST    (TERM_3,AND)
 3082:	  8B21	12 84 E9	term_2: call   tst
 3083:	  8B24	41 4E C4	        db      'AN',('D' OR 80H)
 3084:	  8B27	50 08		        jnc     term_3
 3085:				        ICALL_  FACT
 3086+ 1  8B29	12 8B 42	        CALL    FACT
 3087:	  8B2C	12 83 2F		CALL	IAND

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 55



 Line  I  Addr  Code            Source

 3088:				        HOP_    TERM_0
 3089+ 1  8B2F	80 D4		        SJMP    TERM_0
 3090:				;
 3091:				;*TERM_3: %TST    (TERM_4,MOD)
 3092:	  8B31	12 84 E9	term_3: call   tst
 3093:	  8B34	4D 4F C4	        db      'MO',('D' OR 80H)
 3094:	  8B37	50 08		        jnc     term_4
 3095:				        ICALL_  FACT
 3096+ 1  8B39	12 8B 42	        CALL    FACT
 3097:	  8B3C	12 83 BE		CALL	IMOD
 3098:				        HOP_    TERM_0
 3099+ 1  8B3F	80 C4		        SJMP    TERM_0
 3100:				;
 3101:	  8B41	22		TERM_4: RET
 3102:				;
 3103:				;=======
 3104:				;
 3105:				;*FACT:   %TST    (FACT_1,-)
 3106:	  8B42	12 84 E9	fact:   call   tst
 3107:	  8B45	AD		        db      ('-' OR 80H)
 3108:	  8B46	50 07		        jnc     fact_1
 3109:				        ICALL_  VAR
 3110+ 1  8B48	12 8B 5E	        CALL    VAR
 3111:	  8B4B	12 83 4D		CALL	NEG
 3112:	  8B4E	22		        RET
 3113:				;
 3114:				;*FACT_1: %TST    (VAR,NOT)
 3115:	  8B4F	12 84 E9	fact_1: call   tst
 3116:	  8B52	4E 4F D4	        db      'NO',('T' OR 80H)
 3117:	  8B55	50 07		        jnc     var
 3118:				        ICALL_  VAR
 3119+ 1  8B57	12 8B 5E	        CALL    VAR
 3120:	  8B5A	12 83 5C		CALL	ICPL
 3121:	  8B5D	22		        RET
 3122:				;
 3123:				;
 3124:				;=======
 3125:				;
 3126:	  8B5E			VAR:    TSTV_   VAR_0
 3127+ 1  8B5E	12 85 19	        CALL    TSTV
 3128+ 1  8B61	50 04		        JNC     VAR_0
 3129:	  8B63	12 82 5B		CALL	FETCH
 3130:	  8B66	22		        RET
 3131:				;
 3132:	  8B67			VAR_0:  TSTN_   VAR_1
 3133+ 1  8B67	12 85 7E	        CALL    TSTN
 3134+ 1  8B6A	50 01		        JNC     VAR_1
 3135:	  8B6C	22		        RET
 3136:				;
 3137:				;*VAR_1:  %TST    (VAR_1A,RND)
 3138:	  8B6D	12 84 E9	var_1:  call   tst
 3139:	  8B70	52 4E C4	        db      'RN',('D' OR 80H)
 3140:	  8B73	50 10		        jnc     var_1a
 3141:	  8B75	12 84 1F	        CALL    RND
 3142:				        ICALL_  VAR_2
 3143+ 1  8B78	12 8B 94	        CALL    VAR_2
 3144:	  8B7B	12 83 BE		CALL	IMOD
 3145:	  8B7E	12 83 5F		CALL	IABS

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 56



 Line  I  Addr  Code            Source

 3146:	  8B81	12 83 6D		CALL	IINC
 3147:	  8B84	22		        RET
 3148:				;
 3149:				;*VAR_1A: %TST    (VAR_2,ABS)
 3150:	  8B85	12 84 E9	var_1a: call   tst
 3151:	  8B88	41 42 D3	        db      'AB',('S' OR 80H)
 3152:	  8B8B	50 07		        jnc     var_2
 3153:				        ICALL_  VAR_2
 3154+ 1  8B8D	12 8B 94	        CALL    VAR_2
 3155:	  8B90	12 83 5F		CALL	IABS
 3156:	  8B93	22		        RET
 3157:				;
 3158:				;*VAR_2:  %TST    (SYN_NG,%1()
 3159:	  8B94	12 84 E9	var_2:  call   tst
 3160:	  8B97	A8		        db      ('(' OR 80H)            ;to match TB51.LST
 3161:	  8B98	50 09		        jnc     syn_ng
 3162:				        ICALL_  EXPR
 3163+ 1  8B9A	51 B3		        CALL    EXPR
 3164:				;*        %TST    (SYN_NG,%1))
 3165:	  8B9C	12 84 E9	        call   tst
 3166:	  8B9F	A9		        db      (')' OR 80H)            ;to match TB51.LST
 3167:	  8BA0	50 01		        jnc     syn_ng
 3168:	  8BA2	22		        RET
 3169:				;
 3170:				;=======
 3171:				;
 3172:	  8BA3			SYN_NG: IJMP_   CMD_NG
 3173+ 1  8BA3	01 2C		        JMP     CMD_NG
 3174:				;
 3175:				;$EJECT
 3176:				;
 3177:	  8BA5			RELOP:
 3178:				;	Search for relational operator in text string.
 3179:				;	If found, push appropriate operator code on AES and return with
 3180:				;	carry set.
 3181:				;	Otherwise restore cursor and return with carry=0.
 3182:				;
 3183:				;*        %TST    (REL_1,=)
 3184:	  8BA5	12 84 E9	        call   tst
 3185:	  8BA8	BD		        db      ('=' OR 80H)
 3186:	  8BA9	50 05		        jnc     rel_1
 3187:				        LIT_    010B            ;Test for _=_
 3188+ 1  8BAB	12 81 32		CALL	LIT
 3189+ 1  8BAE	02			DB	010B
 3190:	  8BAF	22		        RET
 3191:				;
 3192:				;*REL_1:  %TST    (REL_2,<=)
 3193:	  8BB0	12 84 E9	rel_1:  call   tst
 3194:	  8BB3	3C BD		        db      '<',('=' OR 80H)
 3195:	  8BB5	50 05		        jnc     rel_2
 3196:				        LIT_    110B            ;Test for <=_
 3197+ 1  8BB7	12 81 32		CALL	LIT
 3198+ 1  8BBA	06			DB	110B
 3199:	  8BBB	22		        RET
 3200:				;
 3201:				;*REL_2:  %TST    (REL_3,<>)
 3202:	  8BBC	12 84 E9	rel_2:  call   tst
 3203:	  8BBF	3C BE		        db      '<',('>' OR 80H)

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 57



 Line  I  Addr  Code            Source

 3204:	  8BC1	50 05		        jnc     rel_3
 3205:				        LIT_    101B            ;Test for <_>
 3206+ 1  8BC3	12 81 32		CALL	LIT
 3207+ 1  8BC6	05			DB	101B
 3208:	  8BC7	22		        RET
 3209:				;
 3210:				;*REL_3:  %TST    (REL_4,<)
 3211:	  8BC8	12 84 E9	rel_3:  call   tst
 3212:	  8BCB	BC		        db      ('<' OR 80H)
 3213:	  8BCC	50 05		        jnc     rel_4
 3214:				        LIT_    100B            ;Test for <__
 3215+ 1  8BCE	12 81 32		CALL	LIT
 3216+ 1  8BD1	04			DB	100B
 3217:	  8BD2	22		        RET
 3218:				;
 3219:				;*REL_4:  %TST    (REL_5,>=)
 3220:	  8BD3	12 84 E9	rel_4:  call   tst
 3221:	  8BD6	3E BD		        db      '>',('=' OR 80H)
 3222:	  8BD8	50 05		        jnc     rel_5
 3223:				        LIT_    011B            ;Test for _=>
 3224+ 1  8BDA	12 81 32		CALL	LIT
 3225+ 1  8BDD	03			DB	011B
 3226:	  8BDE	22		        RET
 3227:				;
 3228:				;*REL_5:  %TST    (REL_6,>)
 3229:	  8BDF	12 84 E9	rel_5:  call   tst
 3230:	  8BE2	BE		        db      ('>' OR 80H)
 3231:	  8BE3	50 05		        jnc     rel_6
 3232:				        LIT_    001B            ;Test for __>
 3233+ 1  8BE5	12 81 32		CALL	LIT
 3234+ 1  8BE8	01			DB	001B
 3235:	  8BE9	22		        RET
 3236:				;
 3237:	  8BEA	C3		REL_6:	CLR	C
 3238:	  8BEB	22		        RET
 3239:				;
 3240:				;=======
 3241:				;
 3242:				;$EJECT
 3243:				;$LIST
 3244:				;
 3245:	  8BEC	0F			INC	R7		;Dummy ML program.
 3246:	  8BED	8F 90			MOV	P1,R7
 3247:	  8BEF	22			RET
 3248:				;
 3249:	  8BF0			INTROM:				;Start of ROM program buffer.
 3250:				;$INCLUDE(TBACEY.SRC)
 3251:	  8BF0	08 35		        dw      2101
 3252:	  8BF2	50 52 2E 22	        db      'PR."Hello"',CR
	  8BF6	48 65 6C 6C
	  8BFA	6F 22 0D
 3253:	  8BFD	08 36		        dw      2102
 3254:	  8BFF	50 52 2E 22	        db      'PR."This is being run under Tiny Basic V2.3"',CR
	  8C03	54 68 69 73
	  8C07	20 69 73 20
	  8C0B	62 65 69 6E
	  8C0F	67 20 72 75
	  8C13	6E 20 75 6E

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 58



 Line  I  Addr  Code            Source

	  8C17	64 65 72 20
	  8C1B	54 69 6E 79
	  8C1F	20 42 61 73
	  8C23	69 63 20 56
	  8C27	32 2E 33 22
	  8C2B	0D
 3255:	  8C2C	0B E0		        dw      3040
 3256:	  8C2E	50 52 2E 3A	        db      'PR.:IN."TYPE anything TO END PROGRAM",D',CR
	  8C32	49 4E 2E 22
	  8C36	54 59 50 45
	  8C3A	20 61 6E 79
	  8C3E	74 68 69 6E
	  8C42	67 20 54 4F
	  8C46	20 45 4E 44
	  8C4A	20 50 52 4F
	  8C4E	47 52 41 4D
	  8C52	22 2C 44 0D
 3257:	  8C56	0B EA		        dw      3050
 3258:	  8C58	50 52 2E 22	        db      'PR."Have fun!!.....J Lum  4/25/92"',CR
	  8C5C	48 61 76 65
	  8C60	20 66 75 6E
	  8C64	21 21 2E 2E
	  8C68	2E 2E 2E 4A
	  8C6C	20 4C 75 6D
	  8C70	20 20 34 2F
	  8C74	32 35 2F 39
	  8C78	32 22 0D
 3259:	  8C7B	0B F4		        dw      3060
 3260:	  8C7D	45 4E 44 0D	        db      'END',CR
 3261:	  8C81	80			DB	80H		;Marks end of program.
 3262:				;
 3263:					END
 3264:





                     register banks used:  ---

                     no errors




ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 59





	       L I S T   O F   S Y M B O L S
	       =============================


SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
??ASEM_51			  NUMBER    8051
??VERSION			  NUMBER    0130
AC				  BIT	      D6	 124
ACC				  DATA	      E0	  49
ADCON				  DATA	      D8	  46
ADCONV				  CODE	    0043	 141
ADDAT				  DATA	      D9	  47
ADD_16				  CODE	    8315	1189
ADM				  BIT	      DB	 129
ADR_ER				  CODE	    81BB	 822
AES				  DATA	      51	 394
AESLEN				  NUMBER    0024	 336
AESP				  DATA	      50	 393
AES_ER				  CODE	    80DD	 598
ALPHAB				  CODE	    8526	1809
APND_1				  CODE	    82E2	1144
APND_2				  CODE	    8306	1167
APND_4				  CODE	    82E0	1143
APN_ER				  CODE	    8308	1171
APPEND				  CODE	    82C5	1127
AR_EXP				  CODE	    8AC3	3013
ASCTBL				  CODE	    80AF	 560
B				  DATA	      F0	  51
BAUDID				  CODE	    8010	 444
BD				  BIT	      DF	 132
BEL				  NUMBER    0007	 414
BIG_PROBLEM			  CODE	    843C	1503
BSY				  BIT	      DC	 130
CCEN				  DATA	      C1	  33
CCH1				  DATA	      C3	  35
CCH2				  DATA	      C5	  37
CCH3				  DATA	      C7	  39
CCL1				  DATA	      C2	  34
CCL2				  DATA	      C4	  36
CCL3				  DATA	      C6	  38
CHAR				  REGISTER    R4	 344
CHAR_FLG			  BIT	      09	 361
CLK				  BIT	      DE	 131
CLKOUT				  BIT	      96	  68
CMD_NG				  CODE	    882C	2608
CMPR				  CODE	    8447	1515
CMPR_1				  CODE	    8466	1554
CMPR_2				  CODE	    846C	1563
CMPR_4				  CODE	    845E	1545
CNTRET				  CODE	    8098	 529
CNTRL				  CODE	    808B	 522
CNTR_2				  CODE	    8093	 526
COND				  CODE	    87C5	2438
COND_				  MACRO	        	 183
CONT				  CODE	    883A	2614
CONT_1				  CODE	    8840	2616
COUT_1				  CODE	    808A	 517

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 60



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
COUT_2				  CODE	    8082	 513
COUT_3				  CODE	    8086	 515
CR				  NUMBER    000D	 412
CRCH				  DATA	      CB	  42
CRCL				  DATA	      CA	  41
CREATE				  CODE	    82B8	1110
CREA_1				  CODE	    82C4	1116
CURS_H				  DATA	      78	 404
CURS_L				  DATA	      77	 403
CY				  BIT	      D7	 125
C_IN				  CODE	    8050	 465
C_IN_1				  CODE	    806B	 486
C_IN_2				  CODE	    805F	 480
C_OUT				  CODE	    806E	 496
C_SAVE				  DATA	      79	 405
DAPR				  DATA	      DA	  48
DD001				  CODE	    8229	 949
DD002				  CODE	    8288	1055
DD003				  CODE	    84A1	1639
DD004				  CODE	    84C7	1688
DD005				  CODE	    8050	 472
DD006				  CODE	    806E	 500
DD007				  CODE	    8071	 502
DD008				  CODE	    8078	 506
DD009				  CODE	    807B	 508
DD010				  CODE	    86ED	2224
DEST_H				  REGISTER    R3	 343
DEST_L				  REGISTER    R1	 341
DIV_1				  CODE	    8415	1467
DIV_2				  CODE	    841A	1470
DIV_LP				  CODE	    83E8	1441
DIV_NG				  CODE	    841D	1473
DIV_RP				  CODE	    83FF	1454
DONE				  CODE	    85B1	1947
DONE_1				  CODE	    85B9	1952
DONE_2				  CODE	    85BD	1955
DPH				  DATA	      83	  15
DPL				  DATA	      82	  14
DUPL				  CODE	    811E	 675
D_BLNK				  CODE	    84D5	1709
E0				  CODE	    8AB6	3004
E1				  CODE	    8AC6	3016
E2				  CODE	    8AD4	3026
E3				  CODE	    8AE2	3036
E4				  CODE	    8AF1	3046
E5				  CODE	    8B01	3055
EADC				  BIT	      B8	  94
EAL				  BIT	      AF	  85
ERRENT				  CODE	    8832	2611
ERROUT				  CODE	    80D1	 582
ES				  BIT	      AC	  82
ET0				  BIT	      A9	  79
ET1				  BIT	      AB	  81
ET2				  BIT	      AD	  83
EX0				  BIT	      A8	  78
EX1				  BIT	      AA	  80
EX2				  BIT	      B9	  95
EX3				  BIT	      BA	  96

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 61



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
EX4				  BIT	      BB	  97
EX5				  BIT	      BC	  98
EX6				  BIT	      BD	  99
EXEN2				  BIT	      BF	 101
EXF2				  BIT	      C7	 109
EXPR				  CODE	    8AB3	3002
EXP_ER				  CODE	    80D4	 591
EXP_OV				  CODE	    8312	1184
EXTI0				  CODE	    0003	 135
EXTI1				  CODE	    0013	 137
EXTI2				  CODE	    004B	 142
EXTI3				  CODE	    0053	 143
EXTI4				  CODE	    005B	 144
EXTI5				  CODE	    0063	 145
EXTI6				  CODE	    006B	 146
EXTINI				  CODE	    8703	2238
EXTMOD				  BIT	      02	 355
EXTRAM				  NUMBER    9034	 332
EXTROM				  NUMBER    C080	 334
EXTVAR				  BIT	      00	 353
F0				  BIT	      D5	 123
F1				  BIT	      D1	 119
FACT				  CODE	    8B42	3106
FACT_1				  CODE	    8B4F	3115
FETBDN				  CODE	    82B3	1096
FETCBY				  CODE	    82AD	1092
FETCH				  CODE	    825B	1003
FETDBY				  CODE	    8294	1067
FETDIR				  CODE	    81CB	 842
FETERR				  CODE	    8292	1063
FETEXT				  CODE	    8287	1054
FETJTB				  CODE	    826F	1026
FETRBI				  CODE	    829A	1074
FETSFR				  CODE	    81D1	 851
FETVAR				  CODE	    8274	1038
FETXBY				  CODE	    82A6	1084
FET_0				  CODE	    825D	1016
FET_1				  CODE	    826A	1022
FIN				  CODE	    8816	2542
FLAGS				  DATA	      21	 359
FNDDON				  CODE	    873B	2303
FNDLBL				  CODE	    871D	2279
FND_1				  CODE	    8723	2289
FORDON				  CODE	    89E5	2874
FOR_ER				  CODE	    89F4	2882
GETLN				  CODE	    85F0	2035
GETL_0				  CODE	    85F6	2042
GETL_1				  CODE	    85FB	2045
GETL_2				  CODE	    8637	2081
GETL_3				  CODE	    862F	2076
GETL_4				  CODE	    8627	2071
GETL_5				  CODE	    8612	2059
GETL_6				  CODE	    8607	2051
GETL_7				  CODE	    861B	2064
GETROM				  CODE	    84A5	1643
GET_BUF				  CODE	    849E	1636
GET_C				  CODE	    8499	1629
HEXMOD				  BIT	      04	 357

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 62



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
HOP_				  MACRO	        	 197
H_FLG				  BIT	      0D	 365
I2FR				  BIT	      CD	 115
I3FR				  BIT	      CE	 116
IABS				  CODE	    835F	1308
IADC				  BIT	      C0	 102
IADD				  CODE	    831D	1201
IAND				  CODE	    832F	1230
ICALL_				  MACRO	        	 201
ICPL				  CODE	    835C	1300
IDIV				  CODE	    83C2	1410
IDIV_0				  CODE	    83C4	1416
IE0				  BIT	      89	  55
IE1				  BIT	      8B	  57
IEN0				  DATA	      A8	  27
IEN1				  DATA	      B8	  30
IEX2				  BIT	      C1	 103
IEX3				  BIT	      C2	 104
IEX4				  BIT	      C3	 105
IEX5				  BIT	      C4	 106
IEX6				  BIT	      C5	 107
IFDN_1				  CODE	    85C7	1971
IFDN_2				  CODE	    85CB	1974
IFDONE				  CODE	    85C1	1967
IFDONE_				  MACRO	        	 173
IINC				  CODE	    836D	1330
IINC_1				  CODE	    8376	1339
IJMP_				  MACRO	        	 193
IMOD				  CODE	    83BE	1404
IMUL				  CODE	    83AF	1388
IMUL_1				  CODE	    8383	1355
IMUL_2				  CODE	    838D	1361
IMUL_3				  CODE	    8397	1367
INDEX				  CODE	    856C	1851
INDTBL				  CODE	    817E	 772
INIT				  CODE	    870D	2254
INIT_1				  CODE	    86FC	2233
INIT_2				  CODE	    8707	2241
INIT_3				  CODE	    870C	2244
INNUM				  CODE	    86B4	2184
INSL_1				  CODE	    879D	2398
INSRT				  CODE	    87A5	2407
INSR_1				  CODE	    87AE	2420
INSR_2				  CODE	    87B1	2422
INSR_4				  CODE	    87C2	2432
INSR_L				  CODE	    8791	2384
INT0				  BIT	      B2	  88
INT1				  BIT	      B3	  89
INT2				  BIT	      94	  66
INT3CC0				  BIT	      90	  62
INT4CC1				  BIT	      91	  63
INT5CC2				  BIT	      92	  64
INT6CC3				  BIT	      93	  65
INTROM				  CODE	    8BF0	3249
INUM_0				  CODE	    86BA	2192
INUM_1				  CODE	    86D3	2206
INUM_2				  CODE	    86DA	2209
INUM_3				  CODE	    86C3	2197

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 63



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
INUM_4				  CODE	    86C8	2200
INUM_5				  CODE	    86CF	2204
INUM_6				  CODE	    86E0	2213
IOR				  CODE	    8339	1247
IP0				  DATA	      A9	  28
IP1				  DATA	      B9	  31
IRCON				  DATA	      C0	  32
ISUB				  CODE	    8323	1216
IT0				  BIT	      88	  54
IT1				  BIT	      8A	  56
IXOR				  CODE	    8343	1264
KILL_2				  CODE	    8743	2319
KILL_3				  CODE	    874E	2324
KILL_9				  CODE	    8757	2329
KILL_L				  CODE	    873D	2307
LABL_H				  DATA	      7B	 408
LABL_L				  DATA	      7A	 407
LF				  NUMBER    000A	 413
LINIT_				  MACRO	        	 178
LINI_1				  CODE	    85E1	2004
LIT				  CODE	    8132	 700
LIT_				  MACRO	        	 148
LIT_1				  CODE	    8141	 709
LNDONE				  CODE	    85B7	1951
LOAD_PNTR			  CODE	    8492	1619
LOOP				  CODE	    87E0	2482
LOOP_0				  CODE	    87ED	2505
LOOP_1				  CODE	    8810	2532
LOOP_2				  CODE	    880D	2527
LP_CNT				  REGISTER    R5	 345
LST				  CODE	    86A5	2172
LSTLIN				  CODE	    868E	2146
LSTL_1				  CODE	    86A4	2164
LSTL_2				  CODE	    869D	2161
LSTRET				  CODE	    86B1	2178
LST_1				  CODE	    86A9	2174
L_CURS				  DATA	      75	 398
L_INIT				  CODE	    85DC	1996
MLCALL				  CODE	    881B	2589
MLCALL_				  MACRO	        	 205
MODE				  DATA	      20	 352
MOD_FLG				  BIT	      0C	 364
MSKTBL				  CODE	    81EB	 878
MSK_PC				  CODE	    81E8	 874
MUL_16				  CODE	    8377	1343
MX0				  BIT	      D8	 126
MX1				  BIT	      D9	 127
MX2				  BIT	      DA	 128
NEG				  CODE	    834D	1281
NEG_0				  CODE	    8350	1286
NEG_IF_NEG			  CODE	    8369	1321
NEXT_LOOP_			  MACRO	        	 188
NIBOUT				  CODE	    80A0	 551
NIBO_1				  CODE	    80AB	 556
NIBO_2				  CODE	    80A7	 554
NIBO_3				  CODE	    80AE	 558
NLINE				  CODE	    806C	 492
NL_NXT				  CODE	    85E3	2011

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 64



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
NOTSYM				  CODE	    8571	1855
NOTVAR				  CODE	    8533	1815
NO_PROBLEM			  CODE	    8440	1506
NO_SFR				  NUMBER    000E	 737
NO_VAR				  NUMBER    000C	 387
NXT				  CODE	    85E5	2016
NXT_1				  CODE	    85ED	2028
OPEN_1				  CODE	    8778	2360
OPEN_2				  CODE	    8785	2371
OPEN_3				  CODE	    875C	2338
OPEN_4				  CODE	    876A	2347
OPEN_5				  CODE	    8763	2341
OPEN_6				  CODE	    878A	2377
OPEN_L				  CODE	    8758	2333
OV				  BIT	      D2	 120
OV_TST				  CODE	    830B	1176
P				  BIT	      D0	 118
P0				  DATA	      80	  12
P1				  DATA	      90	  23
P2				  DATA	      A0	  26
P3				  DATA	      B0	  29
P4				  DATA	      E8	  50
P5				  DATA	      F8	  52
PCON				  DATA	      87	  16
PNTR_H				  REGISTER    R2	 342
PNTR_L				  REGISTER    R0	 340
POP_ACC				  CODE	    8105	 642
POP_TOS				  CODE	    80F3	 618
PRN				  CODE	    8643	2092
PRNHEX				  CODE	    8670	2125
PRNH_1				  CODE	    867E	2133
PRNRET				  CODE	    868D	2142
PRNTOS				  CODE	    8649	2100
PRN_1				  CODE	    8659	2108
PSW				  DATA	      D0	  45
PUSH_C				  CODE	    846E	1564
PUSH_TOS			  CODE	    810B	 652
PUTROM				  CODE	    84CB	1692
PUT_BUF				  CODE	    84C4	1683
RAMLIM				  NUMBER    A000	 333
RAM_INIT			  CODE	    86E8	2220
RB8				  BIT	      9A	  72
RD				  BIT	      B7	  93
RDCHDN				  CODE	    84C1	1676
READ_CHAR			  CODE	    84B6	1659
READ_LABEL			  CODE	    85CF	1981
RELOP				  CODE	    8BA5	3177
REL_1				  CODE	    8BB0	3193
REL_2				  CODE	    8BBC	3202
REL_3				  CODE	    8BC8	3211
REL_4				  CODE	    8BD3	3220
REL_5				  CODE	    8BDF	3229
REL_6				  CODE	    8BEA	3237
REN				  BIT	      9C	  74
REREAD				  CODE	    84C2	1678
RESET				  CODE	    0000	 134
REWIND				  CODE	    8474	1592
REWROM				  CODE	    847E	1598

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 65



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
RI				  BIT	      98	  70
RND				  CODE	    841F	1480
ROMMOD				  BIT	      01	 354
RS0				  BIT	      D3	 121
RS1				  BIT	      D4	 122
RSTR				  CODE	    87D9	2471
RUNMOD				  BIT	      03	 356
RUNROM				  CODE	    8049	 457
RWXROM				  CODE	    8486	1603
RXD				  BIT	      B0	  86
S0				  CODE	    886B	2644
S1				  CODE	    88A4	2677
S10				  CODE	    8943	2778
S10B				  CODE	    8953	2787
S10C				  CODE	    895B	2794
S10D				  CODE	    8966	2801
S11				  CODE	    8969	2804
S12				  CODE	    896F	2810
S13				  CODE	    8980	2819
S13A				  CODE	    8997	2833
S13B				  CODE	    89C3	2859
S13C				  CODE	    89F6	2888
S14				  CODE	    8A03	2897
S14B				  CODE	    8A1C	2910
S15				  CODE	    8A21	2917
S16				  CODE	    8A2E	2927
S16A				  CODE	    8A3B	2936
S17				  CODE	    8A4B	2945
S17A				  CODE	    8A5D	2954
S17B				  CODE	    8A6D	2962
S17C				  CODE	    8A80	2971
S18				  CODE	    8A90	2979
S19				  CODE	    8AA4	2987
S2				  CODE	    88B6	2688
S20				  CODE	    8AB1	2994
S3				  CODE	    88CC	2700
S3A				  CODE	    88DB	2707
S3B				  CODE	    88E3	2714
S3C				  CODE	    88EE	2721
S5				  CODE	    88FE	2731
S5A				  CODE	    8909	2739
S6				  CODE	    8911	2745
S6A				  CODE	    8917	2748
S6B				  CODE	    8914	2746
S8				  CODE	    891A	2753
S8A				  CODE	    892D	2762
S8B				  CODE	    8934	2768
S9				  CODE	    8939	2775
SAV				  CODE	    87D3	2461
SAVE_PNTR			  CODE	    848B	1609
SBUF				  DATA	      99	  25
SCON				  DATA	      98	  24
SE3				  CODE	    887E	2654
SE3A				  CODE	    888F	2665
SE4				  CODE	    8898	2669
SEED_H				  DATA	      36	 380
SEED_L				  DATA	      35	 379
SEQ_FETCH			  CODE	    8257	 996

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 66



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
SEQ_FLG				  BIT	      0B	 363
SEQ_STORE			  CODE	    81F3	 890
SETRBI				  CODE	    824A	 979
SFID_1				  CODE	    81AD	 810
SFID_2				  CODE	    81B6	 819
SFRTBL				  CODE	    8146	 723
SFR_ID				  CODE	    81A8	 802
SGN_FLG				  BIT	      0A	 362
SINT				  CODE	    0023	 139
SKPLIN				  CODE	    84DF	1735
SKPTXT				  CODE	    84E3	1737
SM0				  BIT	      9F	  77
SM1				  BIT	      9E	  76
SM2				  BIT	      9D	  75
SP				  DATA	      81	  13
SPC				  CODE	    8099	 535
SPLIT_DBA			  CODE	    81D7	 857
SPLSFR				  CODE	    81E1	 869
SP_BASE				  NUMBER    007F	 410
SP_INI				  CODE	    8010	 436
START				  CODE	    882F	2610
STK_ER				  CODE	    811B	 669
STMT				  CODE	    8853	2628
STORE				  CODE	    81F7	 897
STOR_0				  CODE	    81F9	 910
STOR_1				  CODE	    820C	 919
STRCBY				  CODE	    824F	 986
STRDBY				  CODE	    8234	 959
STRDIR				  CODE	    81BD	 826
STREXT				  CODE	    8228	 948
STRJTB				  CODE	    8211	 923
STRLEN				  DATA	      37	 383
STROUT				  CODE	    80BF	 567
STRO_1				  CODE	    80C3	 569
STRO_2				  CODE	    80CD	 576
STRRBI				  CODE	    823A	 966
STRSFR				  CODE	    81C5	 836
STRTBL				  CODE	    8154	 741
STRVAR				  CODE	    8216	 936
STRXBY				  CODE	    824F	 985
SWDT				  BIT	      BE	 100
SYN_ER				  CODE	    80E8	 606
SYN_NG				  CODE	    8BA3	3172
S_INIT				  CODE	    8003	 429
T0				  BIT	      B4	  90
T1				  BIT	      B5	  91
T2				  BIT	      97	  69
T2CM				  BIT	      CA	 112
T2CON				  DATA	      C8	  40
T2EX				  BIT	      95	  67
T2I0				  BIT	      C8	 110
T2I1				  BIT	      C9	 111
T2PS				  BIT	      CF	 117
T2R0				  BIT	      CB	 113
T2R1				  BIT	      CC	 114
TABCNT				  DATA	      76	 400
TABSIZ				  NUMBER    0008	 335
TB8				  BIT	      9B	  73

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 67



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
TCON				  DATA	      88	  17
TERM				  CODE	    8B02	3059
TERM_0				  CODE	    8B05	3062
TERM_1				  CODE	    8B13	3072
TERM_2				  CODE	    8B21	3082
TERM_3				  CODE	    8B31	3092
TERM_4				  CODE	    8B41	3101
TF0				  BIT	      8D	  59
TF1				  BIT	      8F	  61
TF2				  BIT	      C6	 108
TH0				  DATA	      8C	  21
TH1				  DATA	      8D	  22
TH2				  DATA	      CD	  44
TI				  BIT	      99	  71
TIMER0				  CODE	    000B	 136
TIMER1				  CODE	    001B	 138
TIMER2				  CODE	    002B	 140
TL0				  DATA	      8A	  19
TL1				  DATA	      8B	  20
TL2				  DATA	      CC	  43
TMOD				  DATA	      89	  18
TMP0				  DATA	      30	 371
TMP1				  DATA	      31	 372
TMP2				  DATA	      32	 373
TMP3				  DATA	      33	 374
TMP4				  DATA	      34	 375
TOKEN				  CODE	    8858	2631
TOS_H				  REGISTER    R7	 347
TOS_L				  REGISTER    R6	 346
TR0				  BIT	      8C	  58
TR1				  BIT	      8E	  60
TST				  CODE	    84E9	1747
TSTCBY				  CODE	    8560	1845
TSTL_				  MACRO	        	 163
TSTN				  CODE	    857E	1879
TSTN_				  MACRO	        	 158
TSTN_1				  CODE	    8587	1885
TSTRBI				  CODE	    8545	1827
TSTS				  CODE	    8593	1919
TSTS_				  MACRO	        	 168
TSTS_1				  CODE	    85A3	1929
TSTS_2				  CODE	    85AA	1933
TSTV				  CODE	    8519	1792
TSTV_				  MACRO	        	 153
TSTV_1				  CODE	    8573	1860
TSTXBY				  CODE	    8552	1836
TST_1				  CODE	    84F1	1757
TST_2				  CODE	    8502	1767
TXD				  BIT	      B1	  87
T_BAD				  CODE	    850C	1777
T_GOOD				  CODE	    8508	1771
US_VAR				  DATA	      38	 388
VAR				  CODE	    8B5E	3126
VAR_0				  CODE	    8B67	3132
VAR_1				  CODE	    8B6D	3138
VAR_1A				  CODE	    8B85	3150
VAR_2				  CODE	    8B94	3159
VERS				  NUMBER    0023	 218

ASEM-51 V1.3                             Tiny-Basic51 - Modified for Metalink ASM51                              PAGE 68



SYMBOL				  TYPE     VALUE	LINE
------------------------------------------------------------
WDT				  BIT	      AE	  84
WR				  BIT	      B6	  92
WRCH_1				  CODE	    84D4	1705
WRITE_CHAR			  CODE	    84CD	1696
XEC				  CODE	    8850	2627
XFER				  CODE	    87CA	2452
XFERNG				  CODE	    87D1	2456
XINIT				  CODE	    8715	2272
XRAD_1				  CODE	    82EC	1148
ZERSUP				  BIT	      08	 360
