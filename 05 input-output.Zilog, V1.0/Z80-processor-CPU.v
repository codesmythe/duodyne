/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */

module Demux2
#(
    parameter Default = 0 
)
(
    output out_0,
    output out_1,
    output out_2,
    output out_3,
    input [1:0] sel,
    input in
);
    assign out_0 = (sel == 2'h0)? in : Default;
    assign out_1 = (sel == 2'h1)? in : Default;
    assign out_2 = (sel == 2'h2)? in : Default;
    assign out_3 = (sel == 2'h3)? in : Default;
endmodule


// dual 2-line to 4-line decoder/demultiplexer
module \74139  (
  input \1A ,
  input \1B ,
  input \~1G ,
  input \2A ,
  input \2B ,
  input \~2G ,
  input VCC,
  input GND,
  output \~1Y0 ,
  output \~1Y1 ,
  output \~1Y2 ,
  output \~1Y3 ,
  output \~2Y0 ,
  output \~2Y1 ,
  output \~2Y2 ,
  output \~2Y3 
);
  wire [1:0] s0;
  wire [1:0] s1;
  assign s0[0] = \1A ;
  assign s0[1] = \1B ;
  assign s1[0] = \2A ;
  assign s1[1] = \2B ;
  Demux2 #(
    .Default(1)
  )
  Demux2_i0 (
    .sel( s0 ),
    .in( \~1G  ),
    .out_0( \~1Y0  ),
    .out_1( \~1Y1  ),
    .out_2( \~1Y2  ),
    .out_3( \~1Y3  )
  );
  Demux2 #(
    .Default(1)
  )
  Demux2_i1 (
    .sel( s1 ),
    .in( \~2G  ),
    .out_0( \~2Y0  ),
    .out_1( \~2Y1  ),
    .out_2( \~2Y2  ),
    .out_3( \~2Y3  )
  );
endmodule

module Mux_2x1_NBits #(
    parameter Bits = 2
)
(
    input [0:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule


// quad 2-line to 1-line data selectors/multiplexers
module \74157  (
  input S, // select
  input A1,
  input A2,
  input A3,
  input A4,
  input B1,
  input B2,
  input B3,
  input B4,
  input G, // strobe
  input VCC,
  input GND,
  output Y1,
  output Y2,
  output Y3,
  output Y4
);
  wire [3:0] s0;
  wire [3:0] s1;
  wire [3:0] s2;
  wire [3:0] s3;
  assign s1[0] = B1;
  assign s1[1] = B2;
  assign s1[2] = B3;
  assign s1[3] = B4;
  assign s0[0] = A1;
  assign s0[1] = A2;
  assign s0[2] = A3;
  assign s0[3] = A4;
  Mux_2x1_NBits #(
    .Bits(4)
  )
  Mux_2x1_NBits_i0 (
    .sel( S ),
    .in_0( s0 ),
    .in_1( s1 ),
    .out( s2 )
  );
  Mux_2x1_NBits #(
    .Bits(4)
  )
  Mux_2x1_NBits_i1 (
    .sel( G ),
    .in_0( s2 ),
    .in_1( 4'b0 ),
    .out( s3 )
  );
  assign Y1 = s3[0];
  assign Y2 = s3[1];
  assign Y3 = s3[2];
  assign Y4 = s3[3];
endmodule

module Mux_4x1
(
    input [1:0] sel,
    input in_0,
    input in_1,
    input in_2,
    input in_3,
    output reg out
);
    always @ (*) begin
        case (sel)
            2'h0: out = in_0;
            2'h1: out = in_1;
            2'h2: out = in_2;
            2'h3: out = in_3;
            default:
                out = 'h0;
        endcase
    end
endmodule


// dual 4-line to 1-line data selectors/multiplexers
module \74153  (
  input A,
  input B,
  input \2G ,
  input \2C0 ,
  input \2C1 ,
  input \2C2 ,
  input \2C3 ,
  input \1G ,
  input \1C0 ,
  input \1C1 ,
  input \1C2 ,
  input \1C3 ,
  input VCC,
  input GND,
  output \2Y ,
  output \1Y 
);
  wire [1:0] s0;
  wire s1;
  wire s2;
  assign s0[0] = A;
  assign s0[1] = B;
  Mux_4x1 Mux_4x1_i0 (
    .sel( s0 ),
    .in_0( \2C0  ),
    .in_1( \2C1  ),
    .in_2( \2C2  ),
    .in_3( \2C3  ),
    .out( s1 )
  );
  Mux_4x1 Mux_4x1_i1 (
    .sel( s0 ),
    .in_0( \1C0  ),
    .in_1( \1C1  ),
    .in_2( \1C2  ),
    .in_3( \1C3  ),
    .out( s2 )
  );
  assign \2Y  = (~ \2G  & s1);
  assign \1Y  = (~ \1G  & s2);
endmodule

// 8-line to 3-Line priority encoder
module \74148  (
  input EI,
  input \0 ,
  input \1 ,
  input \2 ,
  input \3 ,
  input \4 ,
  input \5 ,
  input \6 ,
  input \7 ,
  input VCC,
  input GND,
  output A2,
  output A1,
  output A0,
  output GS,
  output E0
);
  wire s0;
  wire s1;
  wire s2;
  wire s3;
  assign A2 = ((\4  & \5  & \6  & \7 ) | EI);
  assign GS = ((\0  & \1  & \2  & \3  & \4  & \5  & \6  & \7 ) | EI);
  assign s2 = ~ \2 ;
  assign s0 = ~ \4 ;
  assign s1 = ~ \5 ;
  assign s3 = ~ \6 ;
  assign A1 = ((\2  & \3  & \6  & \7 ) | (s0 & \6  & \7 ) | (s1 & \6  & \7 ) | EI);
  assign A0 = ((\1  & \3  & \5  & \7 ) | (s2 & \3  & \5  & \7 ) | (s0 & \5  & \7 ) | (s3 & \7 ) | EI);
  assign E0 = (~ \0  | ~ \1  | s2 | ~ \3  | s0 | s1 | s3 | ~ \7  | EI);
endmodule

module DIG_D_FF_AS_1bit
#(
    parameter Default = 0
)
(
   input Set,
   input D,
   input C,
   input Clr,
   output Q,
   output \~Q
);
    reg state;

    assign Q = state;
    assign \~Q  = ~state;

    always @ (posedge C or posedge Clr or posedge Set)
    begin
        if (Set)
            state <= 1'b1;
        else if (Clr)
            state <= 'h0;
        else
            state <= D;
    end

    initial begin
        state = Default;
    end
endmodule

// 8-bit parallel-out serial shift register, asynchronous clear
module \74164  (
  input CP,
  input DSA,
  input DSB,
  input \~MR ,
  input VCC,
  input GND,
  output Q0,
  output Q1,
  output Q2,
  output Q3,
  output Q4,
  output Q5,
  output Q6,
  output Q7
);
  wire s0;
  wire s1;
  wire Q0_temp;
  wire Q1_temp;
  wire Q2_temp;
  wire Q3_temp;
  wire Q4_temp;
  wire Q5_temp;
  wire Q6_temp;
  assign s0 = (DSA & DSB);
  assign s1 = ~ \~MR ;
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i0 (
    .Set( 1'b0 ),
    .D( s0 ),
    .C( CP ),
    .Clr( s1 ),
    .Q( Q0_temp )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i1 (
    .Set( 1'b0 ),
    .D( Q0_temp ),
    .C( CP ),
    .Clr( s1 ),
    .Q( Q1_temp )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i2 (
    .Set( 1'b0 ),
    .D( Q1_temp ),
    .C( CP ),
    .Clr( s1 ),
    .Q( Q2_temp )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i3 (
    .Set( 1'b0 ),
    .D( Q2_temp ),
    .C( CP ),
    .Clr( s1 ),
    .Q( Q3_temp )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i4 (
    .Set( 1'b0 ),
    .D( Q3_temp ),
    .C( CP ),
    .Clr( s1 ),
    .Q( Q4_temp )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i5 (
    .Set( 1'b0 ),
    .D( Q4_temp ),
    .C( CP ),
    .Clr( s1 ),
    .Q( Q5_temp )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i6 (
    .Set( 1'b0 ),
    .D( Q5_temp ),
    .C( CP ),
    .Clr( s1 ),
    .Q( Q6_temp )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i7 (
    .Set( 1'b0 ),
    .D( Q6_temp ),
    .C( CP ),
    .Clr( s1 ),
    .Q( Q7 )
  );
  assign Q0 = Q0_temp;
  assign Q1 = Q1_temp;
  assign Q2 = Q2_temp;
  assign Q3 = Q3_temp;
  assign Q4 = Q4_temp;
  assign Q5 = Q5_temp;
  assign Q6 = Q6_temp;
endmodule

// dual D-flip-flop
module \7474  (
  input \1~SD ,
  input \1D ,
  input \1CP ,
  input \1~RD ,
  input \2~SD ,
  input \2D ,
  input \2CP ,
  input \2~RD ,
  input VCC,
  input GND,
  output \1Q ,
  output \1~Q ,
  output \2Q ,
  output \2~Q 
);
  wire s0;
  wire s1;
  wire s2;
  wire s3;
  wire s4;
  wire s5;
  assign s0 = ~ \1~SD ;
  assign s1 = ~ \1~RD ;
  assign s3 = ~ \2~SD ;
  assign s4 = ~ \2~RD ;
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i0 (
    .Set( s0 ),
    .D( \1D  ),
    .C( \1CP  ),
    .Clr( s1 ),
    .Q( \1Q  ),
    .\~Q ( s2 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i1 (
    .Set( s3 ),
    .D( \2D  ),
    .C( \2CP  ),
    .Clr( s4 ),
    .Q( \2Q  ),
    .\~Q ( s5 )
  );
  assign \1~Q  = (s2 | (~ \1~SD  & ~ \1~RD ));
  assign \2~Q  = (s5 | (~ \2~SD  & ~ \2~RD ));
endmodule

module \Z80-processor-CPU  (
  input IOxSEL,
  input \~CPUxRD ,
  input \~DMAxIEI1 ,
  input \~CPUxM1 ,
  input \~CPUxIORQ ,
  input \~DMAxIEO2 ,
  input \~FPxLATCH ,
  input \~CPUxWR ,
  input \CPU-A2 ,
  input \~CSxMAP ,
  input \CPU-A14 ,
  input mA14,
  input \CPU-A15 ,
  input mA15,
  input \CPU-A1 ,
  input \~INTxI2C ,
  input \~A ,
  input WSxMEMRD,
  input WSxIORD,
  input WSxMEMWR,
  input WSxIOWR,
  input \~CPUxMREQ ,
  input \~CPUxRFSH ,
  input \CPU-D0 ,
  input \~EIRQ7 ,
  input \~EIRQ6 ,
  input \~EIRQ0 ,
  input \~EIRQ1 ,
  input \~EIRQ2 ,
  input \~EIRQ3 ,
  input \~EIRQ5 ,
  input \~EIRQ4 ,
  input CLK,
  input \~CPUxRESET ,
  output DATAxDIR,
  output \~IM2xEN ,
  output \~FPxLATCHxRD ,
  output FPxLATCHxWR,
  output \~IM2xIEO ,
  output \SEL-A14 ,
  output \SEL-A15 ,
  output \~CSxI2C ,
  output \INT-I2C ,
  output \~CSxI2CxWR ,
  output \~AxPRIME ,
  output READY,
  output \~PAGExEN ,
  output \~PAGExWR ,
  output \~IM2xS2 ,
  output \~IM2xS1 ,
  output \~IM2xS0 ,
  output \~IM2xINT ,
  output \1WS ,
  output \2WS ,
  output \3WS ,
  output \4WS ,
  output \5WS ,
  output \6WS ,
  output \7WS ,
  output \8WS ,
  output RESET
);
  wire s0;
  wire \~IM2xIEO_temp ;
  wire \~IM2xINT_temp ;
  wire s1;
  wire s2;
  wire \~CSxI2C_temp ;
  wire s3;
  wire s4;
  assign s0 = (\~CPUxM1  | \~CPUxIORQ );
  assign \~FPxLATCHxRD  = (\~CPUxRD  | \~FPxLATCH );
  assign FPxLATCHxWR = ~ (\~FPxLATCH  | \~CPUxWR );
  \74139  \74139_i0 (
    .\1A ( \CPU-A2  ),
    .\1B ( \~CSxMAP  ),
    .\~1G ( \~CPUxWR  ),
    .\2A ( \CPU-A2  ),
    .\2B ( \~CSxMAP  ),
    .\~2G ( 1'b0 ),
    .VCC( 1'b1 ),
    .GND( 1'b0 ),
    .\~1Y0 ( \~PAGExWR  ),
    .\~2Y1 ( s1 )
  );
  \74157  \74157_i1 (
    .S( \~CPUxIORQ  ),
    .A1( \CPU-A14  ),
    .A2( \CPU-A15  ),
    .A3( 1'b1 ),
    .A4( 1'b1 ),
    .B1( mA14 ),
    .B2( mA15 ),
    .B3( 1'b1 ),
    .B4( 1'b1 ),
    .G( 1'b0 ),
    .VCC( 1'b1 ),
    .GND( 1'b0 ),
    .Y1( \SEL-A14  ),
    .Y2( \SEL-A15  )
  );
  assign \INT-I2C  = ~ \~INTxI2C ;
  \74153  \74153_i2 (
    .A( \~CPUxMREQ  ),
    .B( \~CPUxRD  ),
    .\2G ( 1'b1 ),
    .\2C0 ( 1'b1 ),
    .\2C1 ( 1'b1 ),
    .\2C2 ( 1'b1 ),
    .\2C3 ( 1'b1 ),
    .\1G ( 1'b0 ),
    .\1C0 ( WSxMEMRD ),
    .\1C1 ( WSxIORD ),
    .\1C2 ( WSxMEMWR ),
    .\1C3 ( WSxIOWR ),
    .VCC( 1'b1 ),
    .GND( 1'b0 ),
    .\1Y ( s3 )
  );
  assign s4 = ~ (\~CPUxMREQ  & \~CPUxIORQ );
  \74148  \74148_i3 (
    .EI( 1'b0 ),
    .\0 ( \~EIRQ7  ),
    .\1 ( \~EIRQ6  ),
    .\2 ( \~EIRQ5  ),
    .\3 ( \~EIRQ4  ),
    .\4 ( \~EIRQ3  ),
    .\5 ( \~EIRQ2  ),
    .\6 ( \~EIRQ1  ),
    .\7 ( \~EIRQ0  ),
    .VCC( 1'b1 ),
    .GND( 1'b0 ),
    .A2( \~IM2xS2  ),
    .A1( \~IM2xS1  ),
    .A0( \~IM2xS0  ),
    .GS( \~IM2xINT_temp  )
  );
  assign RESET = ~ \~CPUxRESET ;
  assign DATAxDIR = ((\~CPUxRD  | IOxSEL) & (s0 | ~ \~DMAxIEI1 ));
  assign \~IM2xIEO_temp  = (\~IM2xINT_temp  | ~ \~DMAxIEO2 );
  assign s2 = (s1 | \CPU-A1 );
  assign \~CSxI2C_temp  = (s1 | ~ \CPU-A1 );
  assign READY = (~ (s4 & \~CPUxRFSH ) | s3);
  \74164  \74164_i4 (
    .CP( CLK ),
    .DSA( 1'b1 ),
    .DSB( 1'b1 ),
    .\~MR ( s4 ),
    .VCC( 1'b1 ),
    .GND( 1'b0 ),
    .Q0( \1WS  ),
    .Q1( \2WS  ),
    .Q2( \3WS  ),
    .Q3( \4WS  ),
    .Q4( \5WS  ),
    .Q5( \6WS  ),
    .Q6( \7WS  ),
    .Q7( \8WS  )
  );
  assign \~IM2xEN  = (s0 | \~IM2xIEO_temp );
  assign \~AxPRIME  = (\~CSxI2C_temp  | \~CPUxWR );
  \7474  \7474_i5 (
    .\1~SD ( 1'b1 ),
    .\1D ( \CPU-D0  ),
    .\1CP ( s2 ),
    .\1~RD ( \~CPUxRESET  ),
    .\2~SD ( 1'b1 ),
    .\2D ( 1'b1 ),
    .\2CP ( 1'b1 ),
    .\2~RD ( 1'b1 ),
    .VCC( 1'b1 ),
    .GND( 1'b0 ),
    .\1~Q ( \~PAGExEN  )
  );
  assign \~IM2xIEO  = \~IM2xIEO_temp ;
  assign \~CSxI2C  = \~CSxI2C_temp ;
  assign \~CSxI2CxWR  = \~A ;
  assign \~IM2xINT  = \~IM2xINT_temp ;
endmodule
