-- generated by Digital. Don't modify this file!
-- Any changes will be lost if this file is regenerated.

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

-- 8-bit identity comparator
entity n74688 is
  port (
    P_0: in std_logic;
    Q_0: in std_logic;
    P_1: in std_logic;
    Q_1: in std_logic;
    P_2: in std_logic;
    Q_2: in std_logic;
    P_3: in std_logic;
    Q_3: in std_logic;
    P_4: in std_logic;
    Q_4: in std_logic;
    P_5: in std_logic;
    Q_5: in std_logic;
    P_6: in std_logic;
    Q_6: in std_logic;
    P_7: in std_logic;
    Q_7: in std_logic;
    notOE: in std_logic;
    VCC: in std_logic;
    GND: in std_logic;
    notEQ: out std_logic);
end n74688;

architecture Behavioral of n74688 is
begin
  notEQ <= NOT (NOT notOE AND NOT ((P_0 XOR Q_0) OR (P_1 XOR Q_1) OR (P_2 XOR Q_2)) AND NOT ((P_3 XOR Q_3) OR (P_4 XOR Q_4) OR (P_5 XOR Q_5)) AND NOT ((P_6 XOR Q_6) OR (P_7 XOR Q_7)));
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity DEMUX_GATE_2 is
  generic (
    Default : integer );
  port (
    out_0: out std_logic;
    out_1: out std_logic;
    out_2: out std_logic;
    out_3: out std_logic;
    sel: in std_logic_vector (1 downto 0);
    p_in: in std_logic );
end DEMUX_GATE_2;

architecture Behavioral of DEMUX_GATE_2 is
begin
    out_0 <= p_in when sel = "00" else std_logic(to_unsigned(Default, 1)(0));
    out_1 <= p_in when sel = "01" else std_logic(to_unsigned(Default, 1)(0));
    out_2 <= p_in when sel = "10" else std_logic(to_unsigned(Default, 1)(0));
    out_3 <= p_in when sel = "11" else std_logic(to_unsigned(Default, 1)(0));
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

-- dual 2-line to 4-line decoder/demultiplexer
entity n74139 is
  port (
    n1A: in std_logic;
    n1B: in std_logic;
    not1G: in std_logic;
    n2A: in std_logic;
    n2B: in std_logic;
    not2G: in std_logic;
    VCC: in std_logic;
    GND: in std_logic;
    not1Y0: out std_logic;
    not1Y1: out std_logic;
    not1Y2: out std_logic;
    not1Y3: out std_logic;
    not2Y0: out std_logic;
    not2Y1: out std_logic;
    not2Y2: out std_logic;
    not2Y3: out std_logic);
end n74139;

architecture Behavioral of n74139 is
  signal s0: std_logic_vector(1 downto 0);
  signal s1: std_logic_vector(1 downto 0);
begin
  s0(0) <= n1A;
  s0(1) <= n1B;
  s1(0) <= n2A;
  s1(1) <= n2B;
  gate0: entity work.DEMUX_GATE_2
    generic map (
      Default => 1)
    port map (
      sel => s0,
      p_in => not1G,
      out_0 => not1Y0,
      out_1 => not1Y1,
      out_2 => not1Y2,
      out_3 => not1Y3);
  gate1: entity work.DEMUX_GATE_2
    generic map (
      Default => 1)
    port map (
      sel => s1,
      p_in => not2G,
      out_0 => not2Y0,
      out_1 => not2Y1,
      out_2 => not2Y2,
      out_3 => not2Y3);
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity MUX_GATE_BUS_1 is
  generic ( Bits : integer ); 
  port (
    p_out: out std_logic_vector ((Bits-1) downto 0);
    sel: in std_logic;
    
    in_0: in std_logic_vector ((Bits-1) downto 0);
    in_1: in std_logic_vector ((Bits-1) downto 0) );
end MUX_GATE_BUS_1;

architecture Behavioral of MUX_GATE_BUS_1 is
begin
  with sel select
    p_out <=
      in_0 when '0',
      in_1 when '1',
      (others => '0') when others;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

-- quad 2-line to 1-line data selectors/multiplexers
entity n74157 is
  port (
    S: in std_logic; -- select
    A1: in std_logic;
    A2: in std_logic;
    A3: in std_logic;
    A4: in std_logic;
    B1: in std_logic;
    B2: in std_logic;
    B3: in std_logic;
    B4: in std_logic;
    G: in std_logic; -- strobe
    VCC: in std_logic;
    GND: in std_logic;
    Y1: out std_logic;
    Y2: out std_logic;
    Y3: out std_logic;
    Y4: out std_logic);
end n74157;

architecture Behavioral of n74157 is
  signal s0: std_logic_vector(3 downto 0);
  signal s1: std_logic_vector(3 downto 0);
  signal s2: std_logic_vector(3 downto 0);
  signal s3: std_logic_vector(3 downto 0);
begin
  s1(0) <= B1;
  s1(1) <= B2;
  s1(2) <= B3;
  s1(3) <= B4;
  s0(0) <= A1;
  s0(1) <= A2;
  s0(2) <= A3;
  s0(3) <= A4;
  gate0: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 4)
    port map (
      sel => S,
      in_0 => s0,
      in_1 => s1,
      p_out => s2);
  gate1: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 4)
    port map (
      sel => G,
      in_0 => s2,
      in_1 => "0000",
      p_out => s3);
  Y1 <= s3(0);
  Y2 <= s3(1);
  Y3 <= s3(2);
  Y4 <= s3(3);
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity DIG_D_FF_AS_BUS is
  generic ( Bits: integer ); 
  port (
    Q: out std_logic_vector ((Bits-1) downto 0);
    notQ: out std_logic_vector ((Bits-1) downto 0);
    Set: in std_logic;
    D: in std_logic_vector ((Bits-1) downto 0);
    C: in std_logic;
    Clr: in std_logic );
end DIG_D_FF_AS_BUS;

architecture Behavioral of DIG_D_FF_AS_BUS is
   signal state : std_logic_vector ((Bits-1) downto 0) := (others => '0');
begin
    process (Set, Clr, C)
    begin
        if (Set='1') then
            state <= NOT((others => '0'));
        elsif (Clr='1') then
            state <= (others => '0');
        elsif rising_edge(C) then
            state <= D;
        end if;
    end process;

    Q <= state;
    notQ <= NOT( state );
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

-- quad D-flip-flop
entity n74175 is
  port (
    CLK: in std_logic;
    notCL: in std_logic;
    D1: in std_logic;
    D2: in std_logic;
    D3: in std_logic;
    D4: in std_logic;
    VCC: in std_logic;
    GND: in std_logic;
    Q1: out std_logic;
    Q2: out std_logic;
    Q3: out std_logic;
    Q4: out std_logic;
    notQ1: out std_logic;
    notQ2: out std_logic;
    notQ3: out std_logic;
    notQ4: out std_logic);
end n74175;

architecture Behavioral of n74175 is
  signal s0: std_logic_vector(3 downto 0);
  signal s1: std_logic;
  signal s2: std_logic_vector(3 downto 0);
  signal s3: std_logic_vector(3 downto 0);
begin
  s1 <= NOT notCL;
  s0(0) <= D1;
  s0(1) <= D2;
  s0(2) <= D3;
  s0(3) <= D4;
  gate0: entity work.DIG_D_FF_AS_BUS
    generic map (
      Bits => 4)
    port map (
      Set => '0',
      D => s0,
      C => CLK,
      Clr => s1,
      Q => s2,
      notQ => s3);
  Q1 <= s2(0);
  Q2 <= s2(1);
  Q3 <= s2(2);
  Q4 <= s2(3);
  notQ1 <= s3(0);
  notQ2 <= s3(1);
  notQ3 <= s3(2);
  notQ4 <= s3(3);
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity main is
  port (
    CPUxA0: in std_logic;
    CPUxA1: in std_logic;
    notCPUxWAIT: in std_logic;
    notBUSRQ: in std_logic;
    notCPUxBUSACK: in std_logic;
    notDMAxINTxPULSE1: in std_logic;
    notDMAxINTxPULSE2: in std_logic;
    CPUxA3: in std_logic;
    notDREQ0: in std_logic;
    notDREQ1: in std_logic;
    notCPUxWR: in std_logic;
    notCPUxRESET: in std_logic;
    notDMAxBAO2: in std_logic;
    CPU_D0: in std_logic;
    CPU_D1: in std_logic;
    CPU_D2: in std_logic;
    CPU_D3: in std_logic;
    notCPUxIORQ: in std_logic;
    notCPUxM1: in std_logic;
    notCPUxA2: in std_logic;
    Q2: in std_logic;
    Q3: in std_logic;
    notCPUxA4: in std_logic;
    notCPUxA5: in std_logic;
    notCPUxA6: in std_logic;
    notCPUxA7: in std_logic;
    Q4: in std_logic;
    Q5: in std_logic;
    Q6: in std_logic;
    Q7: in std_logic;
    R4: in std_logic;
    R5: in std_logic;
    R6: in std_logic;
    R7: in std_logic;
    notFPxLATCH: out std_logic;
    notDMAxCS1: out std_logic;
    notDMAxCS2: out std_logic;
    notBUSxEN: out std_logic;
    DATAxXFER: out std_logic;
    IOxSEL: out std_logic;
    notCSxMAP: out std_logic;
    notCSxUART: out std_logic;
    DMAxRDY1: out std_logic;
    DMAxRDY2: out std_logic;
    notDMAxRESET1: out std_logic;
    notDMAxRESET2: out std_logic;
    BUSACK: out std_logic);
end main;

architecture Behavioral of main is
  signal s0: std_logic;
  signal s1: std_logic;
  signal s2: std_logic;
  signal s3: std_logic;
  signal s4: std_logic;
  signal s5: std_logic;
  signal s6: std_logic;
  signal notDMAxCS1_temp: std_logic;
  signal notDMAxCS2_temp: std_logic;
  signal s7: std_logic;
  signal s8: std_logic;
  signal s9: std_logic;
  signal s10: std_logic;
  signal s11: std_logic;
  signal s12: std_logic;
begin
  DATAxXFER <= ((notCPUxBUSACK OR notBUSRQ) OR (notDMAxINTxPULSE1 AND notDMAxINTxPULSE2));
  s6 <= NOT notCPUxBUSACK;
  BUSACK <= NOT notDMAxBAO2;
  gate0: entity work.n74688
    port map (
      P_0 => notCPUxM1,
      Q_0 => '1',
      P_1 => '1',
      Q_1 => '1',
      P_2 => notCPUxA2,
      Q_2 => Q2,
      P_3 => CPUxA3,
      Q_3 => Q3,
      P_4 => notCPUxA4,
      Q_4 => Q4,
      P_5 => notCPUxA5,
      Q_5 => Q5,
      P_6 => notCPUxA6,
      Q_6 => Q6,
      P_7 => notCPUxA7,
      Q_7 => Q7,
      notOE => notCPUxIORQ,
      VCC => '1',
      GND => '0',
      notEQ => s4);
  gate1: entity work.n74688
    port map (
      P_0 => notCPUxM1,
      Q_0 => '1',
      P_1 => '1',
      Q_1 => '1',
      P_2 => '1',
      Q_2 => '1',
      P_3 => '1',
      Q_3 => '1',
      P_4 => notCPUxA4,
      Q_4 => R4,
      P_5 => notCPUxA5,
      Q_5 => R5,
      P_6 => notCPUxA6,
      Q_6 => R6,
      P_7 => notCPUxA7,
      Q_7 => R7,
      notOE => notCPUxIORQ,
      VCC => '1',
      GND => '0',
      notEQ => s7);
  gate2: entity work.n74139
    port map (
      n1A => '1',
      n1B => '1',
      not1G => '1',
      n2A => CPUxA0,
      n2B => CPUxA1,
      not2G => s4,
      VCC => '1',
      GND => '0',
      not2Y0 => s0,
      not2Y1 => s1,
      not2Y2 => notFPxLATCH,
      not2Y3 => s5);
  IOxSEL <= NOT (s4 AND s7);
  notCSxMAP <= (s7 OR CPUxA3);
  notCSxUART <= (s7 OR NOT CPUxA3);
  gate3: entity work.n74157
    port map (
      S => notBUSRQ,
      A1 => notCPUxWAIT,
      A2 => notCPUxWAIT,
      A3 => '0',
      A4 => '0',
      B1 => s0,
      B2 => s1,
      B3 => '0',
      B4 => '0',
      G => '0',
      VCC => '1',
      GND => '0',
      Y1 => s2,
      Y2 => s3);
  s10 <= (notCPUxWR OR s5);
  notDMAxCS1_temp <= (s6 OR s2);
  notDMAxCS2_temp <= (s6 OR s3);
  gate4: entity work.n74175
    port map (
      CLK => s10,
      notCL => notCPUxRESET,
      D1 => CPU_D0,
      D2 => CPU_D1,
      D3 => CPU_D2,
      D4 => CPU_D3,
      VCC => '1',
      GND => '0',
      Q1 => s8,
      Q2 => s9,
      notQ3 => s11,
      notQ4 => s12);
  notBUSxEN <= NOT (notCPUxBUSACK AND (notDMAxCS1_temp AND notDMAxCS2_temp));
  DMAxRDY1 <= (NOT notDREQ0 OR s8);
  DMAxRDY2 <= (NOT notDREQ1 OR s9);
  notDMAxRESET1 <= (s11 AND notCPUxRESET);
  notDMAxRESET2 <= (notCPUxRESET AND s12);
  notDMAxCS1 <= notDMAxCS1_temp;
  notDMAxCS2 <= notDMAxCS2_temp;
end Behavioral;
