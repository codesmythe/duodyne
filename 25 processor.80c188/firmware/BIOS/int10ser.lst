     1                                  ;========================================================================
     2                                  ; int10ser.asm -- Video display services implementation using serial port
     3                                  ;========================================================================
     4                                  ;
     5                                  ;    Compiles with NASM 2.07, might work with other versions
     6                                  ;
     7                                  ; Copyright (C) 2010 Sergey Kiselev.
     8                                  ;     additions and modifications for ColorVDU:
     9                                  ; Copyright (C) 2012 John R. Coffman.
    10                                  ; Provided for hobbyist use on the N8VEM SBC-188 board.
    11                                  ;
    12                                  ; This program is free software: you can redistribute it and/or modify
    13                                  ; it under the terms of the GNU General Public License as published by
    14                                  ; the Free Software Foundation, either version 3 of the License, or
    15                                  ; (at your option) any later version.
    16                                  ;
    17                                  ; This program is distributed in the hope that it will be useful,
    18                                  ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    19                                  ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    20                                  ; GNU General Public License for more details.
    21                                  ;
    22                                  ; You should have received a copy of the GNU General Public License
    23                                  ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    24                                  ;
    25                                  ; Updated for the Duodyne 80c188 SBC
    26                                  ;========================================================================
    27                                  
    28                                  %include	"config.asm"
    29                              <1> ;/*
    30                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    31                              <1> ; ANSI.CFG
    32                              <1> ;   Copied to CONFIG.ASM for general release.
    33                              <1> ;
    34                              <1> ;       Modify the parameters below to reflect your system
    35                              <1> ;
    36                              <1> ;
    37                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    38                              <1> ;
    39                              <1> ;   Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    40                              <1> ;   Provided for hobbyist use on the N8VEM SBC-188 board.
    41                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    42                              <1> ;
    43                              <1> ; Define the serial terminal that the Video BIOS must emulate
    44                              <1> ; Set one of the following to 1
    45                              <1> ; If you have no idea what to choose, set TTY to 1
    46                              <1> TTY     equ     0       ; hardcopy -- cannot position the cursor
    47                              <1> DUMB    equ     0       ; dumb CRT -- ^H, ^J, ^K, ^L can move the cursor
    48                              <1> ANSI    equ     1       ; very smart, like a VT-100
    49                              <1> WYSE    equ     0       ; very smart Wyse series (30, 50, ...)
    50                              <1> ; others may get added in the future
    51                              <1> ;  ONE OF THE ABOVE must BE SET TO 1!!!!!
    52                              <1> ;
    53                              <1> ; Does the hardware configuration contain the Color Video Display Unit?
    54                              <1> ; Both the 8563 and the 8242 are used.  The default is CVDU=0
    55                              <1> CVDU	equ	0	; system does not have the CVDU
    56                              <1> ;
    57                              <1> ; Does the hardware configuration contain the VGA3 a/n Video card?
    58                              <1> ; The 8563 will be disabled, but the 8242 code is shared with the CVDU
    59                              <1> ; The default is VGA3=0
    60                              <1> VGA3    equ     0       ; system does not have the VGA3
    61                              <1> %if 0
    62                              <1> 	*/
    63                              <1> #define VGA3 0
    64                              <1> /*
    65                              <1> %endif
    66                              <1> ;
    67                              <1> ; Boot up keyboard mode:  20h for NumLock on
    68                              <1> ;CVDU_KEYBOARD_STATUS	equ	0	; NumLock OFF
    69                              <1> CVDU_KEYBOARD_STATUS	equ	20h	; NumLock ON
    70                              <1> 
    71                              <1> ; Define the UART startup bit rate - 1200-19200 are most common
    72                              <1> ;UART_RATE	equ	0		; 1200
    73                              <1> ;UART_RATE	equ	1		; 2400
    74                              <1> ;UART_RATE	equ	2		; 4800
    75                              <1> UART_RATE	equ	3		; 9600
    76                              <1> ;UART_RATE	equ	4		; 19200
    77                              <1> ;UART_RATE	equ	5		; 38400
    78                              <1> ;UART_RATE	equ	6		; 57600
    79                              <1> ;UART_RATE	equ	7		; 115200
    80                              <1> 
    81                              <1> ; Does the serial terminal use the DSR/DTR protocol for flow control?
    82                              <1> ;UART_DSR_PROTOCOL	equ		1	; Yes!
    83                              <1> UART_DSR_PROTOCOL       equ             WYSE    ; Wyse always uses it
    84                              <1> 						; but not ANSI
    85                              <1> ; Define the size of the ROM image on the system in Kilobytes
    86                              <1> ; It may be smaller than the actual EPROM in use.
    87                              <1> ; The following sizes are supported:  32, 64, 128, and 256
    88                              <1> %ifndef ROM
    89                              <1> ROM             equ     32              ; 64 is the default
    90                              <1> %endif
    91                              <1> 
    92                              <1> ; Define the number of Wait States at which the ROM operates
    93                              <1> ROM_WS          equ     1               ; 0..3  (1 is the default)
    94                              <1> 
    95                              <1> ; Define the size in Kilobytes of DOS RAM (low SRAM plus EMM allocate RAM)
    96                              <1> ; This is a desired size and will only be present if a 4MEM board is added
    97                              <1> RAM_DOS         equ     640
    98                              <1> 
    99                              <1> ; Define the size of the low SRAM on the system in Kilobytes
   100                              <1> ; the default is 512 kilobytes
   101                              <1> RAM             equ     512             ; (512 is the default)
   102                              <1> 
   103                              <1> ; Define the number of Wait States at which the RAM operates
   104                              <1> RAM_WS          equ     0               ; 0..3  (0 is the default)
   105                              <1> 
   106                              <1> ; Define the number of Wait States for Local Peripheral devices (600-7FF)
   107                              <1> LCL_IO_WS       equ     1               ; 0..3  (1 is the default)
   108                              <1> 
   109                              <1> ; Define the number of Wait States for ECB BUS peripheral devices (4xx)
   110                              <1> BUS_IO_WS       equ     3               ; 0..3  (3 is the default)
   111                              <1> 
   112                              <1> ; Define the time zone in which we build the Relocatable BIOS
   113                              <1> %ifndef TIMEZONE
   114                              <1> %define TIMEZONE "CST"
   115                              <1> %endif
   116                              <1> 
   117                              <1> ; Has the REDBUG debugger been loaded?
   118                              <1> %ifndef SOFT_DEBUG
   119                              <1> %define SOFT_DEBUG 0
   120                              <1> %endif
   121                              <1> 
   122                              <1> ; Should the BIOS include "Tiny BASIC" in the image?
   123                              <1> %ifndef TBASIC
   124                              <1> TBASIC          equ     1		; default is 1
   125                              <1> %endif
   126                              <1> 
   127                              <1> ; Should the BIOS include the Floating Point Emulator?  The 80188 does
   128                              <1> ; not allow a floating point co-processor, so this is probably a good idea.
   129                              <1> %ifndef FPEM
   130                              <1> FPEM            equ     1               ; default is 1
   131                              <1> %endif
   132                              <1> 
   133                              <1> ; Define the maximum number of EMM (4MEM) boards supported
   134                              <1> EMM_BOARDS      equ     0
   135                              <1> 
   136                              <1> ; Should the Floating Point Emulator use temporary storage in the EBDA
   137                              <1> ; or at locations 0280h..3FFh in low memory?
   138                              <1> %if SOFT_DEBUG
   139                              <1> FPEM_USE_EBDA   equ     FPEM            ; default is 0
   140                              <1> %else
   141                              <1> FPEM_USE_EBDA   equ     0; FPEM            ; default is 0
   142                              <1> %endif
   143                              <1> 
   144                              <1> ; Define the size of the EPROM that is to be installed on the system
   145                              <1> ; It may be larger than the actual ROM image to be generated.
   146                              <1> %ifndef CHIP
   147                              <1> CHIP            equ     64
   148                              <1> %endif
   149                              <1> 
   150                              <1> ; Does the SBC-188 00.4 board have the LS138/LS08 piggyback fix
   151                              <1> ; Set to 1 for the SBC-188 v1.0 and later production boards
   152                              <1> ;FDC_PIGGYBACK_FIX       equ     0       ; Fix not installed
   153                              <1> FDC_PIGGYBACK_FIX       equ     1       ; fix  IS  installed
   154                              <1> 
   155                              <1> ; On SBC-188 rev 00.4 board, there is a published hardware fix (2010-09-18).
   156                              <1> ; If the wiring update is installed, or you have a later board, then
   157                              <1> ; set this to 0.  If you are using the software workaround, then set this
   158                              <1> ; to 1.  The rev 1.0 board has this fix already.
   159                              <1> NEED_TIMER_FIX  equ     0               ; have revised hardware
   160                              <1> ;NEED_TIMER_FIX  equ     1               ; use workaround
   161                              <1> 
   162                              <1> ; Define the UART oscillator speed
   163                              <1> UART_OSC        equ     1843200         ; 1.8432 Mhz is specified
   164                              <1> 
   165                              <1> 
   166                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   167                              <1> ; end of the User configuration
   168                              <1> ;       Do Not modify anything below this point
   169                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   170                              <1> 
   171                              <1> CVDU_8563	equ	CVDU		; separate inits
   172                              <1> CVDU_8242	equ	CVDU|VGA3 	; separate inits
   173                              <1> VGA3_6445       equ     VGA3            ; separate inits
   174                              <1> ; Suppress all UART output in color video Mode 3
   175                              <1> UART_MODE3_SUPPRESS	equ	CVDU_8563
   176                              <1> CVDU_USE_MSDOS_KLUDGE	equ	0; CVDU_8242	; bad, bad MSDOS
   177                              <1> CVDU_USE_KBD_HOOK		equ	CVDU_8242
   178                              <1> 
   179                              <1> ; Define existence of any uart chip
   180                              <1> UART		equ	TTY+DUMB+ANSI+WYSE
   181                              <1> startuplength   equ     512                     ; may be up to 1024
   182                              <1> startseg        equ     0FFFFh - (ROM*64) + 1
   183                              <1> highrom         equ     (ROM*400h)&0FFFFh
   184                              <1> startupseg      equ     0FFFFh - (startuplength>>4) + 1
   185                              <1> bios_data_seg   equ     040h            ; segment of BIOS data area
   186                              <1> 
   187                              <1> 
   188                              <1> %define ARG(n) [bp+2+(n)*2]
   189                              <1> 
   190                              <1> %macro  check   1.nolist
   191                              <1>  %if (%1)
   192                              <1>    %error Check Failure: %1
   193                              <1>  %endif
   194                              <1> %endm
   195                              <1> %macro  range   3.nolist
   196                              <1>  %if (%1)<(%2)
   197                              <1>    %error Out of Range: %1
   198                              <1>  %elif (%1)>(%3)
   199                              <1>    %error Out of Range: %1
   200                              <1>  %endif
   201                              <1> %endm
   202                              <1> _terminal equ UART+CVDU
   203                              <1>  check   RAM_DOS&15
   204                              <1>  check   RAM&(RAM-1)
   205                              <1>  check   ROM&(ROM-1)
   206                              <1>  range   RAM,32,512
   207                              <1>  range   ROM,32,256
   208                              <1>  range   RAM_WS,0,3
   209                              <1>  range   ROM_WS,0,3
   210                              <1>  range   RAM_DOS,RAM,(1024-ROM)
   211                              <1>  range   LCL_IO_WS,0,3
   212                              <1>  range   BUS_IO_WS,0,3
   213                              <1>  range   UART_OSC,500000,16000000
   214                              <1>  range   UART_RATE,0,7
   215                              <1>  range	 UART,0,1
   216                              <1>  range	 _terminal,1,2
   217                              <1> 
   218                              <1> %ifndef SOFT_DEBUG
   219                              <1> %define SOFT_DEBUG 0
   220                              <1> %endif
   221                              <1> 
   222                              <1> %ifndef TRACE
   223                              <1> %define TRACE 0
   224                              <1> %endif
   225                              <1> 
   226                              <1> %ifdef MAKE_OBJECT_FILE
   227                              <1>         segment _DATA WORD PUBLIC CLASS=DATA
   228                              <1>         export _ROMsize
   229                              <1>         export _CHIPsize
   230                              <1> _ROMsize        dw      ROM
   231                              <1> _CHIPsize       dw      CHIP
   232                              <1> %endif
   233                              <1> ; end of the Hardware configuration file
   234                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   235                              <1> ;*/
    29                                  
    30                                  %include	"cpuregs.asm"
    31                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    32                              <1> ; CPUREGS.ASM
    33                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    34                              <1> ;
    35                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    36                              <1> ;
    37                              <1> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    38                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    39                              <1> ;
    40                              <1> ; This program is free software: you can redistribute it and/or modify
    41                              <1> ; it under the terms of the GNU General Public License as published by
    42                              <1> ; the Free Software Foundation, either version 3 of the License, or
    43                              <1> ; (at your option) any later version.
    44                              <1> ;
    45                              <1> ; This program is distributed in the hope that it will be useful,
    46                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    47                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    48                              <1> ; GNU General Public License for more details.
    49                              <1> ;
    50                              <1> ; You should have received a copy of the GNU General Public License
    51                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    52                              <1> ;
    53                              <1> ; Updated for the Duodyne 80c188 SBC
    54                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    55                              <1> %include	"macros.inc"
    56                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    57                              <2> ; MACROS.INC  
    58                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    59                              <2> ;
    60                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    61                              <2> ;
    62                              <2> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    63                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    64                              <2> ;
    65                              <2> ; This program is free software: you can redistribute it and/or modify
    66                              <2> ; it under the terms of the GNU General Public License as published by
    67                              <2> ; the Free Software Foundation, either version 3 of the License, or
    68                              <2> ; (at your option) any later version.
    69                              <2> ;
    70                              <2> ; This program is distributed in the hope that it will be useful,
    71                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    72                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    73                              <2> ; GNU General Public License for more details.
    74                              <2> ;
    75                              <2> ; You should have received a copy of the GNU General Public License
    76                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    77                              <2> ;
    78                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    79                              <2> 
    80                              <2> ; general macros for the SBC188 BIOS ASSEMBLY
    81                              <2> ;
    82                              <2> ;
    83                              <2> %ifndef __MACROS_DEFINED_
    84                              <2> %define __MACROS_DEFINED_ 1
    85                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    86                              <2> ;
    87                              <2> ; some useful macros:
    88                              <2> ;
    89                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    90                              <2> ;
    91                              <2> 	cpu	186
    92                              <2> 
    93                              <2> %imacro setloc  1.nolist
    94                              <2>  times   (%1-($-$$)) db 0FFh
    95                              <2> %endm
    96                              <2> 
    97                              <2> %imacro db_lo   1
    98                              <2>  db (%1)&255
    99                              <2> %endm
   100                              <2> 
   101                              <2> %imacro cnop    0.nolist
   102                              <2> %if SOFT_DEBUG
   103                              <2>         nop
   104                              <2> %endif
   105                              <2> %endm
   106                              <2> 
   107                              <2> %imacro popm 1-*.nolist
   108                              <2> %rep %0
   109                              <2> %ifidni %1,ALL
   110                              <2>  popa
   111                              <2> %elifidni %1,F
   112                              <2>  popf
   113                              <2> %else
   114                              <2>  pop %1
   115                              <2> %ifidni %1,DS
   116                              <2>  cnop
   117                              <2> %elifidni %1,ES
   118                              <2>  cnop
   119                              <2> %endif
   120                              <2> %endif
   121                              <2> %rotate 1
   122                              <2> %endrep
   123                              <2> %endm
   124                              <2> 
   125                              <2> %imacro pushm 1-*.nolist
   126                              <2> %rep %0
   127                              <2> %rotate -1
   128                              <2> %ifidni %1,ALL
   129                              <2>  pusha
   130                              <2> %elifidni %1,F
   131                              <2>  pushf
   132                              <2> %else
   133                              <2>  push %1
   134                              <2> %endif
   135                              <2> %endrep
   136                              <2> %endm
   137                              <2> 
   138                              <2> ;
   139                              <2> ; added from the 386EX project
   140                              <2> ;
   141                              <2> 
   142                              <2> ; call arguments
   143                              <2> %define ARG(n) [bp+2+(n)*2]
   144                              <2> 
   145                              <2> ;
   146                              <2> ; format of the BYTE initialization table:  address, byte
   147                              <2> ;
   148                              <2> %imacro  binit 2
   149                              <2>         dw      %1
   150                              <2>         db      %2
   151                              <2> %endmacro
   152                              <2> ; end with DW -1
   153                              <2> 
   154                              <2> ;
   155                              <2> ; format of the WORD initialization table:  address, word
   156                              <2> ;
   157                              <2> %imacro  winit 2
   158                              <2>         dw      %1
   159                              <2>         dw      %2
   160                              <2> %endmacro
   161                              <2> ; end with DW -1
   162                              <2> 
   163                              <2> 
   164                              <2> ; get the BIOS Data Area segment pointer to a [segment] register
   165                              <2> %imacro get_bda	1.nolist
   166                              <2> 	push	0x0040
   167                              <2> 	pop	%1
   168                              <2> 	cnop
   169                              <2> %endm
   170                              <2> 
   171                              <2> 
   172                              <2> %endif
    56                              <1> 
    57                              <1> 	cpu     186
    58                              <1> ;
    59                              <1> ;
    60                              <1> ; IBM model byte -- must be less than a 286
    61                              <1> ;
    62                              <1> ;MODEL_BYTE		equ	0FEh	; PC-XT
    63                              <1> ;SUBMODEL_BYTE		equ	0FFh	; not used
    64                              <1> 
    65                              <1> MODEL_BYTE		equ	0FEh	; PC-XT
    66                              <1> SUBMODEL_BYTE		equ	00h	;  "
    67                              <1> 
    68                              <1> 
    69                              <1> ; 80188 peripheral control register block address
    70                              <1> CPU_CSCR	        equ	0FF00h
    71                              <1> 
    72                              <1> ; Compatible Mode registers
    73                              <1> 
    74                              <1> cpu_relocation          equ     CPU_CSCR+0FEh
    75                              <1> 
    76                              <1> ; The memory and peripheral chip select register offsets from 0FF00h
    77                              <1> 
    78                              <1> cpu_umcs                equ     CPU_CSCR+0A0h          ; Upper memory select
    79                              <1> cpu_lmcs                equ     CPU_CSCR+0A2h          ; Lower memory select
    80                              <1> cpu_pacs                equ     CPU_CSCR+0A4h          ; Peripheral select
    81                              <1> cpu_mmcs                equ     CPU_CSCR+0A6h          ; Middle memory base
    82                              <1> cpu_mpcs                equ     CPU_CSCR+0A8h          ; Mid mem. & peripherals
    83                              <1> 
    84                              <1> ; Enhanced Mode registers
    85                              <1> 
    86                              <1> cpu_mdram               equ     CPU_CSCR+0E0h          ; memory partition reg.
    87                              <1> cpu_cdram               equ     CPU_CSCR+0E2h          ; clock prescaler
    88                              <1> cpu_edram               equ     CPU_CSCR+0E4h          ; Enable refresh reg.
    89                              <1> cpu_pdcon               equ     CPU_CSCR+0F0h          ; Power-Save control
    90                              <1> 
    91                              <1> 
    92                              <1> ; On-board internal peripheral equates
    93                              <1> ; Programmable Interrupt Controller
    94                              <1> PIC	        equ	CPU_CSCR+020H
    95                              <1> PIC_EOI	        equ	PIC+2           ; End Of Interrupt
    96                              <1> PIC_POLLR	equ	PIC+4
    97                              <1> PIC_POLLSR	equ	PIC+6
    98                              <1> PIC_IMASK	equ	PIC+8
    99                              <1> PIC_PMREG	equ	PIC+0AH
   100                              <1> PIC_SRVR	equ	PIC+0CH
   101                              <1> PIC_IRQR	equ	PIC+0EH
   102                              <1> PIC_IRQSR	equ	PIC+10H
   103                              <1> PIC_TCR	        equ	PIC+12H
   104                              <1> PIC_DMA0CR	equ	PIC+14H
   105                              <1> PIC_DMA1CR	equ	PIC+16H
   106                              <1> PIC_I0CON	equ	PIC+18H
   107                              <1> PIC_I1CON	equ	PIC+1AH
   108                              <1> PIC_I2CON	equ	PIC+1CH
   109                              <1> PIC_I3CON	equ	PIC+1EH
   110                              <1> 
   111                              <1> EOI_NSPEC       equ     8000h           ; Non-Specific EOI
   112                              <1> 
   113                              <1> ; Interrupt masks (Master Mode)
   114                              <1> ;
   115                              <1> mask_timer_all          equ     0001h
   116                              <1> mask_dma0               equ     0004h
   117                              <1> mask_dma1               equ     0008h
   118                              <1> mask_int0               equ     0010h
   119                              <1> mask_int1               equ     0020h
   120                              <1> mask_int2               equ     0040h
   121                              <1> mask_int3               equ     0080h
   122                              <1> 
   123                              <1> 
   124                              <1> 
   125                              <1> ; Timers
   126                              <1> TIM0	        equ	CPU_CSCR+050H
   127                              <1> TIM1	        equ	CPU_CSCR+058H
   128                              <1> TIM2	        equ	CPU_CSCR+060H
   129                              <1> 
   130                              <1> TCNT	        equ	0	; count register
   131                              <1> CMPA	        equ	2	; max count A
   132                              <1> CMPB	        equ	4	; max count B (not present on TIM2)
   133                              <1> TCON	        equ	6	; mode/control word
   134                              <1> 
   135                              <1> ; Timer control bits:
   136                              <1> tc_EN           equ     8000h   ; Enable bit
   137                              <1> tc_nINH         equ     4000h   ; not Inhibit Enable
   138                              <1> tc_INT          equ     2000h   ; Interrupt Enable
   139                              <1> tc_RIU          equ     1000h   ; Register A/B (0/1) in Use
   140                              <1> tc_MC           equ     0020h   ; Maximum Count reached
   141                              <1> tc_RTG          equ     0010h   ; Retrigger (internal source)
   142                              <1> tc_P            equ     0008h   ; Prescale internal clock (timers 0 & 1 only)
   143                              <1> tc_EXT          equ     0004h   ; External clock
   144                              <1> tc_ALT          equ     0002h   ; Alternate between A & B max count registers
   145                              <1> tc_CONT         equ     0001h   ; Continuous: continue after max count
   146                              <1> 
   147                              <1> 
   148                              <1> 
   149                              <1> 
   150                              <1> ; DMA
   151                              <1> DMA0	        equ	CPU_CSCR+0C0H
   152                              <1> DMA1	        equ	CPU_CSCR+0D0H
   153                              <1> DMASPL	        equ	0	; source pointer low
   154                              <1> DMASPU	        equ	2	; source pointer high
   155                              <1> DMADPL	        equ	4	; destination pointer low
   156                              <1> DMADPU	        equ	6	; destination pointer high
   157                              <1> DMATC	        equ	8	; terminal count
   158                              <1> DMACW	        equ	0AH	; control word
   159                              <1> 
   160                              <1> 
   161                              <1> 
   162                              <1> 
   163                              <1> 
   164                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   165                              <1> ;
   166                              <1> ;       SBC-188 external devices
   167                              <1> ;
   168                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   169                              <1> 
   170                              <1> IO_BASE			equ	0400h
   171                              <1> 
   172                              <1> 
   173                              <1> 
   174                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   175                              <1> ; The UART registers (Duodyne SBC 80c188 Console port)
   176                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   177                              <1> 
   178                              <1> uart_base               equ     IO_BASE+0280h
   179                              <1> uart_rbr                equ     uart_base       ;Rcvr Buffer / read only
   180                              <1> uart_thr                equ     uart_base       ;Transmit Holding / write only
   181                              <1> uart_ier                equ     uart_base+1     ;Interrupt Enable
   182                              <1> uart_iir                equ     uart_base+2     ;Interrupt Ident / read only
   183                              <1> uart_fcr                equ     uart_base+2     ;FIFO Control / write only
   184                              <1> uart_lcr                equ     uart_base+3     ;Line Control
   185                              <1> uart_mcr                equ     uart_base+4     ;Modem Control
   186                              <1> uart_lsr                equ     uart_base+5     ;Line Status
   187                              <1> uart_msr                equ     uart_base+6     ;Modem Status
   188                              <1> uart_sr			equ	uart_base+7	;Scratch
   189                              <1> 
   190                              <1> uart_dll                equ     uart_base       ;Divisor Latch LS Byte
   191                              <1> uart_dlm                equ     uart_base+1     ;Divisor Latch MS Byte
   192                              <1> 
   193                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   194                              <1> ; CONTROL LS259 PORT  (DuoDyne 80C188)
   195                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   196                              <1> CTRL259		equ	IO_BASE+0238H
   197                              <1> ; LEDS are at addresses 0..3
   198                              <1> ; other control ports on 4..7
   199                              <1> LED0		equ	CTRL259+0
   200                              <1> LED1		equ	LED0+1
   201                              <1> LED2		equ	LED0+2
   202                              <1> LED3		equ	LED0+3
   203                              <1> T1OSC18		equ	CTRL259+4	; ON=1.8432mhz, OFF="1" (for use of TIMER2)
   204                              <1> ;unused		equ	CTRL259+5
   205                              <1> ;unused		equ	CTRL259+6
   206                              <1> ;unused		equ	CTRL259+7
   207                              <1> 
   208                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   209                              <1> ; Front Panel Connector  (DuoDyne 80C188)
   210                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   211                              <1> FRONT_PANEL_LED	equ	IO_BASE+0230H
   212                              <1> 
   213                              <1> 
   214                              <1> 
   215                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   216                              <1> ; Floppy controller (Duodyne Disk IO)
   217                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   218                              <1> FDC	        equ	IO_BASE+0200H
   219                              <1> FDC_MSR         equ     FDC
   220                              <1> FDC_DATA        equ     FDC_MSR+1
   221                              <1> FDC_DACK        equ	FDC+10H
   222                              <1> FDC_LDOR	equ	FDC+20H
   223                              <1> FDC_LDCR	equ	FDC+30H
   224                              <1> FDC_TC	        equ	FDC+40H
   225                              <1> FDC_RES	        equ	FDC+40H
   226                              <1> FDC_DACK_TC     equ     FDC_DACK | FDC_TC
   227                              <1> 
   228                              <1> 
   229                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   230                              <1> ;DS1302 RTC (Duodyne Ram/ROM Card)
   231                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   232                              <1> RTC	equ	IO_BASE+0094H
   233                              <1> 
   234                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   235                              <1> ; PIO 82C55 I/O  (Duodyne Disk IO)
   236                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   237                              <1> PPI	        equ	IO_BASE+0088H
   238                              <1> 
   239                              <1> PIO_A	        equ	PPI+0	; (OUTPUT)
   240                              <1> PIO_B	        equ	PPI+1	; (INPUT)
   241                              <1> PIO_C	        equ	PPI+2	; (CENTRONICS control low nibble)
   242                              <1> PIO_CTRL	equ	PPI+3	; CONTROL BYTE PIO 82C55
   243                              <1> 
   244                              <1> portA           equ     PPI+0   ;
   245                              <1> portB           equ     PPI+1   ;
   246                              <1> portC           equ     PPI+2   ;
   247                              <1> 
   248                              <1> ; end CPUREGS.ASM
    31                                  %include	"equates.asm"
    32                              <1> ;========================================================================
    33                              <1> ; EQUATES.ASM -- Lots of Defintions for Relocatable BIOS
    34                              <1> ;========================================================================
    35                              <1> ;   for the N8VEM SBC-188 v.00.4 and 00.5
    36                              <1> ;
    37                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    38                              <1> ;
    39                              <1> ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
    40                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    41                              <1> ;
    42                              <1> ; This program is free software: you can redistribute it and/or modify
    43                              <1> ; it under the terms of the GNU General Public License as published by
    44                              <1> ; the Free Software Foundation, either version 3 of the License, or
    45                              <1> ; (at your option) any later version.
    46                              <1> ;
    47                              <1> ; This program is distributed in the hope that it will be useful,
    48                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    49                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    50                              <1> ; GNU General Public License for more details.
    51                              <1> ;
    52                              <1> ; You should have received a copy of the GNU General Public License
    53                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    54                              <1> ;
    55                              <1> ;========================================================================
    56                              <1> 
    57                              <1>         global  FPEM_segment
    58                              <1> 
    59                              <1> 
    60                              <1> %include "segdef.asm"
    61                              <2> ;========================================================================
    62                              <2> ; SEGDEF.ASM -- Lots of Defintions for Relocatable BIOS
    63                              <2> ;========================================================================
    64                              <2> ;   for the N8VEM SBC-188 v.00.4 and 00.5
    65                              <2> ;
    66                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    67                              <2> ;
    68                              <2> ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
    69                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    70                              <2> ;
    71                              <2> ; This program is free software: you can redistribute it and/or modify
    72                              <2> ; it under the terms of the GNU General Public License as published by
    73                              <2> ; the Free Software Foundation, either version 3 of the License, or
    74                              <2> ; (at your option) any later version.
    75                              <2> ;
    76                              <2> ; This program is distributed in the hope that it will be useful,
    77                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    78                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    79                              <2> ; GNU General Public License for more details.
    80                              <2> ;
    81                              <2> ; You should have received a copy of the GNU General Public License
    82                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    83                              <2> ;
    84                              <2> ;========================================================================
    85                              <2> 
    86                              <2> %ifndef __SEGDEF_
    87                              <2> %define __SEGDEF_
    88                              <2> 
    89                              <2> 	SEGMENT  _TEXT ALIGN=2 PUBLIC CLASS=CODE
    90                              <2>         SEGMENT  CONST ALIGN=2 PUBLIC CLASS=DATA
    91                              <2>         SEGMENT  CONST2 ALIGN=2 PUBLIC CLASS=DATA
    92                              <2> 	SEGMENT  _DATA ALIGN=16 PUBLIC CLASS=DATA
    93                              <2> 	SEGMENT  _BSS  ALIGN=2 PUBLIC CLASS=BSS
    94                              <2> ;;;        SEGMENT  _BASIC ALIGN=16 PUBLIC CLASS=BASIC
    95                              <2> 
    96                              <2> 	GROUP	DGROUP CONST CONST2 _DATA _BSS
    97                              <2> 
    98                              <2> %endif
    99                              <2> 
    61                              <1> %include "ascii.asm"
    62                              <2> ; ascii.asm
    63                              <2> ;
    64                              <2> CTRL            equ     1Fh     ; masks a character to CTRL-x
    65                              <2> 
    66                              <2> NUL     equ     00h
    67                              <2> BEL     equ     (CTRL & 'G')
    68                              <2> BS      equ     08h		; ^H
    69                              <2> HT      equ     09h		; ^I
    70                              <2> LF	equ	0Ah		; ^J
    71                              <2> NL      equ     LF
    72                              <2> VT	equ	0Bh		; ^K
    73                              <2> FWD	equ	0Ch		; ^L
    74                              <2> CR	equ	0Dh
    75                              <2> XON     equ     (CTRL & 'Q')
    76                              <2> XOFF    equ     (CTRL & 'S')
    77                              <2> DC1     equ     XON
    78                              <2> DC3     equ     XOFF
    79                              <2> ESC     equ	1Bh
    80                              <2> 
    81                              <2> 
    62                              <1> 
    63                              <1> 
    64                              <1> ; POST error codes. Presently one byte but can expand to word.
    65                              <1> ER_BIOS equ	01h		; Bad ROM bios checksum, patch last byte
    66                              <1> ER_RAM	equ	02h		; Bad RAM in main memory, replace
    67                              <1> ER_CRT	equ	04h		; Bad RAM in video card, replace
    68                              <1> ER_FDC	equ	08h		; Bad FDC
    69                              <1> ER_UNK1	equ	10h		; {unassigned}
    70                              <1> ER_MEM	equ	20h		; Bad RAM in vector area, replace
    71                              <1> ER_ROM	equ	40h		; Bad ROM in expansion area, bad checksum
    72                              <1> ER_UNK2	equ	80h		; {unassigned}
    73                              <1> 
    74                              <1> 
    75                              <1> 
    76                              <1> ;; ************************ BIOS Data Segment ******************************
    77                              <1> ;; BIOS data segment - not all will  be used
    78                              <1> ;                struc   BIOS_DATA_AREA  ; at 0040:0000
    79                              <1> %include "bda.inc"
    80                              <2> ;/*======================================================================
    81                              <2> ; bda.inc -- BIOS data area definitions
    82                              <2> ;========================================================================
    83                              <2> ;   for the N8VEM SBC-188
    84                              <2> ;
    85                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    86                              <2> ;
    87                              <2> ; Copyright (C) 2013 John R. Coffman.  All rights reserved.
    88                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    89                              <2> ;
    90                              <2> ; This program is free software: you can redistribute it and/or modify
    91                              <2> ; it under the terms of the GNU General Public License as published by
    92                              <2> ; the Free Software Foundation, either version 3 of the License, or
    93                              <2> ; (at your option) any later version.
    94                              <2> ;
    95                              <2> ; This program is distributed in the hope that it will be useful,
    96                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    97                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    98                              <2> ; GNU General Public License for more details.
    99                              <2> ;
   100                              <2> ; You should have received a copy of the GNU General Public License
   101                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   102                              <2> ;
   103                              <2> ;========================================================================
   104                              <2> 
   105                              <2> 			;*/ extern				/*
   106                              <2> 	ABSOLUTE  0	;*/ struct BDA {			/*
   107 00000000 ????????????????    <2> serial_ports    resw    4	;*/	word	serial_ports[4];	/*
   108 00000008 ????????????????    <2> parallel_ports  resw    4	;*/	word	parallel_ports[4];	/*
   109 00000010 ????                <2> equipment_flag  resw    1	;*/	EQFL	equipment_flag;		/*
   110                              <2> ;	dw	?		; 40:10 	; Equipment present word
   111                              <2> ;  						;  = (1 iff floppies) *     1.
   112                              <2> ;                                               ;  + (1 iff 187     ) *     2.
   113                              <2> ;  						;  + (#+1 64K sys ram) *    4.
   114                              <2> ;  						;  + (init crt mode ) *    16.
   115                              <2> ;  						;  + (# of floppies ) *    64.
   116                              <2> ;  						;  + (# serial ports) *   512.
   117                              <2> ;  						;  + (1 iff toy port) *  4096.
   118                              <2> ;                                               ;  + (1 iff modem   ) *  8192.
   119                              <2> ;  						;  + (# parallel LPT) * 16384.
   120 00000012 ??                  <2> mfg_test_flags  resb    1	;*/	byte	mfg_test_flags;	/* 40:12 unused by us
   121 00000013 ????                <2> memory_size     resw    1	;*/	word	memory_size;	/* 40:13 kilobytes
   122                              <2> uart_kbd_ctrl_R	equ	$	;*/				/*** JRC: count of ctrl-R's for reboot
   123 00000015 ??                  <2> IPL_errors      resb    1	;*/	byte	IPL_errors;	/* 40:15 IPL errors<-table/scratchpad
   124 00000016 ??                  <2> sbc188_rev       resb    1	;*/	byte	sbc188_rev;	/* was 'unused_01' before BIOS047
   125                              <2> ;;---------------[Keyboard data area]------------;
   126 00000017 ????                <2> keyboard_flags_0 resw   1	;*/	word	keyboard_flags_0;  /* 40:17 Shift/Alt/etc. keyboard flags
   127                              <2> keyboard_flags_1 equ	$-1	;     2nd byte	keyboard_flags_1;  
   128 00000019 ??                  <2> keypad_char	resb	1	;*/	byte	keypad_char;	/* 40:19 Alt-KEYPAD char. goes here
   129 0000001A ????                <2> kbd_buffer_head resw    1	;*/	word	kbd_buffer_head;   /* 40:1A --> keyboard buffer head
   130 0000001C ????                <2> kbd_buffer_tail resw    1	;*/	word	kbd_buffer_tail;   /* 40:1C --> keyboard buffer tail
   131 0000001E <res 20h>           <2> kbd_buffer      resw    16	;*/	word	kbd_buffer[16];	/* 40:1E Keyboard Buffer (Scan,Value)
   132                              <2> kbd_buffer_last	equ	$	;*/				/*
   133                              <2> ;;---------------[Diskette data area]------------;
   134 0000003E ??                  <2> fdc_drv_calib   resb    1	;*/	byte	fdc_drive_calib;   /* 40:3E
   135 0000003F ??                  <2> fdc_motor_LDOR  resb    1	;*/	byte	fdc_motor_LDOR;	   /* 40:3F Motor, DMA, select control
   136 00000040 ??                  <2> fdc_motor_ticks resb    1	;*/	byte	fdc_motor_ticks;   /* 40:40 ticks til motor off
   137 00000041 ??                  <2> fdc_status      resb    1	;*/	byte	fdc_status;	   /* 40:41
   138                              <2> ;				Floppy return code stat byte
   139                              <2> ;				;  1 = bad ic 765 command req.
   140                              <2> ;				;  2 = address mark not found
   141                              <2> ;				;  3 = write to protected disk
   142                              <2> ;				;  4 = sector not found
   143                              <2> ;				;  8 = data late (DMA overrun)
   144                              <2> ;				;  9 = DMA failed 64K page end
   145                              <2> ;				; 16 = bad CRC on floppy read
   146                              <2> ;				; 32 = bad NEC 765 controller
   147                              <2> ;				; 64 = seek operation failed
   148                              <2> ;				;128 = disk drive timed out
   149 00000042 ??????????????      <2> fdc_ctrl_status resb    7	;*/	byte	fdc_ctrl_status[7];  /* 40:42 Status bytes from NEC 765
   150                              <2> ;;---------------[Video display area]------------;
   151 00000049 ??                  <2> video_mode      resb    1	;*/	byte	video_mode;	/* 40:49
   152                              <2> ;			 	; Current CRT mode  (software)
   153                              <2> ;				;  0 = 40 x 25 text (no color)
   154                              <2> ;				;  1 = 40 x 25 text (16 color)
   155                              <2> ;				;  2 = 80 x 25 text (no color)
   156                              <2> ;				;  3 = 80 x 25 text (16 color)
   157                              <2> ;				;  4 = 320 x 200 grafix 4 color
   158                              <2> ;				;  5 = 320 x 200 grafix 0 color
   159                              <2> ;				;  6 = 640 x 200 grafix 0 color
   160                              <2> ;				;  7 = 80 x 25 text (mono card)
   161 0000004A ????                <2> video_columns   resw    1	;*/	word video_columns;	/* 40:4A Columns on CRT screen
   162 0000004C ????                <2> video_regen_bytes  resw 1	;*/	word video_regen_bytes;	/* 40:4C Bytes in the regen region
   163 0000004E ????                <2> video_regen_offset resw 1	;*/	word video_regen_offset;/* 40:4E Byte offset in regen region
   164 00000050 <res 10h>           <2> video_cursor_pos  resw  8	;*/	word video_cursor_pos[8];  /* 40:50 Cursor pos for up to 8 pages
   165 00000060 ????                <2> video_cursor_mode resw  1	;*/	word video_cursor_mode;	/* 40:60 Current cursor mode setting
   166 00000062 ??                  <2> video_page      resb    1	;*/	byte video_page;	/* 40:62 Current page on display
   167 00000063 ????                <2> video_base_seg  resw    1	;*/	word video_base_seg;	/* 40:63 Base address (B000h or B800h)
   168 00000065 ??                  <2> video_hw_mode   resb    1	;*/	byte video_hw_mode;	/* 40:65 ic 6845 mode reg. (hardware)
   169 00000066 ??                  <2> video_cga_palette resb  1	;*/	byte video_cga_palette;	/* 40:66 Current CGA palette
   170                              <2> ;;---------------[Used to setup ROM]-------------;
   171 00000067 ????????            <2> eprom_address   resd    1	;*/	dword eprom_address;	/* 40:67 Eprom base Offset,Segment
   172 0000006B ??                  <2> spurious_irq    resb    1	;*/	byte spurious_irq;	/* 40:6B Last spurious interrupt IRQ
   173                              <2> ;;---------------[Timer data area]---------------;
   174 0000006C ????????            <2> timer_ticks     resd    1	;*/	dword timer_ticks;	/* 40:6C Ticks since midnight (lo,hi)
   175 00000070 ??                  <2> timer_new_day   resb    1	;*/	byte timer_new_day;	/* 40:70 Non-zero if new day
   176                              <2> ;;---------------[System data area]--------------;
   177 00000071 ??                  <2> break_flag      resb    1	;*/	byte break_flag;	/* 40:71 Sign bit set iff break
   178 00000072 ????                <2> warm_boot       resw    1	;*/	word warm_boot;		/* 40:72 Warm boot iff==1234h
   179                              <2> ;;---------------[Hard disk scratchpad]----------;
   180 00000074 ????????            <2> hdd_scratch     resd    1	;*/	word hdd_scratch[2];	/* 40:74
   181                              <2> ;;---------------[Timout areas/PRT/LPT]----------;
   182 00000078 ????????            <2> lpt_timeout     resb    4	;*/	byte lpt_timeout[4];	/* 40:78 Ticks for LPT 1-4 timeouts
   183 0000007C ????????            <2> com_timeout     resb    4	;*/	byte com_timeout[4];	/* 40:7C Ticks for COM 1-4 timeouts
   184                              <2> ;;---obsolete----[Keyboard buf start/end]---jrc--;
   185 00000080 ????                <2> kbd_buffer_start resw   1	;*/	word kbd_buffer_start;	/* 40:80 KBD buffer head (PC/AT)
   186 00000082 ????                <2> kbd_buffer_end  resw    1	;*/	word kbd_buffer_end;	/* 40:82 KBD buffer tail (PC/AT)
   187                              <2> ;;---------------[EGA stuff]---------------------;
   188 00000084 ??????????????      <2> EGA_stuff	resb	7	;*/	byte EGA_stuff[7];	/* 40:84 Unspecified EGA data
   189                              <2> ;;---------------[Floppy/Fixed Media Info]-------------;
   190 0000008B ??                  <2> fdc_last_rate	resb	1	;*/	byte fdc_last_rate;	/* 40:8B Last floppy step rate/data rate?
   191 0000008C ????????            <2> fx_misc_unused	resb	4	;*/	byte fx_misc_unused[4];	/* 40:8C Fixed disk miscellaneous ???
   192 00000090 ????                <2> fdc_disk_state	resb	2	;*/	byte fdc_disk_state[2];	/* 40:90 Floppy disk state
   193 00000092 ????                <2> fdc_op_start	resb	2	;*/	byte fdc_op_start[2];	/* 40:92 Floppy operation start state machine
   194 00000094 ????                <2> fdc_cylinder	resb	2	;*/	byte fdc_cylinder[2];	/* 40:94 Floppy present cylinder
   195                              <2> ;;---------------[Additional KBD flags]----------------;
   196 00000096 ??                  <2> kbd_flag_3	resb	1	;*/	byte kbd_flag_3;	/* 40:96 kbd ???
   197 00000097 ??                  <2> kbd_flag_2	resb	1	;*/	byte kbd_flag_2;	/* 40:97 kbd ???
   198                              <2> ;;---------------[RTC/timer1 data]---------------------;
   199 00000098 ????????            <2> user_semaphore	resw	2	;*/	byte *user_semaphore;	/* 40:98 User semaphore in (bit 7)
   200 0000009C ????????            <2> rtc_count	resd	1	;*/	dword rtc_count;	/* 40:9C RTC tick counter
   201 000000A0 ??                  <2> rtc_wait_active	resb	1	;*/	byte rtc_wait_active;	/* 40:A0 Busy=01, Posted=80h, 
   202                              <2> ;;---------------[Cassette I/O stuff]------------------;
   203 000000A1 ??                  <2> last_val	resb	1	;*/	byte last_val;		/* 40:A1 Last byte read value
   204 000000A2 ????                <2> crc_reg		resw	1	;*/	word crc_reg;		/* 40:A2 CRC accumulation area
   205                              <2> ;									Post Acknowleged=00;
   206 000000A4 ??                  <2> EGA_data	resb	1	;*/	byte EGA_data;		/* 40:A4 Various usage
   207 000000A5 ????                <2> SDstatus	resb	2	;*/	byte SDstatus[2];	/* 40:A5 Status byte from command
   208 000000A7 ????                <2> SDcardtype	resb	2	;*/	byte SDcardtype[2];	/* 40:A7 SDcard type SDSC=2, HC=3, ...
   209                              <2> ;
   210 000000A9 ????????            <2> fixed_disk_tab	resb	4	;*/	byte fixed_disk_tab[4];	/* dispatch table to fixed disk drivers
   211 000000AD ??                  <2> wait12_count	resb	1	;*/	byte wait12_count;	/* 40:AD 12usec CX count
   212 000000AE ??                  <2> lock_count	resb	1	;*/	byte lock_count;	/* 40:AE lock level counter
   213 000000AF ??                  <2> EMS_start       resb    1	;*/	byte EMS_start;		/* start EMS allocation from here
   214                              <2> fx80		equ	$	;*/	struct EDD_disk fx80;	/* fixed disk parameter area 0
   215 000000B0 ????                <2> fx_log_cylinders resw   1	;	word fx_log_cylinders;	 logical number of cylinders
   216 000000B2 ??                  <2> fx_log_heads    resb    1	;	byte fx_log_heads;	 logical number of heads
   217 000000B3 ??                  <2> fx_signature	resb	1	;	byte fx_signature;	 A0h signature = translated geom
   218 000000B4 ??                  <2> fx_phys_sectors	resb    1       ;	byte fx_phys_sectors;	 physical number of sectors per track
   219 000000B5 ????                <2> fx_LBA_high     resw    1       ;	word fx_LBA_high;	 high word of LBA28 number of sectors
   220 000000B7 ??                  <2> fx_reserved	resb	1	;	byte fx_reserved;	 reserved for future use
   221 000000B8 ??                  <2> fx_drive_control resb   1       ;	byte fx_drive_control;	 flag bits for IDE head register
   222 000000B9 ????                <2> fx_phys_cylinders resw	1	;	word fx_phys_cylinders;	 physical number of cylinders
   223 000000BB ??                  <2> fx_phys_heads	resb	1	;	byte fx_phys_heads;	 physical number of heads
   224 000000BC ????                <2> fx_LBA_low	resw	1	;	word fx_LBA_low;	 low word of LBA28 number of sectors
   225 000000BE ??                  <2> fx_log_sectors	resb	1	;	byte fx_log_sectors;	 logical number of sectors per track
   226 000000BF ??                  <2> fx_checksum	resb	1	;	byte fx_checksum;	 checksum, dunno how to compute
   227 000000C0 <res 10h>           <2> fx81            resb    16	;*/	struct EDD_disk fx81;	/* fixed disk parameter area 1
   228 000000D0 <res 10h>           <2> fx82            resb    16	;*/	struct EDD_disk fx82;	/* fixed disk parameter area 2
   229 000000E0 <res 10h>           <2> fx83            resb    16	;*/	struct EDD_disk fx83;	/* fixed disk parameter area 3
   230                              <2> ;
   231                              <2> ;
   232                              <2> 
   233 000000F0 ????                <2> FPEM_segment    resw    1       ;*/	word FPEM_segment;	/* FPEM data segment
   234                              <2> 
   235 000000F2 ????                <2> EBDA_paragraph  resw    1       ;*/	word EBDA_paragraph;	/* lowest EBDA paragraph
   236                              <2> 
   237 000000F4 ????                <2> dma0_cw         resw    1       ;*/	word dma0_cw;		/* end of dma control word
   238 000000F6 ????                <2> dma1_cw         resw    1       ;*/	word dma1_cw;		/*   ditto
   239                              <2> 
   240 000000F8 ????                <2> fdc_type	resb	2	;*/	byte fdc_type[2];	/* disk type in low nibble, alternate in hi nib 
   241                              <2> 
   242 000000FA ????????            <2> debug_static_ptr  resw	2	;*/	void *debug_static_ptr;	/* pointer to debug static area
   243                              <2> 
   244 000000FE ??                  <2> n_fixed_disks   resb    1       ;*/	byte n_fixed_disks;	/* number of fixed disks
   245                              <2> 
   246 000000FF ??                  <2> cpu_xtal        resb    1       ;*/	byte cpu_xtal;		/* CPU crystal frequency in Mhz 
   247                              <2> ;								   CPU clock is half of this
   248                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   249                              <2> ;
   250                              <2> ;  System configuration stuff below
   251                              <2> ;	c.f., CONFIG.ASM (ANSI.CFG, CVDU.CFG, etc.), User configuration stuff
   252                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   253                              <2> %if 0				;*/
   254                              <2> #define FIXED_DISK_MAX 4		/*
   255                              <2> %else
   256                              <2> %define FIXED_DISK_MAX 4
   257                              <2> %endif
   258                              <2> %if 0				;*/
   259                              <2> #define PPIDE_driver 1		/*
   260                              <2> %else
   261                              <2> %define PPIDE_driver 1
   262                              <2> %endif
   263                              <2> %if 0				;*/
   264                              <2> #define DIDE_driver 0		/*
   265                              <2> %else
   266                              <2> %define DIDE_driver 0
   267                              <2> %endif
   268                              <2> %if 0				;*/
   269                              <2> #define DISKIO_driver 1		/*
   270                              <2> %else
   271                              <2> %define DISKIO_driver 1
   272                              <2> %endif
   273                              <2> %if 0				;*/
   274                              <2> #define MFPIC_driver 1		/*
   275                              <2> %else
   276                              <2> %define MFPIC_driver 1
   277                              <2> %endif
   278                              <2> %if 0				;*/
   279                              <2> #define DSD_driver 1		/*
   280                              <2> %else
   281                              <2> %define DSD_driver 1
   282                              <2> %endif
   283                              <2> %if 0				;*/
   284                              <2> #define V3IDE8_driver (SBC188==3)		/*
   285                              <2> %else
   286                              <2> %define V3IDE8_driver (SBC188==3)
   287                              <2> %endif
   288                              <2> 				;*/
    80                              <1> 
    81                              <1> ;  this must be the same in EQUATES.H */
    82                              <1> %if SOFT_DEBUG
    83                              <1> %define NBREAK  8
    84                              <1> %endif
    85                              <1> 
    86                              <1> 
    87                              <1> %if 0
    88                              <1>         segment _TEXT
    89                              <1> ;; *************************************************************************
    90                              <1> 
    91                              <1> 
    92                              <1> 
    93                              <1> 
    94                              <1> ;; ************************ DOS Data Segment *******************************
    95                              <1> ;dosdir	SEGMENT at 50h				; Boot disk directory from IPL
    96                              <1> ;xerox	label	byte				;  0 if Print Screen idle
    97                              <1> ;						;  1 if PrtSc xeroxing screen
    98                              <1> ;						;255 if PrtSc error in xerox
    99                              <1> ;						;  ...non-grafix PrtSc in bios
   100                              <1> ;	db	200h dup(?)			; PC-DOS bootstrap procedure
   101                              <1> ;						;  ...IBMBIO.COM buffers the
   102                              <1> ;						;  ...directory of the boot
   103                              <1> ;						;  ...device here at IPL time
   104                              <1> ;						;  ...when locating the guts
   105                              <1> ;						;  ...of the operating system
   106                              <1> ;						;  ...filename "IBMDOS.COM"
   107                              <1> ;dosdir	ends
   108                              <1> ;; *************************************************************************
   109                              <1> ;; ************************ DOS IPL Segment ********************************
   110                              <1> ;dosseg	SEGMENT at 70h				; "Kernel" of PC-DOS op sys
   111                              <1> ;;IBMBIO.COM file loaded by boot block. Device Drivers/Bootstrap. CONTIGUOUS<---
   112                              <1> ;;IBMDOS.COM operating system nucleus immediately follows IBMBIO.COM and       !
   113                              <1> ;;     doesn`t have to be contiguous.  The IBMDOS operating system nucleus     !
   114                              <1> ;;     binary image is loaded by transient code in IBMBIO binary image	      !
   115                              <1> ;dosseg	ends					;			      !
   116                              <1> ;iplseg	SEGMENT at 0h				; Segment for boot block      !
   117                              <1> ;;The following boot block is loaded with 512 bytes on the first sector of     !
   118                              <1> ;;the bootable device by code resident in the ROM-resident bios.  Control is   !
   119                              <1> ;;then transferred to the first word 0000:7C00 of the disk-resident bootstrap  !
   120                              <1> ;	ORG	07C00h				;  ..offset for boot block    !
   121                              <1> ;boot	db	200h dup(?)			;  ..start disk resident boot--
   122                              <1> ;iplseg	ends
   123                              <1> 
   124                              <1> %endif
    32                                  
    33                                  
    34                                  offset_BP	equ	0
    35                                  offset_BX	equ	offset_BP+2
    36                                  offset_DS	equ	offset_BX+2
    37                                  offset_IP	equ	offset_DS+2
    38                                  offset_CS	equ	offset_IP+2
    39                                  offset_FLAGS	equ	offset_CS+2
    40                                  
    41                                  EOS             equ     0FFh    ; End of String
    42                                  
    43                                  MAX_ROWS	equ	24	; terminals usually have 24 rows...
    44                                  
    45                                  
    46                                  	SEGMENT _TEXT
    47                                  ;========================================================================
    48                                  ; BIOS call entry for video service functions
    49                                  ;	int  10h
    50                                  ;========================================================================
    51                                  	global  BIOS_call_10h
    52                                  BIOS_call_10h:			; Video service entry
    53                                  
    54 00000000 FB                      	sti			; Enable interrupts
    55 00000001 1E5355                  	pushm   bp,bx,ds	; Standard register save
    56 00000004 89E5                    	mov	bp,sp		; establish stack addressing
    57                                  
    58 00000006 FC                              cld                     ; do this for all functions below
    59 00000007 6A40                    	push	bios_data_seg
    60 00000009 1F                      	popm	ds		; establish addressability
    61                                  %if SOFT_DEBUG
    62                                  	push	ax
    63                                  	call	wout
    64                                  	pop	ax
    65                                  %endif
    66                                  
    67 0000000A 88E3                    	mov     bl,ah		; set to index into dispatch table
    68 0000000C 80FC14                  	cmp     ah,.max/2
    69 0000000F 7331                    	jae     exit
    70 00000011 B700                    	mov     bh,0
    71 00000013 D1E3                    	shl     bx,1		; index words
    72                                  
    73 00000015 2EFFA7[1A00]                cs	jmp     near [.dispatch+bx]
    74                                  .dispatch:
    75 0000001A [4600]                  	dw      fn00		; Set video mode
    76 0000001C [EA00]                  	dw      fn01		; Set cursor shape
    77 0000001E [0701]                  	dw      fn02		; Set cursor position
    78 00000020 [1801]                  	dw	fn03		; Get cursor position and size
    79 00000022 [4200]                  	dw	fn04		; Read light pen position
    80 00000024 [2B01]                  	dw	fn05		; Select active display page
    81 00000026 [3501]                  	dw	fn06		; Scroll up window
    82 00000028 [3501]                  	dw	fn07		; Scroll down window
    83 0000002A [A701]                  	dw	fn08		; Read character and attribute at cursor position
    84 0000002C [B401]                  	dw	fn09		; Write character and attribute at cursor position
    85 0000002E [B401]                  	dw	fn0A		; Write character only at cursor position
    86 00000030 [4200]                  	dw	fn0B		; Set background color/Set palete
    87 00000032 [4200]                  	dw	fn0C		; Write graphics pixel
    88 00000034 [4200]                  	dw	fn0D		; Read graphics pixel
    89 00000036 [0402]                  	dw	fn0E		; Teletype output
    90 00000038 [7002]                  	dw	fn0F		; Get current video mode
    91 0000003A [4200]                  	dw	fn10		; N/A
    92 0000003C [4200]                  	dw	fn11		; N/A
    93 0000003E [4200]                  	dw	fn12		; N/A
    94 00000040 [8002]                  	dw	fn13		; Write string
    95                                  .max	equ     $-.dispatch
    96                                  fn04:				; nobody uses a light pen
    97                                  fn0B:				; no overscan color emulation
    98                                  fn0C:				; no graphics
    99                                  fn0D:				; no graphics
   100                                  fn10:				; not implemented for CGA and MDA
   101                                  fn11:				; -//-
   102                                  fn12:				; -//-
   103                                  exit:
   104 00000042 5D5B1F                  	popm	bp,bx,ds
   105 00000045 CF                      	iret
   106                                  
   107                                  ;------------------------------------------------------------------------
   108                                  ;----------------[Video display area]------------;
   109                                  ;video_mode      resb    1
   110                                  ;       db      ?               ; 40:49         ; Current CRT mode  (software)
   111                                  ;                                               ;  0 = 40 x 25 text (no color)
   112                                  ;                                               ;  1 = 40 x 25 text (16 color)
   113                                  ;                                               ;  2 = 80 x 25 text (no color)
   114                                  ;                                               ;  3 = 80 x 25 text (16 color)
   115                                  ;                                               ;  4 = 320 x 200 grafix 4 color
   116                                  ;                                               ;  5 = 320 x 200 grafix 0 color
   117                                  ;                                               ;  6 = 640 x 200 grafix 0 color
   118                                  ;                                               ;  7 = 80 x 25 text (mono card)
   119                                  ;video_columns   resw    1
   120                                  ;       dw      ?               ; 40:4A         ; Columns on CRT screen
   121                                  ;video_regen_bytes  resw 1
   122                                  ;       dw      ?               ; 40:4C         ; Bytes in the regen region
   123                                  ;video_regen_offset resw 1
   124                                  ;       dw      ?               ; 40:4E         ; Byte offset in regen region
   125                                  ;video_cursor_pos  resw  8
   126                                  ;       dw      8 dup(?)        ; 40:50         ; Cursor pos for up to 8 pages
   127                                  ;video_cursor_mode resw  1
   128                                  ;       dw      ?               ; 40:60         ; Current cursor mode setting
   129                                  ;video_page      resb    1
   130                                  ;       db      ?               ; 40:62         ; Current page on display
   131                                  ;video_base_seg  resw    1
   132                                  ;       dw      ?               ; 40:63         ; Base addres (B000h or B800h)
   133                                  ;video_hw_mode   resb    1
   134                                  ;       db      ?               ; 40:65         ; ic 6845 mode reg. (hardware)
   135                                  ;video_cga_palette resb  1
   136                                  
   137                                  
   138                                  ;========================================================================
   139                                  ; Function 00h - Set video mode
   140                                  ; Input:
   141                                  ;	AH = 00h
   142                                  ;	AL = desired video mode
   143                                  ; Output:
   144                                  ;	none
   145                                  ; XXX:
   146                                  ;	reimplement using a table?
   147                                  ;========================================================================
   148                                  fn00:
   149 00000046 065756525150            	pushm	ax,cx,dx,si,di,es
   150 0000004C 88C4                    	mov	ah,al		; save AL to AH
   151 0000004E 241F                    	and	al,1Fh		; limit modes to 0..1F
   152 00000050 3C00                    	cmp	al,0		; 0 = 40 x 25 text (no color)
   153 00000052 750C                    	jne	.1
   154 00000054 B328                    	mov	bl,40		; 40 columns
   155 00000056 B72C                    	mov	bh,2Ch		; hw mode - 40 columns, monochrome
   156 00000058 BE0008                  	mov	si,0800h	; page size = 2048 bytes
   157 0000005B BAD403                  	mov	dx,03D4h	; color CRT base address
   158 0000005E EB3E                    	jmp	.set_mode
   159                                  .1:
   160 00000060 3C01                    	cmp	al,01		; 1 = 40 x 25 text (16 color)
   161 00000062 750C                    	jne	.2
   162 00000064 B328                    	mov	bl,40		; 40 columns
   163 00000066 B728                    	mov	bh,28h		; hw mode - 40 columns, color
   164 00000068 BE0008                  	mov	si,0800h	; page size = 2048 bytes
   165 0000006B BAD403                  	mov	dx,03D4h	; color CRT base address
   166 0000006E EB2E                    	jmp	.set_mode
   167                                  .2:
   168 00000070 3C02                    	cmp	al,02		; 2 = 80 x 25 text (no color)
   169 00000072 750C                    	jne	.3
   170 00000074 B350                    	mov	bl,80		; 80 columns
   171 00000076 B72D                    	mov	bh,2Dh		; hw mode - 80 columns, monochrome
   172 00000078 BE0010                  	mov	si,1000h	; page size = 4096 bytes
   173 0000007B BAD403                  	mov	dx,03D4h	; color CRT base address
   174 0000007E EB1E                    	jmp	.set_mode
   175                                  .3:
   176 00000080 3C03                    	cmp	al,03		; 3 = 80 x 25 text (16 color)
   177 00000082 750C                    	jne	.4
   178 00000084 B350                    	mov	bl,80		; 80 columns
   179 00000086 B729                    	mov	bh,29h		; hw mode - 80 columns, color
   180 00000088 BE0010                  	mov	si,1000h	; page size = 4096 bytes
   181 0000008B BAD403                  	mov	dx,03D4h	; color CRT base address
   182 0000008E EB0E                    	jmp	.set_mode
   183                                  .4:
   184 00000090 3C07                    	cmp	al,07		; 7 = 80 x 25 text (mono card)
   185 00000092 754D                    	jne	.exit
   186 00000094 B350                    	mov	bl,80		; 80 columns
   187 00000096 B72D                    	mov	bh,2Dh		; hw mode - 80 columns, monochrome
   188 00000098 BE0010                  	mov	si,1000h	; page size = 4096 bytes
   189 0000009B BAB403                  	mov	dx,03B4h	; monochrome CRT base address
   190                                  
   191                                  .set_mode:
   192 0000009E A24900                  	mov	byte [video_mode],al
   193 000000A1 B000                    	mov	al,0
   194 000000A3 A26600                  	mov	[video_cga_palette],al		; clear location
   195                                  				; video_cga_palette = 0
   196                                  ;;	cld			; clear video part of BIOS data area
   197 000000A6 BF4A00                  	mov	di,video_mode+1
   198 000000A9 B91C00                  	mov	cx,video_cga_palette-video_mode-1
   199 000000AC 1E                      	pushm	ds
   200 000000AD 07                      	popm	es
   201 000000AE F3AA                        rep	stosb
   202                                  				; video_page = 0
   203                                  				; video_regen_offset = 0
   204                                  				; video_cursor_pos[0..7] = 0
   205                                  
   206 000000B0 883E6500                	mov	byte [video_hw_mode],bh
   207 000000B4 B700                    	mov	bh,0
   208 000000B6 891E4A00                	mov	word [video_columns],bx
   209 000000BA 89364C00                	mov	word [video_regen_bytes],si
   210 000000BE 89166300                	mov	word [video_base_seg],dx
   211 000000C2 B90706                  	mov	cx,0607h	; cursor start line 6, cursor end line - 7
   212 000000C5 890E6000                	mov	word [video_cursor_mode],cx
   213                                  
   214 000000C9 B307                    	mov	bl,07h		; set default attributes to 07h
   215 000000CB E87303                  	call	set_attributes
   216                                  %if SOFT_DEBUG
   217                                  	push	0x11
   218                                  	call	lites
   219                                  %endif
   220                                  
   221 000000CE F6C480                  	test	ah,80h		; if bit 7 of original AL set, don't clear
   222 000000D1 7503                    	jnz	.dont_clear
   223 000000D3 E85603                  	call	clear_screen
   224                                  %if SOFT_DEBUG
   225                                  	push	0x13
   226                                  	call	lites
   227                                  %endif
   228                                  
   229                                  
   230                                  .dont_clear:
   231 000000D6 31D2                    	xor	dx,dx		; set cursor to 1,1
   232 000000D8 E8DE02                  	call	cursor_set_pos
   233 000000DB E82D03                  	call	cursor_show
   234 000000DE E8ED02                  	call	auto_wrap_off
   235                                  
   236                                  .exit:
   237 000000E1 58595A5E5F07            	popm	ax,cx,dx,si,di,es
   238 000000E7 E958FF                  	jmp	exit
   239                                  
   240                                  ;========================================================================
   241                                  ; Function 01h - Set cursor shape
   242                                  ; Input:
   243                                  ;	AH = 01h
   244                                  ;	CH = cursor start and options
   245                                  ;		bit 7    = 0
   246                                  ;		bits 6,5 = 00 normal, other invisible
   247                                  ;		bits 4-0 = topmost scan line
   248                                  ;	CL = (bits 4-0) bottom scan line containing cursor
   249                                  ; Output:
   250                                  ;	none
   251                                  ;========================================================================
   252                                  fn01:
   253 000000EA 51                      	push	cx
   254 000000EB 890E6000                	mov	word [video_cursor_mode],cx
   255 000000EF F6C560                  	test	ch,60h
   256 000000F2 750C                    	jnz	.hide		; hide cursor
   257 000000F4 80E5E0                  	and	ch,0E0h
   258 000000F7 38CD                    	cmp	ch,cl
   259 000000F9 7705                    	ja	.hide		; hide cursor
   260 000000FB E80D03                  	call	cursor_show	; show cursor
   261 000000FE EB03                    	jmp	.exit
   262                                  
   263                                  .hide:
   264 00000100 E8E702                  	call	cursor_hide
   265                                  
   266                                  .exit:
   267 00000103 59                      	pop	cx
   268 00000104 E93BFF                  	jmp	exit
   269                                  
   270                                  ;========================================================================
   271                                  ; Function 02h - Set cursor position
   272                                  ; Input:
   273                                  ;	AH = 02h
   274                                  ;	BH = page number (0-based)
   275                                  ;	DH = row (0-based)
   276                                  ;	DL = column (0-based)
   277                                  ; Output:
   278                                  ;	none
   279                                  ;========================================================================
   280                                  fn02:
   281 00000107 52                      	push	dx
   282 00000108 88FB                    	mov	bl,bh
   283 0000010A B700                    	mov	bh,0
   284 0000010C D1E3                    	shl	bx,1
   285                                  %if !DUMB
   286 0000010E 895750                  	mov	word [video_cursor_pos+bx],dx
   287                                  %endif
   288 00000111 E8A502                  	call	cursor_set_pos
   289 00000114 5A                      	pop	dx
   290 00000115 E92AFF                  	jmp	exit
   291                                  
   292                                  ;========================================================================
   293                                  ; Function 03h - Get cursor position and size
   294                                  ; Input:
   295                                  ;	AH = 03h
   296                                  ;	BH = page number (0-based)
   297                                  ; Output:
   298                                  ;	CH = cursor starting scan-line
   299                                  ;	CL = cursor ending scan-line
   300                                  ;	DH = current row (0-based)
   301                                  ;	DL = current column (0-based)
   302                                  ;========================================================================
   303                                  fn03:
   304 00000118 8B5E02                  	mov	bx,word [offset_BX+bp]
   305 0000011B 88FB                    	mov	bl,bh
   306 0000011D B700                    	mov	bh,0
   307 0000011F D1E3                    	shl	bx,1
   308 00000121 8B5750                  	mov	dx,word [video_cursor_pos+bx]
   309 00000124 8B0E6000                	mov	cx,word [video_cursor_mode]
   310 00000128 E917FF                  	jmp	exit
   311                                  
   312                                  ;========================================================================
   313                                  ; Function 05h - Select active display page
   314                                  ; Input:
   315                                  ;	AH = 05h
   316                                  ;	AL = page number (0-based)
   317                                  ; Output:
   318                                  ;	none
   319                                  ;========================================================================
   320                                  fn05:
   321 0000012B 50                      	push	ax
   322 0000012C 2407                    	and	al,7			; allow 8 pages
   323 0000012E A26200                  	mov	byte [video_page],al
   324 00000131 58                      	pop	ax
   325 00000132 E90DFF                  	jmp	exit
   326                                  
   327                                  ;========================================================================
   328                                  ; Function 06h - Scroll up window
   329                                  ; Function 07h - Scroll down window
   330                                  ; Input:
   331                                  ;	AH = 06h/07h
   332                                  ;	AL = number of lines to scroll in (0=blank entire rectangle)
   333                                  ;	BH = video attribute to be used on blank line(s)
   334                                  ;	CH,CL = row,column of upper-left corner of rectangle to scroll
   335                                  ;	DH,DL = row,column of lower-right corner of rectangle to scroll
   336                                  ; Notes:
   337                                  ;	Due to ANSI limitations column values are ignored
   338                                  ;========================================================================
   339                                  fn06:
   340                                  fn07:
   341                                  
   342                                  %if	ANSI
   343 00000135 525150                  	pushm	ax,cx,dx
   344 00000138 8B5E02                  	mov	bx,word [offset_BX+bp]
   345 0000013B 88FB                    	mov	bl,bh
   346 0000013D E80103                  	call	set_attributes
   347                                  
   348 00000140 08C0                    	or	al,al
   349 00000142 7506                    	jnz	.scroll
   350 00000144 88F0                    	mov	al,dh	; AL = 0 - blank rectangle
   351 00000146 28E8                    	sub	al,ch
   352 00000148 FEC0                    	inc	al
   353                                  
   354                                  .scroll:
   355 0000014A 88F2                    	mov	dl,dh		; DL = lower row
   356 0000014C 88EE                    	mov	dh,ch		; DH = upper row
   357 0000014E 89C1                    	mov	cx,ax		; save AX in CX
   358 00000150 B01B                    	mov	al,ESC		; set scroll region ESC[<row_up>;<row_down]r
   359 00000152 E8D203                  	call	uart_out
   360 00000155 B05B                    	mov	al,'['
   361 00000157 E8CD03                  	call	uart_out
   362 0000015A E82702                  	call	coords_out
   363 0000015D B072                    	mov	al,'r'
   364 0000015F E8C503                  	call	uart_out
   365                                  
   366 00000162 B01B                    	mov	al,ESC		; use ESC[<num_rows>S or ESC[<num_rows>T
   367 00000164 E8C003                  	call	uart_out	; to scroll the region up or down
   368 00000167 B05B                    	mov	al,'['
   369 00000169 E8BB03                  	call	uart_out
   370                                  
   371 0000016C BA0A30                  	mov	dx,300Ah	; '0' to DH - used for ASCII conversion
   372                                  				; 10 to DL for 10-base conversion
   373 0000016F 88C8                    	mov	al,cl		; convert to ASCII and output row number
   374 00000171 B400                    	mov	ah,0
   375 00000173 F6F2                    	div	dl
   376 00000175 00F0                    	add	al,dh		; al + '0' - convert to ASCII
   377 00000177 E8AD03                  	call	uart_out
   378 0000017A 88E0                    	mov	al,ah
   379 0000017C 00F0                    	add	al,dh		; al + '0' - convert to ASCII
   380 0000017E E8A603                  	call	uart_out
   381                                  
   382 00000181 80FD07                  	cmp	ch,07h
   383 00000184 7407                    	je	.scroll_down
   384 00000186 B053                    	mov	al,'S'
   385 00000188 E89C03                  	call	uart_out	; scroll up
   386 0000018B EB05                    	jmp	.reset_scroll
   387                                  
   388                                  .scroll_down:
   389 0000018D B054                    	mov	al,'T'
   390 0000018F E89503                  	call	uart_out	; scroll down
   391                                  
   392                                  .reset_scroll:
   393 00000192 B01B                    	mov	al,ESC
   394 00000194 E89003                  	call	uart_out
   395 00000197 B05B                    	mov	al,'['
   396 00000199 E88B03                  	call	uart_out
   397 0000019C B072                    	mov	al,'r'
   398 0000019E E88603                  	call	uart_out
   399                                  .exit:
   400 000001A1 58595A                  	popm	ax,cx,dx
   401 000001A4 E99BFE                  	jmp	exit
   402                                   %endif
   403                                  ;========================================================================
   404                                  ; Function 08h - Read character and attribute at cursor position
   405                                  ; Input:
   406                                  ;	AH = 08h
   407                                  ;	BH = page number (0-based)
   408                                  ; Output:
   409                                  ;	AL = character read
   410                                  ;	BH = video attribute
   411                                  ; Notes:
   412                                  ;	Impossible to emulate, returns AL = 20h, BH = 07h
   413                                  ;========================================================================
   414                                  fn08:
   415 000001A7 B020                    	mov	al,20h
   416 000001A9 8B5E02                  	mov	bx,word [offset_BX+bp]
   417 000001AC B707                    	mov	bh,07h
   418 000001AE 895E02                  	mov	word [offset_BX+bp],bx
   419 000001B1 E98EFE                  	jmp	exit
   420                                  
   421                                  ;========================================================================
   422                                  ; Function 09h - Write character and attribute at cursor position
   423                                  ; Function 0Ah - Write character only at cursor position
   424                                  ; Input:
   425                                  ;	AH = 09h/0Ah
   426                                  ;	AL = character to write
   427                                  ;	BH = page number (0-based)
   428                                  ;	BL = video attribute (AH = 09h only)
   429                                  ;	CX = repeat count
   430                                  ; Output:
   431                                  ;	none
   432                                  ;========================================================================
   433                                  fn09:
   434                                  fn0A:
   435                                  %if UART
   436 000001B4 525150                  	pushm	ax,cx,dx
   437 000001B7 3C20                    	cmp	al,20h
   438 000001B9 7243                    	jb	.exit		; non-printable character
   439 000001BB 3C7F                    	cmp	al,7Fh
   440 000001BD 743F                    	je	.exit		; non-printable character
   441 000001BF 8B5E02                      	mov	bx,word [offset_BX+bp]
   442 000001C2 80FC0A                  	cmp	ah,0Ah
   443 000001C5 7403                    	je	.no_attributes
   444 000001C7 E87702                  	call	set_attributes
   445                                  .no_attributes:
   446 000001CA 88FB                    	mov	bl,bh
   447 000001CC B700                    	mov	bh,0
   448 000001CE D1E3                    	shl	bx,1
   449 000001D0 8B5750                  	mov	dx,word [video_cursor_pos+bx]
   450                                  
   451                                  .loop:
   452 000001D3 E85103                  	call	uart_out
   453                                  
   454 000001D6 FEC2                    	inc	dl		; increment column
   455 000001D8 3A164A00                	cmp	dl,byte [video_columns]
   456 000001DC 7304                    	jae	.next_line
   457 000001DE E2F3                    	loop	.loop
   458 000001E0 EB0E                    	jmp	.exit_loop
   459                                  
   460                                  .next_line:
   461 000001E2 B200                    	mov	dl,0
   462 000001E4 FEC6                    	inc	dh		; increment row
   463 000001E6 80FE18                  	cmp	dh,MAX_ROWS	; on the last row? (assume 25 rows)
   464 000001E9 7305                    	jae	.exit_loop
   465 000001EB E8CB01                  	call	cursor_set_pos
   466 000001EE E2E3                    	loop	.loop
   467                                  
   468                                  .exit_loop:
   469 000001F0 8A1E6200                	mov	bl,byte [video_page]
   470 000001F4 B700                    	mov	bh,0
   471 000001F6 D1E3                    	shl	bx,1
   472                                  %if !DUMB
   473 000001F8 8B5750                  	mov	dx,word [video_cursor_pos+bx]
   474                                  %endif
   475 000001FB E8BB01                  	call	cursor_set_pos
   476                                  .exit:
   477 000001FE 58595A                  	popm	ax,cx,dx
   478                                  %endif
   479 00000201 E93EFE                  	jmp	exit
   480                                  
   481                                  ;========================================================================
   482                                  ; Function 0Eh - Teletype output
   483                                  ; Input:
   484                                  ;	AH = 0Eh
   485                                  ;	AL = character to write
   486                                  ;	BH = page number (0-based)
   487                                  ;	BL = foreground color (graphics modes only, ignored)
   488                                  ; Output:
   489                                  ;	none
   490                                  ;========================================================================
   491                                  fn0E:
   492 00000204 5250                    	pushm	ax,dx		; preserve AX, too
   493 00000206 8B5E02                  	mov	bx,word [offset_BX+bp]
   494 00000209 88FB                    	mov	bl,bh
   495 0000020B B700                    	mov	bh,0
   496 0000020D D1E3                    	shl	bx,1
   497 0000020F 8B5750                  	mov	dx,word [video_cursor_pos+bx]
   498                                  %if UART
   499 00000212 3C07                    	cmp	al,07h
   500 00000214 7434                    	je	.bell		; BEL code
   501 00000216 3C08                    	cmp	al,08h
   502 00000218 7435                    	je	.bs		; BS code
   503 0000021A 3C0A                    	cmp	al,0Ah
   504 0000021C 743C                    	je	.lf		; Line feed code
   505 0000021E 3C0D                    	cmp	al,0Dh
   506 00000220 7444                    	je	.cr		; Carriage return
   507 00000222 3C20                    	cmp	al,20h
   508 00000224 7245                    	jb	.exit		; some other control character - ignore
   509 00000226 3C7F                    	cmp	al,7Fh
   510 00000228 7441                    	je	.exit		; DEL code - ignore
   511                                  
   512 0000022A E8FA02                  	call	uart_out	; we've got a regular character
   513 0000022D FEC2                    	inc	dl		; move cursor to the next column
   514 0000022F 3A164A00                	cmp	dl,byte [video_columns]
   515 00000233 7236                    	jb	.exit
   516                                  
   517 00000235 B00D                    	mov	al,0Dh
   518 00000237 E8ED02                  	call	uart_out
   519 0000023A B00A                    	mov	al,0Ah
   520 0000023C E8E802                  	call	uart_out
   521 0000023F B200                    	mov	dl,0		; set cursor to the beggining of the next line
   522 00000241 80FE18                  	cmp	dh,MAX_ROWS
   523 00000244 7325                    	jae	.exit		; already on 25th row, no need to move further
   524 00000246 FEC6                    	inc	dh		; move cursor to the next line
   525 00000248 EB21                    	jmp	.exit
   526                                  
   527                                  .bell:
   528 0000024A E8DA02                  	call	uart_out	; just output it
   529 0000024D EB1C                    	jmp 	.exit		; no need to change cursor position
   530                                  
   531                                  .bs:
   532 0000024F 08D2                    	or	dl,dl		; already on the first column?
   533 00000251 7418                    	jz	.exit
   534 00000253 E8D102                  	call	uart_out
   535 00000256 FECA                    	dec	dl		; move cursor to the previous column
   536 00000258 EB11                    	jmp	.exit
   537                                  
   538                                  .lf:
   539 0000025A E8CA02                  	call	uart_out
   540 0000025D 80FE18                  	cmp	dh,24		; assume 25 rows
   541 00000260 7309                    	jae	.exit
   542 00000262 FEC6                    	inc	dh
   543 00000264 EB05                    	jmp	.exit
   544                                  
   545                                  .cr:
   546 00000266 E8BE02                  	call	uart_out
   547 00000269 B200                    	mov	dl,0		; set cursor to the first column
   548                                  
   549                                  .exit:
   550                                  %endif
   551 0000026B 585A                    	popm	ax,dx		; restore AX also
   552 0000026D E9D2FD                  	jmp	exit
   553                                  
   554                                  ;========================================================================
   555                                  ; Function 0Fh - Get current video mode
   556                                  ; Input:
   557                                  ;	AH = 0Fh
   558                                  ; Output:
   559                                  ;	AH = number of character columns
   560                                  ;	AL = video mode
   561                                  ;	BH = active page
   562                                  ;========================================================================
   563                                  fn0F:
   564 00000270 A06200                  	mov	al,byte [video_page]
   565 00000273 884603                  	mov	byte [bp+offset_BX+1],al	; set BH for return
   566 00000276 8A264A00                	mov	ah,byte [video_columns]		; set AH
   567 0000027A A04900                  	mov	al,byte [video_mode]		; set AL
   568 0000027D E9C2FD                  	jmp	exit
   569                                  
   570                                  ;========================================================================
   571                                  ; Function 13h - Write string
   572                                  ; Input:
   573                                  ;	AH = 13h
   574                                  ;	AL = 00h - use video attribute in BL, don't move cursor
   575                                  ;	AL = 01h - use video attribute in BL, update cursor
   576                                  ;		BL = video attribute
   577                                  ;	AL = 02h - use video attribute from string, don't move cursor
   578                                  ;	AL = 03h - use video attribute from string, update cursor
   579                                  ;	BH = page number (0-based)
   580                                  ;	CX = length of the string
   581                                  ;	DH = row (0-based)
   582                                  ;	DL = column (0-based)
   583                                  ;	ES:BP = pointer to the string
   584                                  ; Output:
   585                                  ;	none
   586                                  ; XXX:
   587                                  ;	When printing the last character on the screen cursor will be moved
   588                                  ;	to the first column of the last line
   589                                  ;========================================================================
   590                                  fn13:
   591 00000280 5251                    	pushm	cx,dx
   592 00000282 5550                    	pushm	ax,bp
   593 00000284 8B6E00                  	mov	bp,word [offset_BP+bp]
   594 00000287 E82F01                  	call	cursor_set_pos
   595 0000028A A802                    	test	al,02h
   596 0000028C 756D                    	jnz	fn13_2		; read attribute from the string implementation
   597 0000028E E8B001                  	call	set_attributes
   598                                  .loop:
   599 00000291 268A4600                    es	mov	al,byte [bp]
   600 00000295 45                      	inc	bp
   601 00000296 3C07                    	cmp	al,07h
   602 00000298 743B                    	je	.bell
   603 0000029A 3C0A                    	cmp	al,0Ah
   604 0000029C 743F                    	je	.lf
   605 0000029E 3C0D                    	cmp	al,0Dh
   606 000002A0 744C                    	je	.cr
   607 000002A2 3C20                    	cmp	al,20h
   608 000002A4 7251                    	jb	.next		; control character
   609 000002A6 3C7F                    	cmp	al,7Fh
   610 000002A8 744D                    	je	.next		; DEL
   611                                  
   612 000002AA E87A02                  	call	uart_out
   613                                  
   614 000002AD FEC2                    	inc	dl		; increment column
   615 000002AF 3A164A00                	cmp	dl,byte [video_columns]
   616 000002B3 7305                    	jae	.next_line
   617 000002B5 E2DA                    	loop	.loop
   618 000002B7 E9AB00                  	jmp	fn13_exit
   619                                  
   620                                  .next_line:
   621 000002BA B200                    	mov	dl,0
   622 000002BC FEC6                    	inc	dh		; increment row
   623 000002BE 80FE18                  	cmp	dh,MAX_ROWS
   624 000002C1 7203E99F00              	jae	fn13_exit
   625 000002C6 B00D                    	mov	al,0Dh
   626 000002C8 E85C02                  	call	uart_out
   627 000002CB B00A                    	mov	al,0Ah
   628 000002CD E85702                  	call	uart_out
   629 000002D0 E2BF                    	loop	.loop
   630 000002D2 E99000                  	jmp	fn13_exit
   631                                  
   632                                  .bell:
   633 000002D5 E84F02                  	call	uart_out
   634 000002D8 E2B7                    	loop	.loop
   635 000002DA E98800                  	jmp	fn13_exit
   636                                  
   637                                  .lf:
   638 000002DD 80FE18                  	cmp	dh,24
   639 000002E0 7203E98000              	jae	fn13_exit
   640 000002E5 FEC6                    	inc	dh
   641 000002E7 E83D02                  	call	uart_out
   642 000002EA E2A5                    	loop	.loop
   643 000002EC EB77                    	jmp	fn13_exit
   644                                  
   645                                  .cr:
   646 000002EE B200                    	mov	dl,0
   647 000002F0 E83402                  	call	uart_out
   648 000002F3 E29C                    	loop	.loop
   649 000002F5 EB6E                    	jmp	fn13_exit
   650                                  
   651                                  .next:
   652 000002F7 E298                    	loop	.loop
   653 000002F9 EB6A                    	jmp	fn13_exit
   654                                  
   655                                  fn13_2:
   656 000002FB 8A3E4A00                	mov	bh,byte [video_columns]
   657                                  .loop:
   658 000002FF 268A4600                    es	mov	al,byte [bp]
   659 00000303 45                      	inc	bp
   660 00000304 3C07                    	cmp	al,07h
   661 00000306 743C                    	je	.bell
   662 00000308 3C0A                    	cmp	al,0Ah
   663 0000030A 743F                    	je	.lf
   664 0000030C 3C0D                    	cmp	al,0Dh
   665 0000030E 7449                    	je	.cr
   666 00000310 3C20                    	cmp	al,20h
   667 00000312 724E                    	jb	.next		; control character
   668 00000314 3C7F                    	cmp	al,7Fh
   669 00000316 744A                    	je	.next		; DEL
   670                                  
   671 00000318 268A5E00                    es	mov	bl,byte [bp]
   672 0000031C 45                      	inc	bp
   673 0000031D E82101                  	call	set_attributes
   674                                  
   675 00000320 E80402                  	call	uart_out
   676                                  
   677 00000323 FEC2                    	inc	dl		; increment column
   678 00000325 38FA                    	cmp	dl,bh		; bh = video columns
   679 00000327 7304                    	jae	.next_line
   680 00000329 E2D4                    	loop	.loop
   681 0000032B EB38                    	jmp	fn13_exit
   682                                  
   683                                  .next_line:
   684 0000032D B200                    	mov	dl,0
   685 0000032F FEC6                    	inc	dh		; increment row
   686 00000331 80FE18                  	cmp	dh,MAX_ROWS
   687 00000334 732F                    	jae	fn13_exit
   688                                  ;	call	cursor_set_pos
   689 00000336 B00D                    	mov	al,0Dh
   690 00000338 E8EC01                  	call	uart_out
   691 0000033B B00A                    	mov	al,0Ah
   692 0000033D E8E701                  	call	uart_out
   693 00000340 E2BD                    	loop	.loop
   694 00000342 EB21                    	jmp	fn13_exit
   695                                  
   696                                  .bell:
   697 00000344 E8E001                  	call	uart_out
   698 00000347 E2B6                    	loop	.loop
   699 00000349 EB1A                    	jmp	fn13_exit
   700                                  
   701                                  .lf:
   702 0000034B 80FE18                  	cmp	dh,24
   703 0000034E 7315                    	jae	fn13_exit
   704 00000350 FEC6                    	inc	dh
   705 00000352 E8D201                  	call	uart_out
   706 00000355 E2A8                    	loop	.loop
   707 00000357 EB0C                    	jmp	fn13_exit
   708                                  
   709                                  .cr:
   710 00000359 B200                    	mov	dl,0
   711 0000035B E8C901                  	call	uart_out
   712 0000035E E29F                    	loop	.loop
   713 00000360 EB03                    	jmp	fn13_exit
   714                                  
   715                                  .next:
   716 00000362 45                      	inc	bp		; skip the attribute
   717 00000363 E29A                    	loop	.loop
   718                                  
   719                                  fn13_exit:
   720 00000365 585D                    	popm	ax,bp
   721 00000367 8B5E02                  	mov	bx,word [offset_BX+bp]
   722 0000036A 88FB                    	mov	bl,bh
   723 0000036C B700                    	mov	bh,0
   724 0000036E D1E3                    	shl	bx,1		; bx = page number * 2
   725 00000370 A801                    	test	al,01h		; AL, bit 0 = 1 - update cursor
   726 00000372 7508                    	jne	.update_cursor
   727 00000374 8B5750                  	mov	dx,word [video_cursor_pos+bx]
   728 00000377 E83F00                  	call	cursor_set_pos
   729 0000037A EB03                    	jmp	.exit
   730                                  
   731                                  .update_cursor:
   732 0000037C 895750                  	mov	word [video_cursor_pos+bx],dx
   733                                  
   734                                  .exit:
   735 0000037F 595A                    	popm	cx,dx
   736 00000381 E9BEFC                  	jmp	exit
   737                                  
   738                                  ;========================================================================
   739                                  ; coords_out - Output coordinates in ANSI format X;Y
   740                                  ; Input:
   741                                  ;	DH = X coordinate
   742                                  ;	DL = Y coordinate
   743                                  ; Output:
   744                                  ;	AX is trashed
   745                                  ;	none
   746                                  ;========================================================================
   747                                  coords_out:
   748                                  %if	ANSI
   749 00000384 5251                    	pushm	cx,dx
   750 00000386 81C20101                	add	dx,0101h
   751 0000038A B90A30                  	mov	cx,300Ah	; '0' to CH - used for ASCII conversion
   752                                  				; 10 to CL for 10-base conversion
   753 0000038D 88F0                    	mov	al,dh		; convert to ASCII and output row number
   754 0000038F B400                    	mov	ah,0
   755 00000391 F6F1                    	div	cl
   756 00000393 00E8                    	add	al,ch		; al + '0' - convert to ASCII
   757 00000395 E88F01                  	call	uart_out
   758 00000398 88E0                    	mov	al,ah
   759 0000039A 00E8                    	add	al,ch		; al + '0' - convert to ASCII
   760 0000039C E88801                  	call	uart_out
   761                                  
   762 0000039F B03B                    	mov	al,';'		; output ';' delimiter
   763 000003A1 E88301                  	call	uart_out
   764                                  
   765 000003A4 88D0                    	mov	al,dl		; convert to ASCII and output column number
   766 000003A6 B400                    	mov	ah,0
   767 000003A8 F6F1                    	div	cl
   768 000003AA 00E8                    	add	al,ch		; al + '0' - convert to ASCII
   769 000003AC E87801                  	call	uart_out
   770 000003AF 88E0                    	mov	al,ah
   771 000003B1 00E8                    	add	al,ch		; al + '0' - convert to ASCII
   772 000003B3 E87101                  	call	uart_out
   773 000003B6 595A                    	popm	cx,dx
   774                                  %endif	; ANSI
   775 000003B8 C3                      	ret
   776                                  
   777                                  ;========================================================================
   778                                  ; cursor_set_pos - move cursor to specified position
   779                                  ; Input:
   780                                  ;	DH = row (0-based)
   781                                  ;	DL = column (0-based)
   782                                  ; Output:
   783                                  ;	none
   784                                  ; Notes:
   785                                  ;	Uses ESC[<row>;<column>H ANSI sequence, row and column are 0-based
   786                                  ;========================================================================
   787                                  cursor_set_pos:
   788                                  %if	ANSI
   789 000003B9 50                      	push	ax
   790 000003BA B01B                    	mov	al,ESC		; output CSI sequence
   791 000003BC E86801                  	call	uart_out
   792 000003BF B05B                    	mov	al,'['
   793 000003C1 E86301                  	call	uart_out
   794 000003C4 E8BDFF                  	call	coords_out
   795 000003C7 B048                    	mov	al,'H'		; output 'H' command
   796 000003C9 E85B01                  	call	uart_out
   797 000003CC 58                      	pop	ax
   798                                  %elif	DUMB
   799                                  ; setting the cursor position back on the same line can be done
   800                                  ; by emitting the correct number of BS (backspace) characters
   801                                  	xchg	dx,[video_cursor_pos + 0]	; page 0 always
   802                                  	sub	dl,[video_cursor_pos]		; - delta
   803                                  	jz	.5
   804                                  	mov	ax,0x0100+FWD		; forward space is ^L
   805                                  	js	.1
   806                                  	mov	ax,0xFF00+BS		;
   807                                  .1:	call	uart_out
   808                                  	add	dl,ah
   809                                  	jnz	.1
   810                                  
   811                                  .5:	sub	dh,[video_cursor_pos+1]
   812                                  	jz	.9
   813                                  	mov	ax,0x0100+LF		;line feed (down)
   814                                  	js	.7
   815                                  	mov	ax,0xFF00+VT		;line feed (up)
   816                                  .7:	call	uart_out
   817                                  	add	dh,ah
   818                                  	jnz	.7
   819                                  .9:
   820                                  %endif	; ANSI
   821 000003CD C3                      	ret
   822                                  
   823                                  ;========================================================================
   824                                  ; auto_wrap_off - disable auto wraparound mode
   825                                  ; Input:
   826                                  ;	none
   827                                  ; Output:
   828                                  ;	none
   829                                  ; Notes:
   830                                  ;	Uses ESC[?7l ANSI sequence
   831                                  ;========================================================================
   832                                  auto_wrap_off:
   833                                  %if	ANSI
   834 000003CE 50                      	push	ax
   835 000003CF B01B                    	mov	al,ESC
   836 000003D1 E85301                  	call	uart_out
   837 000003D4 B05B                    	mov	al,'['
   838 000003D6 E84E01                  	call	uart_out
   839 000003D9 B03F                    	mov	al,'?'
   840 000003DB E84901                  	call	uart_out
   841 000003DE B037                    	mov	al,'7'
   842 000003E0 E84401                  	call	uart_out
   843 000003E3 B06C                    	mov	al,'l'
   844 000003E5 E83F01                  	call	uart_out
   845 000003E8 58                      	pop	ax
   846                                  %endif	; ANSI
   847 000003E9 C3                      	ret
   848                                  
   849                                  ;========================================================================
   850                                  ; cursor_hide - hide cursor
   851                                  ; Input:
   852                                  ;	none
   853                                  ; Output:
   854                                  ;	none
   855                                  ; Notes:
   856                                  ;	Uses ESC[?25l ANSI sequence
   857                                  ;========================================================================
   858                                  cursor_hide:
   859                                  %if	ANSI
   860 000003EA 50                      	push	ax
   861 000003EB B01B                    	mov	al,ESC
   862 000003ED E83701                  	call	uart_out
   863 000003F0 B05B                    	mov	al,'['
   864 000003F2 E83201                  	call	uart_out
   865 000003F5 B03F                    	mov	al,'?'
   866 000003F7 E82D01                  	call	uart_out
   867 000003FA B032                    	mov	al,'2'
   868 000003FC E82801                  	call	uart_out
   869 000003FF B035                    	mov	al,'5'
   870 00000401 E82301                  	call	uart_out
   871 00000404 B06C                    	mov	al,'l'
   872 00000406 E81E01                  	call	uart_out
   873 00000409 58                      	pop	ax
   874                                  %endif	; ANSI
   875 0000040A C3                      	ret
   876                                  
   877                                  ;========================================================================
   878                                  ; cursor_show - show cursor
   879                                  ; Input:
   880                                  ;	none
   881                                  ; Output:
   882                                  ;	none
   883                                  ; Notes:
   884                                  ;	Uses ESC[?25h ANSI sequence
   885                                  ;========================================================================
   886                                  cursor_show:
   887                                  %if	ANSI
   888 0000040B 50                      	push	ax
   889 0000040C B01B                    	mov	al,ESC
   890 0000040E E81601                  	call	uart_out
   891 00000411 B05B                    	mov	al,'['
   892 00000413 E81101                  	call	uart_out
   893 00000416 B03F                    	mov	al,'?'
   894 00000418 E80C01                  	call	uart_out
   895 0000041B B032                    	mov	al,'2'
   896 0000041D E80701                  	call	uart_out
   897 00000420 B035                    	mov	al,'5'
   898 00000422 E80201                  	call	uart_out
   899 00000425 B068                    	mov	al,'h'
   900 00000427 E8FD00                  	call	uart_out
   901 0000042A 58                      	pop	ax
   902                                  %endif	; ANSI
   903 0000042B C3                      	ret
   904                                  
   905                                  ;========================================================================
   906                                  ; clear_screen
   907                                  ; Input:
   908                                  ;	none
   909                                  ; Output:
   910                                  ;	AL is trashed
   911                                  ;========================================================================
   912                                  clear_screen:
   913                                  %if   ANSI
   914 0000042C B01B                    	mov	al,ESC		; clear screen - ESC[2J
   915 0000042E E8F600                  	call	uart_out
   916 00000431 B05B                    	mov	al,'['
   917 00000433 E8F100                  	call	uart_out
   918 00000436 B032                    	mov	al,'2'
   919 00000438 E8EC00                  	call	uart_out
   920 0000043B B04A                    	mov	al,'J'
   921 0000043D E8E700                  	call	uart_out
   922                                  %endif  ; ANSI
   923 00000440 C3                      	ret
   924                                  
   925                                  ;========================================================================
   926                                  ; set_attributes - set specified background/foreground color
   927                                  ; Input:
   928                                  ;	BL = attributes
   929                                  ;		color mode:
   930                                  ;			bit 7 	 = 1 - blinking
   931                                  ;			bits 6-4 = background color
   932                                  ;			bits 3-0 = foreground color
   933                                  ;		color mode with high intensity background
   934                                  ;			bits 7-4 = background color
   935                                  ;			bits 3-0 = foreground color
   936                                  ;		monochrome mode
   937                                  ;			01h = underline
   938                                  ;			07h = normal
   939                                  ;			09h = bright underline
   940                                  ;			0Fh = bold
   941                                  ;			70h = reverse (black on white)
   942                                  ;			81h = blinking underline
   943                                  ;			87h = blinking normal
   944                                  ;			89h = blinking bright underline
   945                                  ;			8Fh = blinking bold
   946                                  ; Output:
   947                                  ;	none
   948                                  ; XXX:
   949                                  ;	Add attribute cache, so we won't spend time setting the same attribute again
   950                                  ;========================================================================
   951                                  set_attributes:
   952                                  %if	ANSI
   953 00000441 50                      	push	ax
   954                                  
   955 00000442 B01B                    	mov	al,ESC
   956 00000444 E8E000                  	call	uart_out
   957 00000447 B05B                    	mov	al,'['
   958 00000449 E8DB00                  	call	uart_out
   959                                  
   960 0000044C F6C308                  	test	bl,08h	; bold?
   961 0000044F 750A                    	jnz	.bold
   962 00000451 B032                    	mov	al,'2'		; set normal mode - ESC[22m
   963 00000453 E8D100                  	call	uart_out
   964 00000456 E8CE00                  	call	uart_out
   965 00000459 EB05                    	jmp	.check_mode
   966                                  
   967                                  .bold:
   968 0000045B B031                    	mov	al,'1'		; set bold attribute - ESC[1m
   969 0000045D E8C700                  	call	uart_out
   970                                  
   971                                  .check_mode:
   972 00000460 A04900                  	mov	al,byte [video_mode]
   973 00000463 3C07                    	cmp	al,7
   974 00000465 7530                    	jne	.color
   975                                  
   976 00000467 B03B                    	mov	al,';'
   977 00000469 E8BB00                  	call	uart_out
   978                                  				; monochrome - set underline attribute
   979 0000046C 88D8                    	mov	al,bl
   980 0000046E 2407                    	and	al,7		; get foreground attribute part
   981 00000470 3C01                    	cmp	al,1		; underlined
   982 00000472 740C                    	je	.underline
   983 00000474 B032                    	mov	al,'2'		; set not underlined attribute - ESC[24m
   984 00000476 E8AE00                  	call	uart_out
   985 00000479 B034                    	mov	al,'4'
   986 0000047B E8A900                  	call	uart_out
   987 0000047E EB05                    	jmp	.mono_to_color
   988                                  
   989                                  .underline:
   990 00000480 B034                    	mov	al,'4'		; set underlined attribute - ESC[4m
   991 00000482 E8A200                  	call	uart_out
   992                                  
   993                                  .mono_to_color:
   994 00000485 88D8                    	mov	al,bl
   995 00000487 2407                    	and	al,07h
   996 00000489 7403                    	jz	.mono_bg	; black foreground
   997 0000048B 80CB07                  	or	bl,07h		; anything else is white
   998                                  .mono_bg:
   999 0000048E 88D8                    	mov	al,bl
  1000 00000490 2470                    	and	al,70h
  1001 00000492 7403                    	jz	.color		; black background
  1002 00000494 80CB70                  	or	bl,70h		; anything else is white
  1003                                  .color:
  1004 00000497 B03B                    	mov	al,';'
  1005 00000499 E88B00                  	call	uart_out
  1006                                  
  1007 0000049C 88D8                    	mov	al,bl		; need to exchange bit 0 with 2
  1008 0000049E 80E3AA                  	and	bl,0AAh		; and bit 4 with bit 6
  1009 000004A1 A801                    	test	al,01h
  1010 000004A3 7403                    	jz	.no_blue_fg
  1011 000004A5 80CB04                  	or	bl,04h
  1012                                  .no_blue_fg:
  1013 000004A8 A804                    	test	al,04h
  1014 000004AA 7403                    	jz	.no_red_fg
  1015 000004AC 80CB01                  	or	bl,01h
  1016                                  .no_red_fg:
  1017 000004AF A810                    	test	al,10h
  1018 000004B1 7403                    	jz	.no_blue_bg
  1019 000004B3 80CB40                  	or	bl,40h
  1020                                  .no_blue_bg:
  1021 000004B6 A840                    	test	al,40h
  1022 000004B8 7403                    	jz	.no_red_bg
  1023 000004BA 80CB10                  	or	bl,10h
  1024                                  .no_red_bg:
  1025 000004BD B033                    	mov	al,'3'		; set foreground color - ESC[3<0..7>m
  1026 000004BF E86500                  	call	uart_out
  1027 000004C2 88D8                    	mov	al,bl
  1028 000004C4 2407                    	and	al,07h
  1029 000004C6 0430                    	add	al,'0'
  1030 000004C8 E85C00                  	call	uart_out
  1031                                  
  1032 000004CB B03B                    	mov	al,';'
  1033 000004CD E85700                  	call	uart_out
  1034                                  
  1035 000004D0 F6C380                  	test	bl,80h
  1036 000004D3 741F                    	jz	.normal_bg	; normal background
  1037 000004D5 A06500                  	mov	al,byte [video_hw_mode]
  1038 000004D8 A820                    	test	al,20h		; intense colors
  1039 000004DA 7518                    	jnz	.normal_bg	; normal background, blinking
  1040                                  
  1041 000004DC B031                    	mov	al,'1'		; set intense background color - ESC[10<0..7>m
  1042 000004DE E84600                  	call	uart_out	; note - this is not supported everywhere
  1043 000004E1 B030                    	mov	al,'0'
  1044 000004E3 E84100                  	call	uart_out
  1045 000004E6 88D8                    	mov	al,bl
  1046 000004E8 2470                    	and	al,70h
  1047 000004EA C0E804                  	shr	al,4
  1048 000004ED 0430                    	add	al,'0'
  1049 000004EF E83500                  	call	uart_out
  1050 000004F2 EB2C                    	jmp	.exit
  1051                                  
  1052                                  .normal_bg:
  1053 000004F4 B034                    	mov	al,'4'		; set background color - ESC[4<0..7>m
  1054 000004F6 E82E00                  	call	uart_out
  1055 000004F9 88D8                    	mov	al,bl
  1056 000004FB 2470                    	and	al,70h
  1057 000004FD C0E804                  	shr	al,4
  1058 00000500 0430                    	add	al,'0'
  1059 00000502 E82200                  	call	uart_out
  1060                                  
  1061 00000505 B03B                    	mov	al,';'
  1062 00000507 E81D00                  	call	uart_out
  1063                                  
  1064 0000050A F6C380                  	test	bl,80h
  1065 0000050D 750C                    	jnz	.blink
  1066 0000050F B032                    	mov	al,'2'		; set not blinking attribute - ESC[25m
  1067 00000511 E81300                  	call	uart_out
  1068 00000514 B035                    	mov	al,'5'
  1069 00000516 E80E00                  	call	uart_out
  1070 00000519 EB05                    	jmp	.exit
  1071                                  
  1072                                  .blink:
  1073 0000051B B035                    	mov	al,'5'		; set blinking attribute - ESC[5m
  1074 0000051D E80700                  	call	uart_out
  1075                                  
  1076                                  .exit:
  1077 00000520 B06D                    	mov	al,'m'
  1078 00000522 E80200                  	call	uart_out
  1079                                  
  1080 00000525 58                      	pop	ax
  1081                                  %endif	; ANSI
  1082 00000526 C3                      	ret
  1083                                  
  1084                                  ;========================================================================
  1085                                  ; uart_out - write character to serial port
  1086                                  ; Input:
  1087                                  ;	AL = character to write
  1088                                  ; Output:
  1089                                  ;	none
  1090                                  ;========================================================================
  1091                                  uart_out:
  1092                                  %if UART_MODE3_SUPPRESS
  1093                                  	push	ds
  1094                                  	push	bios_data_seg
  1095                                  	popm	ds
  1096                                  	cmp	byte [video_mode],3
  1097                                  	popm	ds
  1098                                  	je	.9		; skip output in mode 3 (color)
  1099                                  %endif
  1100                                  ;;;	global	uart_out_	; used in debugging mode (C-callable)
  1101                                  ;;;uart_out_:			; **** label .9 cannot reach if un-commented
  1102 00000527 52                      	push	dx
  1103 00000528 50                      	push	ax
  1104                                  %if UART_DSR_PROTOCOL
  1105                                          extern  microsecond
  1106                                  .wait_dsr:
  1107                                          mov     dx,uart_msr
  1108                                  BIT_DSR         equ     1<<5
  1109                                          in      al,dx           ; read the Modem Status Register
  1110                                          test    al,BIT_DSR      ; Data Set Ready
  1111                                          jnz     .nowait
  1112                                          push    cx
  1113                                          mov     cx,100
  1114                                          call    microsecond
  1115                                          pop     cx
  1116                                          jmp     .wait_dsr
  1117                                  .nowait:
  1118                                  %endif
  1119                                  .1:
  1120 00000529 BA8506                  	mov	dx,uart_lsr
  1121 0000052C EC                      	in	al,dx
  1122 0000052D A820                    	test	al,20h		; THRE is empty
  1123 0000052F 74F8                    	jz	.1
  1124 00000531 58                      	pop	ax
  1125 00000532 BA8006                  	mov	dx,uart_thr
  1126 00000535 EE                      	out	dx,al		; write character
  1127 00000536 5A                      	pop	dx
  1128                                  .9:
  1129 00000537 C3                      	ret
  1130                                  
  1131                                  
  1132                                  ;========================================================================
  1133                                  ; video_init - initialize video service
  1134                                  ; Input:
  1135                                  ;	AL = baud rate
  1136                                  ;	DS = DGROUP
  1137                                  ; Output:
  1138                                  ;	none
  1139                                  ;========================================================================
  1140                                  	global	video_init
  1141                                  video_init:
  1142                                  		; XXX - move interrupt registration code here
  1143 00000538 50                      	push	ax
  1144 00000539 E80301                  	call	uart_init
  1145 0000053C BA8006                  	mov	dx,uart_base
  1146 0000053F E84801                  	call	uart_detect
  1147 00000542 50                      	push	ax
  1148                                  %if SOFT_DEBUG
  1149                                  	extern	lites
  1150                                  	or	al,0C0h
  1151                                  	push	ax
  1152                                  	call	lites
  1153                                  	extern	crlf,boutsp,wout,bout,cout
  1154                                  %if 1
  1155                                  	pop	ax
  1156                                  	push	ax
  1157                                  	call	boutsp
  1158                                  	call	crlf
  1159                                  	pushm	dx,cx
  1160                                  	mov	cx,uart_sr-uart_iir+1
  1161                                  	mov	dx,uart_iir
  1162                                  .234:	in	al,dx
  1163                                  	call	boutsp
  1164                                  	inc	dl
  1165                                  	loop	.234
  1166                                  	popm	dx,cx
  1167                                  %endif
  1168                                  %endif
  1169 00000543 B80700                  	mov	ax,0007h
  1170 00000546 CD10                    	int	10h
  1171 00000548 58                      	pop	ax
  1172                                  %if SOFT_DEBUG
  1173                                  	push	ax
  1174                                  	call	boutsp
  1175                                  	pop	ax
  1176                                  %endif
  1177 00000549 0E                      	push	cs
  1178 0000054A 3C04                    	cmp	al,UART_16550A
  1179 0000054C 7205                    	jb	.no_fifo
  1180 0000054E 68[3806]                	push	.enabled
  1181 00000551 EB03                    	jmp	.print_uart
  1182                                  .no_fifo:
  1183 00000553 68[3B06]                	push	.disabled
  1184                                  .print_uart:
  1185 00000556 0E                      	push	cs
  1186 00000557 3C01                    	cmp	al,UART_8250
  1187 00000559 7505                    	jne	.check_16450
  1188 0000055B 68[F905]                	push	.uart_8250
  1189 0000055E EB42                    	jmp	.print_hi
  1190                                  .check_16450:
  1191 00000560 3C02                    	cmp	al,UART_16450
  1192 00000562 7505                    	jne	.check_16550
  1193 00000564 68[FE05]                	push	.uart_16450
  1194 00000567 EB39                    	jmp	.print_hi
  1195                                  .check_16550:
  1196 00000569 3C03                    	cmp	al,UART_16550
  1197 0000056B 7505                    	jne	.check_16550A
  1198 0000056D 68[0A06]                	push	.uart_16550
  1199 00000570 EB30                    	jmp	.print_hi
  1200                                  .check_16550A:
  1201 00000572 3C04                    	cmp	al,UART_16550A
  1202 00000574 7505                    	jne	.check_16550C
  1203 00000576 68[1006]                	push	.uart_16550A
  1204 00000579 EB27                    	jmp	.print_hi
  1205                                  .check_16550C:
  1206 0000057B 3C05                    	cmp	al,UART_16550C
  1207 0000057D 7505                    	jne	.check_16650
  1208 0000057F 68[1706]                	push	.uart_16550C
  1209 00000582 EB1E                    	jmp	.print_hi
  1210                                  .check_16650:
  1211 00000584 3C06                    	cmp	al,UART_16650
  1212 00000586 7505                    	jne	.check_16750
  1213 00000588 68[1E06]                	push	.uart_16650
  1214 0000058B EB15                    	jmp	.print_hi
  1215                                  .check_16750:
  1216 0000058D 3C07                    	cmp	al,UART_16750
  1217 0000058F 7505                    	jne	.check_16850
  1218 00000591 68[2406]                	push	.uart_16750
  1219 00000594 EB0C                    	jmp	.print_hi
  1220                                  .check_16850:
  1221 00000596 3C08                    	cmp	al,UART_16850
  1222 00000598 7505                    	jne	.unknown
  1223 0000059A 68[2A06]                	push	.uart_16850
  1224 0000059D EB03                    	jmp	.print_hi
  1225                                  .unknown:
  1226 0000059F 68[3006]                	push	.uart_unknown
  1227                                  .print_hi:
  1228 000005A2 0E                      	push	cs
  1229 000005A3 68[AE05]                	push	.hi
  1230                                  	extern	_cprintf
  1231 000005A6 E8(0000)                	call	_cprintf	; _cprintf uses int10 0Eh
  1232 000005A9 83C40C                  	add	sp,12
  1233                                  
  1234 000005AC 58                      	pop	ax
  1235                                  %if SOFT_DEBUG
  1236                                  ;;;	hlt
  1237                                  %endif
  1238 000005AD C3                      	ret
  1239                                  
  1240                                  .hi:
  1241                                  
  1242                                  %if UART
  1243 000005AE 53657269616C20492F-     	db	'Serial I/O BIOS (c) 2010 Sergey Kiselev', NL
  1243 000005B7 4F2042494F53202863-
  1243 000005C0 292032303130205365-
  1243 000005C9 72676579204B697365-
  1243 000005D2 6C65760A           
  1244 000005D6 446574656374656420-     	db	'Detected %s UART, FIFO is %sabled', NL
  1244 000005DF 257320554152542C20-
  1244 000005E8 4649464F2069732025-
  1244 000005F1 7361626C65640A     
  1245                                  %endif
  1246 000005F8 00                      	db	0
  1247                                  
  1248                                  .uart_8250:
  1249 000005F9 3832353000              	db	'8250', 0
  1250                                  .uart_16450:
  1251 000005FE 38323530412F313634-     	db	'8250A/16450', 0
  1251 00000607 353000             
  1252                                  .uart_16550:
  1253 0000060A 313635353000            	db	'16550', 0
  1254                                  .uart_16550A:
  1255 00000610 31363535304100          	db	'16550A', 0
  1256                                  .uart_16550C:
  1257 00000617 31363535304300          	db	'16550C', 0
  1258                                  .uart_16650:
  1259 0000061E 313636353000            	db	'16650', 0
  1260                                  .uart_16750:
  1261 00000624 313637353000            	db	'16750', 0
  1262                                  .uart_16850:
  1263 0000062A 313638353000            	db	'16850', 0
  1264                                  .uart_unknown:
  1265 00000630 756E6B6E6F776E00        	db	'unknown', 0
  1266                                  .enabled:
  1267 00000638 656E00                  	db	'en', 0
  1268                                  .disabled:
  1269 0000063B 64697300                	db	'dis', 0
  1270                                  
  1271                                  ;========================================================================
  1272                                  ; uart_init - initialize UART
  1273                                  ; Input:
  1274                                  ;	AL = baud rate
  1275                                  ; Output:
  1276                                  ;	none
  1277                                  ;========================================================================
  1278                                  uart_init:
  1279 0000063F 525350                  	pushm	ax,bx,dx
  1280 00000642 B400                    	mov	ah,0
  1281 00000644 D0E0                    	shl	al,1
  1282 00000646 89C3                    	mov	bx,ax		; Index in the .divisors table
  1283 00000648 2E8B9F[7A06]               cs	mov	bx,word[.divisors+bx]
  1284                                  	; Divisor Latch Access bit set, no parity, one stop bit, 8 data bits
  1285 0000064D B083                    	mov	al,83h
  1286 0000064F BA8306                  	mov	dx,uart_lcr
  1287 00000652 EE                      	out	dx,al
  1288                                  	; Lookup table for baud rates
  1289 00000653 88D8                    	mov	al,bl		; low byte
  1290 00000655 BA8006                  	mov	dx,uart_dll
  1291 00000658 EE                      	out	dx,al
  1292 00000659 88F8                    	mov	al,bh		; high byte
  1293 0000065B BA8106                  	mov	dx,uart_dlm
  1294 0000065E EE                      	out	dx,al
  1295                                  	; no parity, one stop bit, 8 data bits
  1296 0000065F B003                    	mov	al,03h
  1297 00000661 BA8306                  	mov	dx,uart_lcr
  1298 00000664 EE                      	out	dx,al
  1299                                  	; XXX?
  1300 00000665 BA8406                  	mov	dx,uart_mcr
  1301 00000668 EC                      	in	al,dx				; for SBC3
  1302 00000669 0C07                    	or	al,7
  1303 0000066B EE                      	out	dx,al
  1304                                  	; disable interrupts for now
  1305 0000066C B000                    	mov	al,0		; AL = 0
  1306 0000066E BA8106                  	mov	dx,uart_ier
  1307 00000671 EE                      	out	dx,al
  1308                                  	; disable FIFO for now
  1309                                  	; note - AL = 0
  1310 00000672 BA8206                  	mov	dx,uart_fcr
  1311 00000675 EE                      	out	dx,al
  1312 00000676 585B5A                  	popm	ax,bx,dx
  1313 00000679 C3                      	ret
  1314                                  
  1315                                  .divisors:
  1316 0000067A 6000                    	dw	UART_OSC/16/1200	; 1200 Kbit/sec
  1317 0000067C 3000                    	dw	UART_OSC/16/2400	; 2400 Kbit/sec
  1318 0000067E 1800                    	dw	UART_OSC/16/4800	; 4800 Kbit/sec
  1319 00000680 0C00                    	dw	UART_OSC/16/9600	; 9600 Kbit/sec
  1320 00000682 0600                    	dw	UART_OSC/16/19200	; 19200 Kbit/sec
  1321 00000684 0300                    	dw	UART_OSC/16/38400	; 38400 Kbit/sec
  1322 00000686 0200                    	dw	UART_OSC/16/57600	; 57600 Kbit/sec
  1323 00000688 0100                    	dw	UART_OSC/16/115200	; 115200 Kbit/sec
  1324                                  
  1325                                  %if 0
  1326                                  ;========================================================================
  1327                                  ; uart_detect - detect UART type, enable FIFO if present
  1328                                  ; Input:
  1329                                  ;	none
  1330                                  ; Output:
  1331                                  ;	AL = UART type
  1332                                  ;
  1333                                  ; UART detection code from
  1334                                  ; http://en.wikibooks.org/wiki/Serial_Programming/8250_UART_Programming
  1335                                  ;========================================================================
  1336                                  UART_8250	equ	1
  1337                                  UART_16450	equ	2
  1338                                  UART_16550	equ	3
  1339                                  UART_16550A	equ	4
  1340                                  UART_16550C	equ	5
  1341                                  UART_16650	equ	6
  1342                                  UART_16750	equ	7
  1343                                  UART_16850	equ	8
  1344                                  
  1345                                  uart_detect:
  1346                                  	push	dx
  1347                                  	; Set the value "0xE7" to the FCR to test the status of the FIFO flags
  1348                                  	mov	al,0E7h
  1349                                  	mov	dx,uart_fcr
  1350                                  	out	dx,al
  1351                                  	; Read the value of the IIR to test for what flags actually got set
  1352                                  	mov	dx,uart_iir
  1353                                  	in	al,dx
  1354                                  	test	al,40h
  1355                                  	jz	.no_fifo
  1356                                  	test	al,80h
  1357                                  	jz	.uart_16550
  1358                                  	test	al,20h
  1359                                  	jz	.uart_16550A
  1360                                  	mov	al,UART_16750
  1361                                  	jmp	.exit
  1362                                  .uart_16550A:
  1363                                  	mov	al,UART_16550A
  1364                                  	jmp	.exit
  1365                                  .uart_16550:
  1366                                  	; Disable FIFO on 16550 (FIFO is broken)
  1367                                  	mov	al,0
  1368                                  	mov	dx,uart_fcr
  1369                                  	out	dx,al
  1370                                  	mov	al,UART_16550
  1371                                  	jmp	.exit
  1372                                  .no_fifo:
  1373                                  	; Chip doesn't use FIFO, so we need to check the scratch register
  1374                                  	; Set some arbitrary value like 0x2A to the Scratch Register
  1375                                  	mov	al,2Ah
  1376                                  	mov	dx,uart_sr
  1377                                  	out	dx,al
  1378                                  	; Read the value of the Scratch Register
  1379                                  	in	al,dx
  1380                                  	cmp	al,2Ah
  1381                                  	jnz	.uart_8250
  1382                                  	; If the arbitrary value comes back identical
  1383                                  	mov	al,UART_16450
  1384                                  	jmp	.exit
  1385                                  .uart_8250:
  1386                                  	mov	al,UART_8250
  1387                                  .exit:
  1388                                  	pop	dx
  1389                                  	ret
  1390                                  %else
  1391                                  %include "uart_det.asm"
  1392                              <1> ;========================================================================
  1393                              <1> ; uart_detect - detect UART type, enable FIFO if present
  1394                              <1> ;========================================================================
  1395                              <1> ;
  1396                              <1> ; Copyright (C) 2012,2020 John R Coffman.  All rights reserved.
  1397                              <1> ; Provided for hobbyist use on the RetroBrew Computers' SBC-188 boards.
  1398                              <1> ;
  1399                              <1> ; This program is free software: you can redistribute it and/or modify
  1400                              <1> ; it under the terms of the GNU General Public License as published by
  1401                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1402                              <1> ; (at your option) any later version.
  1403                              <1> ;
  1404                              <1> ; This program is distributed in the hope that it will be useful,
  1405                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1406                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1407                              <1> ; GNU General Public License for more details.
  1408                              <1> ;
  1409                              <1> ; You should have received a copy of the GNU General Public License
  1410                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1411                              <1> ;
  1412                              <1> ; Updated for the Duodyne 80c188 SBC
  1413                              <1> ;========================================================================
  1414                              <1> ; History:
  1415                              <1> ;   Derived from the RetroBrew/JRCoffman UNA source code 'uart_det.s'
  1416                              <1> ;   Copyright (C) 2012 John Coffman.  All rights reserved.
  1417                              <1> ;   Distributed under the above GPL license.
  1418                              <1> ;========================================================================
  1419                              <1> %ifdef STANDALONE
  1420                              <1> %include "config.asm"
  1421                              <1> %include "cpuregs.asm"
  1422                              <1> ;
  1423                              <1> ; C-language interface:
  1424                              <1> ;	unsigned char near uart_det(unsigned dev);
  1425                              <1> 	global	uart_det_
  1426                              <1>    SEGMENT  _TEXT ALIGN=2 PUBLIC CLASS=CODE
  1427                              <1> uart_det_:
  1428                              <1> 	mov	dx,ax
  1429                              <1> 	call	uart_detect
  1430                              <1> 	ret
  1431                              <1> %endif
  1432                              <1> ;========================================================================
  1433                              <1> ; uart_detect - detect UART type, enable FIFO if present
  1434                              <1> ;
  1435                              <1> ; Input:
  1436                              <1> ;	DX = UART device code to probe
  1437                              <1> ;
  1438                              <1> ; Output:
  1439                              <1> ;	AL = UART type
  1440                              <1> ;
  1441                              <1> ; UART detection code from
  1442                              <1> ; http://en.wikibooks.org/wiki/Serial_Programming/8250_UART_Programming
  1443                              <1> ;========================================================================
  1444                              <1> UART_NONE	equ	0	; no UART detected
  1445                              <1> UART_8250	equ	1	; no Scratch register
  1446                              <1> UART_16450	equ	2	; or 8250A
  1447                              <1> UART_16550	equ	3
  1448                              <1> UART_16550A	equ	4
  1449                              <1> UART_16550C	equ	5
  1450                              <1> UART_16650	equ	6
  1451                              <1> UART_16750	equ	7
  1452                              <1> UART_16850	equ	8
  1453                              <1> ;*******************************************************************
  1454                              <1> ;***N.B.:  the above list must be kept in sync with 'sio.h' enum ***
  1455                              <1> ;*******************************************************************
  1456                              <1> 
  1457                              <1> ; macros assume DI is set to base UART register
  1458                              <1> %macro	uget 2		; dest reg8, src UART reg or offset
  1459                              <1> 	mov	bl,(%2)&0xFF
  1460                              <1> 	call	udet_get
  1461                              <1> 	mov	%1,al
  1462                              <1> %endmacro
  1463                              <1> 
  1464                              <1> %macro	uput 2		; dest UART reg or offset, src reg8
  1465                              <1> 	mov	bl,(%1)&0xFF
  1466                              <1> 	mov	al,%2
  1467                              <1> 	call	udet_put
  1468                              <1> %endmacro
  1469                              <1> 
  1470                              <1> %macro	 ucmp 2		; dest UART reg (read to AL), src reg8 or value
  1471                              <1> 	mov	bl,(%1)&0xFF
  1472                              <1> 	call	udet_get
  1473                              <1> 	cmp	al,(%2)&0xFF
  1474                              <1> %endmacro
  1475                              <1> 
  1476                              <1> uart_detect:
  1477 0000068A 57535152            <1> 	pushm	dx,cx,bx,di
  1478 0000068E 31C9                <1> 	xor	cx,cx		; no uart present CL=0
  1479 00000690 83E2F8              <1> 	and	dx,~7		; mask 8 UART registers
  1480 00000693 89D7                <1> 	mov	di,dx		; device base to di
  1481                              <1> ; UART is present if toggling the DLAT bit in LCR makes divisor available
  1482                              <1> 	uget	ch,uart_lcr	; save LCR value
  1459 00000695 B383                <2>  mov bl,(%2)&0xFF
  1460 00000697 E8EC00              <2>  call udet_get
  1461 0000069A 88C5                <2>  mov %1,al
  1483                              <1> 	uput	uart_lcr,0	; make DLAT inaccessible
  1465 0000069C B383                <2>  mov bl,(%1)&0xFF
  1466 0000069E B000                <2>  mov al,%2
  1467 000006A0 E8DA00              <2>  call udet_put
  1484                              <1> 	uput	uart_ier,0	; IER==DLM
  1465 000006A3 B381                <2>  mov bl,(%1)&0xFF
  1466 000006A5 B000                <2>  mov al,%2
  1467 000006A7 E8D300              <2>  call udet_put
  1485                              <1> 	uput	uart_lcr,0x80	; LCR  set DLAT bit
  1465 000006AA B383                <2>  mov bl,(%1)&0xFF
  1466 000006AC B080                <2>  mov al,%2
  1467 000006AE E8CC00              <2>  call udet_put
  1486                              <1> 	uget	bh,uart_dlm	; save DLM
  1459 000006B1 B381                <2>  mov bl,(%2)&0xFF
  1460 000006B3 E8D000              <2>  call udet_get
  1461 000006B6 88C7                <2>  mov %1,al
  1487                              <1> 	uput	uart_dlm,0x5a	; DLM==IER  set some pattern
  1465 000006B8 B381                <2>  mov bl,(%1)&0xFF
  1466 000006BA B05A                <2>  mov al,%2
  1467 000006BC E8BE00              <2>  call udet_put
  1488                              <1> 	ucmp	uart_dlm,0x5a	; does it read back the same?
  1471 000006BF B381                <2>  mov bl,(%1)&0xFF
  1472 000006C1 E8C200              <2>  call udet_get
  1473 000006C4 3C5A                <2>  cmp al,(%2)&0xFF
  1489 000006C6 7403E9AA00          <1> 	jne	.exit		; no UART here
  1490                              <1> 	uput	uart_lcr,0x00	; LCR=00, reset DLAT
  1465 000006CB B383                <2>  mov bl,(%1)&0xFF
  1466 000006CD B000                <2>  mov al,%2
  1467 000006CF E8AB00              <2>  call udet_put
  1491                              <1> 	ucmp	uart_dlm,0x5a	; is it still 0x5A?
  1471 000006D2 B381                <2>  mov bl,(%1)&0xFF
  1472 000006D4 E8AF00              <2>  call udet_get
  1473 000006D7 3C5A                <2>  cmp al,(%2)&0xFF
  1492 000006D9 7503E99700          <1> 	je	.exit		; no uart if still 0x5A
  1493                              <1> 
  1494                              <1> ; restore DLM
  1495                              <1> 	uput	uart_lcr,0x80
  1465 000006DE B383                <2>  mov bl,(%1)&0xFF
  1466 000006E0 B080                <2>  mov al,%2
  1467 000006E2 E89800              <2>  call udet_put
  1496                              <1> 	uput	uart_dlm,bh
  1465 000006E5 B381                <2>  mov bl,(%1)&0xFF
  1466 000006E7 88F8                <2>  mov al,%2
  1467 000006E9 E89100              <2>  call udet_put
  1497 000006EC 80E57F              <1> 	and	ch,~0x80	; clear DLAT
  1498                              <1> 	uput	uart_lcr,ch	; restore DLAT
  1465 000006EF B383                <2>  mov bl,(%1)&0xFF
  1466 000006F1 88E8                <2>  mov al,%2
  1467 000006F3 E88700              <2>  call udet_put
  1499 000006F6 41                  <1> 	inc	cx		; UART=8250 or above is present
  1500                              <1> ; look for the Scratch register
  1501                              <1> 	uput	uart_sr,0x5a	; set a value
  1465 000006F7 B387                <2>  mov bl,(%1)&0xFF
  1466 000006F9 B05A                <2>  mov al,%2
  1467 000006FB E87F00              <2>  call udet_put
  1502                              <1> 	ucmp	uart_sr,0x5a	; does it read back
  1471 000006FE B387                <2>  mov bl,(%1)&0xFF
  1472 00000700 E88300              <2>  call udet_get
  1473 00000703 3C5A                <2>  cmp al,(%2)&0xFF
  1503 00000705 756E                <1> 	jne	.exit		; test for no Scratch register
  1504                              <1> 
  1505 00000707 41                  <1> 	inc	cx		; 8250A, 16450 or higher
  1506                              <1> 	uput	uart_lcr,0xBF	; special value for higher UARTs
  1465 00000708 B383                <2>  mov bl,(%1)&0xFF
  1466 0000070A B0BF                <2>  mov al,%2
  1467 0000070C E86E00              <2>  call udet_put
  1507                              <1> 	ucmp	uart_sr,0x5A	; is it still 0x5a?
  1471 0000070F B387                <2>  mov bl,(%1)&0xFF
  1472 00000711 E87200              <2>  call udet_get
  1473 00000714 3C5A                <2>  cmp al,(%2)&0xFF
  1508 00000716 7404                <1> 	je	.below650
  1509 00000718 B106                <1> 	mov	cl,6		; it is a 16650 or 16850, which cannot
  1510 0000071A EB59                <1> 	jmp	.exit		;  be distinguished
  1511                              <1> .below650:
  1512                              <1> ; UART is 16550C or below
  1513                              <1> 	uput	uart_lcr,0x80	; set DLAT again
  1465 0000071C B383                <2>  mov bl,(%1)&0xFF
  1466 0000071E B080                <2>  mov al,%2
  1467 00000720 E85A00              <2>  call udet_put
  1514                              <1> 	uput	uart_fcr,0xE1	; output to FCR (FIFO Control)
  1465 00000723 B382                <2>  mov bl,(%1)&0xFF
  1466 00000725 B0E1                <2>  mov al,%2
  1467 00000727 E85300              <2>  call udet_put
  1515                              <1> 	uget	bh,uart_iir	; FCR=IIR
  1459 0000072A B382                <2>  mov bl,(%2)&0xFF
  1460 0000072C E85700              <2>  call udet_get
  1461 0000072F 88C7                <2>  mov %1,al
  1516                              <1> 	uput	uart_lcr,0x07	; reset the LCR DLAT bit & set 8n2
  1465 00000731 B383                <2>  mov bl,(%1)&0xFF
  1466 00000733 B007                <2>  mov al,%2
  1467 00000735 E84500              <2>  call udet_put
  1517                              <1> ; test for a FIFO
  1518 00000738 F6C740              <1> 	test	bh,1<<6		; test low order FIFO bit
  1519 0000073B 7438                <1> 	jz	.exit		; 16450 if zero
  1520                              <1> 
  1521 0000073D 41                  <1> 	inc	cx		; 16550 or higher
  1522 0000073E F6C780              <1> 	test	bh,1<<7		; test high FIFO bit
  1523 00000741 7432                <1> 	jz	.exit		; 16550 if zero
  1524                              <1> 
  1525 00000743 41                  <1> 	inc	cx		; 16550A or higher
  1526 00000744 F6C720              <1> 	test	bh,1<<5		; test for 64-byte FIFO
  1527 00000747 7404                <1> 	jz	.is550AorC
  1528                              <1> ; has a 64-byte FIFO
  1529 00000749 B107                <1> 	mov	cl,7		; it is a 16750
  1530 0000074B EB28                <1> 	jmp	.exit
  1531                              <1> 
  1532                              <1> ; two levels of UART left to distinguish
  1533                              <1> .is550AorC:
  1534                              <1> ;;;;				; 16550A or higher
  1535                              <1> 	uget	bh,uart_mcr	; save MCR setting
  1459 0000074D B384                <2>  mov bl,(%2)&0xFF
  1460 0000074F E83400              <2>  call udet_get
  1461 00000752 88C7                <2>  mov %1,al
  1536 00000754 80CF20              <1> 	or	bh,1<<5		; set bit 5
  1537                              <1> 	uput	uart_mcr,bh	; set the AFE bit (auto flowcontrol enable)
  1465 00000757 B384                <2>  mov bl,(%1)&0xFF
  1466 00000759 88F8                <2>  mov al,%2
  1467 0000075B E81F00              <2>  call udet_put
  1538                              <1> 	uget	bh,uart_mcr	; read it back
  1459 0000075E B384                <2>  mov bl,(%2)&0xFF
  1460 00000760 E82300              <2>  call udet_get
  1461 00000763 88C7                <2>  mov %1,al
  1539 00000765 F6C720              <1> 	test	bh,1<<5		; is the bit still set
  1540 00000768 740B                <1> 	jz	.exit
  1541 0000076A 41                  <1> 	inc	cx		; 16550C found
  1542 0000076B 80E7DF              <1> 	and	bh,0xFF-(1<<5)	; clear the AFE bit
  1543                              <1> 	uput	uart_mcr,bh	; AFC is broken on DIP version of 16550
  1465 0000076E B384                <2>  mov bl,(%1)&0xFF
  1466 00000770 88F8                <2>  mov al,%2
  1467 00000772 E80800              <2>  call udet_put
  1544                              <1> .exit:
  1545 00000775 88C8                <1> 	mov	al,cl		; return UART ID
  1546 00000777 98                  <1> 	cbw
  1547 00000778 5A595B5F            <1> 	popm	dx,cx,bx,di
  1548 0000077C C3                  <1> 	ret
  1549                              <1> 
  1550                              <1> udet_put:
  1551 0000077D 53                  <1> 	push	bx
  1552 0000077E 83E307              <1> 	and	bx,7		; mask to uart offset
  1553 00000781 8D11                <1> 	lea	dx,[di+bx]	; device code to DX
  1554 00000783 EE                  <1> 	out	dx,al
  1555 00000784 5B                  <1> 	pop	bx
  1556 00000785 C3                  <1> 	ret
  1557                              <1> udet_get:
  1558 00000786 53                  <1> 	push	bx
  1559 00000787 83E307              <1> 	and	bx,7		; mask to uart offset
  1560 0000078A 8D11                <1> 	lea	dx,[di+bx]	; device code to DX
  1561 0000078C EC                  <1> 	in	al,dx
  1562 0000078D 5B                  <1> 	pop	bx
  1563 0000078E C3                  <1> 	ret
  1564                              <1> 
  1565                              <1> 
  1566                              <1> ;;; end of UART_DET.ASM
  1392                                  %endif
  1393                                  
  1394                                  ;========================================================================
  1395                                  ; uart_putchar - write the character in teletype mode
  1396                                  ; Input:
  1397                                  ;	AL = character
  1398                                  ;========================================================================
  1399                                          global  @VIDEO_putchar
  1400                                  	global  @uart_putchar
  1401                                  @VIDEO_putchar:
  1402                                  @uart_putchar:
  1403 0000078F 50                              push    ax
  1404 00000790 53                              push    bx
  1405 00000791 B40E                            mov     ah,0Eh
  1406 00000793 BB0700                          mov     bx,0007h        ; page 0, normal attributes
  1407 00000796 CD10                            int     10h
  1408 00000798 5B                              pop     bx
  1409 00000799 58                              pop     ax
  1410 0000079A C3                              ret
  1411                                  
  1412                                  ;========================================================================
