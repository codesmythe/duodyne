     1                                  %ifndef SOFT_DEBUG
     2                                  ;;;%define SOFT_DEBUG 1
     3                                  %endif
     4                                  ;========================================================================
     5                                  ; int10ser.asm -- Video display services implementation using serial port
     6                                  ;========================================================================
     7                                  ;
     8                                  ;    Compiles with NASM 2.07, might work with other versions
     9                                  ;
    10                                  ; Copyright (C) 2010 Sergey Kiselev.
    11                                  ;     additions and modifications for ColorVDU:
    12                                  ; Copyright (C) 2012 John R. Coffman.
    13                                  ; Provided for hobbyist use on the N8VEM SBC-188 board.
    14                                  ;  
    15                                  ; This program is free software: you can redistribute it and/or modify
    16                                  ; it under the terms of the GNU General Public License as published by
    17                                  ; the Free Software Foundation, either version 3 of the License, or
    18                                  ; (at your option) any later version.
    19                                  ;
    20                                  ; This program is distributed in the hope that it will be useful,
    21                                  ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    22                                  ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    23                                  ; GNU General Public License for more details.
    24                                  ;
    25                                  ; You should have received a copy of the GNU General Public License
    26                                  ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    27                                  ;
    28                                  ; TODO:
    29                                  ;       Complete the WYSE character attribute emulation -- JRC
    30                                  ;========================================================================
    31                                  
    32                                  %include	"config.asm"
    33                              <1> ;/*
    34                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    35                              <1> ; ANSI.CFG
    36                              <1> ;   Copied to CONFIG.ASM for general release.
    37                              <1> ;
    38                              <1> ;       Modify the parameters below to reflect your system
    39                              <1> ;
    40                              <1> ;
    41                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    42                              <1> ;
    43                              <1> ;   Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    44                              <1> ;   Provided for hobbyist use on the N8VEM SBC-188 board.
    45                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    46                              <1> ;
    47                              <1> ; Define the serial terminal that the Video BIOS must emulate
    48                              <1> ; Set one of the following to 1
    49                              <1> ; If you have no idea what to choose, set TTY to 1
    50                              <1> TTY     equ     0       ; hardcopy -- cannot position the cursor
    51                              <1> DUMB    equ     0       ; dumb CRT -- ^H, ^J, ^K, ^L can move the cursor
    52                              <1> ANSI    equ     1       ; very smart, like a VT-100
    53                              <1> WYSE    equ     0       ; very smart Wyse series (30, 50, ...)
    54                              <1> ; others may get added in the future
    55                              <1> ;  ONE OF THE ABOVE must BE SET TO 1!!!!!
    56                              <1> ;
    57                              <1> ; Does the hardware configuration contain the Color Video Display Unit?
    58                              <1> ; Both the 8563 and the 8242 are used.  The default is CVDU=0
    59                              <1> CVDU	equ	0	; system does not have the CVDU
    60                              <1> ;
    61                              <1> ; Does the hardware configuration contain the VGA3 a/n Video card?
    62                              <1> ; The 8563 will be disabled, but the 8242 code is shared with the CVDU
    63                              <1> ; The default is VGA3=0
    64                              <1> VGA3    equ     0       ; system does not have the VGA3
    65                              <1> %if 0
    66                              <1> 	*/
    67                              <1> #define VGA3 0
    68                              <1> /*
    69                              <1> %endif
    70                              <1> ;
    71                              <1> ; Boot up keyboard mode:  20h for NumLock on
    72                              <1> ;CVDU_KEYBOARD_STATUS	equ	0	; NumLock OFF
    73                              <1> CVDU_KEYBOARD_STATUS	equ	20h	; NumLock ON
    74                              <1> 
    75                              <1> ; Define the UART startup bit rate - 1200-19200 are most common
    76                              <1> ;UART_RATE	equ	0		; 1200
    77                              <1> ;UART_RATE	equ	1		; 2400
    78                              <1> ;UART_RATE	equ	2		; 4800
    79                              <1> UART_RATE	equ	3		; 9600
    80                              <1> ;UART_RATE	equ	4		; 19200
    81                              <1> ;UART_RATE	equ	5		; 38400
    82                              <1> ;UART_RATE	equ	6		; 57600
    83                              <1> ;UART_RATE	equ	7		; 115200
    84                              <1> 
    85                              <1> ; Does the serial terminal use the DSR/DTR protocol for flow control?
    86                              <1> ;UART_DSR_PROTOCOL	equ		1	; Yes!
    87                              <1> UART_DSR_PROTOCOL       equ             WYSE    ; Wyse always uses it
    88                              <1> 						; but not ANSI
    89                              <1> ; Define the size of the ROM image on the system in Kilobytes
    90                              <1> ; It may be smaller than the actual EPROM in use.
    91                              <1> ; The following sizes are supported:  32, 64, 128, and 256
    92                              <1> %ifndef ROM
    93                              <1> ROM             equ     32              ; 64 is the default
    94                              <1> %endif
    95                              <1> 
    96                              <1> ; Define the number of Wait States at which the ROM operates
    97                              <1> ROM_WS          equ     1               ; 0..3  (1 is the default)
    98                              <1> 
    99                              <1> ; Define the size in Kilobytes of DOS RAM (low SRAM plus EMM allocate RAM)
   100                              <1> ; This is a desired size and will only be present if a 4MEM board is added
   101                              <1> RAM_DOS         equ     640
   102                              <1> 
   103                              <1> ; Define the size of the low SRAM on the system in Kilobytes
   104                              <1> ; the default is 512 kilobytes
   105                              <1> RAM             equ     512             ; (512 is the default)
   106                              <1> 
   107                              <1> ; Define the number of Wait States at which the RAM operates
   108                              <1> RAM_WS          equ     0               ; 0..3  (0 is the default)
   109                              <1> 
   110                              <1> ; Define the number of Wait States for Local Peripheral devices (600-7FF)
   111                              <1> LCL_IO_WS       equ     1               ; 0..3  (1 is the default)
   112                              <1> 
   113                              <1> ; Define the number of Wait States for ECB BUS peripheral devices (4xx)
   114                              <1> BUS_IO_WS       equ     3               ; 0..3  (3 is the default)
   115                              <1> 
   116                              <1> ; Define the time zone in which we build the Relocatable BIOS
   117                              <1> %ifndef TIMEZONE
   118                              <1> %define TIMEZONE "PST"
   119                              <1> %endif
   120                              <1> 
   121                              <1> ; Has the REDBUG debugger been loaded?
   122                              <1> %ifndef SOFT_DEBUG
   123                              <1> %define SOFT_DEBUG 0
   124                              <1> %endif
   125                              <1> 
   126                              <1> ; Should the BIOS include "Tiny BASIC" in the image?
   127                              <1> %ifndef TBASIC
   128                              <1> TBASIC          equ     1		; default is 1
   129                              <1> %endif
   130                              <1> 
   131                              <1> ; Should the BIOS include the Floating Point Emulator?  The 80188 does
   132                              <1> ; not allow a floating point co-processor, so this is probably a good idea.
   133                              <1> %ifndef FPEM
   134                              <1> FPEM            equ     1               ; default is 1
   135                              <1> %endif
   136                              <1> 
   137                              <1> ; Define the maximum number of EMM (4MEM) boards supported
   138                              <1> EMM_BOARDS      equ     4
   139                              <1> 
   140                              <1> ; Should the Floating Point Emulator use temporary storage in the EBDA
   141                              <1> ; or at locations 0280h..3FFh in low memory?
   142                              <1> %if SOFT_DEBUG
   143                              <1> FPEM_USE_EBDA   equ     FPEM            ; default is 0
   144                              <1> %else
   145                              <1> FPEM_USE_EBDA   equ     0; FPEM            ; default is 0
   146                              <1> %endif
   147                              <1> 
   148                              <1> ; Define the size of the EPROM that is to be installed on the system
   149                              <1> ; It may be larger than the actual ROM image to be generated.
   150                              <1> %ifndef CHIP
   151                              <1> CHIP            equ     64
   152                              <1> %endif
   153                              <1> 
   154                              <1> ; Does the SBC-188 00.4 board have the LS138/LS08 piggyback fix
   155                              <1> ; Set to 1 for the SBC-188 v1.0 and later production boards
   156                              <1> ;FDC_PIGGYBACK_FIX       equ     0       ; Fix not installed
   157                              <1> FDC_PIGGYBACK_FIX       equ     1       ; fix  IS  installed
   158                              <1> 
   159                              <1> ; On SBC-188 rev 00.4 board, there is a published hardware fix (2010-09-18).
   160                              <1> ; If the wiring update is installed, or you have a later board, then
   161                              <1> ; set this to 0.  If you are using the software workaround, then set this
   162                              <1> ; to 1.  The rev 1.0 board has this fix already.
   163                              <1> NEED_TIMER_FIX  equ     0               ; have revised hardware
   164                              <1> ;NEED_TIMER_FIX  equ     1               ; use workaround
   165                              <1> 
   166                              <1> ; Define the UART oscillator speed
   167                              <1> UART_OSC        equ     1843200         ; 1.8432 Mhz is specified
   168                              <1> 
   169                              <1> 
   170                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   171                              <1> ; end of the User configuration
   172                              <1> ;       Do Not modify anything below this point
   173                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   174                              <1> 
   175                              <1> CVDU_8563	equ	CVDU		; separate inits
   176                              <1> CVDU_8242	equ	CVDU|VGA3 	; separate inits
   177                              <1> VGA3_6445       equ     VGA3            ; separate inits
   178                              <1> ; Suppress all UART output in color video Mode 3
   179                              <1> UART_MODE3_SUPPRESS	equ	CVDU_8563
   180                              <1> CVDU_USE_MSDOS_KLUDGE	equ	0; CVDU_8242	; bad, bad MSDOS
   181                              <1> CVDU_USE_KBD_HOOK		equ	CVDU_8242
   182                              <1> 
   183                              <1> ; Define existence of any uart chip
   184                              <1> UART		equ	TTY+DUMB+ANSI+WYSE
   185                              <1> startuplength   equ     512                     ; may be up to 1024
   186                              <1> startseg        equ     0FFFFh - (ROM*64) + 1
   187                              <1> highrom         equ     (ROM*400h)&0FFFFh
   188                              <1> startupseg      equ     0FFFFh - (startuplength>>4) + 1
   189                              <1> bios_data_seg   equ     040h            ; segment of BIOS data area
   190                              <1> 
   191                              <1> 
   192                              <1> %define ARG(n) [bp+2+(n)*2]
   193                              <1> 
   194                              <1> %macro  check   1.nolist
   195                              <1>  %if (%1)
   196                              <1>    %error Check Failure: %1
   197                              <1>  %endif
   198                              <1> %endm
   199                              <1> %macro  range   3.nolist
   200                              <1>  %if (%1)<(%2)
   201                              <1>    %error Out of Range: %1
   202                              <1>  %elif (%1)>(%3)
   203                              <1>    %error Out of Range: %1
   204                              <1>  %endif
   205                              <1> %endm
   206                              <1> _terminal equ UART+CVDU
   207                              <1>  check   RAM_DOS&15
   208                              <1>  check   RAM&(RAM-1)
   209                              <1>  check   ROM&(ROM-1)
   210                              <1>  range   RAM,32,512
   211                              <1>  range   ROM,32,256
   212                              <1>  range   RAM_WS,0,3
   213                              <1>  range   ROM_WS,0,3
   214                              <1>  range   RAM_DOS,RAM,(1024-ROM)
   215                              <1>  range   LCL_IO_WS,0,3
   216                              <1>  range   BUS_IO_WS,0,3
   217                              <1>  range   UART_OSC,500000,16000000
   218                              <1>  range   UART_RATE,0,7
   219                              <1>  range	 UART,0,1
   220                              <1>  range	 _terminal,1,2
   221                              <1> 
   222                              <1> %ifndef SOFT_DEBUG
   223                              <1> %define SOFT_DEBUG 0
   224                              <1> %endif
   225                              <1> 
   226                              <1> %ifndef TRACE
   227                              <1> %define TRACE 0
   228                              <1> %endif
   229                              <1> 
   230                              <1> %ifdef MAKE_OBJECT_FILE
   231                              <1>         segment _DATA WORD PUBLIC CLASS=DATA
   232                              <1>         export _ROMsize
   233                              <1>         export _CHIPsize
   234                              <1> _ROMsize        dw      ROM
   235                              <1> _CHIPsize       dw      CHIP
   236                              <1> %endif
   237                              <1> ; end of the Hardware configuration file
   238                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   239                              <1> ;*/
    33                                  ANY_VIDEO	equ	(CVDU_8563|VGA3_6445)
    34                                  
    35                                  %include	"cpuregs.asm"
    36                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    37                              <1> ; CPUREGS.ASM
    38                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    39                              <1> ;
    40                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    41                              <1> ;
    42                              <1> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    43                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    44                              <1> ;
    45                              <1> ; This program is free software: you can redistribute it and/or modify
    46                              <1> ; it under the terms of the GNU General Public License as published by
    47                              <1> ; the Free Software Foundation, either version 3 of the License, or
    48                              <1> ; (at your option) any later version.
    49                              <1> ;
    50                              <1> ; This program is distributed in the hope that it will be useful,
    51                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    52                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    53                              <1> ; GNU General Public License for more details.
    54                              <1> ;
    55                              <1> ; You should have received a copy of the GNU General Public License
    56                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    57                              <1> ;
    58                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    59                              <1> %include	"macros.inc"
    60                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    61                              <2> ; MACROS.INC  
    62                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    63                              <2> ;
    64                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    65                              <2> ;
    66                              <2> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    67                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    68                              <2> ;
    69                              <2> ; This program is free software: you can redistribute it and/or modify
    70                              <2> ; it under the terms of the GNU General Public License as published by
    71                              <2> ; the Free Software Foundation, either version 3 of the License, or
    72                              <2> ; (at your option) any later version.
    73                              <2> ;
    74                              <2> ; This program is distributed in the hope that it will be useful,
    75                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    76                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    77                              <2> ; GNU General Public License for more details.
    78                              <2> ;
    79                              <2> ; You should have received a copy of the GNU General Public License
    80                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    81                              <2> ;
    82                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    83                              <2> 
    84                              <2> ; general macros for the SBC188 BIOS ASSEMBLY
    85                              <2> ;
    86                              <2> ;
    87                              <2> %ifndef __MACROS_DEFINED_
    88                              <2> %define __MACROS_DEFINED_ 1
    89                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    90                              <2> ;
    91                              <2> ; some useful macros:
    92                              <2> ;
    93                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    94                              <2> ;
    95                              <2> 	cpu	186
    96                              <2> 
    97                              <2> %imacro setloc  1.nolist
    98                              <2>  times   (%1-($-$$)) db 0FFh
    99                              <2> %endm
   100                              <2> 
   101                              <2> %imacro db_lo   1
   102                              <2>  db (%1)&255
   103                              <2> %endm
   104                              <2> 
   105                              <2> %imacro cnop    0.nolist
   106                              <2> %if SOFT_DEBUG
   107                              <2>         nop
   108                              <2> %endif
   109                              <2> %endm
   110                              <2> 
   111                              <2> %imacro popm 1-*.nolist
   112                              <2> %rep %0
   113                              <2> %ifidni %1,ALL
   114                              <2>  popa
   115                              <2> %elifidni %1,F
   116                              <2>  popf
   117                              <2> %else
   118                              <2>  pop %1
   119                              <2> %ifidni %1,DS
   120                              <2>  cnop
   121                              <2> %elifidni %1,ES
   122                              <2>  cnop
   123                              <2> %endif
   124                              <2> %endif
   125                              <2> %rotate 1
   126                              <2> %endrep
   127                              <2> %endm
   128                              <2> 
   129                              <2> %imacro pushm 1-*.nolist
   130                              <2> %rep %0
   131                              <2> %rotate -1
   132                              <2> %ifidni %1,ALL
   133                              <2>  pusha
   134                              <2> %elifidni %1,F
   135                              <2>  pushf
   136                              <2> %else
   137                              <2>  push %1
   138                              <2> %endif
   139                              <2> %endrep
   140                              <2> %endm
   141                              <2> 
   142                              <2> ;
   143                              <2> ; added from the 386EX project
   144                              <2> ;
   145                              <2> 
   146                              <2> ; call arguments
   147                              <2> %define ARG(n) [bp+2+(n)*2]
   148                              <2> 
   149                              <2> ;
   150                              <2> ; format of the BYTE initialization table:  address, byte
   151                              <2> ;
   152                              <2> %imacro  binit 2
   153                              <2>         dw      %1
   154                              <2>         db      %2
   155                              <2> %endmacro
   156                              <2> ; end with DW -1
   157                              <2> 
   158                              <2> ;
   159                              <2> ; format of the WORD initialization table:  address, word
   160                              <2> ;
   161                              <2> %imacro  winit 2
   162                              <2>         dw      %1
   163                              <2>         dw      %2
   164                              <2> %endmacro
   165                              <2> ; end with DW -1
   166                              <2> 
   167                              <2> 
   168                              <2> ; get the BIOS Data Area segment pointer to a [segment] register
   169                              <2> %imacro get_bda	1.nolist
   170                              <2> 	push	0x0040
   171                              <2> 	pop	%1
   172                              <2> 	cnop
   173                              <2> %endm
   174                              <2> 
   175                              <2> 
   176                              <2> %endif
    60                              <1> 
    61                              <1> 	cpu     186
    62                              <1> ;
    63                              <1> ;
    64                              <1> ; IBM model byte -- must be less than a 286
    65                              <1> ;
    66                              <1> ;MODEL_BYTE		equ	0FEh	; PC-XT
    67                              <1> ;SUBMODEL_BYTE		equ	0FFh	; not used
    68                              <1> 
    69                              <1> MODEL_BYTE		equ	0FEh	; PC-XT
    70                              <1> SUBMODEL_BYTE		equ	00h	;  "
    71                              <1> 
    72                              <1> 
    73                              <1> ; 80188 peripheral control register block address
    74                              <1> CPU_CSCR	        equ	0FF00h
    75                              <1> 
    76                              <1> ; Compatible Mode registers
    77                              <1> 
    78                              <1> cpu_relocation          equ     CPU_CSCR+0FEh
    79                              <1> 
    80                              <1> ; The memory and peripheral chip select register offsets from 0FF00h
    81                              <1> 
    82                              <1> cpu_umcs                equ     CPU_CSCR+0A0h          ; Upper memory select
    83                              <1> cpu_lmcs                equ     CPU_CSCR+0A2h          ; Lower memory select
    84                              <1> cpu_pacs                equ     CPU_CSCR+0A4h          ; Peripheral select
    85                              <1> cpu_mmcs                equ     CPU_CSCR+0A6h          ; Middle memory base
    86                              <1> cpu_mpcs                equ     CPU_CSCR+0A8h          ; Mid mem. & peripherals
    87                              <1> 
    88                              <1> ; Enhanced Mode registers
    89                              <1> 
    90                              <1> cpu_mdram               equ     CPU_CSCR+0E0h          ; memory partition reg.
    91                              <1> cpu_cdram               equ     CPU_CSCR+0E2h          ; clock prescaler
    92                              <1> cpu_edram               equ     CPU_CSCR+0E4h          ; Enable refresh reg.
    93                              <1> cpu_pdcon               equ     CPU_CSCR+0F0h          ; Power-Save control
    94                              <1> 
    95                              <1> 
    96                              <1> ; On-board internal peripheral equates
    97                              <1> ; Programmable Interrupt Controller
    98                              <1> PIC	        equ	CPU_CSCR+020H
    99                              <1> PIC_EOI	        equ	PIC+2           ; End Of Interrupt
   100                              <1> PIC_POLLR	equ	PIC+4
   101                              <1> PIC_POLLSR	equ	PIC+6
   102                              <1> PIC_IMASK	equ	PIC+8
   103                              <1> PIC_PMREG	equ	PIC+0AH
   104                              <1> PIC_SRVR	equ	PIC+0CH
   105                              <1> PIC_IRQR	equ	PIC+0EH
   106                              <1> PIC_IRQSR	equ	PIC+10H
   107                              <1> PIC_TCR	        equ	PIC+12H
   108                              <1> PIC_DMA0CR	equ	PIC+14H
   109                              <1> PIC_DMA1CR	equ	PIC+16H
   110                              <1> PIC_I0CON	equ	PIC+18H
   111                              <1> PIC_I1CON	equ	PIC+1AH
   112                              <1> PIC_I2CON	equ	PIC+1CH
   113                              <1> PIC_I3CON	equ	PIC+1EH
   114                              <1> 
   115                              <1> EOI_NSPEC       equ     8000h           ; Non-Specific EOI
   116                              <1> 
   117                              <1> ; Interrupt masks (Master Mode)
   118                              <1> ;
   119                              <1> mask_timer_all          equ     0001h
   120                              <1> mask_dma0               equ     0004h
   121                              <1> mask_dma1               equ     0008h
   122                              <1> mask_int0               equ     0010h
   123                              <1> mask_int1               equ     0020h
   124                              <1> mask_int2               equ     0040h
   125                              <1> mask_int3               equ     0080h
   126                              <1> 
   127                              <1> 
   128                              <1> 
   129                              <1> ; Timers
   130                              <1> TIM0	        equ	CPU_CSCR+050H
   131                              <1> TIM1	        equ	CPU_CSCR+058H
   132                              <1> TIM2	        equ	CPU_CSCR+060H
   133                              <1> 
   134                              <1> TCNT	        equ	0	; count register
   135                              <1> CMPA	        equ	2	; max count A
   136                              <1> CMPB	        equ	4	; max count B (not present on TIM2)
   137                              <1> TCON	        equ	6	; mode/control word
   138                              <1> 
   139                              <1> ; Timer control bits:
   140                              <1> tc_EN           equ     8000h   ; Enable bit
   141                              <1> tc_nINH         equ     4000h   ; not Inhibit Enable
   142                              <1> tc_INT          equ     2000h   ; Interrupt Enable
   143                              <1> tc_RIU          equ     1000h   ; Register A/B (0/1) in Use
   144                              <1> tc_MC           equ     0020h   ; Maximum Count reached
   145                              <1> tc_RTG          equ     0010h   ; Retrigger (internal source)
   146                              <1> tc_P            equ     0008h   ; Prescale internal clock (timers 0 & 1 only)
   147                              <1> tc_EXT          equ     0004h   ; External clock
   148                              <1> tc_ALT          equ     0002h   ; Alternate between A & B max count registers
   149                              <1> tc_CONT         equ     0001h   ; Continuous: continue after max count
   150                              <1> 
   151                              <1> 
   152                              <1> 
   153                              <1> 
   154                              <1> ; DMA
   155                              <1> DMA0	        equ	CPU_CSCR+0C0H
   156                              <1> DMA1	        equ	CPU_CSCR+0D0H
   157                              <1> DMASPL	        equ	0	; source pointer low
   158                              <1> DMASPU	        equ	2	; source pointer high
   159                              <1> DMADPL	        equ	4	; destination pointer low
   160                              <1> DMADPU	        equ	6	; destination pointer high
   161                              <1> DMATC	        equ	8	; terminal count
   162                              <1> DMACW	        equ	0AH	; control word
   163                              <1> 
   164                              <1> 
   165                              <1> 
   166                              <1> 
   167                              <1> 
   168                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   169                              <1> ;
   170                              <1> ;       SBC-188 external devices
   171                              <1> ;
   172                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   173                              <1> 
   174                              <1> IO_BASE			equ	0400h
   175                              <1> 
   176                              <1> 
   177                              <1> 
   178                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   179                              <1> ; The UART registers
   180                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   181                              <1> 
   182                              <1> uart_base               equ     IO_BASE+0280h
   183                              <1> uart_rbr                equ     uart_base       ;Rcvr Buffer / read only
   184                              <1> uart_thr                equ     uart_base       ;Transmit Holding / write only
   185                              <1> uart_ier                equ     uart_base+1     ;Interrupt Enable
   186                              <1> uart_iir                equ     uart_base+2     ;Interrupt Ident / read only
   187                              <1> uart_fcr                equ     uart_base+2     ;FIFO Control / write only
   188                              <1> uart_lcr                equ     uart_base+3     ;Line Control
   189                              <1> uart_mcr                equ     uart_base+4     ;Modem Control
   190                              <1> uart_lsr                equ     uart_base+5     ;Line Status
   191                              <1> uart_msr                equ     uart_base+6     ;Modem Status
   192                              <1> uart_sr			equ	uart_base+7	;Scratch
   193                              <1> 
   194                              <1> uart_dll                equ     uart_base       ;Divisor Latch LS Byte
   195                              <1> uart_dlm                equ     uart_base+1     ;Divisor Latch MS Byte
   196                              <1> 
   197                              <1> 
   198                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   199                              <1> ; Floppy controller
   200                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   201                              <1> FDC	        equ	IO_BASE+0200H
   202                              <1> FDC_MSR         equ     FDC
   203                              <1> FDC_DATA        equ     FDC_MSR+1
   204                              <1> FDC_DACK        equ	FDC+10H
   205                              <1> FDC_LDOR	equ	FDC+20H
   206                              <1> FDC_LDCR	equ	FDC+30H
   207                              <1> FDC_TC	        equ	FDC+40H
   208                              <1> FDC_DACK_TC     equ     FDC_DACK | FDC_TC
   209                              <1> 
   210                              <1> 
   211                              <1> %if SBC188==1
   212                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   213                              <1> ;DS1302 RTC
   214                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   215                              <1> RTC	equ	IO_BASE+0300H
   216                              <1> %endif
   217                              <1> 
   218                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   219                              <1> ; PIO 82C55 I/O 
   220                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   221                              <1> ; for the SBCv1/v2 with PPIDE adapter board
   222                              <1> ; and for the SBCv3 with PPIDE connector
   223                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   224                              <1> PPI	        equ	IO_BASE+0260H
   225                              <1> 
   226                              <1> PIO_A	        equ	PPI+0	; (OUTPUT)
   227                              <1> PIO_B	        equ	PPI+1	; (INPUT)
   228                              <1> PIO_C	        equ	PPI+2	; (CENTRONICS control low nibble)  
   229                              <1> PIO_CTRL	equ	PPI+3	; CONTROL BYTE PIO 82C55
   230                              <1> 
   231                              <1> portA           equ     PPI+0   ;
   232                              <1> portB           equ     PPI+1   ;
   233                              <1> portC           equ     PPI+2   ;
   234                              <1> 
   235                              <1> 
   236                              <1> 
   237                              <1> ;;;%if SBC188==3   startup.asm is universal
   238                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   239                              <1> ; CONTROL LS259 PORT ON SBC188 V3
   240                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   241                              <1> CTRL259		equ	IO_BASE+0270H
   242                              <1> ; LEDS are at addresses 0..3
   243                              <1> ; other control ports on 4..7
   244                              <1> LED0		equ	CTRL259+0
   245                              <1> LED1		equ	LED0+1
   246                              <1> LED2		equ	LED0+2
   247                              <1> LED3		equ	LED0+3
   248                              <1> T1OSC18		equ	CTRL259+4	; ON=1.8432mhz, OFF="1" (for use of TIMER2)
   249                              <1> ;unused		equ	CTRL259+5
   250                              <1> FDC_RES		equ	CTRL259+6	; RESET IS ACTIVE HIGH
   251                              <1> IDE8_RES	equ	CTRL259+7	; fast IDE RESET IS ACTIVE LOW
   252                              <1> 
   253                              <1> 
   254                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   255                              <1> ; FIDE8 8-bit IDE on the 80C188 bus
   256                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   257                              <1> FIDE_BASE       equ     IO_BASE+2C0h
   258                              <1> 
   259                              <1> IDE8_CS0        equ     FIDE_BASE
   260                              <1> IDE8_CS1        equ     FIDE_BASE+0x10
   261                              <1> 
   262                              <1> ;;;%endif   startup.asm is universal
   263                              <1> 
   264                              <1> 
   265                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   266                              <1> ; Dual [DMA] IDE devices
   267                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   268                              <1> DIDE		equ	IO_BASE + 20H	; range 0x20..0x3F
   269                              <1> 
   270                              <1> DIDE0		equ	DIDE		; first interface (master & slave)
   271                              <1> DIDE1		equ	DIDE+10h	; second interface (master & slave)
   272                              <1> 
   273                              <1> 
   274                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   275                              <1> ; DISK I/O v3 device codes (PPIDE only)
   276                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   277                              <1> DISKIO		equ	IO_BASE + 20h	; range 0x20..0x3F
   278                              <1> 
   279                              <1> DISKIO_PPIDE	equ	DISKIO		; 82c55
   280                              <1> DISKIO_FDC	equ	DISKIO + 10h	; FDC 9266
   281                              <1> DISKIO_DOR	equ	DISKIO + 18h	; OPERATION REGISTER	
   282                              <1> 
   283                              <1> 
   284                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   285                              <1> ; MF/PIC interfaces
   286                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   287                              <1> MFPIC		equ	IO_BASE + 40h	; range 0x40..0x4F
   288                              <1> 
   289                              <1> ;MFPIC_202	equ	MFPIC		; NS32202 is not usable on SBC-188
   290                              <1> MFPIC_PPIDE	equ	MFPIC + 4	; PPIDE disk interface
   291                              <1> MFPIC_UART	equ	MFPIC + 8	; TL16Cx50 SIO chip
   292                              <1> 
   293                              <1> 
   294                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   295                              <1> ; Cassette I/O
   296                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   297                              <1> cuart_base	EQU 	IO_BASE+80H	; BASE IO ADDRESS OF CASSETTE UART
   298                              <1> cuart_rbr	equ     cuart_base	;Rcvr Buffer / read only
   299                              <1> cuart_thr	equ     cuart_base	;Transmit Holding / write only
   300                              <1> cuart_ier	equ     cuart_base+1	;Interrupt Enable
   301                              <1> cuart_iir	equ     cuart_base+2	;Interrupt Ident / read only
   302                              <1> cuart_fcr	equ     cuart_base+2	;FIFO Control / write only
   303                              <1> cuart_lcr	equ     cuart_base+3	;Line Control
   304                              <1> cuart_mcr	equ     cuart_base+4	;Modem Control
   305                              <1> cuart_lsr	equ     cuart_base+5	;Line Status
   306                              <1> cuart_msr	equ     cuart_base+6	;Modem Status
   307                              <1> cuart_sr	equ	cuart_base+7	;Scratch
   308                              <1> 
   309                              <1> cuart_dll	equ     cuart_base	;Divisor Latch LS Byte
   310                              <1> cuart_dlm	equ	cuart_base+1	;Divisor Latch MS Byte
   311                              <1> 
   312                              <1> 
   313                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   314                              <1> ;
   315                              <1> ;       4MEM control registers
   316                              <1> ;
   317                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   318                              <1> EMM_addr        equ     1               ; high 6 bits of 20-bit address
   319                              <1> EMM_page        equ     0               ; 4MEM page in [0..254]
   320                              <1> 
   321                              <1> EMM_BASE        equ     IO_BASE + 000h          ; first EMM (4MEM) board
   322                              <1> EMM_unmapped    equ     255             ; unmapped 4MEM page
   323                              <1> 
   324                              <1> EMM0            equ     EMM_BASE        ; first  EMM board
   325                              <1> EMM1            equ     EMM0 + 2        ; second EMM board
   326                              <1> EMM2            equ     EMM1 + 2        ; third  EMM board
   327                              <1> EMM3            equ     EMM2 + 2        ; fourth EMM board
   328                              <1> 
   329                              <1> 
   330                              <1> 
   331                              <1> 
   332                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   333                              <1> ;
   334                              <1> ;	ColorVDU devices
   335                              <1> ;
   336                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   337                              <1> ;
   338                              <1> ;	major select on the Z80 bus
   339                              <1> ;
   340                              <1> devCVDU_8bit	equ	0xE0		; this may change to 0x10
   341                              <1> 
   342                              <1> devCVDUbase 	equ	IO_BASE + devCVDU_8bit
   343                              <1> 
   344                              <1> M8563status	equ	devCVDUbase + 4		; 4 == bitrev(2)
   345                              <1> M8563register	equ	devCVDUbase + 4
   346                              <1> M8563data	equ	devCVDUbase + 12	; 12 == bitrev(3)
   347                              <1> 
   348                              <1> %if CVDU_8563
   349                              <1> I8242status	equ	devCVDUbase + 10	; 10 == bitrev(5)
   350                              <1> I8242command	equ	devCVDUbase + 10
   351                              <1> I8242data	equ	devCVDUbase + 2		; 2 == bitrev(4)
   352                              <1> %endif
   353                              <1> 
   354                              <1> 
   355                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   356                              <1> ;
   357                              <1> ;	VGA3 devices
   358                              <1> ;
   359                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   360                              <1> ;
   361                              <1> ;	major select on the Z80 bus
   362                              <1> ;
   363                              <1> devVGA3_8bit    equ     0xE0                    ; same as CVDU
   364                              <1> 
   365                              <1> devVGA3base       equ     IO_BASE + devVGA3_8bit
   366                              <1> 
   367                              <1> %if VGA3_6445
   368                              <1> I8242status	equ	devVGA3base + 1
   369                              <1> I8242command	equ	devVGA3base + 1
   370                              <1> I8242data	equ	devVGA3base + 0
   371                              <1> %endif
   372                              <1> HD6445addr	equ	devVGA3base + 2		; to address the HD6445 registers
   373                              <1> HD6445reg	equ	devVGA3base + 3		; to r/w a register on the CRTC
   374                              <1> 
   375                              <1> vga3cfg		equ	devVGA3base + 4
   376                              <1> ; the following are probably not used on the SBC-188, except for testing/checking
   377                              <1> vga3adhi	equ	devVGA3base + 5
   378                              <1> vga3adlo	equ	devVGA3base + 6
   379                              <1> vga3data	equ	devVGA3base + 7
   380                              <1> 
   381                              <1> 
   382                              <1> 
   383                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   384                              <1> ;
   385                              <1> ;       2S1P registers
   386                              <1> ;
   387                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   388                              <1> dev_2S1P_loc		equ	0xC0	; same as 4UART !!!
   389                              <1> 
   390                              <1> dev_2S1P_base		equ	IO_BASE + dev_2S1P_loc	
   391                              <1> 
   392                              <1> dev_2S1P_A		equ	dev_2S1P_base		; serial port
   393                              <1> dev_2S1P_B		equ	dev_2S1P_base + 8h	; serial port
   394                              <1> 
   395                              <1> dev_2S1P_C		equ	dev_2S1P_base + 10h	; parallel port
   396                              <1> 
   397                              <1> 
   398                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   399                              <1> ;
   400                              <1> ;       4UART registers
   401                              <1> ;
   402                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   403                              <1> dev_4UART_loc		equ	0xC0	; same as 2S1P !!!
   404                              <1> ;				0xA0	; possible alternate
   405                              <1> dev_4UART_alt_offset	equ	0xA0 - dev_4UART_loc
   406                              <1> 
   407                              <1> dev_4UART_base		equ	IO_BASE + dev_4UART_loc	
   408                              <1> 
   409                              <1> dev_4UART_A		equ	dev_4UART_base
   410                              <1> dev_4UART_B		equ	dev_4UART_base + 8h
   411                              <1> dev_4UART_C		equ	dev_4UART_base + 10h
   412                              <1> dev_4UART_D		equ	dev_4UART_base + 18h
   413                              <1> 
   414                              <1> dev_4UART_config	equ	dev_4UART_B + 7		; overlays scratch register
   415                              <1> 
   416                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   417                              <1> ; debug port -- JRC only
   418                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   419                              <1> portD		equ	IO_BASE + 0FFh		; 0x04FF
   420                              <1> ;portD		equ	portB		     ; older 8255 output on PPI
   421                              <1> 
   422                              <1> ; end CPUREGS.ASM
   423                              <1> 
    36                                  %include	"equates.asm"
    37                              <1> ;========================================================================
    38                              <1> ; EQUATES.ASM -- Lots of Defintions for Relocatable BIOS
    39                              <1> ;========================================================================
    40                              <1> ;   for the N8VEM SBC-188 v.00.4 and 00.5
    41                              <1> ;
    42                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    43                              <1> ;
    44                              <1> ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
    45                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    46                              <1> ;
    47                              <1> ; This program is free software: you can redistribute it and/or modify
    48                              <1> ; it under the terms of the GNU General Public License as published by
    49                              <1> ; the Free Software Foundation, either version 3 of the License, or
    50                              <1> ; (at your option) any later version.
    51                              <1> ;
    52                              <1> ; This program is distributed in the hope that it will be useful,
    53                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    54                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    55                              <1> ; GNU General Public License for more details.
    56                              <1> ;
    57                              <1> ; You should have received a copy of the GNU General Public License
    58                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    59                              <1> ;
    60                              <1> ;========================================================================
    61                              <1> 
    62                              <1>         global  FPEM_segment
    63                              <1> 
    64                              <1> 
    65                              <1> %include "segdef.asm"
    66                              <2> ;========================================================================
    67                              <2> ; SEGDEF.ASM -- Lots of Defintions for Relocatable BIOS
    68                              <2> ;========================================================================
    69                              <2> ;   for the N8VEM SBC-188 v.00.4 and 00.5
    70                              <2> ;
    71                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    72                              <2> ;
    73                              <2> ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
    74                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    75                              <2> ;
    76                              <2> ; This program is free software: you can redistribute it and/or modify
    77                              <2> ; it under the terms of the GNU General Public License as published by
    78                              <2> ; the Free Software Foundation, either version 3 of the License, or
    79                              <2> ; (at your option) any later version.
    80                              <2> ;
    81                              <2> ; This program is distributed in the hope that it will be useful,
    82                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    83                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    84                              <2> ; GNU General Public License for more details.
    85                              <2> ;
    86                              <2> ; You should have received a copy of the GNU General Public License
    87                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    88                              <2> ;
    89                              <2> ;========================================================================
    90                              <2> 
    91                              <2> %ifndef __SEGDEF_
    92                              <2> %define __SEGDEF_
    93                              <2> 
    94                              <2> 	SEGMENT  _TEXT ALIGN=2 PUBLIC CLASS=CODE
    95                              <2>         SEGMENT  CONST ALIGN=2 PUBLIC CLASS=DATA
    96                              <2>         SEGMENT  CONST2 ALIGN=2 PUBLIC CLASS=DATA
    97                              <2> 	SEGMENT  _DATA ALIGN=16 PUBLIC CLASS=DATA
    98                              <2> 	SEGMENT  _BSS  ALIGN=2 PUBLIC CLASS=BSS
    99                              <2> ;;;        SEGMENT  _BASIC ALIGN=16 PUBLIC CLASS=BASIC
   100                              <2> 
   101                              <2> 	GROUP	DGROUP CONST CONST2 _DATA _BSS
   102                              <2> 
   103                              <2> %endif
   104                              <2> 
    66                              <1> %include "ascii.asm"
    67                              <2> ; ascii.asm
    68                              <2> ;
    69                              <2> CTRL            equ     1Fh     ; masks a character to CTRL-x
    70                              <2> 
    71                              <2> NUL     equ     00h
    72                              <2> BEL     equ     (CTRL & 'G')
    73                              <2> BS      equ     08h		; ^H
    74                              <2> HT      equ     09h		; ^I
    75                              <2> LF	equ	0Ah		; ^J
    76                              <2> NL      equ     LF
    77                              <2> VT	equ	0Bh		; ^K
    78                              <2> FWD	equ	0Ch		; ^L
    79                              <2> CR	equ	0Dh
    80                              <2> XON     equ     (CTRL & 'Q')
    81                              <2> XOFF    equ     (CTRL & 'S')
    82                              <2> DC1     equ     XON
    83                              <2> DC3     equ     XOFF
    84                              <2> ESC     equ	1Bh
    85                              <2> 
    86                              <2> 
    67                              <1> 
    68                              <1> 
    69                              <1> ; POST error codes. Presently one byte but can expand to word.
    70                              <1> ER_BIOS equ	01h		; Bad ROM bios checksum, patch last byte
    71                              <1> ER_RAM	equ	02h		; Bad RAM in main memory, replace
    72                              <1> ER_CRT	equ	04h		; Bad RAM in video card, replace
    73                              <1> ER_FDC	equ	08h		; Bad FDC
    74                              <1> ER_UNK1	equ	10h		; {unassigned}
    75                              <1> ER_MEM	equ	20h		; Bad RAM in vector area, replace
    76                              <1> ER_ROM	equ	40h		; Bad ROM in expansion area, bad checksum
    77                              <1> ER_UNK2	equ	80h		; {unassigned}
    78                              <1> 
    79                              <1> 
    80                              <1> 
    81                              <1> ;; ************************ BIOS Data Segment ******************************
    82                              <1> ;; BIOS data segment - not all will  be used
    83                              <1> ;                struc   BIOS_DATA_AREA  ; at 0040:0000
    84                              <1> %include "bda.inc"
    85                              <2> ;/*======================================================================
    86                              <2> ; bda.inc -- BIOS data area definitions
    87                              <2> ;========================================================================
    88                              <2> ;   for the N8VEM SBC-188
    89                              <2> ;
    90                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    91                              <2> ;
    92                              <2> ; Copyright (C) 2013 John R. Coffman.  All rights reserved.
    93                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    94                              <2> ;
    95                              <2> ; This program is free software: you can redistribute it and/or modify
    96                              <2> ; it under the terms of the GNU General Public License as published by
    97                              <2> ; the Free Software Foundation, either version 3 of the License, or
    98                              <2> ; (at your option) any later version.
    99                              <2> ;
   100                              <2> ; This program is distributed in the hope that it will be useful,
   101                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   102                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   103                              <2> ; GNU General Public License for more details.
   104                              <2> ;
   105                              <2> ; You should have received a copy of the GNU General Public License
   106                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   107                              <2> ;
   108                              <2> ;========================================================================
   109                              <2> 
   110                              <2> 			;*/ extern				/*
   111                              <2> 	ABSOLUTE  0	;*/ struct BDA {			/*
   112 00000000 ????????????????    <2> serial_ports    resw    4	;*/	word	serial_ports[4];	/*
   113 00000008 ????????????????    <2> parallel_ports  resw    4	;*/	word	parallel_ports[4];	/*
   114 00000010 ????                <2> equipment_flag  resw    1	;*/	EQFL	equipment_flag;		/*
   115                              <2> ;	dw	?		; 40:10 	; Equipment present word
   116                              <2> ;  						;  = (1 iff floppies) *     1.
   117                              <2> ;                                               ;  + (1 iff 187     ) *     2.
   118                              <2> ;  						;  + (#+1 64K sys ram) *    4.
   119                              <2> ;  						;  + (init crt mode ) *    16.
   120                              <2> ;  						;  + (# of floppies ) *    64.
   121                              <2> ;  						;  + (# serial ports) *   512.
   122                              <2> ;  						;  + (1 iff toy port) *  4096.
   123                              <2> ;                                               ;  + (1 iff modem   ) *  8192.
   124                              <2> ;  						;  + (# parallel LPT) * 16384.
   125 00000012 ??                  <2> mfg_test_flags  resb    1	;*/	byte	mfg_test_flags;	/* 40:12 unused by us
   126 00000013 ????                <2> memory_size     resw    1	;*/	word	memory_size;	/* 40:13 kilobytes
   127                              <2> uart_kbd_ctrl_R	equ	$	;*/				/*** JRC: count of ctrl-R's for reboot
   128 00000015 ??                  <2> IPL_errors      resb    1	;*/	byte	IPL_errors;	/* 40:15 IPL errors<-table/scratchpad
   129 00000016 ??                  <2> sbc188_rev       resb    1	;*/	byte	sbc188_rev;	/* was 'unused_01' before BIOS047
   130                              <2> ;;---------------[Keyboard data area]------------;
   131 00000017 ????                <2> keyboard_flags_0 resw   1	;*/	word	keyboard_flags_0;  /* 40:17 Shift/Alt/etc. keyboard flags
   132                              <2> keyboard_flags_1 equ	$-1	;     2nd byte	keyboard_flags_1;  
   133 00000019 ??                  <2> keypad_char	resb	1	;*/	byte	keypad_char;	/* 40:19 Alt-KEYPAD char. goes here
   134 0000001A ????                <2> kbd_buffer_head resw    1	;*/	word	kbd_buffer_head;   /* 40:1A --> keyboard buffer head
   135 0000001C ????                <2> kbd_buffer_tail resw    1	;*/	word	kbd_buffer_tail;   /* 40:1C --> keyboard buffer tail
   136 0000001E <res 20h>           <2> kbd_buffer      resw    16	;*/	word	kbd_buffer[16];	/* 40:1E Keyboard Buffer (Scan,Value)
   137                              <2> kbd_buffer_last	equ	$	;*/				/*
   138                              <2> ;;---------------[Diskette data area]------------;
   139 0000003E ??                  <2> fdc_drv_calib   resb    1	;*/	byte	fdc_drive_calib;   /* 40:3E
   140 0000003F ??                  <2> fdc_motor_LDOR  resb    1	;*/	byte	fdc_motor_LDOR;	   /* 40:3F Motor, DMA, select control
   141 00000040 ??                  <2> fdc_motor_ticks resb    1	;*/	byte	fdc_motor_ticks;   /* 40:40 ticks til motor off
   142 00000041 ??                  <2> fdc_status      resb    1	;*/	byte	fdc_status;	   /* 40:41
   143                              <2> ;				Floppy return code stat byte
   144                              <2> ;				;  1 = bad ic 765 command req.
   145                              <2> ;				;  2 = address mark not found
   146                              <2> ;				;  3 = write to protected disk
   147                              <2> ;				;  4 = sector not found
   148                              <2> ;				;  8 = data late (DMA overrun)
   149                              <2> ;				;  9 = DMA failed 64K page end
   150                              <2> ;				; 16 = bad CRC on floppy read
   151                              <2> ;				; 32 = bad NEC 765 controller
   152                              <2> ;				; 64 = seek operation failed
   153                              <2> ;				;128 = disk drive timed out
   154 00000042 ??????????????      <2> fdc_ctrl_status resb    7	;*/	byte	fdc_ctrl_status[7];  /* 40:42 Status bytes from NEC 765
   155                              <2> ;;---------------[Video display area]------------;
   156 00000049 ??                  <2> video_mode      resb    1	;*/	byte	video_mode;	/* 40:49
   157                              <2> ;			 	; Current CRT mode  (software)
   158                              <2> ;				;  0 = 40 x 25 text (no color)
   159                              <2> ;				;  1 = 40 x 25 text (16 color)
   160                              <2> ;				;  2 = 80 x 25 text (no color)
   161                              <2> ;				;  3 = 80 x 25 text (16 color)
   162                              <2> ;				;  4 = 320 x 200 grafix 4 color
   163                              <2> ;				;  5 = 320 x 200 grafix 0 color
   164                              <2> ;				;  6 = 640 x 200 grafix 0 color
   165                              <2> ;				;  7 = 80 x 25 text (mono card)
   166 0000004A ????                <2> video_columns   resw    1	;*/	word video_columns;	/* 40:4A Columns on CRT screen
   167 0000004C ????                <2> video_regen_bytes  resw 1	;*/	word video_regen_bytes;	/* 40:4C Bytes in the regen region
   168 0000004E ????                <2> video_regen_offset resw 1	;*/	word video_regen_offset;/* 40:4E Byte offset in regen region
   169 00000050 <res 10h>           <2> video_cursor_pos  resw  8	;*/	word video_cursor_pos[8];  /* 40:50 Cursor pos for up to 8 pages
   170 00000060 ????                <2> video_cursor_mode resw  1	;*/	word video_cursor_mode;	/* 40:60 Current cursor mode setting
   171 00000062 ??                  <2> video_page      resb    1	;*/	byte video_page;	/* 40:62 Current page on display
   172 00000063 ????                <2> video_base_seg  resw    1	;*/	word video_base_seg;	/* 40:63 Base address (B000h or B800h)
   173 00000065 ??                  <2> video_hw_mode   resb    1	;*/	byte video_hw_mode;	/* 40:65 ic 6845 mode reg. (hardware)
   174 00000066 ??                  <2> video_cga_palette resb  1	;*/	byte video_cga_palette;	/* 40:66 Current CGA palette
   175                              <2> ;;---------------[Used to setup ROM]-------------;
   176 00000067 ????????            <2> eprom_address   resd    1	;*/	dword eprom_address;	/* 40:67 Eprom base Offset,Segment
   177 0000006B ??                  <2> spurious_irq    resb    1	;*/	byte spurious_irq;	/* 40:6B Last spurious interrupt IRQ
   178                              <2> ;;---------------[Timer data area]---------------;
   179 0000006C ????????            <2> timer_ticks     resd    1	;*/	dword timer_ticks;	/* 40:6C Ticks since midnight (lo,hi)
   180 00000070 ??                  <2> timer_new_day   resb    1	;*/	byte timer_new_day;	/* 40:70 Non-zero if new day
   181                              <2> ;;---------------[System data area]--------------;
   182 00000071 ??                  <2> break_flag      resb    1	;*/	byte break_flag;	/* 40:71 Sign bit set iff break
   183 00000072 ????                <2> warm_boot       resw    1	;*/	word warm_boot;		/* 40:72 Warm boot iff==1234h
   184                              <2> ;;---------------[Hard disk scratchpad]----------;
   185 00000074 ????????            <2> hdd_scratch     resd    1	;*/	word hdd_scratch[2];	/* 40:74
   186                              <2> ;;---------------[Timout areas/PRT/LPT]----------;
   187 00000078 ????????            <2> lpt_timeout     resb    4	;*/	byte lpt_timeout[4];	/* 40:78 Ticks for LPT 1-4 timeouts
   188 0000007C ????????            <2> com_timeout     resb    4	;*/	byte com_timeout[4];	/* 40:7C Ticks for COM 1-4 timeouts
   189                              <2> ;;---obsolete----[Keyboard buf start/end]---jrc--;
   190 00000080 ????                <2> kbd_buffer_start resw   1	;*/	word kbd_buffer_start;	/* 40:80 KBD buffer head (PC/AT)
   191 00000082 ????                <2> kbd_buffer_end  resw    1	;*/	word kbd_buffer_end;	/* 40:82 KBD buffer tail (PC/AT)
   192                              <2> ;;---------------[EGA stuff]---------------------;
   193 00000084 ??????????????      <2> EGA_stuff	resb	7	;*/	byte EGA_stuff[7];	/* 40:84 Unspecified EGA data
   194                              <2> ;;---------------[Floppy/Fixed Media Info]-------------;
   195 0000008B ??                  <2> fdc_last_rate	resb	1	;*/	byte fdc_last_rate;	/* 40:8B Last floppy step rate/data rate?
   196 0000008C ????????            <2> fx_misc_unused	resb	4	;*/	byte fx_misc_unused[4];	/* 40:8C Fixed disk miscellaneous ???
   197 00000090 ????                <2> fdc_disk_state	resb	2	;*/	byte fdc_disk_state[2];	/* 40:90 Floppy disk state
   198 00000092 ????                <2> fdc_op_start	resb	2	;*/	byte fdc_op_start[2];	/* 40:92 Floppy operation start state machine
   199 00000094 ????                <2> fdc_cylinder	resb	2	;*/	byte fdc_cylinder[2];	/* 40:94 Floppy present cylinder
   200                              <2> ;;---------------[Additional KBD flags]----------------;
   201 00000096 ??                  <2> kbd_flag_3	resb	1	;*/	byte kbd_flag_3;	/* 40:96 kbd ???
   202 00000097 ??                  <2> kbd_flag_2	resb	1	;*/	byte kbd_flag_2;	/* 40:97 kbd ???
   203                              <2> ;;---------------[RTC/timer1 data]---------------------;
   204 00000098 ????????            <2> user_semaphore	resw	2	;*/	byte *user_semaphore;	/* 40:98 User semaphore in (bit 7)
   205 0000009C ????????            <2> rtc_count	resd	1	;*/	dword rtc_count;	/* 40:9C RTC tick counter
   206 000000A0 ??                  <2> rtc_wait_active	resb	1	;*/	byte rtc_wait_active;	/* 40:A0 Busy=01, Posted=80h, 
   207                              <2> ;;---------------[Cassette I/O stuff]------------------;
   208 000000A1 ??                  <2> last_val	resb	1	;*/	byte last_val;		/* 40:A1 Last byte read value
   209 000000A2 ????                <2> crc_reg		resw	1	;*/	word crc_reg;		/* 40:A2 CRC accumulation area
   210                              <2> ;									Post Acknowleged=00;
   211 000000A4 ??                  <2> EGA_data	resb	1	;*/	byte EGA_data;		/* 40:A4 Various usage
   212 000000A5 ????                <2> SDstatus	resb	2	;*/	byte SDstatus[2];	/* 40:A5 Status byte from command
   213 000000A7 ????                <2> SDcardtype	resb	2	;*/	byte SDcardtype[2];	/* 40:A7 SDcard type SDSC=2, HC=3, ...
   214                              <2> ;
   215 000000A9 ????????            <2> fixed_disk_tab	resb	4	;*/	byte fixed_disk_tab[4];	/* dispatch table to fixed disk drivers
   216 000000AD ??                  <2> wait12_count	resb	1	;*/	byte wait12_count;	/* 40:AD 12usec CX count
   217 000000AE ??                  <2> lock_count	resb	1	;*/	byte lock_count;	/* 40:AE lock level counter
   218 000000AF ??                  <2> EMS_start       resb    1	;*/	byte EMS_start;		/* start EMS allocation from here
   219                              <2> fx80		equ	$	;*/	struct EDD_disk fx80;	/* fixed disk parameter area 0
   220 000000B0 ????                <2> fx_log_cylinders resw   1	;	word fx_log_cylinders;	 logical number of cylinders
   221 000000B2 ??                  <2> fx_log_heads    resb    1	;	byte fx_log_heads;	 logical number of heads
   222 000000B3 ??                  <2> fx_signature	resb	1	;	byte fx_signature;	 A0h signature = translated geom
   223 000000B4 ??                  <2> fx_phys_sectors	resb    1       ;	byte fx_phys_sectors;	 physical number of sectors per track
   224 000000B5 ????                <2> fx_LBA_high     resw    1       ;	word fx_LBA_high;	 high word of LBA28 number of sectors
   225 000000B7 ??                  <2> fx_reserved	resb	1	;	byte fx_reserved;	 reserved for future use
   226 000000B8 ??                  <2> fx_drive_control resb   1       ;	byte fx_drive_control;	 flag bits for IDE head register
   227 000000B9 ????                <2> fx_phys_cylinders resw	1	;	word fx_phys_cylinders;	 physical number of cylinders
   228 000000BB ??                  <2> fx_phys_heads	resb	1	;	byte fx_phys_heads;	 physical number of heads
   229 000000BC ????                <2> fx_LBA_low	resw	1	;	word fx_LBA_low;	 low word of LBA28 number of sectors
   230 000000BE ??                  <2> fx_log_sectors	resb	1	;	byte fx_log_sectors;	 logical number of sectors per track
   231 000000BF ??                  <2> fx_checksum	resb	1	;	byte fx_checksum;	 checksum, dunno how to compute
   232 000000C0 <res 10h>           <2> fx81            resb    16	;*/	struct EDD_disk fx81;	/* fixed disk parameter area 1
   233 000000D0 <res 10h>           <2> fx82            resb    16	;*/	struct EDD_disk fx82;	/* fixed disk parameter area 2
   234 000000E0 <res 10h>           <2> fx83            resb    16	;*/	struct EDD_disk fx83;	/* fixed disk parameter area 3
   235                              <2> ;
   236                              <2> ;
   237                              <2> 
   238 000000F0 ????                <2> FPEM_segment    resw    1       ;*/	word FPEM_segment;	/* FPEM data segment
   239                              <2> 
   240 000000F2 ????                <2> EBDA_paragraph  resw    1       ;*/	word EBDA_paragraph;	/* lowest EBDA paragraph
   241                              <2> 
   242 000000F4 ????                <2> dma0_cw         resw    1       ;*/	word dma0_cw;		/* end of dma control word
   243 000000F6 ????                <2> dma1_cw         resw    1       ;*/	word dma1_cw;		/*   ditto
   244                              <2> 
   245 000000F8 ????                <2> fdc_type	resb	2	;*/	byte fdc_type[2];	/* disk type in low nibble, alternate in hi nib 
   246                              <2> 
   247 000000FA ????????            <2> debug_static_ptr  resw	2	;*/	void *debug_static_ptr;	/* pointer to debug static area
   248                              <2> 
   249 000000FE ??                  <2> n_fixed_disks   resb    1       ;*/	byte n_fixed_disks;	/* number of fixed disks
   250                              <2> 
   251 000000FF ??                  <2> cpu_xtal        resb    1       ;*/	byte cpu_xtal;		/* CPU crystal frequency in Mhz 
   252                              <2> ;								   CPU clock is half of this
   253                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   254                              <2> ;
   255                              <2> ;  System configuration stuff below
   256                              <2> ;	c.f., CONFIG.ASM (ANSI.CFG, CVDU.CFG, etc.), User configuration stuff
   257                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   258                              <2> %if 0				;*/
   259                              <2> #define FIXED_DISK_MAX 4		/*
   260                              <2> %else
   261                              <2> %define FIXED_DISK_MAX 4
   262                              <2> %endif
   263                              <2> %if 0				;*/
   264                              <2> #define PPIDE_driver 1		/*
   265                              <2> %else
   266                              <2> %define PPIDE_driver 1
   267                              <2> %endif
   268                              <2> %if 0				;*/
   269                              <2> #define DIDE_driver 0		/*
   270                              <2> %else
   271                              <2> %define DIDE_driver 0
   272                              <2> %endif
   273                              <2> %if 0				;*/
   274                              <2> #define DISKIO_driver 1		/*
   275                              <2> %else
   276                              <2> %define DISKIO_driver 1
   277                              <2> %endif
   278                              <2> %if 0				;*/
   279                              <2> #define MFPIC_driver 1		/*
   280                              <2> %else
   281                              <2> %define MFPIC_driver 1
   282                              <2> %endif
   283                              <2> %if 0				;*/
   284                              <2> #define DSD_driver 1		/*
   285                              <2> %else
   286                              <2> %define DSD_driver 1
   287                              <2> %endif
   288                              <2> %if 0				;*/
   289                              <2> #define V3IDE8_driver (SBC188==3)		/*
   290                              <2> %else
   291                              <2> %define V3IDE8_driver (SBC188==3)
   292                              <2> %endif
   293                              <2> 				;*/
    85                              <1> 
    86                              <1> ;  this must be the same in EQUATES.H */
    87                              <1> %if SOFT_DEBUG
    88                              <1> %define NBREAK  8
    89                              <1> %endif
    90                              <1> 
    91                              <1> 
    92                              <1> %if 0
    93                              <1>         segment _TEXT
    94                              <1> ;; *************************************************************************
    95                              <1> 
    96                              <1> 
    97                              <1> 
    98                              <1> 
    99                              <1> ;; ************************ DOS Data Segment *******************************
   100                              <1> ;dosdir	SEGMENT at 50h				; Boot disk directory from IPL
   101                              <1> ;xerox	label	byte				;  0 if Print Screen idle
   102                              <1> ;						;  1 if PrtSc xeroxing screen
   103                              <1> ;						;255 if PrtSc error in xerox
   104                              <1> ;						;  ...non-grafix PrtSc in bios
   105                              <1> ;	db	200h dup(?)			; PC-DOS bootstrap procedure
   106                              <1> ;						;  ...IBMBIO.COM buffers the
   107                              <1> ;						;  ...directory of the boot
   108                              <1> ;						;  ...device here at IPL time
   109                              <1> ;						;  ...when locating the guts
   110                              <1> ;						;  ...of the operating system
   111                              <1> ;						;  ...filename "IBMDOS.COM"
   112                              <1> ;dosdir	ends
   113                              <1> ;; *************************************************************************
   114                              <1> ;; ************************ DOS IPL Segment ********************************
   115                              <1> ;dosseg	SEGMENT at 70h				; "Kernel" of PC-DOS op sys
   116                              <1> ;;IBMBIO.COM file loaded by boot block. Device Drivers/Bootstrap. CONTIGUOUS<---
   117                              <1> ;;IBMDOS.COM operating system nucleus immediately follows IBMBIO.COM and       !
   118                              <1> ;;     doesn`t have to be contiguous.  The IBMDOS operating system nucleus     !
   119                              <1> ;;     binary image is loaded by transient code in IBMBIO binary image	      !
   120                              <1> ;dosseg	ends					;			      !
   121                              <1> ;iplseg	SEGMENT at 0h				; Segment for boot block      !
   122                              <1> ;;The following boot block is loaded with 512 bytes on the first sector of     !
   123                              <1> ;;the bootable device by code resident in the ROM-resident bios.  Control is   !
   124                              <1> ;;then transferred to the first word 0000:7C00 of the disk-resident bootstrap  !
   125                              <1> ;	ORG	07C00h				;  ..offset for boot block    !
   126                              <1> ;boot	db	200h dup(?)			;  ..start disk resident boot--
   127                              <1> ;iplseg	ends
   128                              <1> 
   129                              <1> %endif
    37                                  %if CVDU_8563
    38                                  %include	"ega9a.asm"
    39                                  %endif
    40                                  
    41                                  %if VGA3_6445
    42                                  %define Init8563_ Init_vga3_
    43                                  %define Scroll8563_ Scroll_vga3_
    44                                  %define get_char_and_attribute_ vga3_get_char_and_attribute_
    45                                  %define blast_characters_ vga3_blast_characters_
    46                                  %define @cvdu_tty_out @vga3_tty_out
    47                                  %define	set_cursor_pos_ vga3_set_cursor_pos_
    48                                  %endif
    49                                  
    50                                  
    51                                  offset_BP	equ	0
    52                                  offset_BX	equ	offset_BP+2
    53                                  offset_DS	equ	offset_BX+2
    54                                  offset_IP	equ	offset_DS+2
    55                                  offset_CS	equ	offset_IP+2
    56                                  offset_FLAGS	equ	offset_CS+2
    57                                  
    58                                  EOS             equ     0FFh    ; End of String
    59                                  
    60                                  %if  WYSE
    61                                  MAX_ROWS	equ	24	; Wyse terminals have 24 rows
    62                                  %else
    63                                  MAX_ROWS	equ	24	; terminals usually have 24 rows...
    64                                  %endif
    65                                  
    66                                  
    67                                  	SEGMENT _TEXT
    68                                  ;========================================================================
    69                                  ; BIOS call entry for video service functions
    70                                  ;	int  10h
    71                                  ;========================================================================
    72                                  	global  BIOS_call_10h
    73                                  BIOS_call_10h:			; Video service entry
    74                                  
    75 00000000 FB                      	sti			; Enable interrupts
    76 00000001 1E5355                  	pushm   bp,bx,ds	; Standard register save
    77 00000004 89E5                    	mov	bp,sp		; establish stack addressing
    78                                  
    79 00000006 FC                              cld                     ; do this for all functions below
    80 00000007 6A40                    	push	bios_data_seg
    81 00000009 1F                      	popm	ds		; establish addressability
    82                                  %if SOFT_DEBUG
    83                                  	push	ax
    84                                  	call	wout
    85                                  	pop	ax
    86                                  %endif
    87                                  
    88 0000000A 88E3                    	mov     bl,ah		; set to index into dispatch table
    89 0000000C 80FC14                  	cmp     ah,.max/2
    90 0000000F 7331                    	jae     exit
    91 00000011 B700                    	mov     bh,0
    92 00000013 D1E3                    	shl     bx,1		; index words
    93                                  
    94 00000015 2EFFA7[1A00]                cs	jmp     near [.dispatch+bx]
    95                                  .dispatch:
    96 0000001A [4600]                  	dw      fn00		; Set video mode
    97 0000001C [EA00]                  	dw      fn01		; Set cursor shape
    98 0000001E [0701]                  	dw      fn02		; Set cursor position
    99 00000020 [1801]                  	dw	fn03		; Get cursor position and size
   100 00000022 [4200]                  	dw	fn04		; Read light pen position
   101 00000024 [2B01]                  	dw	fn05		; Select active display page
   102 00000026 [3501]                  	dw	fn06		; Scroll up window
   103 00000028 [3501]                  	dw	fn07		; Scroll down window
   104 0000002A [A701]                  	dw	fn08		; Read character and attribute at cursor position
   105 0000002C [B401]                  	dw	fn09		; Write character and attribute at cursor position
   106 0000002E [B401]                  	dw	fn0A		; Write character only at cursor position
   107 00000030 [4200]                  	dw	fn0B		; Set background color/Set palete
   108 00000032 [4200]                  	dw	fn0C		; Write graphics pixel
   109 00000034 [4200]                  	dw	fn0D		; Read graphics pixel
   110 00000036 [0402]                  	dw	fn0E		; Teletype output
   111 00000038 [7302]                  	dw	fn0F		; Get current video mode
   112 0000003A [4200]                  	dw	fn10		; N/A
   113 0000003C [4200]                  	dw	fn11		; N/A
   114 0000003E [4200]                  	dw	fn12		; N/A
   115 00000040 [8302]                  	dw	fn13		; Write string
   116                                  .max	equ     $-.dispatch
   117                                  fn04:				; nobody uses a light pen
   118                                  fn0B:				; no overscan color emulation
   119                                  fn0C:				; no graphics
   120                                  fn0D:				; no graphics
   121                                  fn10:				; not implemented for CGA and MDA
   122                                  fn11:				; -//-
   123                                  fn12:				; -//-
   124                                  exit:
   125 00000042 5D5B1F                  	popm	bp,bx,ds
   126 00000045 CF                      	iret
   127                                  
   128                                  ;------------------------------------------------------------------------
   129                                  ;----------------[Video display area]------------;
   130                                  ;video_mode      resb    1
   131                                  ;       db      ?               ; 40:49         ; Current CRT mode  (software)
   132                                  ;                                               ;  0 = 40 x 25 text (no color)
   133                                  ;                                               ;  1 = 40 x 25 text (16 color)
   134                                  ;                                               ;  2 = 80 x 25 text (no color)
   135                                  ;                                               ;  3 = 80 x 25 text (16 color)
   136                                  ;                                               ;  4 = 320 x 200 grafix 4 color
   137                                  ;                                               ;  5 = 320 x 200 grafix 0 color
   138                                  ;                                               ;  6 = 640 x 200 grafix 0 color
   139                                  ;                                               ;  7 = 80 x 25 text (mono card)
   140                                  ;video_columns   resw    1
   141                                  ;       dw      ?               ; 40:4A         ; Columns on CRT screen
   142                                  ;video_regen_bytes  resw 1
   143                                  ;       dw      ?               ; 40:4C         ; Bytes in the regen region
   144                                  ;video_regen_offset resw 1
   145                                  ;       dw      ?               ; 40:4E         ; Byte offset in regen region
   146                                  ;video_cursor_pos  resw  8
   147                                  ;       dw      8 dup(?)        ; 40:50         ; Cursor pos for up to 8 pages
   148                                  ;video_cursor_mode resw  1
   149                                  ;       dw      ?               ; 40:60         ; Current cursor mode setting
   150                                  ;video_page      resb    1
   151                                  ;       db      ?               ; 40:62         ; Current page on display
   152                                  ;video_base_seg  resw    1
   153                                  ;       dw      ?               ; 40:63         ; Base addres (B000h or B800h)
   154                                  ;video_hw_mode   resb    1
   155                                  ;       db      ?               ; 40:65         ; ic 6845 mode reg. (hardware)
   156                                  ;video_cga_palette resb  1
   157                                  
   158                                  
   159                                  ;========================================================================
   160                                  ; Function 00h - Set video mode
   161                                  ; Input:
   162                                  ;	AH = 00h
   163                                  ;	AL = desired video mode
   164                                  ; Output:
   165                                  ;	none
   166                                  ; XXX:
   167                                  ;	reimplement using a table?
   168                                  ;========================================================================
   169                                  fn00:
   170 00000046 065756525150            	pushm	ax,cx,dx,si,di,es
   171 0000004C 88C4                    	mov	ah,al		; save AL to AH
   172 0000004E 241F                    	and	al,1Fh		; limit modes to 0..1F
   173 00000050 3C00                    	cmp	al,0		; 0 = 40 x 25 text (no color)
   174 00000052 750C                    	jne	.1
   175 00000054 B328                    	mov	bl,40		; 40 columns
   176 00000056 B72C                    	mov	bh,2Ch		; hw mode - 40 columns, monochrome
   177 00000058 BE0008                  	mov	si,0800h	; page size = 2048 bytes
   178 0000005B BAD403                  	mov	dx,03D4h	; color CRT base address
   179 0000005E EB3E                    	jmp	.set_mode
   180                                  .1:
   181 00000060 3C01                    	cmp	al,01		; 1 = 40 x 25 text (16 color)
   182 00000062 750C                    	jne	.2
   183 00000064 B328                    	mov	bl,40		; 40 columns
   184 00000066 B728                    	mov	bh,28h		; hw mode - 40 columns, color
   185 00000068 BE0008                  	mov	si,0800h	; page size = 2048 bytes
   186 0000006B BAD403                  	mov	dx,03D4h	; color CRT base address
   187 0000006E EB2E                    	jmp	.set_mode
   188                                  .2:
   189 00000070 3C02                    	cmp	al,02		; 2 = 80 x 25 text (no color)
   190 00000072 750C                    	jne	.3
   191 00000074 B350                    	mov	bl,80		; 80 columns
   192 00000076 B72D                    	mov	bh,2Dh		; hw mode - 80 columns, monochrome
   193 00000078 BE0010                  	mov	si,1000h	; page size = 4096 bytes
   194 0000007B BAD403                  	mov	dx,03D4h	; color CRT base address
   195 0000007E EB1E                    	jmp	.set_mode
   196                                  .3:
   197 00000080 3C03                    	cmp	al,03		; 3 = 80 x 25 text (16 color)
   198 00000082 750C                    	jne	.4
   199 00000084 B350                    	mov	bl,80		; 80 columns
   200 00000086 B729                    	mov	bh,29h		; hw mode - 80 columns, color
   201 00000088 BE0010                  	mov	si,1000h	; page size = 4096 bytes
   202 0000008B BAD403                  	mov	dx,03D4h	; color CRT base address
   203 0000008E EB0E                    	jmp	.set_mode
   204                                  .4:
   205 00000090 3C07                    	cmp	al,07		; 7 = 80 x 25 text (mono card)
   206 00000092 754D                    	jne	.exit
   207 00000094 B350                    	mov	bl,80		; 80 columns
   208 00000096 B72D                    	mov	bh,2Dh		; hw mode - 80 columns, monochrome
   209 00000098 BE0010                  	mov	si,1000h	; page size = 4096 bytes
   210 0000009B BAB403                  	mov	dx,03B4h	; monochrome CRT base address
   211                                  
   212                                  .set_mode:
   213 0000009E A24900                  	mov	byte [video_mode],al
   214                                  %if ANY_VIDEO
   215                                  	pushm	ds
   216                                  	push	DGROUP
   217                                  	popm	ds
   218                                  	extern	Init8563_	; or Init_vga3_
   219                                  	call	Init8563_
   220                                  	popm	ds
   221                                  	mov	si,0800h	; page size = 2048 bytes
   222                                  	mov	[video_cga_palette],al		; set memory size
   223                                  	mov	al,0
   224                                  %else
   225 000000A1 B000                    	mov	al,0
   226 000000A3 A26600                  	mov	[video_cga_palette],al		; clear location
   227                                  				; video_cga_palette = 0
   228                                  %endif
   229                                  ;;	cld			; clear video part of BIOS data area
   230 000000A6 BF4A00                  	mov	di,video_mode+1
   231 000000A9 B91C00                  	mov	cx,video_cga_palette-video_mode-1
   232 000000AC 1E                      	pushm	ds
   233 000000AD 07                      	popm	es
   234 000000AE F3AA                        rep	stosb
   235                                  				; video_page = 0
   236                                  				; video_regen_offset = 0
   237                                  				; video_cursor_pos[0..7] = 0
   238                                  
   239 000000B0 883E6500                	mov	byte [video_hw_mode],bh
   240 000000B4 B700                    	mov	bh,0
   241 000000B6 891E4A00                	mov	word [video_columns],bx
   242 000000BA 89364C00                	mov	word [video_regen_bytes],si
   243 000000BE 89166300                	mov	word [video_base_seg],dx
   244 000000C2 B90706                  	mov	cx,0607h	; cursor start line 6, cursor end line - 7
   245 000000C5 890E6000                	mov	word [video_cursor_mode],cx
   246                                  
   247 000000C9 B307                    	mov	bl,07h		; set default attributes to 07h
   248 000000CB E87603                  	call	set_attributes
   249                                  %if SOFT_DEBUG
   250                                  	push	0x11
   251                                  	call	lites
   252                                  %endif
   253                                  
   254 000000CE F6C480                  	test	ah,80h		; if bit 7 of original AL set, don't clear
   255 000000D1 7503                    	jnz	.dont_clear
   256 000000D3 E85903                  	call	clear_screen
   257                                  %if SOFT_DEBUG
   258                                  	push	0x13
   259                                  	call	lites
   260                                  %endif
   261                                  
   262                                  
   263                                  .dont_clear:
   264 000000D6 31D2                    	xor	dx,dx		; set cursor to 1,1
   265 000000D8 E8E102                  	call	cursor_set_pos
   266 000000DB E83003                  	call	cursor_show
   267 000000DE E8F002                  	call	auto_wrap_off
   268                                  
   269                                  .exit:
   270 000000E1 58595A5E5F07            	popm	ax,cx,dx,si,di,es
   271 000000E7 E958FF                  	jmp	exit
   272                                  
   273                                  ;========================================================================
   274                                  ; Function 01h - Set cursor shape
   275                                  ; Input:
   276                                  ;	AH = 01h
   277                                  ;	CH = cursor start and options
   278                                  ;		bit 7    = 0
   279                                  ;		bits 6,5 = 00 normal, other invisible
   280                                  ;		bits 4-0 = topmost scan line
   281                                  ;	CL = (bits 4-0) bottom scan line containing cursor
   282                                  ; Output:
   283                                  ;	none
   284                                  ;========================================================================
   285                                  fn01:
   286 000000EA 51                      	push	cx
   287 000000EB 890E6000                	mov	word [video_cursor_mode],cx
   288 000000EF F6C560                  	test	ch,60h
   289 000000F2 750C                    	jnz	.hide		; hide cursor
   290 000000F4 80E5E0                  	and	ch,0E0h
   291 000000F7 38CD                    	cmp	ch,cl
   292 000000F9 7705                    	ja	.hide		; hide cursor
   293 000000FB E81003                  	call	cursor_show	; show cursor
   294 000000FE EB03                    	jmp	.exit
   295                                  
   296                                  .hide:
   297 00000100 E8EA02                  	call	cursor_hide
   298                                  	
   299                                  .exit:
   300 00000103 59                      	pop	cx
   301 00000104 E93BFF                  	jmp	exit
   302                                  
   303                                  ;========================================================================
   304                                  ; Function 02h - Set cursor position
   305                                  ; Input:
   306                                  ;	AH = 02h
   307                                  ;	BH = page number (0-based)
   308                                  ;	DH = row (0-based)
   309                                  ;	DL = column (0-based)
   310                                  ; Output:
   311                                  ;	none
   312                                  ;========================================================================
   313                                  fn02:
   314 00000107 52                      	push	dx
   315 00000108 88FB                    	mov	bl,bh
   316 0000010A B700                    	mov	bh,0
   317 0000010C D1E3                    	shl	bx,1
   318                                  %if !DUMB
   319 0000010E 895750                  	mov	word [video_cursor_pos+bx],dx
   320                                  %endif
   321 00000111 E8A802                  	call	cursor_set_pos
   322 00000114 5A                      	pop	dx
   323 00000115 E92AFF                  	jmp	exit
   324                                  
   325                                  ;========================================================================
   326                                  ; Function 03h - Get cursor position and size
   327                                  ; Input:
   328                                  ;	AH = 03h
   329                                  ;	BH = page number (0-based)
   330                                  ; Output:
   331                                  ;	CH = cursor starting scan-line
   332                                  ;	CL = cursor ending scan-line
   333                                  ;	DH = current row (0-based)
   334                                  ;	DL = current column (0-based)
   335                                  ;========================================================================
   336                                  fn03:
   337 00000118 8B5E02                  	mov	bx,word [offset_BX+bp]
   338 0000011B 88FB                    	mov	bl,bh
   339 0000011D B700                    	mov	bh,0
   340 0000011F D1E3                    	shl	bx,1
   341 00000121 8B5750                  	mov	dx,word [video_cursor_pos+bx]
   342 00000124 8B0E6000                	mov	cx,word [video_cursor_mode]
   343 00000128 E917FF                  	jmp	exit
   344                                  
   345                                  ;========================================================================
   346                                  ; Function 05h - Select active display page
   347                                  ; Input:
   348                                  ;	AH = 05h
   349                                  ;	AL = page number (0-based)	
   350                                  ; Output:
   351                                  ;	none
   352                                  ;========================================================================
   353                                  fn05:
   354 0000012B 50                      	push	ax
   355 0000012C 2407                    	and	al,7			; allow 8 pages
   356 0000012E A26200                  	mov	byte [video_page],al
   357 00000131 58                      	pop	ax
   358 00000132 E90DFF                  	jmp	exit
   359                                  
   360                                  ;========================================================================
   361                                  ; Function 06h - Scroll up window
   362                                  ; Function 07h - Scroll down window
   363                                  ; Input:
   364                                  ;	AH = 06h/07h
   365                                  ;	AL = number of lines to scroll in (0=blank entire rectangle)
   366                                  ;	BH = video attribute to be used on blank line(s)
   367                                  ;	CH,CL = row,column of upper-left corner of rectangle to scroll
   368                                  ;	DH,DL = row,column of lower-right corner of rectangle to scroll
   369                                  ; Notes:
   370                                  ;	Due to ANSI limitations column values are ignored
   371                                  ;========================================================================
   372                                  fn06:
   373                                  fn07:
   374                                  %if	ANY_VIDEO
   375                                  	mov	bl,[video_page]
   376                                  	xchg	bl,bh
   377                                  	pushm	bx,ax,cx,dx,ds,es
   378                                  
   379                                  	push	DGROUP
   380                                  	popm	ds
   381                                  	extern	Scroll8563_	;or Scroll_vga3_ 
   382                                  	call	Scroll8563_	;
   383                                  
   384                                  	popm	bx,ax,cx,dx,ds,es
   385                                  %endif	; ANY_VIDEO
   386                                  
   387                                  %if	ANSI
   388 00000135 525150                  	pushm	ax,cx,dx
   389 00000138 8B5E02                  	mov	bx,word [offset_BX+bp]
   390 0000013B 88FB                    	mov	bl,bh
   391 0000013D E80403                  	call	set_attributes
   392                                  
   393 00000140 08C0                    	or	al,al
   394 00000142 7506                    	jnz	.scroll
   395 00000144 88F0                    	mov	al,dh	; AL = 0 - blank rectangle
   396 00000146 28E8                    	sub	al,ch
   397 00000148 FEC0                    	inc	al
   398                                  
   399                                  .scroll:
   400 0000014A 88F2                    	mov	dl,dh		; DL = lower row
   401 0000014C 88EE                    	mov	dh,ch		; DH = upper row
   402 0000014E 89C1                    	mov	cx,ax		; save AX in CX
   403 00000150 B01B                    	mov	al,ESC		; set scroll region ESC[<row_up>;<row_down]r
   404 00000152 E8D503                  	call	uart_out
   405 00000155 B05B                    	mov	al,'['
   406 00000157 E8D003                  	call	uart_out
   407 0000015A E82A02                  	call	coords_out
   408 0000015D B072                    	mov	al,'r'
   409 0000015F E8C803                  	call	uart_out
   410                                  
   411 00000162 B01B                    	mov	al,ESC		; use ESC[<num_rows>S or ESC[<num_rows>T
   412 00000164 E8C303                  	call	uart_out	; to scroll the region up or down
   413 00000167 B05B                    	mov	al,'['
   414 00000169 E8BE03                  	call	uart_out
   415                                  	
   416 0000016C BA0A30                  	mov	dx,300Ah	; '0' to DH - used for ASCII conversion
   417                                  				; 10 to DL for 10-base conversion
   418 0000016F 88C8                    	mov	al,cl		; convert to ASCII and output row number
   419 00000171 B400                    	mov	ah,0
   420 00000173 F6F2                    	div	dl
   421 00000175 00F0                    	add	al,dh		; al + '0' - convert to ASCII
   422 00000177 E8B003                  	call	uart_out
   423 0000017A 88E0                    	mov	al,ah
   424 0000017C 00F0                    	add	al,dh		; al + '0' - convert to ASCII
   425 0000017E E8A903                  	call	uart_out
   426                                  
   427 00000181 80FD07                  	cmp	ch,07h
   428 00000184 7407                    	je	.scroll_down
   429 00000186 B053                    	mov	al,'S'
   430 00000188 E89F03                  	call	uart_out	; scroll up
   431 0000018B EB05                    	jmp	.reset_scroll
   432                                  
   433                                  .scroll_down:
   434 0000018D B054                    	mov	al,'T'
   435 0000018F E89803                  	call	uart_out	; scroll down
   436                                  
   437                                  .reset_scroll:
   438 00000192 B01B                    	mov	al,ESC
   439 00000194 E89303                  	call	uart_out
   440 00000197 B05B                    	mov	al,'['
   441 00000199 E88E03                  	call	uart_out
   442 0000019C B072                    	mov	al,'r'
   443 0000019E E88903                  	call	uart_out
   444                                  
   445                                  .exit:
   446 000001A1 58595A                  	popm	ax,cx,dx
   447                                  %elif  WYSE
   448                                  	pushm	ax,cx,dx
   449                                          cmp     dh,MAX_ROWS
   450                                          jb      .0
   451                                          mov     dh,MAX_ROWS-1
   452                                  .0:
   453                                  %if 0
   454                                          mov	bx,word [offset_BX+bp]
   455                                  	mov	bl,bh
   456                                  	call	set_attributes
   457                                  %endif
   458                                          or      al,al
   459                                          jnz     .1
   460                                          mov     al,dh
   461                                          sub     al,ch
   462                                          inc     al
   463                                  .1:     mov     dx,cx
   464                                          xchg    ax,cx
   465                                          call    cursor_set_pos
   466                                  .4:     test    ch,1            ; former AH
   467                                          jnz     .down
   468                                          call    uart_send
   469                                          db      ESC, 'R', EOS
   470                                          jmp     .5
   471                                  .down:  call    uart_send
   472                                          db      ESC, 'E', EOS
   473                                  .5      dec     cl
   474                                          jnz     .4
   475                                          popm    ax,cx,dx        
   476                                  %endif	; ANSI | WYSE
   477 000001A4 E99BFE                  	jmp	exit
   478                                  
   479                                  ;========================================================================
   480                                  ; Function 08h - Read character and attribute at cursor position
   481                                  ; Input:
   482                                  ;	AH = 08h
   483                                  ;	BH = page number (0-based)
   484                                  ; Output:
   485                                  ;	AL = character read
   486                                  ;	BH = video attribute
   487                                  ; Notes:
   488                                  ;	Impossible to emulate, returns AL = 20h, BH = 07h
   489                                  ;========================================================================
   490                                  fn08:
   491                                  %if ANY_VIDEO
   492                                  	pushm	es		; BP,BX,DS already saved
   493                                  
   494                                  	pushm	ds
   495                                  	push	DGROUP
   496                                  	popm	ds
   497                                  	mov	ax,word [offset_BX+bp]
   498                                  	extern	get_char_and_attribute_		; or vga3_get_char_and_attribute_
   499                                  	call	get_char_and_attribute_		; saves BX,CX,DX (SI,DI not used)
   500                                  	popm	ds
   501                                  	
   502                                  	popm	es
   503                                  %else
   504 000001A7 B020                    	mov	al,20h
   505 000001A9 8B5E02                  	mov	bx,word [offset_BX+bp]
   506 000001AC B707                    	mov	bh,07h
   507 000001AE 895E02                  	mov	word [offset_BX+bp],bx
   508                                  %endif
   509 000001B1 E98EFE                  	jmp	exit
   510                                  
   511                                  ;========================================================================
   512                                  ; Function 09h - Write character and attribute at cursor position
   513                                  ; Function 0Ah - Write character only at cursor position
   514                                  ; Input:
   515                                  ;	AH = 09h/0Ah
   516                                  ;	AL = character to write
   517                                  ;	BH = page number (0-based)
   518                                  ;	BL = video attribute (AH = 09h only)
   519                                  ;	CX = repeat count
   520                                  ; Output:
   521                                  ;	none
   522                                  ;========================================================================
   523                                  fn09:
   524                                  fn0A:
   525                                  %if ANY_VIDEO
   526                                  	pushm	ax,dx,ds,es
   527                                  
   528                                  	push	DGROUP
   529                                  	popm	ds
   530                                      	mov	dx,word [offset_BX+bp]
   531                                  	mov	bx,cx
   532                                  	extern	blast_characters_	; or vga3_blast_characters_
   533                                  	call	blast_characters_
   534                                  
   535                                  	popm	ax,dx,ds,es
   536                                  %endif
   537                                  %if UART
   538 000001B4 525150                  	pushm	ax,cx,dx
   539 000001B7 3C20                    	cmp	al,20h
   540 000001B9 7243                    	jb	.exit		; non-printable character
   541 000001BB 3C7F                    	cmp	al,7Fh
   542 000001BD 743F                    	je	.exit		; non-printable character
   543 000001BF 8B5E02                      	mov	bx,word [offset_BX+bp]
   544 000001C2 80FC0A                  	cmp	ah,0Ah
   545 000001C5 7403                    	je	.no_attributes
   546 000001C7 E87A02                  	call	set_attributes
   547                                  .no_attributes:
   548 000001CA 88FB                    	mov	bl,bh
   549 000001CC B700                    	mov	bh,0
   550 000001CE D1E3                    	shl	bx,1
   551 000001D0 8B5750                  	mov	dx,word [video_cursor_pos+bx]
   552                                  
   553                                  .loop:
   554 000001D3 E85403                  	call	uart_out
   555                                  
   556 000001D6 FEC2                    	inc	dl		; increment column
   557 000001D8 3A164A00                	cmp	dl,byte [video_columns]
   558 000001DC 7304                    	jae	.next_line
   559 000001DE E2F3                    	loop	.loop
   560 000001E0 EB0E                    	jmp	.exit_loop
   561                                  
   562                                  .next_line:
   563 000001E2 B200                    	mov	dl,0
   564 000001E4 FEC6                    	inc	dh		; increment row
   565 000001E6 80FE18                  	cmp	dh,MAX_ROWS	; on the last row? (assume 25 rows)
   566 000001E9 7305                    	jae	.exit_loop
   567 000001EB E8CE01                  	call	cursor_set_pos
   568 000001EE E2E3                    	loop	.loop
   569                                  
   570                                  .exit_loop:
   571 000001F0 8A1E6200                	mov	bl,byte [video_page]
   572 000001F4 B700                    	mov	bh,0
   573 000001F6 D1E3                    	shl	bx,1
   574                                  %if !DUMB
   575 000001F8 8B5750                  	mov	dx,word [video_cursor_pos+bx]
   576                                  %endif
   577 000001FB E8BE01                  	call	cursor_set_pos
   578                                  .exit:
   579 000001FE 58595A                  	popm	ax,cx,dx
   580                                  %endif
   581 00000201 E93EFE                  	jmp	exit
   582                                  
   583                                  ;========================================================================
   584                                  ; Function 0Eh - Teletype output
   585                                  ; Input:
   586                                  ;	AH = 0Eh
   587                                  ;	AL = character to write
   588                                  ;	BH = page number (0-based)
   589                                  ;	BL = foreground color (graphics modes only, ignored)
   590                                  ; Output:
   591                                  ;	none
   592                                  ;========================================================================
   593                                  fn0E:
   594 00000204 5250                    	pushm	ax,dx		; preserve AX, too
   595                                  
   596                                  %if ANY_VIDEO
   597                                  	pushm	cx,ds,es
   598                                  	mov	dx,word [offset_BX+bp]
   599                                  	push	DGROUP
   600                                  	popm	ds
   601                                  	extern	@cvdu_tty_out	; or @vga3_tty_out
   602                                  	call	@cvdu_tty_out	; AX set, DX set, BX set
   603                                  ; cvdu/vga3_tty_out is responsible for updating the cursor position
   604                                  	popm	cx,ds,es
   605                                  %endif
   606                                  
   607 00000206 8B5E02                  	mov	bx,word [offset_BX+bp]
   608 00000209 88FB                    	mov	bl,bh
   609 0000020B B700                    	mov	bh,0
   610 0000020D D1E3                    	shl	bx,1
   611 0000020F 8B5750                  	mov	dx,word [video_cursor_pos+bx]
   612                                  %if UART
   613 00000212 3C07                    	cmp	al,07h
   614 00000214 7434                    	je	.bell		; BEL code
   615 00000216 3C08                    	cmp	al,08h
   616 00000218 7435                    	je	.bs		; BS code
   617 0000021A 3C0A                    	cmp	al,0Ah
   618 0000021C 743C                    	je	.lf		; Line feed code
   619 0000021E 3C0D                    	cmp	al,0Dh
   620 00000220 7444                    	je	.cr		; Carriage return
   621 00000222 3C20                    	cmp	al,20h
   622 00000224 7245                    	jb	.exit		; some other control character - ignore
   623 00000226 3C7F                    	cmp	al,7Fh
   624 00000228 7441                    	je	.exit		; DEL code - ignore
   625                                  
   626 0000022A E8FD02                  	call	uart_out	; we've got a regular character
   627 0000022D FEC2                    	inc	dl		; move cursor to the next column
   628 0000022F 3A164A00                	cmp	dl,byte [video_columns]
   629 00000233 7236                    	jb	.exit
   630                                  
   631 00000235 B00D                    	mov	al,0Dh
   632 00000237 E8F002                  	call	uart_out
   633 0000023A B00A                    	mov	al,0Ah
   634 0000023C E8EB02                  	call	uart_out
   635 0000023F B200                    	mov	dl,0		; set cursor to the beggining of the next line
   636 00000241 80FE18                  	cmp	dh,MAX_ROWS
   637 00000244 7325                    	jae	.exit		; already on 25th row, no need to move further
   638 00000246 FEC6                    	inc	dh		; move cursor to the next line
   639 00000248 EB21                    	jmp	.exit
   640                                  
   641                                  .bell:
   642 0000024A E8DD02                  	call	uart_out	; just output it
   643 0000024D EB1C                    	jmp 	.exit		; no need to change cursor position
   644                                  
   645                                  .bs:
   646 0000024F 08D2                    	or	dl,dl		; already on the first column?
   647 00000251 7418                    	jz	.exit
   648 00000253 E8D402                  	call	uart_out
   649 00000256 FECA                    	dec	dl		; move cursor to the previous column
   650 00000258 EB11                    	jmp	.exit
   651                                  
   652                                  .lf:
   653 0000025A E8CD02                  	call	uart_out
   654 0000025D 80FE18                  	cmp	dh,24		; assume 25 rows
   655 00000260 7309                    	jae	.exit
   656 00000262 FEC6                    	inc	dh
   657 00000264 EB05                    	jmp	.exit
   658                                  
   659                                  .cr:
   660 00000266 E8C102                  	call	uart_out
   661 00000269 B200                    	mov	dl,0		; set cursor to the first column
   662                                  
   663                                  .exit:
   664                                  %if ANY_VIDEO==0
   665 0000026B 895750                  	mov	word [video_cursor_pos+bx],dx
   666                                  %endif
   667                                  %endif
   668 0000026E 585A                    	popm	ax,dx		; restore AX also
   669 00000270 E9CFFD                  	jmp	exit
   670                                  
   671                                  ;========================================================================
   672                                  ; Function 0Fh - Get current video mode
   673                                  ; Input:
   674                                  ;	AH = 0Fh
   675                                  ; Output:
   676                                  ;	AH = number of character columns
   677                                  ;	AL = video mode
   678                                  ;	BH = active page
   679                                  ;========================================================================
   680                                  fn0F:
   681 00000273 A06200                  	mov	al,byte [video_page]
   682 00000276 884603                  	mov	byte [bp+offset_BX+1],al	; set BH for return
   683 00000279 8A264A00                	mov	ah,byte [video_columns]		; set AH
   684 0000027D A04900                  	mov	al,byte [video_mode]		; set AL
   685 00000280 E9BFFD                  	jmp	exit
   686                                  
   687                                  ;========================================================================
   688                                  ; Function 13h - Write string
   689                                  ; Input:
   690                                  ;	AH = 13h
   691                                  ;	AL = 00h - use video attribute in BL, don't move cursor
   692                                  ;	AL = 01h - use video attribute in BL, update cursor
   693                                  ;		BL = video attribute
   694                                  ;	AL = 02h - use video attribute from string, don't move cursor
   695                                  ;	AL = 03h - use video attribute from string, update cursor
   696                                  ;	BH = page number (0-based)
   697                                  ;	CX = length of the string
   698                                  ;	DH = row (0-based)
   699                                  ;	DL = column (0-based)
   700                                  ;	ES:BP = pointer to the string
   701                                  ; Output:
   702                                  ;	none
   703                                  ; XXX:
   704                                  ;	When printing the last character on the screen cursor will be moved
   705                                  ;	to the first column of the last line
   706                                  ;========================================================================
   707                                  fn13:
   708 00000283 5251                    	pushm	cx,dx
   709 00000285 5550                    	pushm	ax,bp
   710 00000287 8B6E00                  	mov	bp,word [offset_BP+bp]
   711 0000028A E82F01                  	call	cursor_set_pos
   712 0000028D A802                    	test	al,02h
   713 0000028F 756D                    	jnz	fn13_2		; read attribute from the string implementation
   714 00000291 E8B001                  	call	set_attributes
   715                                  .loop:
   716 00000294 268A4600                    es	mov	al,byte [bp]
   717 00000298 45                      	inc	bp
   718 00000299 3C07                    	cmp	al,07h
   719 0000029B 743B                    	je	.bell
   720 0000029D 3C0A                    	cmp	al,0Ah
   721 0000029F 743F                    	je	.lf
   722 000002A1 3C0D                    	cmp	al,0Dh
   723 000002A3 744C                    	je	.cr
   724 000002A5 3C20                    	cmp	al,20h
   725 000002A7 7251                    	jb	.next		; control character
   726 000002A9 3C7F                    	cmp	al,7Fh	
   727 000002AB 744D                    	je	.next		; DEL
   728                                  
   729 000002AD E87A02                  	call	uart_out
   730                                  
   731 000002B0 FEC2                    	inc	dl		; increment column
   732 000002B2 3A164A00                	cmp	dl,byte [video_columns]
   733 000002B6 7305                    	jae	.next_line
   734 000002B8 E2DA                    	loop	.loop
   735 000002BA E9AB00                  	jmp	fn13_exit
   736                                  
   737                                  .next_line:
   738 000002BD B200                    	mov	dl,0
   739 000002BF FEC6                    	inc	dh		; increment row
   740 000002C1 80FE18                  	cmp	dh,MAX_ROWS
   741 000002C4 7203E99F00              	jae	fn13_exit
   742 000002C9 B00D                    	mov	al,0Dh
   743 000002CB E85C02                  	call	uart_out
   744 000002CE B00A                    	mov	al,0Ah
   745 000002D0 E85702                  	call	uart_out
   746 000002D3 E2BF                    	loop	.loop
   747 000002D5 E99000                  	jmp	fn13_exit
   748                                  
   749                                  .bell:
   750 000002D8 E84F02                  	call	uart_out
   751 000002DB E2B7                    	loop	.loop
   752 000002DD E98800                  	jmp	fn13_exit
   753                                  
   754                                  .lf:
   755 000002E0 80FE18                  	cmp	dh,24
   756 000002E3 7203E98000              	jae	fn13_exit
   757 000002E8 FEC6                    	inc	dh
   758 000002EA E83D02                  	call	uart_out
   759 000002ED E2A5                    	loop	.loop
   760 000002EF EB77                    	jmp	fn13_exit
   761                                  
   762                                  .cr:
   763 000002F1 B200                    	mov	dl,0
   764 000002F3 E83402                  	call	uart_out
   765 000002F6 E29C                    	loop	.loop
   766 000002F8 EB6E                    	jmp	fn13_exit
   767                                  
   768                                  .next:
   769 000002FA E298                    	loop	.loop
   770 000002FC EB6A                    	jmp	fn13_exit
   771                                  
   772                                  fn13_2:
   773 000002FE 8A3E4A00                	mov	bh,byte [video_columns]
   774                                  .loop:
   775 00000302 268A4600                    es	mov	al,byte [bp]
   776 00000306 45                      	inc	bp
   777 00000307 3C07                    	cmp	al,07h
   778 00000309 743C                    	je	.bell
   779 0000030B 3C0A                    	cmp	al,0Ah
   780 0000030D 743F                    	je	.lf
   781 0000030F 3C0D                    	cmp	al,0Dh
   782 00000311 7449                    	je	.cr
   783 00000313 3C20                    	cmp	al,20h
   784 00000315 724E                    	jb	.next		; control character
   785 00000317 3C7F                    	cmp	al,7Fh	
   786 00000319 744A                    	je	.next		; DEL
   787                                  
   788 0000031B 268A5E00                    es	mov	bl,byte [bp]
   789 0000031F 45                      	inc	bp
   790 00000320 E82101                  	call	set_attributes
   791                                  
   792 00000323 E80402                  	call	uart_out
   793                                  
   794 00000326 FEC2                    	inc	dl		; increment column
   795 00000328 38FA                    	cmp	dl,bh		; bh = video columns
   796 0000032A 7304                    	jae	.next_line
   797 0000032C E2D4                    	loop	.loop
   798 0000032E EB38                    	jmp	fn13_exit
   799                                  
   800                                  .next_line:
   801 00000330 B200                    	mov	dl,0
   802 00000332 FEC6                    	inc	dh		; increment row
   803 00000334 80FE18                  	cmp	dh,MAX_ROWS
   804 00000337 732F                    	jae	fn13_exit
   805                                  ;	call	cursor_set_pos
   806 00000339 B00D                    	mov	al,0Dh
   807 0000033B E8EC01                  	call	uart_out
   808 0000033E B00A                    	mov	al,0Ah
   809 00000340 E8E701                  	call	uart_out
   810 00000343 E2BD                    	loop	.loop
   811 00000345 EB21                    	jmp	fn13_exit
   812                                  
   813                                  .bell:
   814 00000347 E8E001                  	call	uart_out
   815 0000034A E2B6                    	loop	.loop
   816 0000034C EB1A                    	jmp	fn13_exit
   817                                  
   818                                  .lf:
   819 0000034E 80FE18                  	cmp	dh,24
   820 00000351 7315                    	jae	fn13_exit
   821 00000353 FEC6                    	inc	dh
   822 00000355 E8D201                  	call	uart_out
   823 00000358 E2A8                    	loop	.loop
   824 0000035A EB0C                    	jmp	fn13_exit
   825                                  
   826                                  .cr:
   827 0000035C B200                    	mov	dl,0
   828 0000035E E8C901                  	call	uart_out
   829 00000361 E29F                    	loop	.loop
   830 00000363 EB03                    	jmp	fn13_exit
   831                                  
   832                                  .next:
   833 00000365 45                      	inc	bp		; skip the attribute
   834 00000366 E29A                    	loop	.loop
   835                                  
   836                                  fn13_exit:
   837 00000368 585D                    	popm	ax,bp
   838 0000036A 8B5E02                  	mov	bx,word [offset_BX+bp]
   839 0000036D 88FB                    	mov	bl,bh
   840 0000036F B700                    	mov	bh,0
   841 00000371 D1E3                    	shl	bx,1		; bx = page number * 2
   842 00000373 A801                    	test	al,01h		; AL, bit 0 = 1 - update cursor
   843 00000375 7508                    	jne	.update_cursor
   844 00000377 8B5750                  	mov	dx,word [video_cursor_pos+bx]
   845 0000037A E83F00                  	call	cursor_set_pos
   846 0000037D EB03                    	jmp	.exit
   847                                  
   848                                  .update_cursor:
   849 0000037F 895750                  	mov	word [video_cursor_pos+bx],dx
   850                                  
   851                                  .exit:
   852 00000382 595A                    	popm	cx,dx
   853 00000384 E9BBFC                  	jmp	exit
   854                                  
   855                                  ;========================================================================
   856                                  ; coords_out - Output coordinates in ANSI format X;Y
   857                                  ;              Output coordinates in WYSE format:  SP+row SP+col
   858                                  ; Input:
   859                                  ;	DH = X coordinate
   860                                  ;	DL = Y coordinate
   861                                  ; Output:
   862                                  ;	AX is trashed
   863                                  ;	none
   864                                  ;========================================================================
   865                                  coords_out:
   866                                  %if	ANSI
   867 00000387 5251                    	pushm	cx,dx
   868 00000389 81C20101                	add	dx,0101h
   869 0000038D B90A30                  	mov	cx,300Ah	; '0' to CH - used for ASCII conversion
   870                                  				; 10 to CL for 10-base conversion
   871 00000390 88F0                    	mov	al,dh		; convert to ASCII and output row number
   872 00000392 B400                    	mov	ah,0
   873 00000394 F6F1                    	div	cl
   874 00000396 00E8                    	add	al,ch		; al + '0' - convert to ASCII
   875 00000398 E88F01                  	call	uart_out
   876 0000039B 88E0                    	mov	al,ah
   877 0000039D 00E8                    	add	al,ch		; al + '0' - convert to ASCII
   878 0000039F E88801                  	call	uart_out
   879                                  
   880 000003A2 B03B                    	mov	al,';'		; output ';' delimiter
   881 000003A4 E88301                  	call	uart_out
   882                                  
   883 000003A7 88D0                    	mov	al,dl		; convert to ASCII and output column number
   884 000003A9 B400                    	mov	ah,0
   885 000003AB F6F1                    	div	cl
   886 000003AD 00E8                    	add	al,ch		; al + '0' - convert to ASCII
   887 000003AF E87801                  	call	uart_out
   888 000003B2 88E0                    	mov	al,ah
   889 000003B4 00E8                    	add	al,ch		; al + '0' - convert to ASCII
   890 000003B6 E87101                  	call	uart_out
   891 000003B9 595A                    	popm	cx,dx
   892                                  %elif WYSE
   893                                          pushm   dx
   894                                          add     dx,2020h        ; SPACE || SPACE
   895                                          mov     al,dh           ; row
   896                                  	call	uart_out
   897                                          mov     al,dl           ; column
   898                                  	call	uart_out
   899                                          popm    dx
   900                                  %endif	; ANSI | WYSE
   901 000003BB C3                      	ret
   902                                  
   903                                  ;========================================================================
   904                                  ; cursor_set_pos - move cursor to specified position
   905                                  ; Input:
   906                                  ;	DH = row (0-based)
   907                                  ;	DL = column (0-based)
   908                                  ; Output:
   909                                  ;	none
   910                                  ; Notes:
   911                                  ;	Uses ESC[<row>;<column>H ANSI sequence, row and column are 0-based
   912                                  ;========================================================================
   913                                  cursor_set_pos:
   914                                  %if ANY_VIDEO
   915                                  	pushm	ax,dx
   916                                  	mov	ax,dx
   917                                  	pushm	ds
   918                                  	pushm	DGROUP
   919                                  	popm	ds
   920                                  	extern	set_cursor_pos_		; or vga3_set_cursor_pos_
   921                                  	call	set_cursor_pos_
   922                                  	popm	ds
   923                                  	popm	ax,dx
   924                                  %endif
   925                                  %if	ANSI
   926 000003BC 50                      	push	ax
   927 000003BD B01B                    	mov	al,ESC		; output CSI sequence
   928 000003BF E86801                  	call	uart_out
   929 000003C2 B05B                    	mov	al,'['
   930 000003C4 E86301                  	call	uart_out
   931 000003C7 E8BDFF                  	call	coords_out
   932 000003CA B048                    	mov	al,'H'		; output 'H' command
   933 000003CC E85B01                  	call	uart_out
   934 000003CF 58                      	pop	ax
   935                                  %elif  WYSE
   936                                          pushm   ax
   937                                          mov     al,ESC
   938                                  	call	uart_out
   939                                          mov     al,'='          ; ESC '=' r  c
   940                                  	call	uart_out
   941                                          call	coords_out
   942                                          popm    ax
   943                                  %elif	DUMB
   944                                  ; setting the cursor position back on the same line can be done
   945                                  ; by emitting the correct number of BS (backspace) characters
   946                                  	xchg	dx,[video_cursor_pos + 0]	; page 0 always
   947                                  	sub	dl,[video_cursor_pos]		; - delta
   948                                  	jz	.5
   949                                  	mov	ax,0x0100+FWD		; forward space is ^L
   950                                  	js	.1
   951                                  	mov	ax,0xFF00+BS		; 
   952                                  .1:	call	uart_out
   953                                  	add	dl,ah
   954                                  	jnz	.1
   955                                  
   956                                  .5:	sub	dh,[video_cursor_pos+1]
   957                                  	jz	.9
   958                                  	mov	ax,0x0100+LF		;line feed (down)
   959                                  	js	.7
   960                                  	mov	ax,0xFF00+VT		;line feed (up)
   961                                  .7:	call	uart_out
   962                                  	add	dh,ah
   963                                  	jnz	.7
   964                                  .9:
   965                                  %endif	; ANSI | WYSE
   966 000003D0 C3                      	ret
   967                                  
   968                                  ;========================================================================
   969                                  ; auto_wrap_off - disable auto wraparound mode
   970                                  ; Input:
   971                                  ;	none
   972                                  ; Output:
   973                                  ;	none
   974                                  ; Notes:
   975                                  ;	Uses ESC[?7l ANSI sequence
   976                                  ;========================================================================
   977                                  auto_wrap_off:
   978                                  %if	ANSI
   979 000003D1 50                      	push	ax
   980 000003D2 B01B                    	mov	al,ESC
   981 000003D4 E85301                  	call	uart_out
   982 000003D7 B05B                    	mov	al,'['
   983 000003D9 E84E01                  	call	uart_out
   984 000003DC B03F                    	mov	al,'?'
   985 000003DE E84901                  	call	uart_out
   986 000003E1 B037                    	mov	al,'7'
   987 000003E3 E84401                  	call	uart_out
   988 000003E6 B06C                    	mov	al,'l'
   989 000003E8 E83F01                  	call	uart_out
   990 000003EB 58                      	pop	ax
   991                                  %elif  WYSE
   992                                  ;   Function is not available
   993                                  %endif	; ANSI | WYSE
   994 000003EC C3                      	ret
   995                                  
   996                                  ;========================================================================
   997                                  ; cursor_hide - hide cursor
   998                                  ; Input:
   999                                  ;	none
  1000                                  ; Output:
  1001                                  ;	none
  1002                                  ; Notes:
  1003                                  ;	Uses ESC[?25l ANSI sequence
  1004                                  ;========================================================================
  1005                                  cursor_hide:
  1006                                  %if	ANSI
  1007 000003ED 50                      	push	ax
  1008 000003EE B01B                    	mov	al,ESC
  1009 000003F0 E83701                  	call	uart_out
  1010 000003F3 B05B                    	mov	al,'['
  1011 000003F5 E83201                  	call	uart_out
  1012 000003F8 B03F                    	mov	al,'?'
  1013 000003FA E82D01                  	call	uart_out
  1014 000003FD B032                    	mov	al,'2'
  1015 000003FF E82801                  	call	uart_out
  1016 00000402 B035                    	mov	al,'5'
  1017 00000404 E82301                  	call	uart_out
  1018 00000407 B06C                    	mov	al,'l'
  1019 00000409 E81E01                  	call	uart_out
  1020 0000040C 58                      	pop	ax
  1021                                  %elif  WYSE
  1022                                          pushm   ax
  1023                                  	mov	al,ESC
  1024                                  	call	uart_out
  1025                                          mov     al, '`'
  1026                                  	call	uart_out
  1027                                          mov     al,'0'
  1028                                  	call	uart_out
  1029                                          popm    ax
  1030                                  %endif	; ANSI | WYSE
  1031 0000040D C3                      	ret
  1032                                  
  1033                                  ;========================================================================
  1034                                  ; cursor_show - show cursor
  1035                                  ; Input:
  1036                                  ;	none
  1037                                  ; Output:
  1038                                  ;	none
  1039                                  ; Notes:
  1040                                  ;	Uses ESC[?25h ANSI sequence
  1041                                  ;========================================================================
  1042                                  cursor_show:
  1043                                  %if	ANSI
  1044 0000040E 50                      	push	ax
  1045 0000040F B01B                    	mov	al,ESC
  1046 00000411 E81601                  	call	uart_out
  1047 00000414 B05B                    	mov	al,'['
  1048 00000416 E81101                  	call	uart_out
  1049 00000419 B03F                    	mov	al,'?'
  1050 0000041B E80C01                  	call	uart_out
  1051 0000041E B032                    	mov	al,'2'
  1052 00000420 E80701                  	call	uart_out
  1053 00000423 B035                    	mov	al,'5'
  1054 00000425 E80201                  	call	uart_out
  1055 00000428 B068                    	mov	al,'h'
  1056 0000042A E8FD00                  	call	uart_out
  1057 0000042D 58                      	pop	ax
  1058                                  %elif  WYSE
  1059                                          pushm   ax
  1060                                  	mov	al,ESC
  1061                                  	call	uart_out
  1062                                          mov     al, '`'
  1063                                  	call	uart_out
  1064                                          mov     ax,[video_cursor_mode]
  1065                                          and     ax,1F1Fh
  1066                                          sub     al,ah
  1067                                          cmp     al,3
  1068                                          jb      .line
  1069                                  ; blinking block cursor
  1070                                          mov     al,'5'
  1071                                          jmp     .3
  1072                                  .line:  ; blinking line cursor
  1073                                          mov     al,'3'
  1074                                  .3:     call    uart_out
  1075                                  
  1076                                  	mov	al,ESC
  1077                                  	call	uart_out
  1078                                          mov     al, '`'
  1079                                  	call	uart_out
  1080                                          mov     al,'1'
  1081                                  	call	uart_out
  1082                                          popm    ax
  1083                                  %endif	; ANSI | WYSE
  1084 0000042E C3                      	ret
  1085                                  
  1086                                  ;========================================================================
  1087                                  ; clear_screen
  1088                                  ; Input:
  1089                                  ;	none
  1090                                  ; Output:
  1091                                  ;	AL is trashed
  1092                                  ;========================================================================
  1093                                  clear_screen:
  1094                                  %if   ANSI
  1095 0000042F B01B                    	mov	al,ESC		; clear screen - ESC[2J
  1096 00000431 E8F600                  	call	uart_out
  1097 00000434 B05B                    	mov	al,'['
  1098 00000436 E8F100                  	call	uart_out
  1099 00000439 B032                    	mov	al,'2'
  1100 0000043B E8EC00                  	call	uart_out
  1101 0000043E B04A                    	mov	al,'J'
  1102 00000440 E8E700                  	call	uart_out
  1103                                  %elif WYSE
  1104                                          call    uart_send
  1105                                          db      ESC, '+'        ; home cursor; clr to spaces; turn off
  1106                                                                  ; protect and write protect modes
  1107                                          db      ESC, "A00"      ; data area attribute NORMAL
  1108                                          db      ESC, "A1p"      ; label area DIM (bottom line)
  1109                                          db      ESC, "A3x"      ; terminal message field dim underline
  1110                                          db      ESC, "A2t"      ; computer message field dim reverse
  1111                                          db      ESC, '"'        ; unlock keyboard
  1112                                          db      EOS
  1113                                  %endif  ; ANSI | WYSE
  1114 00000443 C3                      	ret
  1115                                  
  1116                                  ;========================================================================
  1117                                  ; set_attributes - set specified background/foreground color
  1118                                  ; Input:
  1119                                  ;	BL = attributes
  1120                                  ;		color mode:
  1121                                  ;			bit 7 	 = 1 - blinking
  1122                                  ;			bits 6-4 = background color
  1123                                  ;			bits 3-0 = foreground color
  1124                                  ;		color mode with high intensity background
  1125                                  ;			bits 7-4 = background color
  1126                                  ;			bits 3-0 = foreground color
  1127                                  ;		monochrome mode
  1128                                  ;			01h = underline
  1129                                  ;			07h = normal
  1130                                  ;			09h = bright underline
  1131                                  ;			0Fh = bold
  1132                                  ;			70h = reverse (black on white)
  1133                                  ;			81h = blinking underline
  1134                                  ;			87h = blinking normal
  1135                                  ;			89h = blinking bright underline
  1136                                  ;			8Fh = blinking bold
  1137                                  ; Output:
  1138                                  ;	none
  1139                                  ; XXX:
  1140                                  ;	Add attribute cache, so we won't spend time setting the same attribute again
  1141                                  ;========================================================================
  1142                                  set_attributes:
  1143                                  %if	ANSI
  1144 00000444 50                      	push	ax
  1145                                  
  1146 00000445 B01B                    	mov	al,ESC
  1147 00000447 E8E000                  	call	uart_out
  1148 0000044A B05B                    	mov	al,'['
  1149 0000044C E8DB00                  	call	uart_out
  1150                                  
  1151 0000044F F6C308                  	test	bl,08h	; bold?
  1152 00000452 750A                    	jnz	.bold
  1153 00000454 B032                    	mov	al,'2'		; set normal mode - ESC[22m
  1154 00000456 E8D100                  	call	uart_out
  1155 00000459 E8CE00                  	call	uart_out
  1156 0000045C EB05                    	jmp	.check_mode
  1157                                  
  1158                                  .bold:
  1159 0000045E B031                    	mov	al,'1'		; set bold attribute - ESC[1m
  1160 00000460 E8C700                  	call	uart_out
  1161                                  
  1162                                  .check_mode:
  1163 00000463 A04900                  	mov	al,byte [video_mode]
  1164 00000466 3C07                    	cmp	al,7
  1165 00000468 7530                    	jne	.color
  1166                                  
  1167 0000046A B03B                    	mov	al,';'
  1168 0000046C E8BB00                  	call	uart_out
  1169                                  				; monochrome - set underline attribute
  1170 0000046F 88D8                    	mov	al,bl
  1171 00000471 2407                    	and	al,7		; get foreground attribute part
  1172 00000473 3C01                    	cmp	al,1		; underlined
  1173 00000475 740C                    	je	.underline
  1174 00000477 B032                    	mov	al,'2'		; set not underlined attribute - ESC[24m
  1175 00000479 E8AE00                  	call	uart_out
  1176 0000047C B034                    	mov	al,'4'
  1177 0000047E E8A900                  	call	uart_out
  1178 00000481 EB05                    	jmp	.mono_to_color
  1179                                  
  1180                                  .underline:
  1181 00000483 B034                    	mov	al,'4'		; set underlined attribute - ESC[4m
  1182 00000485 E8A200                  	call	uart_out
  1183                                  
  1184                                  .mono_to_color:
  1185 00000488 88D8                    	mov	al,bl
  1186 0000048A 2407                    	and	al,07h
  1187 0000048C 7403                    	jz	.mono_bg	; black foreground
  1188 0000048E 80CB07                  	or	bl,07h		; anything else is white
  1189                                  .mono_bg:
  1190 00000491 88D8                    	mov	al,bl
  1191 00000493 2470                    	and	al,70h
  1192 00000495 7403                    	jz	.color		; black background
  1193 00000497 80CB70                  	or	bl,70h		; anything else is white
  1194                                  .color:
  1195 0000049A B03B                    	mov	al,';'
  1196 0000049C E88B00                  	call	uart_out
  1197                                  
  1198 0000049F 88D8                    	mov	al,bl		; need to exchange bit 0 with 2
  1199 000004A1 80E3AA                  	and	bl,0AAh		; and bit 4 with bit 6
  1200 000004A4 A801                    	test	al,01h
  1201 000004A6 7403                    	jz	.no_blue_fg
  1202 000004A8 80CB04                  	or	bl,04h
  1203                                  .no_blue_fg:
  1204 000004AB A804                    	test	al,04h
  1205 000004AD 7403                    	jz	.no_red_fg
  1206 000004AF 80CB01                  	or	bl,01h
  1207                                  .no_red_fg:
  1208 000004B2 A810                    	test	al,10h
  1209 000004B4 7403                    	jz	.no_blue_bg
  1210 000004B6 80CB40                  	or	bl,40h
  1211                                  .no_blue_bg:
  1212 000004B9 A840                    	test	al,40h
  1213 000004BB 7403                    	jz	.no_red_bg
  1214 000004BD 80CB10                  	or	bl,10h
  1215                                  .no_red_bg:
  1216 000004C0 B033                    	mov	al,'3'		; set foreground color - ESC[3<0..7>m
  1217 000004C2 E86500                  	call	uart_out
  1218 000004C5 88D8                    	mov	al,bl
  1219 000004C7 2407                    	and	al,07h
  1220 000004C9 0430                    	add	al,'0'
  1221 000004CB E85C00                  	call	uart_out
  1222                                  
  1223 000004CE B03B                    	mov	al,';'
  1224 000004D0 E85700                  	call	uart_out
  1225                                  
  1226 000004D3 F6C380                  	test	bl,80h
  1227 000004D6 741F                    	jz	.normal_bg	; normal background
  1228 000004D8 A06500                  	mov	al,byte [video_hw_mode]
  1229 000004DB A820                    	test	al,20h		; intense colors 
  1230 000004DD 7518                    	jnz	.normal_bg	; normal background, blinking
  1231                                  
  1232 000004DF B031                    	mov	al,'1'		; set intense background color - ESC[10<0..7>m
  1233 000004E1 E84600                  	call	uart_out	; note - this is not supported everywhere
  1234 000004E4 B030                    	mov	al,'0'
  1235 000004E6 E84100                  	call	uart_out
  1236 000004E9 88D8                    	mov	al,bl
  1237 000004EB 2470                    	and	al,70h
  1238 000004ED C0E804                  	shr	al,4
  1239 000004F0 0430                    	add	al,'0'
  1240 000004F2 E83500                  	call	uart_out
  1241 000004F5 EB2C                    	jmp	.exit
  1242                                  
  1243                                  .normal_bg:
  1244 000004F7 B034                    	mov	al,'4'		; set background color - ESC[4<0..7>m
  1245 000004F9 E82E00                  	call	uart_out
  1246 000004FC 88D8                    	mov	al,bl
  1247 000004FE 2470                    	and	al,70h
  1248 00000500 C0E804                  	shr	al,4
  1249 00000503 0430                    	add	al,'0'
  1250 00000505 E82200                  	call	uart_out
  1251                                  
  1252 00000508 B03B                    	mov	al,';'
  1253 0000050A E81D00                  	call	uart_out
  1254                                  
  1255 0000050D F6C380                  	test	bl,80h
  1256 00000510 750C                    	jnz	.blink
  1257 00000512 B032                    	mov	al,'2'		; set not blinking attribute - ESC[25m
  1258 00000514 E81300                  	call	uart_out
  1259 00000517 B035                    	mov	al,'5'
  1260 00000519 E80E00                  	call	uart_out
  1261 0000051C EB05                    	jmp	.exit
  1262                                  
  1263                                  .blink:
  1264 0000051E B035                    	mov	al,'5'		; set blinking attribute - ESC[5m
  1265 00000520 E80700                  	call	uart_out
  1266                                  
  1267                                  .exit:
  1268 00000523 B06D                    	mov	al,'m'
  1269 00000525 E80200                  	call	uart_out
  1270                                  
  1271 00000528 58                      	pop	ax
  1272                                  %elif WYSE & 0
  1273                                  ;*** this needs to be implemented correctly
  1274                                  
  1275                                  	push	ax
  1276                                  
  1277                                  	mov	al,ESC
  1278                                  	call	uart_out
  1279                                  	mov	al,'['
  1280                                  	call	uart_out
  1281                                  
  1282                                  	test	bl,08h	; bold?
  1283                                  	jnz	.bold
  1284                                  	mov	al,'2'		; set normal mode - ESC[22m
  1285                                  	call	uart_out
  1286                                  	call	uart_out
  1287                                  	jmp	.check_mode
  1288                                  
  1289                                  .bold:
  1290                                  	mov	al,'1'		; set bold attribute - ESC[1m
  1291                                  	call	uart_out
  1292                                  
  1293                                  .check_mode:
  1294                                  	mov	al,byte [video_mode]
  1295                                  	cmp	al,7
  1296                                  	jne	.color
  1297                                  
  1298                                  	mov	al,';'
  1299                                  	call	uart_out
  1300                                  				; monochrome - set underline attribute
  1301                                  	mov	al,bl
  1302                                  	and	al,7		; get foreground attribute part
  1303                                  	cmp	al,1		; underlined
  1304                                  	je	.underline
  1305                                  	mov	al,'2'		; set not underlined attribute - ESC[24m
  1306                                  	call	uart_out
  1307                                  	mov	al,'4'
  1308                                  	call	uart_out
  1309                                  	jmp	.mono_to_color
  1310                                  
  1311                                  .underline:
  1312                                  	mov	al,'4'		; set underlined attribute - ESC[4m
  1313                                  	call	uart_out
  1314                                  
  1315                                  .mono_to_color:
  1316                                  	mov	al,bl
  1317                                  	and	al,07h
  1318                                  	jz	.mono_bg	; black foreground
  1319                                  	or	bl,07h		; anything else is white
  1320                                  .mono_bg:
  1321                                  	mov	al,bl
  1322                                  	and	al,70h
  1323                                  	jz	.color		; black background
  1324                                  	or	bl,70h		; anything else is white
  1325                                  .color:
  1326                                  	mov	al,';'
  1327                                  	call	uart_out
  1328                                  
  1329                                  	mov	al,bl		; need to exchange bit 0 with 2
  1330                                  	and	bl,0AAh		; and bit 4 with bit 6
  1331                                  	test	al,01h
  1332                                  	jz	.no_blue_fg
  1333                                  	or	bl,04h
  1334                                  .no_blue_fg:
  1335                                  	test	al,04h
  1336                                  	jz	.no_red_fg
  1337                                  	or	bl,01h
  1338                                  .no_red_fg:
  1339                                  	test	al,10h
  1340                                  	jz	.no_blue_bg
  1341                                  	or	bl,40h
  1342                                  .no_blue_bg:
  1343                                  	test	al,40h
  1344                                  	jz	.no_red_bg
  1345                                  	or	bl,10h
  1346                                  .no_red_bg:
  1347                                  	mov	al,'3'		; set foreground color - ESC[3<0..7>m
  1348                                  	call	uart_out
  1349                                  	mov	al,bl
  1350                                  	and	al,07h
  1351                                  	add	al,'0'
  1352                                  	call	uart_out
  1353                                  
  1354                                  	mov	al,';'
  1355                                  	call	uart_out
  1356                                  
  1357                                  	test	bl,80h
  1358                                  	jz	.normal_bg	; normal background
  1359                                  	mov	al,byte [video_hw_mode]
  1360                                  	test	al,20h		; intense colors 
  1361                                  	jnz	.normal_bg	; normal background, blinking
  1362                                  
  1363                                  	mov	al,'1'		; set intense background color - ESC[10<0..7>m
  1364                                  	call	uart_out	; note - this is not supported everywhere
  1365                                  	mov	al,'0'
  1366                                  	call	uart_out
  1367                                  	mov	al,bl
  1368                                  	and	al,70h
  1369                                  	shr	al,4
  1370                                  	add	al,'0'
  1371                                  	call	uart_out
  1372                                  	jmp	.exit
  1373                                  
  1374                                  .normal_bg:
  1375                                  	mov	al,'4'		; set background color - ESC[4<0..7>m
  1376                                  	call	uart_out
  1377                                  	mov	al,bl
  1378                                  	and	al,70h
  1379                                          shr     al,4
  1380                                  	add	al,'0'
  1381                                  	call	uart_out
  1382                                  
  1383                                  	mov	al,';'
  1384                                  	call	uart_out
  1385                                  
  1386                                  	test	bl,80h
  1387                                  	jnz	.blink
  1388                                  	mov	al,'2'		; set not blinking attribute - ESC[25m
  1389                                  	call	uart_out
  1390                                  	mov	al,'5'
  1391                                  	call	uart_out
  1392                                  	jmp	.exit
  1393                                  
  1394                                  .blink:
  1395                                  	mov	al,'5'		; set blinking attribute - ESC[5m
  1396                                  	call	uart_out
  1397                                  
  1398                                  .exit:
  1399                                  	mov	al,'m'
  1400                                  	call	uart_out
  1401                                  
  1402                                  	pop	ax
  1403                                  %endif	; ANSI | WYSE
  1404 00000529 C3                      	ret
  1405                                  
  1406                                  ;========================================================================
  1407                                  ; uart_out - write character to serial port
  1408                                  ; Input:
  1409                                  ;	AL = character to write
  1410                                  ; Output:
  1411                                  ;	none
  1412                                  ;========================================================================
  1413                                  uart_out:
  1414                                  %if UART_MODE3_SUPPRESS
  1415                                  	push	ds
  1416                                  	push	bios_data_seg
  1417                                  	popm	ds
  1418                                  	cmp	byte [video_mode],3
  1419                                  	popm	ds
  1420                                  	je	.9		; skip output in mode 3 (color)
  1421                                  %endif
  1422                                  ;;;	global	uart_out_	; used in debugging mode (C-callable)
  1423                                  ;;;uart_out_:			; **** label .9 cannot reach if un-commented
  1424 0000052A 52                      	push	dx
  1425 0000052B 50                      	push	ax
  1426                                  %if UART_DSR_PROTOCOL
  1427                                   %if SBC188<3
  1428                                          extern  microsecond
  1429                                  .wait_dsr:
  1430                                          mov     dx,uart_msr
  1431                                  BIT_DSR         equ     1<<5
  1432                                          in      al,dx           ; read the Modem Status Register
  1433                                          test    al,BIT_DSR      ; Data Set Ready
  1434                                          jnz     .nowait
  1435                                          push    cx
  1436                                          mov     cx,100
  1437                                          call    microsecond
  1438                                          pop     cx
  1439                                          jmp     .wait_dsr
  1440                                  .nowait:
  1441                                   %endif
  1442                                  %endif
  1443                                  .1:
  1444 0000052C BA8506                  	mov	dx,uart_lsr
  1445 0000052F EC                      	in	al,dx
  1446 00000530 A820                    	test	al,20h		; THRE is empty
  1447 00000532 74F8                    	jz	.1
  1448 00000534 58                      	pop	ax
  1449 00000535 BA8006                  	mov	dx,uart_thr
  1450 00000538 EE                      	out	dx,al		; write character
  1451 00000539 5A                      	pop	dx
  1452                                  .9:
  1453 0000053A C3                      	ret
  1454                                  
  1455                                  %if  WYSE
  1456                                  ;========================================================================
  1457                                  ; uart_send - write an in-line EOS terminated string to serial port
  1458                                  ; Input:
  1459                                  ;	in the instruction stream
  1460                                  ; Output:
  1461                                  ;	destroys AX
  1462                                  ;========================================================================
  1463                                  uart_send:
  1464                                          pop     ax              ; pointer to character string
  1465                                          xchg    ax,si
  1466                                  	pushm	ax		; save SI
  1467                                  
  1468                                  .next:
  1469                                      cs	lodsb			; load byte at CS:SI
  1470                                          inc     al
  1471                                          jz      .done           ; EOS is 0FFh, so this is easy test
  1472                                          dec     al
  1473                                          call    uart_out
  1474                                          jmp     .next
  1475                                  .done:
  1476                                  	popm	ax		; restore SI
  1477                                          xchg    ax,si		; **
  1478                                          jmp     ax		; RETURN
  1479                                  %endif ; WYSE
  1480                                  
  1481                                  ;========================================================================
  1482                                  ; video_init - initialize video service
  1483                                  ; Input:
  1484                                  ;	AL = baud rate
  1485                                  ;	DS = DGROUP
  1486                                  ; Output:
  1487                                  ;	none
  1488                                  ;========================================================================
  1489                                  	global	video_init
  1490                                  video_init:
  1491                                  		; XXX - move interrupt registration code here
  1492 0000053B 50                      	push	ax
  1493 0000053C E8FE00                  	call	uart_init
  1494 0000053F BA8006                  	mov	dx,uart_base
  1495 00000542 E84301                  	call	uart_detect
  1496 00000545 50                      	push	ax
  1497                                  %if SOFT_DEBUG
  1498                                  	extern	lites
  1499                                  	or	al,0C0h
  1500                                  	push	ax
  1501                                  	call	lites
  1502                                  	extern	crlf,boutsp,wout,bout,cout
  1503                                  %if 1
  1504                                  	pop	ax
  1505                                  	push	ax
  1506                                  	call	boutsp
  1507                                  	call	crlf
  1508                                  	pushm	dx,cx
  1509                                  	mov	cx,uart_sr-uart_iir+1
  1510                                  	mov	dx,uart_iir
  1511                                  .234:	in	al,dx
  1512                                  	call	boutsp
  1513                                  	inc	dl
  1514                                  	loop	.234
  1515                                  	popm	dx,cx
  1516                                  %endif
  1517                                  %endif
  1518                                  %if CVDU|VGA3
  1519                                  	mov	ax,0003h
  1520                                  %else
  1521 00000546 B80700                  	mov	ax,0007h
  1522                                  %endif
  1523 00000549 CD10                    	int	10h
  1524 0000054B 58                      	pop	ax
  1525                                  %if SOFT_DEBUG
  1526                                  	push	ax
  1527                                  	call	boutsp
  1528                                  	pop	ax
  1529                                  %endif
  1530 0000054C 0E                      	push	cs
  1531 0000054D 3C04                    	cmp	al,UART_16550A
  1532 0000054F 7205                    	jb	.no_fifo
  1533 00000551 68[3606]                	push	.enabled
  1534 00000554 EB03                    	jmp	.print_uart
  1535                                  .no_fifo:
  1536 00000556 68[3906]                	push	.disabled
  1537                                  .print_uart:
  1538 00000559 0E                      	push	cs
  1539 0000055A 3C01                    	cmp	al,UART_8250
  1540 0000055C 7505                    	jne	.check_16450
  1541 0000055E 68[F705]                	push	.uart_8250
  1542 00000561 EB42                    	jmp	.print_hi
  1543                                  .check_16450:
  1544 00000563 3C02                    	cmp	al,UART_16450
  1545 00000565 7505                    	jne	.check_16550
  1546 00000567 68[FC05]                	push	.uart_16450
  1547 0000056A EB39                    	jmp	.print_hi
  1548                                  .check_16550:
  1549 0000056C 3C03                    	cmp	al,UART_16550
  1550 0000056E 7505                    	jne	.check_16550A
  1551 00000570 68[0806]                	push	.uart_16550
  1552 00000573 EB30                    	jmp	.print_hi
  1553                                  .check_16550A:
  1554 00000575 3C04                    	cmp	al,UART_16550A
  1555 00000577 7505                    	jne	.check_16550C
  1556 00000579 68[0E06]                	push	.uart_16550A
  1557 0000057C EB27                    	jmp	.print_hi
  1558                                  .check_16550C:
  1559 0000057E 3C05                    	cmp	al,UART_16550C
  1560 00000580 7505                    	jne	.check_16650
  1561 00000582 68[1506]                	push	.uart_16550C
  1562 00000585 EB1E                    	jmp	.print_hi
  1563                                  .check_16650:
  1564 00000587 3C06                    	cmp	al,UART_16650
  1565 00000589 7505                    	jne	.check_16750
  1566 0000058B 68[1C06]                	push	.uart_16650
  1567 0000058E EB15                    	jmp	.print_hi
  1568                                  .check_16750:
  1569 00000590 3C07                    	cmp	al,UART_16750
  1570 00000592 7505                    	jne	.check_16850
  1571 00000594 68[2206]                	push	.uart_16750
  1572 00000597 EB0C                    	jmp	.print_hi
  1573                                  .check_16850:
  1574 00000599 3C08                    	cmp	al,UART_16850
  1575 0000059B 7505                    	jne	.unknown
  1576 0000059D 68[2806]                	push	.uart_16850
  1577 000005A0 EB03                    	jmp	.print_hi
  1578                                  .unknown:
  1579 000005A2 68[2E06]                	push	.uart_unknown
  1580                                  .print_hi:
  1581 000005A5 0E                      	push	cs
  1582 000005A6 68[B105]                	push	.hi
  1583                                  	extern	_cprintf
  1584 000005A9 E8(0000)                	call	_cprintf	; _cprintf uses int10 0Eh
  1585 000005AC 83C40C                  	add	sp,12
  1586                                  
  1587 000005AF 58                      	pop	ax
  1588                                  %if SOFT_DEBUG
  1589                                  ;;;	hlt
  1590                                  %endif
  1591 000005B0 C3                      	ret
  1592                                  
  1593                                  .hi:
  1594                                  %if ANY_VIDEO
  1595                                  %if CVDU_8563
  1596                                  	db	'ColorVDU BIOS (c) 2013 John R. Coffman', NL
  1597                                  %endif
  1598                                  %if VGA3_6445
  1599                                  	db	'VGA3 Video BIOS (c) 2017 John R. Coffman', NL
  1600                                  %endif
  1601                                  
  1602                                  %if UART
  1603                                  	db	'Serial I/O BIOS (c) 2010 Sergey Kiselev', NL
  1604                                  	db	'Detected %s UART, FIFO is %sabled', NL
  1605                                  %endif
  1606                                  %else
  1607 000005B1 566964656F2042494F-     	db	'Video BIOS (C) 2010 Sergey Kiselev', NL
  1607 000005BA 532028432920323031-
  1607 000005C3 302053657267657920-
  1607 000005CC 4B6973656C65760A   
  1608 000005D4 446574656374656420-     	db	'Detected %s UART, FIFO is %sabled', NL
  1608 000005DD 257320554152542C20-
  1608 000005E6 4649464F2069732025-
  1608 000005EF 7361626C65640A     
  1609                                  %endif
  1610 000005F6 00                      	db	0
  1611                                  
  1612                                  .uart_8250:
  1613 000005F7 3832353000              	db	'8250', 0
  1614                                  .uart_16450:
  1615 000005FC 38323530412F313634-     	db	'8250A/16450', 0
  1615 00000605 353000             
  1616                                  .uart_16550:
  1617 00000608 313635353000            	db	'16550', 0
  1618                                  .uart_16550A:
  1619 0000060E 31363535304100          	db	'16550A', 0
  1620                                  .uart_16550C:
  1621 00000615 31363535304300          	db	'16550C', 0
  1622                                  .uart_16650:
  1623 0000061C 313636353000            	db	'16650', 0
  1624                                  .uart_16750:
  1625 00000622 313637353000            	db	'16750', 0
  1626                                  .uart_16850:
  1627 00000628 313638353000            	db	'16850', 0
  1628                                  .uart_unknown:
  1629 0000062E 756E6B6E6F776E00        	db	'unknown', 0
  1630                                  .enabled:
  1631 00000636 656E00                  	db	'en', 0
  1632                                  .disabled:
  1633 00000639 64697300                	db	'dis', 0
  1634                                  
  1635                                  ;========================================================================
  1636                                  ; uart_init - initialize UART
  1637                                  ; Input:
  1638                                  ;	AL = baud rate
  1639                                  ; Output:
  1640                                  ;	none
  1641                                  ;========================================================================
  1642                                  uart_init:
  1643 0000063D 525350                  	pushm	ax,bx,dx
  1644 00000640 B400                    	mov	ah,0
  1645 00000642 D0E0                    	shl	al,1
  1646 00000644 89C3                    	mov	bx,ax		; Index in the .divisors table
  1647 00000646 2E8B9F[7806]               cs	mov	bx,word[.divisors+bx]
  1648                                  	; Divisor Latch Access bit set, no parity, one stop bit, 8 data bits
  1649 0000064B B083                    	mov	al,83h
  1650 0000064D BA8306                  	mov	dx,uart_lcr
  1651 00000650 EE                      	out	dx,al
  1652                                  	; Lookup table for baud rates
  1653 00000651 88D8                    	mov	al,bl		; low byte
  1654 00000653 BA8006                  	mov	dx,uart_dll
  1655 00000656 EE                      	out	dx,al
  1656 00000657 88F8                    	mov	al,bh		; high byte
  1657 00000659 BA8106                  	mov	dx,uart_dlm
  1658 0000065C EE                      	out	dx,al
  1659                                  	; no parity, one stop bit, 8 data bits
  1660 0000065D B003                    	mov	al,03h
  1661 0000065F BA8306                  	mov	dx,uart_lcr
  1662 00000662 EE                      	out	dx,al
  1663                                  	; XXX?
  1664 00000663 BA8406                  	mov	dx,uart_mcr
  1665 00000666 EC                      	in	al,dx				; for SBC3
  1666 00000667 0C07                    	or	al,7
  1667 00000669 EE                      	out	dx,al
  1668                                  	; disable interrupts for now
  1669 0000066A B000                    	mov	al,0		; AL = 0
  1670 0000066C BA8106                  	mov	dx,uart_ier
  1671 0000066F EE                      	out	dx,al
  1672                                  	; disable FIFO for now
  1673                                  	; note - AL = 0
  1674 00000670 BA8206                  	mov	dx,uart_fcr
  1675 00000673 EE                      	out	dx,al
  1676 00000674 585B5A                  	popm	ax,bx,dx
  1677 00000677 C3                      	ret
  1678                                  
  1679                                  .divisors:
  1680 00000678 6000                    	dw	UART_OSC/16/1200	; 1200 Kbit/sec
  1681 0000067A 3000                    	dw	UART_OSC/16/2400	; 2400 Kbit/sec
  1682 0000067C 1800                    	dw	UART_OSC/16/4800	; 4800 Kbit/sec
  1683 0000067E 0C00                    	dw	UART_OSC/16/9600	; 9600 Kbit/sec
  1684 00000680 0600                    	dw	UART_OSC/16/19200	; 19200 Kbit/sec
  1685 00000682 0300                    	dw	UART_OSC/16/38400	; 38400 Kbit/sec
  1686 00000684 0200                    	dw	UART_OSC/16/57600	; 57600 Kbit/sec
  1687 00000686 0100                    	dw	UART_OSC/16/115200	; 115200 Kbit/sec
  1688                                  
  1689                                  %if 0
  1690                                  ;========================================================================
  1691                                  ; uart_detect - detect UART type, enable FIFO if present
  1692                                  ; Input:
  1693                                  ;	none
  1694                                  ; Output:
  1695                                  ;	AL = UART type
  1696                                  ;
  1697                                  ; UART detection code from
  1698                                  ; http://en.wikibooks.org/wiki/Serial_Programming/8250_UART_Programming
  1699                                  ;========================================================================
  1700                                  UART_8250	equ	1
  1701                                  UART_16450	equ	2
  1702                                  UART_16550	equ	3
  1703                                  UART_16550A	equ	4
  1704                                  UART_16550C	equ	5
  1705                                  UART_16650	equ	6
  1706                                  UART_16750	equ	7
  1707                                  UART_16850	equ	8
  1708                                  
  1709                                  uart_detect:
  1710                                  	push	dx
  1711                                  	; Set the value "0xE7" to the FCR to test the status of the FIFO flags
  1712                                  	mov	al,0E7h
  1713                                  	mov	dx,uart_fcr
  1714                                  	out	dx,al
  1715                                  	; Read the value of the IIR to test for what flags actually got set
  1716                                  	mov	dx,uart_iir
  1717                                  	in	al,dx
  1718                                  	test	al,40h
  1719                                  	jz	.no_fifo
  1720                                  	test	al,80h
  1721                                  	jz	.uart_16550
  1722                                  	test	al,20h
  1723                                  	jz	.uart_16550A
  1724                                  	mov	al,UART_16750
  1725                                  	jmp	.exit
  1726                                  .uart_16550A:
  1727                                  	mov	al,UART_16550A
  1728                                  	jmp	.exit
  1729                                  .uart_16550:
  1730                                  	; Disable FIFO on 16550 (FIFO is broken)
  1731                                  	mov	al,0
  1732                                  	mov	dx,uart_fcr
  1733                                  	out	dx,al
  1734                                  	mov	al,UART_16550
  1735                                  	jmp	.exit
  1736                                  .no_fifo:
  1737                                  	; Chip doesn't use FIFO, so we need to check the scratch register
  1738                                  	; Set some arbitrary value like 0x2A to the Scratch Register
  1739                                  	mov	al,2Ah
  1740                                  	mov	dx,uart_sr
  1741                                  	out	dx,al
  1742                                  	; Read the value of the Scratch Register
  1743                                  	in	al,dx
  1744                                  	cmp	al,2Ah
  1745                                  	jnz	.uart_8250
  1746                                  	; If the arbitrary value comes back identical
  1747                                  	mov	al,UART_16450
  1748                                  	jmp	.exit
  1749                                  .uart_8250:
  1750                                  	mov	al,UART_8250
  1751                                  .exit:
  1752                                  	pop	dx
  1753                                  	ret
  1754                                  %else
  1755                                  %include "uart_det.asm"
  1756                              <1> ;========================================================================
  1757                              <1> ; uart_detect - detect UART type, enable FIFO if present
  1758                              <1> ;========================================================================
  1759                              <1> ;
  1760                              <1> ; Copyright (C) 2012,2020 John R Coffman.  All rights reserved.
  1761                              <1> ; Provided for hobbyist use on the RetroBrew Computers' SBC-188 boards.
  1762                              <1> ;
  1763                              <1> ; This program is free software: you can redistribute it and/or modify
  1764                              <1> ; it under the terms of the GNU General Public License as published by
  1765                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1766                              <1> ; (at your option) any later version.
  1767                              <1> ;
  1768                              <1> ; This program is distributed in the hope that it will be useful,
  1769                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1770                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1771                              <1> ; GNU General Public License for more details.
  1772                              <1> ;
  1773                              <1> ; You should have received a copy of the GNU General Public License
  1774                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1775                              <1> ;
  1776                              <1> ;========================================================================
  1777                              <1> ; History:
  1778                              <1> ;   Derived from the RetroBrew/JRCoffman UNA source code 'uart_det.s'
  1779                              <1> ;   Copyright (C) 2012 John Coffman.  All rights reserved.
  1780                              <1> ;   Distributed under the above GPL license.
  1781                              <1> ;========================================================================
  1782                              <1> %ifdef STANDALONE
  1783                              <1> %include "config.asm"
  1784                              <1> %include "cpuregs.asm"
  1785                              <1> ;
  1786                              <1> ; C-language interface:
  1787                              <1> ;	unsigned char near uart_det(unsigned dev);
  1788                              <1> 	global	uart_det_
  1789                              <1>    SEGMENT  _TEXT ALIGN=2 PUBLIC CLASS=CODE
  1790                              <1> uart_det_:
  1791                              <1> 	mov	dx,ax
  1792                              <1> 	call	uart_detect
  1793                              <1> 	ret
  1794                              <1> %endif
  1795                              <1> ;========================================================================
  1796                              <1> ; uart_detect - detect UART type, enable FIFO if present
  1797                              <1> ;
  1798                              <1> ; Input:
  1799                              <1> ;	DX = UART device code to probe
  1800                              <1> ;
  1801                              <1> ; Output:
  1802                              <1> ;	AL = UART type
  1803                              <1> ;
  1804                              <1> ; UART detection code from
  1805                              <1> ; http://en.wikibooks.org/wiki/Serial_Programming/8250_UART_Programming
  1806                              <1> ;========================================================================
  1807                              <1> UART_NONE	equ	0	; no UART detected
  1808                              <1> UART_8250	equ	1	; no Scratch register
  1809                              <1> UART_16450	equ	2	; or 8250A
  1810                              <1> UART_16550	equ	3
  1811                              <1> UART_16550A	equ	4
  1812                              <1> UART_16550C	equ	5
  1813                              <1> UART_16650	equ	6
  1814                              <1> UART_16750	equ	7
  1815                              <1> UART_16850	equ	8
  1816                              <1> ;*******************************************************************
  1817                              <1> ;***N.B.:  the above list must be kept in sync with 'sio.h' enum ***
  1818                              <1> ;*******************************************************************
  1819                              <1> 
  1820                              <1> ; macros assume DI is set to base UART register
  1821                              <1> %macro	uget 2		; dest reg8, src UART reg or offset
  1822                              <1> 	mov	bl,(%2)&0xFF
  1823                              <1> 	call	udet_get
  1824                              <1> 	mov	%1,al
  1825                              <1> %endmacro
  1826                              <1> 
  1827                              <1> %macro	uput 2		; dest UART reg or offset, src reg8
  1828                              <1> 	mov	bl,(%1)&0xFF
  1829                              <1> 	mov	al,%2
  1830                              <1> 	call	udet_put
  1831                              <1> %endmacro
  1832                              <1> 
  1833                              <1> %macro	 ucmp 2		; dest UART reg (read to AL), src reg8 or value
  1834                              <1> 	mov	bl,(%1)&0xFF
  1835                              <1> 	call	udet_get
  1836                              <1> 	cmp	al,(%2)&0xFF
  1837                              <1> %endmacro
  1838                              <1> 
  1839                              <1> uart_detect:
  1840 00000688 57535152            <1> 	pushm	dx,cx,bx,di
  1841 0000068C 31C9                <1> 	xor	cx,cx		; no uart present CL=0
  1842 0000068E 83E2F8              <1> 	and	dx,~7		; mask 8 UART registers
  1843 00000691 89D7                <1> 	mov	di,dx		; device base to di
  1844                              <1> ; UART is present if toggling the DLAT bit in LCR makes divisor available
  1845                              <1> 	uget	ch,uart_lcr	; save LCR value
  1822 00000693 B383                <2>  mov bl,(%2)&0xFF
  1823 00000695 E8EC00              <2>  call udet_get
  1824 00000698 88C5                <2>  mov %1,al
  1846                              <1> 	uput	uart_lcr,0	; make DLAT inaccessible
  1828 0000069A B383                <2>  mov bl,(%1)&0xFF
  1829 0000069C B000                <2>  mov al,%2
  1830 0000069E E8DA00              <2>  call udet_put
  1847                              <1> 	uput	uart_ier,0	; IER==DLM
  1828 000006A1 B381                <2>  mov bl,(%1)&0xFF
  1829 000006A3 B000                <2>  mov al,%2
  1830 000006A5 E8D300              <2>  call udet_put
  1848                              <1> 	uput	uart_lcr,0x80	; LCR  set DLAT bit
  1828 000006A8 B383                <2>  mov bl,(%1)&0xFF
  1829 000006AA B080                <2>  mov al,%2
  1830 000006AC E8CC00              <2>  call udet_put
  1849                              <1> 	uget	bh,uart_dlm	; save DLM
  1822 000006AF B381                <2>  mov bl,(%2)&0xFF
  1823 000006B1 E8D000              <2>  call udet_get
  1824 000006B4 88C7                <2>  mov %1,al
  1850                              <1> 	uput	uart_dlm,0x5a	; DLM==IER  set some pattern
  1828 000006B6 B381                <2>  mov bl,(%1)&0xFF
  1829 000006B8 B05A                <2>  mov al,%2
  1830 000006BA E8BE00              <2>  call udet_put
  1851                              <1> 	ucmp	uart_dlm,0x5a	; does it read back the same?
  1834 000006BD B381                <2>  mov bl,(%1)&0xFF
  1835 000006BF E8C200              <2>  call udet_get
  1836 000006C2 3C5A                <2>  cmp al,(%2)&0xFF
  1852 000006C4 7403E9AA00          <1> 	jne	.exit		; no UART here
  1853                              <1> 	uput	uart_lcr,0x00	; LCR=00, reset DLAT
  1828 000006C9 B383                <2>  mov bl,(%1)&0xFF
  1829 000006CB B000                <2>  mov al,%2
  1830 000006CD E8AB00              <2>  call udet_put
  1854                              <1> 	ucmp	uart_dlm,0x5a	; is it still 0x5A?
  1834 000006D0 B381                <2>  mov bl,(%1)&0xFF
  1835 000006D2 E8AF00              <2>  call udet_get
  1836 000006D5 3C5A                <2>  cmp al,(%2)&0xFF
  1855 000006D7 7503E99700          <1> 	je	.exit		; no uart if still 0x5A
  1856                              <1> 
  1857                              <1> ; restore DLM
  1858                              <1> 	uput	uart_lcr,0x80
  1828 000006DC B383                <2>  mov bl,(%1)&0xFF
  1829 000006DE B080                <2>  mov al,%2
  1830 000006E0 E89800              <2>  call udet_put
  1859                              <1> 	uput	uart_dlm,bh
  1828 000006E3 B381                <2>  mov bl,(%1)&0xFF
  1829 000006E5 88F8                <2>  mov al,%2
  1830 000006E7 E89100              <2>  call udet_put
  1860 000006EA 80E57F              <1> 	and	ch,~0x80	; clear DLAT
  1861                              <1> 	uput	uart_lcr,ch	; restore DLAT
  1828 000006ED B383                <2>  mov bl,(%1)&0xFF
  1829 000006EF 88E8                <2>  mov al,%2
  1830 000006F1 E88700              <2>  call udet_put
  1862 000006F4 41                  <1> 	inc	cx		; UART=8250 or above is present
  1863                              <1> ; look for the Scratch register
  1864                              <1> 	uput	uart_sr,0x5a	; set a value
  1828 000006F5 B387                <2>  mov bl,(%1)&0xFF
  1829 000006F7 B05A                <2>  mov al,%2
  1830 000006F9 E87F00              <2>  call udet_put
  1865                              <1> 	ucmp	uart_sr,0x5a	; does it read back
  1834 000006FC B387                <2>  mov bl,(%1)&0xFF
  1835 000006FE E88300              <2>  call udet_get
  1836 00000701 3C5A                <2>  cmp al,(%2)&0xFF
  1866 00000703 756E                <1> 	jne	.exit		; test for no Scratch register
  1867                              <1> 
  1868 00000705 41                  <1> 	inc	cx		; 8250A, 16450 or higher
  1869                              <1> 	uput	uart_lcr,0xBF	; special value for higher UARTs
  1828 00000706 B383                <2>  mov bl,(%1)&0xFF
  1829 00000708 B0BF                <2>  mov al,%2
  1830 0000070A E86E00              <2>  call udet_put
  1870                              <1> 	ucmp	uart_sr,0x5A	; is it still 0x5a?
  1834 0000070D B387                <2>  mov bl,(%1)&0xFF
  1835 0000070F E87200              <2>  call udet_get
  1836 00000712 3C5A                <2>  cmp al,(%2)&0xFF
  1871 00000714 7404                <1> 	je	.below650
  1872 00000716 B106                <1> 	mov	cl,6		; it is a 16650 or 16850, which cannot
  1873 00000718 EB59                <1> 	jmp	.exit		;  be distinguished
  1874                              <1> .below650:
  1875                              <1> ; UART is 16550C or below
  1876                              <1> 	uput	uart_lcr,0x80	; set DLAT again
  1828 0000071A B383                <2>  mov bl,(%1)&0xFF
  1829 0000071C B080                <2>  mov al,%2
  1830 0000071E E85A00              <2>  call udet_put
  1877                              <1> 	uput	uart_fcr,0xE1	; output to FCR (FIFO Control)
  1828 00000721 B382                <2>  mov bl,(%1)&0xFF
  1829 00000723 B0E1                <2>  mov al,%2
  1830 00000725 E85300              <2>  call udet_put
  1878                              <1> 	uget	bh,uart_iir	; FCR=IIR
  1822 00000728 B382                <2>  mov bl,(%2)&0xFF
  1823 0000072A E85700              <2>  call udet_get
  1824 0000072D 88C7                <2>  mov %1,al
  1879                              <1> 	uput	uart_lcr,0x07	; reset the LCR DLAT bit & set 8n2
  1828 0000072F B383                <2>  mov bl,(%1)&0xFF
  1829 00000731 B007                <2>  mov al,%2
  1830 00000733 E84500              <2>  call udet_put
  1880                              <1> ; test for a FIFO
  1881 00000736 F6C740              <1> 	test	bh,1<<6		; test low order FIFO bit
  1882 00000739 7438                <1> 	jz	.exit		; 16450 if zero
  1883                              <1> 
  1884 0000073B 41                  <1> 	inc	cx		; 16550 or higher
  1885 0000073C F6C780              <1> 	test	bh,1<<7		; test high FIFO bit
  1886 0000073F 7432                <1> 	jz	.exit		; 16550 if zero
  1887                              <1> 
  1888 00000741 41                  <1> 	inc	cx		; 16550A or higher
  1889 00000742 F6C720              <1> 	test	bh,1<<5		; test for 64-byte FIFO
  1890 00000745 7404                <1> 	jz	.is550AorC
  1891                              <1> ; has a 64-byte FIFO
  1892 00000747 B107                <1> 	mov	cl,7		; it is a 16750
  1893 00000749 EB28                <1> 	jmp	.exit
  1894                              <1> 
  1895                              <1> ; two levels of UART left to distinguish
  1896                              <1> .is550AorC:
  1897                              <1> ;;;;				; 16550A or higher
  1898                              <1> 	uget	bh,uart_mcr	; save MCR setting
  1822 0000074B B384                <2>  mov bl,(%2)&0xFF
  1823 0000074D E83400              <2>  call udet_get
  1824 00000750 88C7                <2>  mov %1,al
  1899 00000752 80CF20              <1> 	or	bh,1<<5		; set bit 5
  1900                              <1> 	uput	uart_mcr,bh	; set the AFE bit (auto flowcontrol enable)
  1828 00000755 B384                <2>  mov bl,(%1)&0xFF
  1829 00000757 88F8                <2>  mov al,%2
  1830 00000759 E81F00              <2>  call udet_put
  1901                              <1> 	uget	bh,uart_mcr	; read it back
  1822 0000075C B384                <2>  mov bl,(%2)&0xFF
  1823 0000075E E82300              <2>  call udet_get
  1824 00000761 88C7                <2>  mov %1,al
  1902 00000763 F6C720              <1> 	test	bh,1<<5		; is the bit still set
  1903 00000766 740B                <1> 	jz	.exit
  1904 00000768 41                  <1> 	inc	cx		; 16550C found
  1905 00000769 80E7DF              <1> 	and	bh,0xFF-(1<<5)	; clear the AFE bit
  1906                              <1> 	uput	uart_mcr,bh	; AFC is broken on DIP version of 16550
  1828 0000076C B384                <2>  mov bl,(%1)&0xFF
  1829 0000076E 88F8                <2>  mov al,%2
  1830 00000770 E80800              <2>  call udet_put
  1907                              <1> .exit:
  1908 00000773 88C8                <1> 	mov	al,cl		; return UART ID
  1909 00000775 98                  <1> 	cbw
  1910 00000776 5A595B5F            <1> 	popm	dx,cx,bx,di
  1911 0000077A C3                  <1> 	ret
  1912                              <1> 
  1913                              <1> udet_put:
  1914 0000077B 53                  <1> 	push	bx
  1915 0000077C 83E307              <1> 	and	bx,7		; mask to uart offset
  1916 0000077F 8D11                <1> 	lea	dx,[di+bx]	; device code to DX
  1917 00000781 EE                  <1> 	out	dx,al
  1918 00000782 5B                  <1> 	pop	bx
  1919 00000783 C3                  <1> 	ret
  1920                              <1> udet_get:
  1921 00000784 53                  <1> 	push	bx
  1922 00000785 83E307              <1> 	and	bx,7		; mask to uart offset
  1923 00000788 8D11                <1> 	lea	dx,[di+bx]	; device code to DX
  1924 0000078A EC                  <1> 	in	al,dx
  1925 0000078B 5B                  <1> 	pop	bx
  1926 0000078C C3                  <1> 	ret
  1927                              <1> 
  1928                              <1> 
  1929                              <1> 
  1930                              <1> ;========================================================================
  1931                              <1> ; is_present_4UART -- check for presence of 4UART board
  1932                              <1> ;
  1933                              <1> ; Input:
  1934                              <1> ;	none
  1935                              <1> ;
  1936                              <1> ; Output:
  1937                              <1> ;	AX = 0	if board is not present
  1938                              <1> ;	  != 0	if board is present (returns base device code, 4C0h or 4A0h
  1939                              <1> ;
  1940                              <1> ;
  1941                              <1> ; C-callable:
  1942                              <1> ;	int is_present_4UART(void);
  1943                              <1> ;
  1944                              <1> ; UART detection code from
  1945                              <1> ; http://en.wikibooks.org/wiki/Serial_Programming/8250_UART_Programming
  1946                              <1> ;========================================================================
  1947                              <1> 	global	is_present_4UART_
  1948                              <1> 
  1949                              <1> is_present_4UART_:		; Watcom calling convention
  1950 0000078D 5652                <1> 	pushm	dx,si
  1951 0000078F BAD804              <1> 	mov	dx,dev_4UART_D
  1952 00000792 E8F3FE              <1> 	call	uart_detect
  1953 00000795 3C06                <1> 	cmp	al,UART_16650
  1954 00000797 7519                <1> 	jne	.not_present
  1955                              <1> 
  1956 00000799 BAD004              <1> 	mov	dx,dev_4UART_C
  1957 0000079C E8E9FE              <1> 	call	uart_detect
  1958 0000079F 3C06                <1> 	cmp	al,UART_16650
  1959 000007A1 750F                <1> 	jne	.not_present
  1960                              <1> 
  1961                              <1> ; dangerouts to test the B_uart, since the 4UART control register
  1962                              <1> ; overlays the B_uart scratch register.  However, the uart_detect
  1963                              <1> ; code above does not set bit 7, which is the LOCKOUT bit.
  1964                              <1> %if 0
  1965                              <1> 	mov	dx,dev_4UART_B
  1966                              <1> 	call	uart_detect
  1967                              <1> 	cmp	al,UART_16650
  1968                              <1> 	jne	.not_present
  1969                              <1> %endif
  1970                              <1> 
  1971 000007A3 BAC004              <1> 	mov	dx,dev_4UART_A
  1972 000007A6 E8DFFE              <1> 	call	uart_detect
  1973 000007A9 3C06                <1> 	cmp	al,UART_16650
  1974 000007AB 7505                <1> 	jne	.not_present
  1975                              <1> 
  1976 000007AD B8C004              <1> 	mov	AX,dev_4UART_base
  1977 000007B0 EB02                <1> 	jmp	.return	
  1978                              <1> .not_present:
  1979 000007B2 31C0                <1> 	xor	ax,ax
  1980                              <1> .return:
  1981 000007B4 5A5E                <1> 	popm	dx,si
  1982 000007B6 C3                  <1> 	ret
  1983                              <1> 
  1984                              <1> 
  1985                              <1> 
  1986                              <1> 
  1987                              <1> 
  1988                              <1> ;========================================================================
  1989                              <1> ; is_present_2S1P -- check for presence of 2S1P board
  1990                              <1> ;	!!! This test may only be done IFF the 4UART board is NOT present
  1991                              <1> ;	Otherwise, the 4UART control register may be damaged.
  1992                              <1> ;
  1993                              <1> ; Input:
  1994                              <1> ;	none
  1995                              <1> ;
  1996                              <1> ; Output:
  1997                              <1> ;	AX = 0	if board is not present
  1998                              <1> ;	  != 0	if board is present (returns base device code, 4C0h or 4A0h
  1999                              <1> ;
  2000                              <1> ;
  2001                              <1> ; C-callable:
  2002                              <1> ;	int is_present_2S1P(void);
  2003                              <1> ;
  2004                              <1> ; UART detection code from
  2005                              <1> ; http://en.wikibooks.org/wiki/Serial_Programming/8250_UART_Programming
  2006                              <1> ;========================================================================
  2007                              <1> 	global	is_present_2S1P_
  2008                              <1> 
  2009                              <1> is_present_2S1P_:		; Watcom calling convention
  2010 000007B7 5652                <1> 	pushm	dx,si
  2011                              <1> 
  2012 000007B9 BAD804              <1> 	mov	dx,dev_2S1P_C+8	; board selects, but there is nothing there
  2013 000007BC E8C9FE              <1> 	call	uart_detect
  2014 000007BF 3C00                <1> 	cmp	al,UART_NONE	; if a UART is there, it may be 4UART board
  2015 000007C1 7523                <1> 	jne	.not_present
  2016                              <1> 
  2017 000007C3 BAD004              <1> 	mov	dx,dev_2S1P_C
  2018 000007C6 E8BFFE              <1> 	call	uart_detect
  2019 000007C9 3C00                <1> 	cmp	al,UART_NONE
  2020 000007CB 7519                <1> 	jne	.not_present
  2021                              <1> 
  2022 000007CD BAC804              <1> 	mov	dx,dev_2S1P_B
  2023 000007D0 E8B5FE              <1> 	call	uart_detect
  2024 000007D3 3C04                <1> 	cmp	al,UART_16550A		; value for TL16C552 chip
  2025 000007D5 750F                <1> 	jne	.not_present
  2026                              <1> 
  2027 000007D7 BAC004              <1> 	mov	dx,dev_2S1P_A
  2028 000007DA E8ABFE              <1> 	call	uart_detect
  2029 000007DD 3C04                <1> 	cmp	al,UART_16550A		; value for TL16C552 chip
  2030 000007DF 7505                <1> 	jne	.not_present
  2031                              <1> 
  2032 000007E1 B8C004              <1> 	mov	AX,dev_2S1P_base
  2033 000007E4 EB02                <1> 	jmp	.return	
  2034                              <1> .not_present:
  2035 000007E6 31C0                <1> 	xor	ax,ax
  2036                              <1> .return:
  2037 000007E8 5A5E                <1> 	popm	dx,si
  2038 000007EA C3                  <1> 	ret
  2039                              <1> 
  2040                              <1> 
  2041                              <1> 
  2042                              <1> 
  2043                              <1> 
  2044                              <1> 
  2045                              <1> 
  2046                              <1> 
  2047                              <1> 
  2048                              <1> 
  2049                              <1> 
  2050                              <1> 
  2051                              <1> 
  2052                              <1> ;;; end of UART_DET.ASM
  2053                              <1> 
  1756                                  %endif
  1757                                  
  1758                                  ;========================================================================
  1759                                  ; uart_putchar - write the character in teletype mode
  1760                                  ; Input:
  1761                                  ;	AL = character
  1762                                  ;========================================================================
  1763                                          global  @uart_putchar
  1764                                  @uart_putchar:
  1765 000007EB 50                              push    ax
  1766 000007EC 53                              push    bx
  1767 000007ED B40E                            mov     ah,0Eh
  1768 000007EF BB0700                          mov     bx,0007h        ; page 0, normal attributes
  1769 000007F2 CD10                            int     10h
  1770 000007F4 5B                              pop     bx
  1771 000007F5 58                              pop     ax
  1772 000007F6 C3                              ret
  1773                                  
  1774                                  ;========================================================================
  1775                                  ; CVDU_putchar - write the character in teletype mode
  1776                                  ; Input:
  1777                                  ;	AL = character
  1778                                  ;	DL = attribute (IBM-PC)
  1779                                  ;  C-declaration:
  1780                                  ;	void __fastcall CVDU_putchar(int char, int attribute);
  1781                                  ;========================================================================
  1782                                          global  @VIDEO_putchar
  1783                                  @VIDEO_putchar:
  1784 000007F7 50                      	push	ax
  1785 000007F8 B40F                    	mov	ah,0Fh		; get page in BH
  1786 000007FA CD10                    	int	10h
  1787 000007FC 88D3                    	mov	bl,dl		; get attribute in BL
  1788 000007FE 58                      	pop	ax
  1789 000007FF B40E                    	mov	ah,0Eh		; write char
  1790 00000801 CD10                    	int	10h
  1791 00000803 C3                      	ret
  1792                                  
  1793                                  %if VGA3_6445 
  1794                                  ;========================================================================
  1795                                  ; mv_word - move words using video index
  1796                                  ; Input:
  1797                                  ;	AX = destination character index
  1798                                  ;	DX = source character index
  1799                                  ;	BX = count of words to move
  1800                                  ;========================================================================
  1801                                  	global mv_word_
  1802                                  mv_word_:
  1803                                  	pushm	si,di,cx,ds
  1804                                  	mov	di,ax			; destination
  1805                                  	shl	di,1			; it is a word pointer
  1806                                  	mov	si,dx			; source
  1807                                  	shl	si,1			; word pointer
  1808                                  	mov	cx,bx			; count to CX
  1809                                  	extern	video_buffer_ptr_
  1810                                  	call	video_buffer_ptr_	; DX:AX is set
  1811                                  	mov	es,dx			; set up segment registers
  1812                                  	mov	ds,dx			;  **
  1813                                  	add	di,ax			; AX is 0 for page 0
  1814                                  	add	si,ax			;  **
  1815                                  
  1816                                  	rep	movsw			; do the fast move
  1817                                  
  1818                                  	popm	si,di,cx,ds	
  1819                                  	ret
  1820                                  %endif
  1821                                  
  1822                                  
  1823                                  
  1824                                  
  1825                                  ;========================================================================
