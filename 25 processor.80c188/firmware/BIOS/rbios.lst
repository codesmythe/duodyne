     1                                  %ifndef SOFT_DEBUG
     2                                  ;;%define SOFT_DEBUG 1
     3                                  %endif
     4                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     5                                  ; RBIOS.ASM -- Relocatable BIOS for the RetroBrew SBC-188 v.0.4 to 3.1
     6                                  ; Updated for the Duodyne 80c188 SBC 10/2024
     7                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     8                                  ;
     9                                  ;   This version is for assembly by  NASM 0.98.39 or later
    10                                  ;
    11                                  ; Copyright (C) 2011-2017 John R. Coffman.  All rights reserved.
    12                                  ; Provided for hobbyist use on the RetroBrew SBC-188 board.
    13                                  ;
    14                                  ; This program is free software: you can redistribute it and/or modify
    15                                  ; it under the terms of the GNU General Public License as published by
    16                                  ; the Free Software Foundation, either version 3 of the License, or
    17                                  ; (at your option) any later version.
    18                                  ;
    19                                  ; This program is distributed in the hope that it will be useful,
    20                                  ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    21                                  ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    22                                  ; GNU General Public License for more details.
    23                                  ;
    24                                  ; You should have received a copy of the GNU General Public License
    25                                  ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    26                                  ;
    27                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    28                                  
    29                                  	cpu	186
    30                                  
    31                                  
    32                                  
    33                                  
    34                                  %include	"config.asm"
    35                              <1> ;/*
    36                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    37                              <1> ; ANSI.CFG
    38                              <1> ;   Copied to CONFIG.ASM for general release.
    39                              <1> ;
    40                              <1> ;       Modify the parameters below to reflect your system
    41                              <1> ;
    42                              <1> ;
    43                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    44                              <1> ;
    45                              <1> ;   Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    46                              <1> ;   Provided for hobbyist use on the N8VEM SBC-188 board.
    47                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    48                              <1> ;
    49                              <1> ; Define the serial terminal that the Video BIOS must emulate
    50                              <1> ; Set one of the following to 1
    51                              <1> ; If you have no idea what to choose, set TTY to 1
    52                              <1> TTY     equ     0       ; hardcopy -- cannot position the cursor
    53                              <1> DUMB    equ     0       ; dumb CRT -- ^H, ^J, ^K, ^L can move the cursor
    54                              <1> ANSI    equ     1       ; very smart, like a VT-100
    55                              <1> WYSE    equ     0       ; very smart Wyse series (30, 50, ...)
    56                              <1> ; others may get added in the future
    57                              <1> ;  ONE OF THE ABOVE must BE SET TO 1!!!!!
    58                              <1> ;
    59                              <1> ; Does the hardware configuration contain the Color Video Display Unit?
    60                              <1> ; Both the 8563 and the 8242 are used.  The default is CVDU=0
    61                              <1> CVDU	equ	0	; system does not have the CVDU
    62                              <1> ;
    63                              <1> ; Does the hardware configuration contain the VGA3 a/n Video card?
    64                              <1> ; The 8563 will be disabled, but the 8242 code is shared with the CVDU
    65                              <1> ; The default is VGA3=0
    66                              <1> VGA3    equ     0       ; system does not have the VGA3
    67                              <1> %if 0
    68                              <1> 	*/
    69                              <1> #define VGA3 0
    70                              <1> /*
    71                              <1> %endif
    72                              <1> ;
    73                              <1> ; Boot up keyboard mode:  20h for NumLock on
    74                              <1> ;CVDU_KEYBOARD_STATUS	equ	0	; NumLock OFF
    75                              <1> CVDU_KEYBOARD_STATUS	equ	20h	; NumLock ON
    76                              <1> 
    77                              <1> ; Define the UART startup bit rate - 1200-19200 are most common
    78                              <1> ;UART_RATE	equ	0		; 1200
    79                              <1> ;UART_RATE	equ	1		; 2400
    80                              <1> ;UART_RATE	equ	2		; 4800
    81                              <1> UART_RATE	equ	3		; 9600
    82                              <1> ;UART_RATE	equ	4		; 19200
    83                              <1> ;UART_RATE	equ	5		; 38400
    84                              <1> ;UART_RATE	equ	6		; 57600
    85                              <1> ;UART_RATE	equ	7		; 115200
    86                              <1> 
    87                              <1> ; Does the serial terminal use the DSR/DTR protocol for flow control?
    88                              <1> ;UART_DSR_PROTOCOL	equ		1	; Yes!
    89                              <1> UART_DSR_PROTOCOL       equ             WYSE    ; Wyse always uses it
    90                              <1> 						; but not ANSI
    91                              <1> ; Define the size of the ROM image on the system in Kilobytes
    92                              <1> ; It may be smaller than the actual EPROM in use.
    93                              <1> ; The following sizes are supported:  32, 64, 128, and 256
    94                              <1> %ifndef ROM
    95                              <1> ROM             equ     32              ; 64 is the default
    96                              <1> %endif
    97                              <1> 
    98                              <1> ; Define the number of Wait States at which the ROM operates
    99                              <1> ROM_WS          equ     1               ; 0..3  (1 is the default)
   100                              <1> 
   101                              <1> ; Define the size in Kilobytes of DOS RAM (low SRAM plus EMM allocate RAM)
   102                              <1> ; This is a desired size and will only be present if a 4MEM board is added
   103                              <1> RAM_DOS         equ     640
   104                              <1> 
   105                              <1> ; Define the size of the low SRAM on the system in Kilobytes
   106                              <1> ; the default is 512 kilobytes
   107                              <1> RAM             equ     512             ; (512 is the default)
   108                              <1> 
   109                              <1> ; Define the number of Wait States at which the RAM operates
   110                              <1> RAM_WS          equ     0               ; 0..3  (0 is the default)
   111                              <1> 
   112                              <1> ; Define the number of Wait States for Local Peripheral devices (600-7FF)
   113                              <1> LCL_IO_WS       equ     1               ; 0..3  (1 is the default)
   114                              <1> 
   115                              <1> ; Define the number of Wait States for ECB BUS peripheral devices (4xx)
   116                              <1> BUS_IO_WS       equ     3               ; 0..3  (3 is the default)
   117                              <1> 
   118                              <1> ; Define the time zone in which we build the Relocatable BIOS
   119                              <1> %ifndef TIMEZONE
   120                              <1> %define TIMEZONE "CST"
   121                              <1> %endif
   122                              <1> 
   123                              <1> ; Has the REDBUG debugger been loaded?
   124                              <1> %ifndef SOFT_DEBUG
   125                              <1> %define SOFT_DEBUG 0
   126                              <1> %endif
   127                              <1> 
   128                              <1> ; Should the BIOS include "Tiny BASIC" in the image?
   129                              <1> %ifndef TBASIC
   130                              <1> TBASIC          equ     1		; default is 1
   131                              <1> %endif
   132                              <1> 
   133                              <1> ; Should the BIOS include the Floating Point Emulator?  The 80188 does
   134                              <1> ; not allow a floating point co-processor, so this is probably a good idea.
   135                              <1> %ifndef FPEM
   136                              <1> FPEM            equ     1               ; default is 1
   137                              <1> %endif
   138                              <1> 
   139                              <1> ; Define the maximum number of EMM (4MEM) boards supported
   140                              <1> EMM_BOARDS      equ     0
   141                              <1> 
   142                              <1> ; Should the Floating Point Emulator use temporary storage in the EBDA
   143                              <1> ; or at locations 0280h..3FFh in low memory?
   144                              <1> %if SOFT_DEBUG
   145                              <1> FPEM_USE_EBDA   equ     FPEM            ; default is 0
   146                              <1> %else
   147                              <1> FPEM_USE_EBDA   equ     0; FPEM            ; default is 0
   148                              <1> %endif
   149                              <1> 
   150                              <1> ; Define the size of the EPROM that is to be installed on the system
   151                              <1> ; It may be larger than the actual ROM image to be generated.
   152                              <1> %ifndef CHIP
   153                              <1> CHIP            equ     64
   154                              <1> %endif
   155                              <1> 
   156                              <1> ; Does the SBC-188 00.4 board have the LS138/LS08 piggyback fix
   157                              <1> ; Set to 1 for the SBC-188 v1.0 and later production boards
   158                              <1> ;FDC_PIGGYBACK_FIX       equ     0       ; Fix not installed
   159                              <1> FDC_PIGGYBACK_FIX       equ     1       ; fix  IS  installed
   160                              <1> 
   161                              <1> ; On SBC-188 rev 00.4 board, there is a published hardware fix (2010-09-18).
   162                              <1> ; If the wiring update is installed, or you have a later board, then
   163                              <1> ; set this to 0.  If you are using the software workaround, then set this
   164                              <1> ; to 1.  The rev 1.0 board has this fix already.
   165                              <1> NEED_TIMER_FIX  equ     0               ; have revised hardware
   166                              <1> ;NEED_TIMER_FIX  equ     1               ; use workaround
   167                              <1> 
   168                              <1> ; Define the UART oscillator speed
   169                              <1> UART_OSC        equ     1843200         ; 1.8432 Mhz is specified
   170                              <1> 
   171                              <1> 
   172                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   173                              <1> ; end of the User configuration
   174                              <1> ;       Do Not modify anything below this point
   175                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   176                              <1> 
   177                              <1> CVDU_8563	equ	CVDU		; separate inits
   178                              <1> CVDU_8242	equ	CVDU|VGA3 	; separate inits
   179                              <1> VGA3_6445       equ     VGA3            ; separate inits
   180                              <1> ; Suppress all UART output in color video Mode 3
   181                              <1> UART_MODE3_SUPPRESS	equ	CVDU_8563
   182                              <1> CVDU_USE_MSDOS_KLUDGE	equ	0; CVDU_8242	; bad, bad MSDOS
   183                              <1> CVDU_USE_KBD_HOOK		equ	CVDU_8242
   184                              <1> 
   185                              <1> ; Define existence of any uart chip
   186                              <1> UART		equ	TTY+DUMB+ANSI+WYSE
   187                              <1> startuplength   equ     512                     ; may be up to 1024
   188                              <1> startseg        equ     0FFFFh - (ROM*64) + 1
   189                              <1> highrom         equ     (ROM*400h)&0FFFFh
   190                              <1> startupseg      equ     0FFFFh - (startuplength>>4) + 1
   191                              <1> bios_data_seg   equ     040h            ; segment of BIOS data area
   192                              <1> 
   193                              <1> 
   194                              <1> %define ARG(n) [bp+2+(n)*2]
   195                              <1> 
   196                              <1> %macro  check   1.nolist
   197                              <1>  %if (%1)
   198                              <1>    %error Check Failure: %1
   199                              <1>  %endif
   200                              <1> %endm
   201                              <1> %macro  range   3.nolist
   202                              <1>  %if (%1)<(%2)
   203                              <1>    %error Out of Range: %1
   204                              <1>  %elif (%1)>(%3)
   205                              <1>    %error Out of Range: %1
   206                              <1>  %endif
   207                              <1> %endm
   208                              <1> _terminal equ UART+CVDU
   209                              <1>  check   RAM_DOS&15
   210                              <1>  check   RAM&(RAM-1)
   211                              <1>  check   ROM&(ROM-1)
   212                              <1>  range   RAM,32,512
   213                              <1>  range   ROM,32,256
   214                              <1>  range   RAM_WS,0,3
   215                              <1>  range   ROM_WS,0,3
   216                              <1>  range   RAM_DOS,RAM,(1024-ROM)
   217                              <1>  range   LCL_IO_WS,0,3
   218                              <1>  range   BUS_IO_WS,0,3
   219                              <1>  range   UART_OSC,500000,16000000
   220                              <1>  range   UART_RATE,0,7
   221                              <1>  range	 UART,0,1
   222                              <1>  range	 _terminal,1,2
   223                              <1> 
   224                              <1> %ifndef SOFT_DEBUG
   225                              <1> %define SOFT_DEBUG 0
   226                              <1> %endif
   227                              <1> 
   228                              <1> %ifndef TRACE
   229                              <1> %define TRACE 0
   230                              <1> %endif
   231                              <1> 
   232                              <1> %ifdef MAKE_OBJECT_FILE
   233                              <1>         segment _DATA WORD PUBLIC CLASS=DATA
   234                              <1>         export _ROMsize
   235                              <1>         export _CHIPsize
   236                              <1> _ROMsize        dw      ROM
   237                              <1> _CHIPsize       dw      CHIP
   238                              <1> %endif
   239                              <1> ; end of the Hardware configuration file
   240                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   241                              <1> ;*/
    35                                  %include	"cpuregs.asm"
    36                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    37                              <1> ; CPUREGS.ASM
    38                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    39                              <1> ;
    40                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    41                              <1> ;
    42                              <1> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    43                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    44                              <1> ;
    45                              <1> ; This program is free software: you can redistribute it and/or modify
    46                              <1> ; it under the terms of the GNU General Public License as published by
    47                              <1> ; the Free Software Foundation, either version 3 of the License, or
    48                              <1> ; (at your option) any later version.
    49                              <1> ;
    50                              <1> ; This program is distributed in the hope that it will be useful,
    51                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    52                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    53                              <1> ; GNU General Public License for more details.
    54                              <1> ;
    55                              <1> ; You should have received a copy of the GNU General Public License
    56                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    57                              <1> ;
    58                              <1> ; Updated for the Duodyne 80c188 SBC
    59                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    60                              <1> %include	"macros.inc"
    61                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    62                              <2> ; MACROS.INC  
    63                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    64                              <2> ;
    65                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    66                              <2> ;
    67                              <2> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    68                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    69                              <2> ;
    70                              <2> ; This program is free software: you can redistribute it and/or modify
    71                              <2> ; it under the terms of the GNU General Public License as published by
    72                              <2> ; the Free Software Foundation, either version 3 of the License, or
    73                              <2> ; (at your option) any later version.
    74                              <2> ;
    75                              <2> ; This program is distributed in the hope that it will be useful,
    76                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    77                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    78                              <2> ; GNU General Public License for more details.
    79                              <2> ;
    80                              <2> ; You should have received a copy of the GNU General Public License
    81                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    82                              <2> ;
    83                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    84                              <2> 
    85                              <2> ; general macros for the SBC188 BIOS ASSEMBLY
    86                              <2> ;
    87                              <2> ;
    88                              <2> %ifndef __MACROS_DEFINED_
    89                              <2> %define __MACROS_DEFINED_ 1
    90                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    91                              <2> ;
    92                              <2> ; some useful macros:
    93                              <2> ;
    94                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    95                              <2> ;
    96                              <2> 	cpu	186
    97                              <2> 
    98                              <2> %imacro setloc  1.nolist
    99                              <2>  times   (%1-($-$$)) db 0FFh
   100                              <2> %endm
   101                              <2> 
   102                              <2> %imacro db_lo   1
   103                              <2>  db (%1)&255
   104                              <2> %endm
   105                              <2> 
   106                              <2> %imacro cnop    0.nolist
   107                              <2> %if SOFT_DEBUG
   108                              <2>         nop
   109                              <2> %endif
   110                              <2> %endm
   111                              <2> 
   112                              <2> %imacro popm 1-*.nolist
   113                              <2> %rep %0
   114                              <2> %ifidni %1,ALL
   115                              <2>  popa
   116                              <2> %elifidni %1,F
   117                              <2>  popf
   118                              <2> %else
   119                              <2>  pop %1
   120                              <2> %ifidni %1,DS
   121                              <2>  cnop
   122                              <2> %elifidni %1,ES
   123                              <2>  cnop
   124                              <2> %endif
   125                              <2> %endif
   126                              <2> %rotate 1
   127                              <2> %endrep
   128                              <2> %endm
   129                              <2> 
   130                              <2> %imacro pushm 1-*.nolist
   131                              <2> %rep %0
   132                              <2> %rotate -1
   133                              <2> %ifidni %1,ALL
   134                              <2>  pusha
   135                              <2> %elifidni %1,F
   136                              <2>  pushf
   137                              <2> %else
   138                              <2>  push %1
   139                              <2> %endif
   140                              <2> %endrep
   141                              <2> %endm
   142                              <2> 
   143                              <2> ;
   144                              <2> ; added from the 386EX project
   145                              <2> ;
   146                              <2> 
   147                              <2> ; call arguments
   148                              <2> %define ARG(n) [bp+2+(n)*2]
   149                              <2> 
   150                              <2> ;
   151                              <2> ; format of the BYTE initialization table:  address, byte
   152                              <2> ;
   153                              <2> %imacro  binit 2
   154                              <2>         dw      %1
   155                              <2>         db      %2
   156                              <2> %endmacro
   157                              <2> ; end with DW -1
   158                              <2> 
   159                              <2> ;
   160                              <2> ; format of the WORD initialization table:  address, word
   161                              <2> ;
   162                              <2> %imacro  winit 2
   163                              <2>         dw      %1
   164                              <2>         dw      %2
   165                              <2> %endmacro
   166                              <2> ; end with DW -1
   167                              <2> 
   168                              <2> 
   169                              <2> ; get the BIOS Data Area segment pointer to a [segment] register
   170                              <2> %imacro get_bda	1.nolist
   171                              <2> 	push	0x0040
   172                              <2> 	pop	%1
   173                              <2> 	cnop
   174                              <2> %endm
   175                              <2> 
   176                              <2> 
   177                              <2> %endif
    61                              <1> 
    62                              <1> 	cpu     186
    63                              <1> ;
    64                              <1> ;
    65                              <1> ; IBM model byte -- must be less than a 286
    66                              <1> ;
    67                              <1> ;MODEL_BYTE		equ	0FEh	; PC-XT
    68                              <1> ;SUBMODEL_BYTE		equ	0FFh	; not used
    69                              <1> 
    70                              <1> MODEL_BYTE		equ	0FEh	; PC-XT
    71                              <1> SUBMODEL_BYTE		equ	00h	;  "
    72                              <1> 
    73                              <1> 
    74                              <1> ; 80188 peripheral control register block address
    75                              <1> CPU_CSCR	        equ	0FF00h
    76                              <1> 
    77                              <1> ; Compatible Mode registers
    78                              <1> 
    79                              <1> cpu_relocation          equ     CPU_CSCR+0FEh
    80                              <1> 
    81                              <1> ; The memory and peripheral chip select register offsets from 0FF00h
    82                              <1> 
    83                              <1> cpu_umcs                equ     CPU_CSCR+0A0h          ; Upper memory select
    84                              <1> cpu_lmcs                equ     CPU_CSCR+0A2h          ; Lower memory select
    85                              <1> cpu_pacs                equ     CPU_CSCR+0A4h          ; Peripheral select
    86                              <1> cpu_mmcs                equ     CPU_CSCR+0A6h          ; Middle memory base
    87                              <1> cpu_mpcs                equ     CPU_CSCR+0A8h          ; Mid mem. & peripherals
    88                              <1> 
    89                              <1> ; Enhanced Mode registers
    90                              <1> 
    91                              <1> cpu_mdram               equ     CPU_CSCR+0E0h          ; memory partition reg.
    92                              <1> cpu_cdram               equ     CPU_CSCR+0E2h          ; clock prescaler
    93                              <1> cpu_edram               equ     CPU_CSCR+0E4h          ; Enable refresh reg.
    94                              <1> cpu_pdcon               equ     CPU_CSCR+0F0h          ; Power-Save control
    95                              <1> 
    96                              <1> 
    97                              <1> ; On-board internal peripheral equates
    98                              <1> ; Programmable Interrupt Controller
    99                              <1> PIC	        equ	CPU_CSCR+020H
   100                              <1> PIC_EOI	        equ	PIC+2           ; End Of Interrupt
   101                              <1> PIC_POLLR	equ	PIC+4
   102                              <1> PIC_POLLSR	equ	PIC+6
   103                              <1> PIC_IMASK	equ	PIC+8
   104                              <1> PIC_PMREG	equ	PIC+0AH
   105                              <1> PIC_SRVR	equ	PIC+0CH
   106                              <1> PIC_IRQR	equ	PIC+0EH
   107                              <1> PIC_IRQSR	equ	PIC+10H
   108                              <1> PIC_TCR	        equ	PIC+12H
   109                              <1> PIC_DMA0CR	equ	PIC+14H
   110                              <1> PIC_DMA1CR	equ	PIC+16H
   111                              <1> PIC_I0CON	equ	PIC+18H
   112                              <1> PIC_I1CON	equ	PIC+1AH
   113                              <1> PIC_I2CON	equ	PIC+1CH
   114                              <1> PIC_I3CON	equ	PIC+1EH
   115                              <1> 
   116                              <1> EOI_NSPEC       equ     8000h           ; Non-Specific EOI
   117                              <1> 
   118                              <1> ; Interrupt masks (Master Mode)
   119                              <1> ;
   120                              <1> mask_timer_all          equ     0001h
   121                              <1> mask_dma0               equ     0004h
   122                              <1> mask_dma1               equ     0008h
   123                              <1> mask_int0               equ     0010h
   124                              <1> mask_int1               equ     0020h
   125                              <1> mask_int2               equ     0040h
   126                              <1> mask_int3               equ     0080h
   127                              <1> 
   128                              <1> 
   129                              <1> 
   130                              <1> ; Timers
   131                              <1> TIM0	        equ	CPU_CSCR+050H
   132                              <1> TIM1	        equ	CPU_CSCR+058H
   133                              <1> TIM2	        equ	CPU_CSCR+060H
   134                              <1> 
   135                              <1> TCNT	        equ	0	; count register
   136                              <1> CMPA	        equ	2	; max count A
   137                              <1> CMPB	        equ	4	; max count B (not present on TIM2)
   138                              <1> TCON	        equ	6	; mode/control word
   139                              <1> 
   140                              <1> ; Timer control bits:
   141                              <1> tc_EN           equ     8000h   ; Enable bit
   142                              <1> tc_nINH         equ     4000h   ; not Inhibit Enable
   143                              <1> tc_INT          equ     2000h   ; Interrupt Enable
   144                              <1> tc_RIU          equ     1000h   ; Register A/B (0/1) in Use
   145                              <1> tc_MC           equ     0020h   ; Maximum Count reached
   146                              <1> tc_RTG          equ     0010h   ; Retrigger (internal source)
   147                              <1> tc_P            equ     0008h   ; Prescale internal clock (timers 0 & 1 only)
   148                              <1> tc_EXT          equ     0004h   ; External clock
   149                              <1> tc_ALT          equ     0002h   ; Alternate between A & B max count registers
   150                              <1> tc_CONT         equ     0001h   ; Continuous: continue after max count
   151                              <1> 
   152                              <1> 
   153                              <1> 
   154                              <1> 
   155                              <1> ; DMA
   156                              <1> DMA0	        equ	CPU_CSCR+0C0H
   157                              <1> DMA1	        equ	CPU_CSCR+0D0H
   158                              <1> DMASPL	        equ	0	; source pointer low
   159                              <1> DMASPU	        equ	2	; source pointer high
   160                              <1> DMADPL	        equ	4	; destination pointer low
   161                              <1> DMADPU	        equ	6	; destination pointer high
   162                              <1> DMATC	        equ	8	; terminal count
   163                              <1> DMACW	        equ	0AH	; control word
   164                              <1> 
   165                              <1> 
   166                              <1> 
   167                              <1> 
   168                              <1> 
   169                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   170                              <1> ;
   171                              <1> ;       SBC-188 external devices
   172                              <1> ;
   173                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   174                              <1> 
   175                              <1> IO_BASE			equ	0400h
   176                              <1> 
   177                              <1> 
   178                              <1> 
   179                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   180                              <1> ; The UART registers (Duodyne SBC 80c188 Console port)
   181                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   182                              <1> 
   183                              <1> uart_base               equ     IO_BASE+0280h
   184                              <1> uart_rbr                equ     uart_base       ;Rcvr Buffer / read only
   185                              <1> uart_thr                equ     uart_base       ;Transmit Holding / write only
   186                              <1> uart_ier                equ     uart_base+1     ;Interrupt Enable
   187                              <1> uart_iir                equ     uart_base+2     ;Interrupt Ident / read only
   188                              <1> uart_fcr                equ     uart_base+2     ;FIFO Control / write only
   189                              <1> uart_lcr                equ     uart_base+3     ;Line Control
   190                              <1> uart_mcr                equ     uart_base+4     ;Modem Control
   191                              <1> uart_lsr                equ     uart_base+5     ;Line Status
   192                              <1> uart_msr                equ     uart_base+6     ;Modem Status
   193                              <1> uart_sr			equ	uart_base+7	;Scratch
   194                              <1> 
   195                              <1> uart_dll                equ     uart_base       ;Divisor Latch LS Byte
   196                              <1> uart_dlm                equ     uart_base+1     ;Divisor Latch MS Byte
   197                              <1> 
   198                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   199                              <1> ; CONTROL LS259 PORT  (DuoDyne 80C188)
   200                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   201                              <1> CTRL259		equ	IO_BASE+0238H
   202                              <1> ; LEDS are at addresses 0..3
   203                              <1> ; other control ports on 4..7
   204                              <1> LED0		equ	CTRL259+0
   205                              <1> LED1		equ	LED0+1
   206                              <1> LED2		equ	LED0+2
   207                              <1> LED3		equ	LED0+3
   208                              <1> T1OSC18		equ	CTRL259+4	; ON=1.8432mhz, OFF="1" (for use of TIMER2)
   209                              <1> ;unused		equ	CTRL259+5
   210                              <1> ;unused		equ	CTRL259+6
   211                              <1> ;unused		equ	CTRL259+7
   212                              <1> 
   213                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   214                              <1> ; Front Panel Connector  (DuoDyne 80C188)
   215                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   216                              <1> FRONT_PANEL_LED	equ	IO_BASE+0230H
   217                              <1> 
   218                              <1> 
   219                              <1> 
   220                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   221                              <1> ; Floppy controller (Duodyne Disk IO)
   222                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   223                              <1> FDC	        equ	IO_BASE+0200H
   224                              <1> FDC_MSR         equ     FDC
   225                              <1> FDC_DATA        equ     FDC_MSR+1
   226                              <1> FDC_DACK        equ	FDC+10H
   227                              <1> FDC_LDOR	equ	FDC+20H
   228                              <1> FDC_LDCR	equ	FDC+30H
   229                              <1> FDC_TC	        equ	FDC+40H
   230                              <1> FDC_RES	        equ	FDC+40H
   231                              <1> FDC_DACK_TC     equ     FDC_DACK | FDC_TC
   232                              <1> 
   233                              <1> 
   234                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   235                              <1> ;DS1302 RTC (Duodyne Ram/ROM Card)
   236                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   237                              <1> RTC	equ	IO_BASE+0094H
   238                              <1> 
   239                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   240                              <1> ; PIO 82C55 I/O  (Duodyne Disk IO)
   241                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   242                              <1> PPI	        equ	IO_BASE+0088H
   243                              <1> 
   244                              <1> PIO_A	        equ	PPI+0	; (OUTPUT)
   245                              <1> PIO_B	        equ	PPI+1	; (INPUT)
   246                              <1> PIO_C	        equ	PPI+2	; (CENTRONICS control low nibble)
   247                              <1> PIO_CTRL	equ	PPI+3	; CONTROL BYTE PIO 82C55
   248                              <1> 
   249                              <1> portA           equ     PPI+0   ;
   250                              <1> portB           equ     PPI+1   ;
   251                              <1> portC           equ     PPI+2   ;
   252                              <1> 
   253                              <1> ; end CPUREGS.ASM
    36                                  %include	"date.asm"
    37                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    38                              <1> ; date.asm
    39                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    40                              <1> ; string 0 is for "startup.asm" inclusion; must be 8 chars exactly
    41                              <1> ; string 1 is for RBIOS.ASM inclusion; should be very readable
    42                              <1> ;
    43                              <1> ; N.B.  version 46 is Rich Cini's version for the 2S1P board
    44                              <1> ;
    45                              <1> ; so we jump from BIOS 045 to 047, the first BIOS to support
    46                              <1> ; the Version 3.0 board (with 1024K memory on-board)
    47                              <1> ;
    48                              <1> ; Definitions for version 3.5-2:
    49                              <1> ;
    50                              <1> 
    51                              <1> 
    52                              <1> %define DATE_STRING0	"04/29/21"
    53                              <1> %define DATE_STRING1	"29-Apr-2021"
    54                              <1> 
    55                              <1> %define VERSION_MAJOR		3
    56                              <1> %define VERSION_MINOR		5
    57                              <1> %define VERSION_REVISION	1
    58                              <1> %define VERSION_SUFFIX		""
    59                              <1> %define VERSION_SEQUENCE	55
    60                              <1> 
    61                              <1> %define VERSION_STRING		"3.5-1",VERSION_SUFFIX
    62                              <1> 
    63                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    64                              <1> ; Revision information:
    65                              <1> ;  ver.	2.1 -- table-driven support for all IBM floppy types
    66                              <1> ;	2.2 -- Dual IDE driver; CVDU memory sizing
    67                              <1> ;	2.3 -- font_vga corrects (i grave) (n_tilde)
    68                              <1> ;	    &  Dual SDcard & Minix boot
    69                              <1> ;	2.4 -- Int 15h multiprogramming hooks: fn90, fn91 (never done)
    70                              <1> ;	3.0 -- VGA3 support
    71                              <1> ;	3.1 -- SBC-188 v.3 board support
    72                              <1> ;	3.2 -- IDE8 support on the v.3 board
    73                              <1> ;	3.3 -- add 2S1P board support (2 SIO & PPort)
    74                              <1> ;	3.4 -- floppy drives did not work
    75                              <1> ;	3.5 -- back to 3.3, sequence #51
    76                              <1> ;		change NVRAM battery backup setup to #53
    77                              <1> ;		re-install 3.4 boot fix for FreeDOS
    78                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    37                                  %include	"equates.asm"
    38                              <1> ;========================================================================
    39                              <1> ; EQUATES.ASM -- Lots of Defintions for Relocatable BIOS
    40                              <1> ;========================================================================
    41                              <1> ;   for the N8VEM SBC-188 v.00.4 and 00.5
    42                              <1> ;
    43                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    44                              <1> ;
    45                              <1> ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
    46                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    47                              <1> ;
    48                              <1> ; This program is free software: you can redistribute it and/or modify
    49                              <1> ; it under the terms of the GNU General Public License as published by
    50                              <1> ; the Free Software Foundation, either version 3 of the License, or
    51                              <1> ; (at your option) any later version.
    52                              <1> ;
    53                              <1> ; This program is distributed in the hope that it will be useful,
    54                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    55                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    56                              <1> ; GNU General Public License for more details.
    57                              <1> ;
    58                              <1> ; You should have received a copy of the GNU General Public License
    59                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    60                              <1> ;
    61                              <1> ;========================================================================
    62                              <1> 
    63                              <1>         global  FPEM_segment
    64                              <1> 
    65                              <1> 
    66                              <1> %include "segdef.asm"
    67                              <2> ;========================================================================
    68                              <2> ; SEGDEF.ASM -- Lots of Defintions for Relocatable BIOS
    69                              <2> ;========================================================================
    70                              <2> ;   for the N8VEM SBC-188 v.00.4 and 00.5
    71                              <2> ;
    72                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    73                              <2> ;
    74                              <2> ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
    75                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    76                              <2> ;
    77                              <2> ; This program is free software: you can redistribute it and/or modify
    78                              <2> ; it under the terms of the GNU General Public License as published by
    79                              <2> ; the Free Software Foundation, either version 3 of the License, or
    80                              <2> ; (at your option) any later version.
    81                              <2> ;
    82                              <2> ; This program is distributed in the hope that it will be useful,
    83                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    84                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    85                              <2> ; GNU General Public License for more details.
    86                              <2> ;
    87                              <2> ; You should have received a copy of the GNU General Public License
    88                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    89                              <2> ;
    90                              <2> ;========================================================================
    91                              <2> 
    92                              <2> %ifndef __SEGDEF_
    93                              <2> %define __SEGDEF_
    94                              <2> 
    95                              <2> 	SEGMENT  _TEXT ALIGN=2 PUBLIC CLASS=CODE
    96                              <2>         SEGMENT  CONST ALIGN=2 PUBLIC CLASS=DATA
    97                              <2>         SEGMENT  CONST2 ALIGN=2 PUBLIC CLASS=DATA
    98                              <2> 	SEGMENT  _DATA ALIGN=16 PUBLIC CLASS=DATA
    99                              <2> 	SEGMENT  _BSS  ALIGN=2 PUBLIC CLASS=BSS
   100                              <2> ;;;        SEGMENT  _BASIC ALIGN=16 PUBLIC CLASS=BASIC
   101                              <2> 
   102                              <2> 	GROUP	DGROUP CONST CONST2 _DATA _BSS
   103                              <2> 
   104                              <2> %endif
   105                              <2> 
    67                              <1> %include "ascii.asm"
    68                              <2> ; ascii.asm
    69                              <2> ;
    70                              <2> CTRL            equ     1Fh     ; masks a character to CTRL-x
    71                              <2> 
    72                              <2> NUL     equ     00h
    73                              <2> BEL     equ     (CTRL & 'G')
    74                              <2> BS      equ     08h		; ^H
    75                              <2> HT      equ     09h		; ^I
    76                              <2> LF	equ	0Ah		; ^J
    77                              <2> NL      equ     LF
    78                              <2> VT	equ	0Bh		; ^K
    79                              <2> FWD	equ	0Ch		; ^L
    80                              <2> CR	equ	0Dh
    81                              <2> XON     equ     (CTRL & 'Q')
    82                              <2> XOFF    equ     (CTRL & 'S')
    83                              <2> DC1     equ     XON
    84                              <2> DC3     equ     XOFF
    85                              <2> ESC     equ	1Bh
    86                              <2> 
    87                              <2> 
    68                              <1> 
    69                              <1> 
    70                              <1> ; POST error codes. Presently one byte but can expand to word.
    71                              <1> ER_BIOS equ	01h		; Bad ROM bios checksum, patch last byte
    72                              <1> ER_RAM	equ	02h		; Bad RAM in main memory, replace
    73                              <1> ER_CRT	equ	04h		; Bad RAM in video card, replace
    74                              <1> ER_FDC	equ	08h		; Bad FDC
    75                              <1> ER_UNK1	equ	10h		; {unassigned}
    76                              <1> ER_MEM	equ	20h		; Bad RAM in vector area, replace
    77                              <1> ER_ROM	equ	40h		; Bad ROM in expansion area, bad checksum
    78                              <1> ER_UNK2	equ	80h		; {unassigned}
    79                              <1> 
    80                              <1> 
    81                              <1> 
    82                              <1> ;; ************************ BIOS Data Segment ******************************
    83                              <1> ;; BIOS data segment - not all will  be used
    84                              <1> ;                struc   BIOS_DATA_AREA  ; at 0040:0000
    85                              <1> %include "bda.inc"
    86                              <2> ;/*======================================================================
    87                              <2> ; bda.inc -- BIOS data area definitions
    88                              <2> ;========================================================================
    89                              <2> ;   for the N8VEM SBC-188
    90                              <2> ;
    91                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    92                              <2> ;
    93                              <2> ; Copyright (C) 2013 John R. Coffman.  All rights reserved.
    94                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    95                              <2> ;
    96                              <2> ; This program is free software: you can redistribute it and/or modify
    97                              <2> ; it under the terms of the GNU General Public License as published by
    98                              <2> ; the Free Software Foundation, either version 3 of the License, or
    99                              <2> ; (at your option) any later version.
   100                              <2> ;
   101                              <2> ; This program is distributed in the hope that it will be useful,
   102                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   103                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   104                              <2> ; GNU General Public License for more details.
   105                              <2> ;
   106                              <2> ; You should have received a copy of the GNU General Public License
   107                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   108                              <2> ;
   109                              <2> ;========================================================================
   110                              <2> 
   111                              <2> 			;*/ extern				/*
   112                              <2> 	ABSOLUTE  0	;*/ struct BDA {			/*
   113 00000000 ????????????????    <2> serial_ports    resw    4	;*/	word	serial_ports[4];	/*
   114 00000008 ????????????????    <2> parallel_ports  resw    4	;*/	word	parallel_ports[4];	/*
   115 00000010 ????                <2> equipment_flag  resw    1	;*/	EQFL	equipment_flag;		/*
   116                              <2> ;	dw	?		; 40:10 	; Equipment present word
   117                              <2> ;  						;  = (1 iff floppies) *     1.
   118                              <2> ;                                               ;  + (1 iff 187     ) *     2.
   119                              <2> ;  						;  + (#+1 64K sys ram) *    4.
   120                              <2> ;  						;  + (init crt mode ) *    16.
   121                              <2> ;  						;  + (# of floppies ) *    64.
   122                              <2> ;  						;  + (# serial ports) *   512.
   123                              <2> ;  						;  + (1 iff toy port) *  4096.
   124                              <2> ;                                               ;  + (1 iff modem   ) *  8192.
   125                              <2> ;  						;  + (# parallel LPT) * 16384.
   126 00000012 ??                  <2> mfg_test_flags  resb    1	;*/	byte	mfg_test_flags;	/* 40:12 unused by us
   127 00000013 ????                <2> memory_size     resw    1	;*/	word	memory_size;	/* 40:13 kilobytes
   128                              <2> uart_kbd_ctrl_R	equ	$	;*/				/*** JRC: count of ctrl-R's for reboot
   129 00000015 ??                  <2> IPL_errors      resb    1	;*/	byte	IPL_errors;	/* 40:15 IPL errors<-table/scratchpad
   130 00000016 ??                  <2> sbc188_rev       resb    1	;*/	byte	sbc188_rev;	/* was 'unused_01' before BIOS047
   131                              <2> ;;---------------[Keyboard data area]------------;
   132 00000017 ????                <2> keyboard_flags_0 resw   1	;*/	word	keyboard_flags_0;  /* 40:17 Shift/Alt/etc. keyboard flags
   133                              <2> keyboard_flags_1 equ	$-1	;     2nd byte	keyboard_flags_1;  
   134 00000019 ??                  <2> keypad_char	resb	1	;*/	byte	keypad_char;	/* 40:19 Alt-KEYPAD char. goes here
   135 0000001A ????                <2> kbd_buffer_head resw    1	;*/	word	kbd_buffer_head;   /* 40:1A --> keyboard buffer head
   136 0000001C ????                <2> kbd_buffer_tail resw    1	;*/	word	kbd_buffer_tail;   /* 40:1C --> keyboard buffer tail
   137 0000001E <res 20h>           <2> kbd_buffer      resw    16	;*/	word	kbd_buffer[16];	/* 40:1E Keyboard Buffer (Scan,Value)
   138                              <2> kbd_buffer_last	equ	$	;*/				/*
   139                              <2> ;;---------------[Diskette data area]------------;
   140 0000003E ??                  <2> fdc_drv_calib   resb    1	;*/	byte	fdc_drive_calib;   /* 40:3E
   141 0000003F ??                  <2> fdc_motor_LDOR  resb    1	;*/	byte	fdc_motor_LDOR;	   /* 40:3F Motor, DMA, select control
   142 00000040 ??                  <2> fdc_motor_ticks resb    1	;*/	byte	fdc_motor_ticks;   /* 40:40 ticks til motor off
   143 00000041 ??                  <2> fdc_status      resb    1	;*/	byte	fdc_status;	   /* 40:41
   144                              <2> ;				Floppy return code stat byte
   145                              <2> ;				;  1 = bad ic 765 command req.
   146                              <2> ;				;  2 = address mark not found
   147                              <2> ;				;  3 = write to protected disk
   148                              <2> ;				;  4 = sector not found
   149                              <2> ;				;  8 = data late (DMA overrun)
   150                              <2> ;				;  9 = DMA failed 64K page end
   151                              <2> ;				; 16 = bad CRC on floppy read
   152                              <2> ;				; 32 = bad NEC 765 controller
   153                              <2> ;				; 64 = seek operation failed
   154                              <2> ;				;128 = disk drive timed out
   155 00000042 ??????????????      <2> fdc_ctrl_status resb    7	;*/	byte	fdc_ctrl_status[7];  /* 40:42 Status bytes from NEC 765
   156                              <2> ;;---------------[Video display area]------------;
   157 00000049 ??                  <2> video_mode      resb    1	;*/	byte	video_mode;	/* 40:49
   158                              <2> ;			 	; Current CRT mode  (software)
   159                              <2> ;				;  0 = 40 x 25 text (no color)
   160                              <2> ;				;  1 = 40 x 25 text (16 color)
   161                              <2> ;				;  2 = 80 x 25 text (no color)
   162                              <2> ;				;  3 = 80 x 25 text (16 color)
   163                              <2> ;				;  4 = 320 x 200 grafix 4 color
   164                              <2> ;				;  5 = 320 x 200 grafix 0 color
   165                              <2> ;				;  6 = 640 x 200 grafix 0 color
   166                              <2> ;				;  7 = 80 x 25 text (mono card)
   167 0000004A ????                <2> video_columns   resw    1	;*/	word video_columns;	/* 40:4A Columns on CRT screen
   168 0000004C ????                <2> video_regen_bytes  resw 1	;*/	word video_regen_bytes;	/* 40:4C Bytes in the regen region
   169 0000004E ????                <2> video_regen_offset resw 1	;*/	word video_regen_offset;/* 40:4E Byte offset in regen region
   170 00000050 <res 10h>           <2> video_cursor_pos  resw  8	;*/	word video_cursor_pos[8];  /* 40:50 Cursor pos for up to 8 pages
   171 00000060 ????                <2> video_cursor_mode resw  1	;*/	word video_cursor_mode;	/* 40:60 Current cursor mode setting
   172 00000062 ??                  <2> video_page      resb    1	;*/	byte video_page;	/* 40:62 Current page on display
   173 00000063 ????                <2> video_base_seg  resw    1	;*/	word video_base_seg;	/* 40:63 Base address (B000h or B800h)
   174 00000065 ??                  <2> video_hw_mode   resb    1	;*/	byte video_hw_mode;	/* 40:65 ic 6845 mode reg. (hardware)
   175 00000066 ??                  <2> video_cga_palette resb  1	;*/	byte video_cga_palette;	/* 40:66 Current CGA palette
   176                              <2> ;;---------------[Used to setup ROM]-------------;
   177 00000067 ????????            <2> eprom_address   resd    1	;*/	dword eprom_address;	/* 40:67 Eprom base Offset,Segment
   178 0000006B ??                  <2> spurious_irq    resb    1	;*/	byte spurious_irq;	/* 40:6B Last spurious interrupt IRQ
   179                              <2> ;;---------------[Timer data area]---------------;
   180 0000006C ????????            <2> timer_ticks     resd    1	;*/	dword timer_ticks;	/* 40:6C Ticks since midnight (lo,hi)
   181 00000070 ??                  <2> timer_new_day   resb    1	;*/	byte timer_new_day;	/* 40:70 Non-zero if new day
   182                              <2> ;;---------------[System data area]--------------;
   183 00000071 ??                  <2> break_flag      resb    1	;*/	byte break_flag;	/* 40:71 Sign bit set iff break
   184 00000072 ????                <2> warm_boot       resw    1	;*/	word warm_boot;		/* 40:72 Warm boot iff==1234h
   185                              <2> ;;---------------[Hard disk scratchpad]----------;
   186 00000074 ????????            <2> hdd_scratch     resd    1	;*/	word hdd_scratch[2];	/* 40:74
   187                              <2> ;;---------------[Timout areas/PRT/LPT]----------;
   188 00000078 ????????            <2> lpt_timeout     resb    4	;*/	byte lpt_timeout[4];	/* 40:78 Ticks for LPT 1-4 timeouts
   189 0000007C ????????            <2> com_timeout     resb    4	;*/	byte com_timeout[4];	/* 40:7C Ticks for COM 1-4 timeouts
   190                              <2> ;;---obsolete----[Keyboard buf start/end]---jrc--;
   191 00000080 ????                <2> kbd_buffer_start resw   1	;*/	word kbd_buffer_start;	/* 40:80 KBD buffer head (PC/AT)
   192 00000082 ????                <2> kbd_buffer_end  resw    1	;*/	word kbd_buffer_end;	/* 40:82 KBD buffer tail (PC/AT)
   193                              <2> ;;---------------[EGA stuff]---------------------;
   194 00000084 ??????????????      <2> EGA_stuff	resb	7	;*/	byte EGA_stuff[7];	/* 40:84 Unspecified EGA data
   195                              <2> ;;---------------[Floppy/Fixed Media Info]-------------;
   196 0000008B ??                  <2> fdc_last_rate	resb	1	;*/	byte fdc_last_rate;	/* 40:8B Last floppy step rate/data rate?
   197 0000008C ????????            <2> fx_misc_unused	resb	4	;*/	byte fx_misc_unused[4];	/* 40:8C Fixed disk miscellaneous ???
   198 00000090 ????                <2> fdc_disk_state	resb	2	;*/	byte fdc_disk_state[2];	/* 40:90 Floppy disk state
   199 00000092 ????                <2> fdc_op_start	resb	2	;*/	byte fdc_op_start[2];	/* 40:92 Floppy operation start state machine
   200 00000094 ????                <2> fdc_cylinder	resb	2	;*/	byte fdc_cylinder[2];	/* 40:94 Floppy present cylinder
   201                              <2> ;;---------------[Additional KBD flags]----------------;
   202 00000096 ??                  <2> kbd_flag_3	resb	1	;*/	byte kbd_flag_3;	/* 40:96 kbd ???
   203 00000097 ??                  <2> kbd_flag_2	resb	1	;*/	byte kbd_flag_2;	/* 40:97 kbd ???
   204                              <2> ;;---------------[RTC/timer1 data]---------------------;
   205 00000098 ????????            <2> user_semaphore	resw	2	;*/	byte *user_semaphore;	/* 40:98 User semaphore in (bit 7)
   206 0000009C ????????            <2> rtc_count	resd	1	;*/	dword rtc_count;	/* 40:9C RTC tick counter
   207 000000A0 ??                  <2> rtc_wait_active	resb	1	;*/	byte rtc_wait_active;	/* 40:A0 Busy=01, Posted=80h, 
   208                              <2> ;;---------------[Cassette I/O stuff]------------------;
   209 000000A1 ??                  <2> last_val	resb	1	;*/	byte last_val;		/* 40:A1 Last byte read value
   210 000000A2 ????                <2> crc_reg		resw	1	;*/	word crc_reg;		/* 40:A2 CRC accumulation area
   211                              <2> ;									Post Acknowleged=00;
   212 000000A4 ??                  <2> EGA_data	resb	1	;*/	byte EGA_data;		/* 40:A4 Various usage
   213 000000A5 ????                <2> SDstatus	resb	2	;*/	byte SDstatus[2];	/* 40:A5 Status byte from command
   214 000000A7 ????                <2> SDcardtype	resb	2	;*/	byte SDcardtype[2];	/* 40:A7 SDcard type SDSC=2, HC=3, ...
   215                              <2> ;
   216 000000A9 ????????            <2> fixed_disk_tab	resb	4	;*/	byte fixed_disk_tab[4];	/* dispatch table to fixed disk drivers
   217 000000AD ??                  <2> wait12_count	resb	1	;*/	byte wait12_count;	/* 40:AD 12usec CX count
   218 000000AE ??                  <2> lock_count	resb	1	;*/	byte lock_count;	/* 40:AE lock level counter
   219 000000AF ??                  <2> EMS_start       resb    1	;*/	byte EMS_start;		/* start EMS allocation from here
   220                              <2> fx80		equ	$	;*/	struct EDD_disk fx80;	/* fixed disk parameter area 0
   221 000000B0 ????                <2> fx_log_cylinders resw   1	;	word fx_log_cylinders;	 logical number of cylinders
   222 000000B2 ??                  <2> fx_log_heads    resb    1	;	byte fx_log_heads;	 logical number of heads
   223 000000B3 ??                  <2> fx_signature	resb	1	;	byte fx_signature;	 A0h signature = translated geom
   224 000000B4 ??                  <2> fx_phys_sectors	resb    1       ;	byte fx_phys_sectors;	 physical number of sectors per track
   225 000000B5 ????                <2> fx_LBA_high     resw    1       ;	word fx_LBA_high;	 high word of LBA28 number of sectors
   226 000000B7 ??                  <2> fx_reserved	resb	1	;	byte fx_reserved;	 reserved for future use
   227 000000B8 ??                  <2> fx_drive_control resb   1       ;	byte fx_drive_control;	 flag bits for IDE head register
   228 000000B9 ????                <2> fx_phys_cylinders resw	1	;	word fx_phys_cylinders;	 physical number of cylinders
   229 000000BB ??                  <2> fx_phys_heads	resb	1	;	byte fx_phys_heads;	 physical number of heads
   230 000000BC ????                <2> fx_LBA_low	resw	1	;	word fx_LBA_low;	 low word of LBA28 number of sectors
   231 000000BE ??                  <2> fx_log_sectors	resb	1	;	byte fx_log_sectors;	 logical number of sectors per track
   232 000000BF ??                  <2> fx_checksum	resb	1	;	byte fx_checksum;	 checksum, dunno how to compute
   233 000000C0 <res 10h>           <2> fx81            resb    16	;*/	struct EDD_disk fx81;	/* fixed disk parameter area 1
   234 000000D0 <res 10h>           <2> fx82            resb    16	;*/	struct EDD_disk fx82;	/* fixed disk parameter area 2
   235 000000E0 <res 10h>           <2> fx83            resb    16	;*/	struct EDD_disk fx83;	/* fixed disk parameter area 3
   236                              <2> ;
   237                              <2> ;
   238                              <2> 
   239 000000F0 ????                <2> FPEM_segment    resw    1       ;*/	word FPEM_segment;	/* FPEM data segment
   240                              <2> 
   241 000000F2 ????                <2> EBDA_paragraph  resw    1       ;*/	word EBDA_paragraph;	/* lowest EBDA paragraph
   242                              <2> 
   243 000000F4 ????                <2> dma0_cw         resw    1       ;*/	word dma0_cw;		/* end of dma control word
   244 000000F6 ????                <2> dma1_cw         resw    1       ;*/	word dma1_cw;		/*   ditto
   245                              <2> 
   246 000000F8 ????                <2> fdc_type	resb	2	;*/	byte fdc_type[2];	/* disk type in low nibble, alternate in hi nib 
   247                              <2> 
   248 000000FA ????????            <2> debug_static_ptr  resw	2	;*/	void *debug_static_ptr;	/* pointer to debug static area
   249                              <2> 
   250 000000FE ??                  <2> n_fixed_disks   resb    1       ;*/	byte n_fixed_disks;	/* number of fixed disks
   251                              <2> 
   252 000000FF ??                  <2> cpu_xtal        resb    1       ;*/	byte cpu_xtal;		/* CPU crystal frequency in Mhz 
   253                              <2> ;								   CPU clock is half of this
   254                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   255                              <2> ;
   256                              <2> ;  System configuration stuff below
   257                              <2> ;	c.f., CONFIG.ASM (ANSI.CFG, CVDU.CFG, etc.), User configuration stuff
   258                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   259                              <2> %if 0				;*/
   260                              <2> #define FIXED_DISK_MAX 4		/*
   261                              <2> %else
   262                              <2> %define FIXED_DISK_MAX 4
   263                              <2> %endif
   264                              <2> %if 0				;*/
   265                              <2> #define PPIDE_driver 1		/*
   266                              <2> %else
   267                              <2> %define PPIDE_driver 1
   268                              <2> %endif
   269                              <2> %if 0				;*/
   270                              <2> #define DIDE_driver 0		/*
   271                              <2> %else
   272                              <2> %define DIDE_driver 0
   273                              <2> %endif
   274                              <2> %if 0				;*/
   275                              <2> #define DISKIO_driver 1		/*
   276                              <2> %else
   277                              <2> %define DISKIO_driver 1
   278                              <2> %endif
   279                              <2> %if 0				;*/
   280                              <2> #define MFPIC_driver 1		/*
   281                              <2> %else
   282                              <2> %define MFPIC_driver 1
   283                              <2> %endif
   284                              <2> %if 0				;*/
   285                              <2> #define DSD_driver 1		/*
   286                              <2> %else
   287                              <2> %define DSD_driver 1
   288                              <2> %endif
   289                              <2> %if 0				;*/
   290                              <2> #define V3IDE8_driver (SBC188==3)		/*
   291                              <2> %else
   292                              <2> %define V3IDE8_driver (SBC188==3)
   293                              <2> %endif
   294                              <2> 				;*/
    86                              <1> 
    87                              <1> ;  this must be the same in EQUATES.H */
    88                              <1> %if SOFT_DEBUG
    89                              <1> %define NBREAK  8
    90                              <1> %endif
    91                              <1> 
    92                              <1> 
    93                              <1> %if 0
    94                              <1>         segment _TEXT
    95                              <1> ;; *************************************************************************
    96                              <1> 
    97                              <1> 
    98                              <1> 
    99                              <1> 
   100                              <1> ;; ************************ DOS Data Segment *******************************
   101                              <1> ;dosdir	SEGMENT at 50h				; Boot disk directory from IPL
   102                              <1> ;xerox	label	byte				;  0 if Print Screen idle
   103                              <1> ;						;  1 if PrtSc xeroxing screen
   104                              <1> ;						;255 if PrtSc error in xerox
   105                              <1> ;						;  ...non-grafix PrtSc in bios
   106                              <1> ;	db	200h dup(?)			; PC-DOS bootstrap procedure
   107                              <1> ;						;  ...IBMBIO.COM buffers the
   108                              <1> ;						;  ...directory of the boot
   109                              <1> ;						;  ...device here at IPL time
   110                              <1> ;						;  ...when locating the guts
   111                              <1> ;						;  ...of the operating system
   112                              <1> ;						;  ...filename "IBMDOS.COM"
   113                              <1> ;dosdir	ends
   114                              <1> ;; *************************************************************************
   115                              <1> ;; ************************ DOS IPL Segment ********************************
   116                              <1> ;dosseg	SEGMENT at 70h				; "Kernel" of PC-DOS op sys
   117                              <1> ;;IBMBIO.COM file loaded by boot block. Device Drivers/Bootstrap. CONTIGUOUS<---
   118                              <1> ;;IBMDOS.COM operating system nucleus immediately follows IBMBIO.COM and       !
   119                              <1> ;;     doesn`t have to be contiguous.  The IBMDOS operating system nucleus     !
   120                              <1> ;;     binary image is loaded by transient code in IBMBIO binary image	      !
   121                              <1> ;dosseg	ends					;			      !
   122                              <1> ;iplseg	SEGMENT at 0h				; Segment for boot block      !
   123                              <1> ;;The following boot block is loaded with 512 bytes on the first sector of     !
   124                              <1> ;;the bootable device by code resident in the ROM-resident bios.  Control is   !
   125                              <1> ;;then transferred to the first word 0000:7C00 of the disk-resident bootstrap  !
   126                              <1> ;	ORG	07C00h				;  ..offset for boot block    !
   127                              <1> ;boot	db	200h dup(?)			;  ..start disk resident boot--
   128                              <1> ;iplseg	ends
   129                              <1> 
   130                              <1> %endif
    38                                  
    39                                  %define	VERSION	VERSION_STRING
    40                                  %define	DATE	DATE_STRING1
    41                                  
    42                                  ;;      global  begin_here
    43                                  	global	cold_boot
    44                                          global  initialization
    45                                  	extern	ident2
    46                                          extern  _cprintf
    47                                  %if TRACE
    48                                  	extern	int_trace
    49                                  %endif	; TRACE
    50                                  
    51                                  
    52                                  	segment         _TEXT
    53                                  
    54                                  cold_boot:
    55 00000000 FA                              cli                     ; Should be clear already
    56 00000001 89C3                    	mov	bx,ax		; save board revision in BX
    57                                  %if SOFT_DEBUG
    58                                          mov     dx,FRONT_PANEL_LED
    59                                          mov     al,0A5h         ; A5 to the LITES
    60                                          out     dx,al
    61                                  %endif
    62 00000003 B84000                          mov     ax,bios_data_seg
    63 00000006 8ED0                            mov     ss,ax
    64 00000008 BC0070                          mov     sp,7000h        ; Stack should be out of the way
    65                                  ; cannot use the stack yet, since memory is not tested
    66                                  %if 0
    67                                      ss	mov	bx,word [warm_boot]	; check for 1234h == Warm Boot
    68                                  %else
    69 0000000B 30FF                    	xor	bh,bh			; not warm boot
    70 0000000D 36813E72003412              ss  cmp	word [warm_boot],1234h
    71 00000014 7504                    	jne	.1
    72 00000016 FEC7                    	inc	bh			; it IS a warm boot
    73 00000018 EB08                    	jmp	cold_continue		; JRC - DEBUG test
    74                                  .1:
    75                                  %endif
    76                                  %if SOFT_DEBUG
    77                                  	push	5Ah
    78                                  	call	lites
    79                                  %endif
    80                                  memory_testing:
    81                                  ; Immediately test low memory
    82 0000001A 31C0                            xor     ax,ax           ; Segment 0
    83 0000001C BD[2200]                        mov     bp,.0           ; return address
    84 0000001F E9E103                          jmp     memtest0        ; don't use the stack
    85                                  .0:
    86                                  ; BX was preserved by 'memtest0'
    87                                  
    88                                  %if SOFT_DEBUG
    89                                          jnc     cold_continue
    90                                          mov     dx,FRONT_PANEL_LED
    91                                          mov     al,0F1h         ; F1 to the LITES
    92                                          out     dx,al
    93                                  .1:
    94                                          hlt
    95                                          jmp     .1              ; solid halt on error
    96                                  %endif
    97                                  
    98                                  cold_continue:
    99 00000022 FC                              cld                     ; Clear the direction flag
   100 00000023 31C0                            xor     ax,ax
   101 00000025 8EC0                            mov     es,ax
   102                                          cnop
   103 00000027 89C7                            mov     di,ax
   104 00000029 B90003                          mov     cx,600h/2       ; clear segments 00h, 040h and 050h
   105 0000002C F3AB                       rep  stosw                   ; clear out BIOS DATA AREA
   106                                  
   107                                  %if 0
   108                                     ss	mov	word [warm_boot],bx	; save only warm boot flag
   109                                  %else
   110 0000002E 36881E1600                 ss	mov	byte [sbc188_rev],bl	; save board revision
   111 00000033 36891E7200                 ss	mov	word [warm_boot],bx	; save warm boot garbage
   112 00000038 08FF                       	or	bh,bh			; test for warm boot
   113 0000003A 7407                    	jz	.3
   114 0000003C 36C70672003412             ss	mov	word [warm_boot],1234h	; restore warm boot code
   115                                  .3:
   116                                  %endif
   117 00000043 E84F03                          call    get_ramsize
   118 00000046 C1E006                          shl     ax,6            ; convert to Segment address
   119                                  %if SOFT_DEBUG
   120                                  	mov	cx,_BSS		; paragraph of _BSS segment
   121                                  ; since the BSS is of length 0000, this is beyond all data
   122                                  
   123                                          mov     bx,cs           ; Code Segment
   124                                          sub     cx,bx           ; Code paragraphs
   125                                          push    cx
   126                                          mov     bx,ax           ; Save HMA in K
   127                                          sub     bx,cx           ; new Code segment
   128                                          mov     es,bx           ; Destination
   129                                          cnop
   130                                          mov     ax,bx           ; Paragraph address to AX
   131                                  
   132                                          push    cs
   133                                          popm     ds              ; Source
   134                                          xor     si,si
   135                                          xor     di,di
   136                                          pop     cx              ; Code length in Paragraphs
   137                                          shl     cx,3            ; Code length in words
   138                                     rep  movsw                   ; move all of it
   139                                          push    es              ; new Code segment
   140                                          push    word SOFT_continue   ; IP
   141                                          retf
   142                                  
   143                                          global  SOFT_continue
   144                                  SOFT_continue:                  ; Continue here in soft memory
   145                                  ;
   146                                  ;  Allocate the DEBUG static area
   147                                  ;
   148                                  	mov	cx,(NBREAK+1)*8 + 15
   149                                  	shr	cx,4		; CX=needed paragraphs
   150                                  	sub	ax,cx		; allocate space
   151                                    ss	mov	[debug_static_ptr+2],ax	 	; setup static area segment
   152                                    ss	mov	word [debug_static_ptr],0	; and offset
   153                                    	shl	cx,4		; word count
   154                                  	pushm	ax,ax		; save segment, twice
   155                                  	popm	es		; set segment to zap
   156                                  	xor	di,di		; start at offset 0
   157                                  	mov	ax,di		; AL=0
   158                                    rep	stosb	    		; Zap memory
   159                                  	popm	ax		; restore AX, EBDA paragraph segment
   160                                  %endif
   161                                  ;
   162                                  ; Save the memory pointers
   163                                  ;
   164 00000049 36A3F200                    ss  mov     [EBDA_paragraph],ax
   165 0000004D C1E806                          shr     ax,6
   166 00000050 36A31300                    ss  mov     [memory_size],ax
   167                                  
   168 00000054 68[ssss]                        push    DGROUP
   169 00000057 1F                              popm    ds              ; This is for the C-programs
   170                                  
   171 00000058 E80702                          call    set_traps	; setup interrupt table
   172 0000005B E80302                  	call	set_interrupt_priority ; set default interrupt priorities
   173                                  
   174 0000005E B80300                  	mov	ax,UART_RATE	; set the default rate
   175                                  	extern	@nvram_get_video
   176 00000061 E8(0000)                	call	@nvram_get_video
   177                                  				; get RAM_serial byte - UART speed
   178                                  				; returned in AL
   179                                  %if SOFT_DEBUG
   180                                  	PUSH	3
   181                                  	CALL	lites
   182                                  %endif
   183                                  	extern	video_init
   184 00000064 E8(0000)                	call	video_init
   185                                  
   186                                  %if SOFT_DEBUG
   187                                  	PUSH	4
   188                                  	CALL	lites
   189                                  %endif
   190                                  	extern	keyboard_init
   191 00000067 E8(0000)                	call	keyboard_init
   192                                  
   193                                  %if SOFT_DEBUG
   194                                  	PUSH	5
   195                                  	CALL	lites
   196                                  %endif
   197 0000006A FB                      	sti                     ; enable interrupts
   198                                  %if FPEM
   199 0000006B 9BDBE3                  	finit			; will allocate memory
   200                                  %endif
   201                                  %if SOFT_DEBUG
   202                                  	PUSH	1
   203                                  	CALL	lites
   204                                  %endif
   205                                  
   206 0000006E 6A37                    	push	VERSION_SEQUENCE
   207 00000070 0E                      	push	cs
   208 00000071 68[3E06]                	push	ident1
   209 00000074 E8(0000)                	call	_cprintf
   210 00000077 58                      	pop     ax
   211 00000078 68[0000]                	push	ident2
   212 0000007B E8(0000)                	call	_cprintf
   213 0000007E 58                      	pop     ax
   214 0000007F 68[E805]                	push	ident3
   215 00000082 E8(0000)                	call	_cprintf
   216 00000085 58                      	pop     ax
   217 00000086 58                      	pop     ax
   218 00000087 58                      	pop	ax
   219                                  
   220                                  %if SOFT_DEBUG
   221                                  %if SOFT_DEBUG>1
   222                                  	PUSH	2
   223                                  	CALL	lites
   224                                  %endif
   225                                          extern     redbug
   226                                  
   227                                          pushf           ; push the flags
   228                                          push    cs      ; simulate a far call
   229                                          call    redbug  ; call our weak debugger
   230                                     es   mov     cx,[bp+si+4]
   231                                  %if SOFT_DEBUG>1
   232                                  	PUSH	3
   233                                  	CALL	lites
   234                                  %endif
   235                                  
   236                                  %endif
   237                                  
   238                                  HAS_FLOPPY	equ	0000000000000001b
   239                                  HAS_FPU		equ	0000000000000010b
   240                                  HAS_MOUSE	equ	0000000000000100b
   241                                  VIDEO_EGA	equ	0000000000000000b
   242                                  VIDEO_COLOR_40	equ	0000000000010000b
   243                                  VIDEO_COLOR_80	equ	0000000000100000b
   244                                  VIDEO_MONO	equ	0000000000110000b
   245                                  FLOPPIES_1	equ	0000000000000000b
   246                                  FLOPPIES_2	equ	0000000001000000b
   247                                  FLOPPIES_3	equ	0000000010000000b
   248                                  FLOPPIES_4	equ	0000000011000000b
   249                                  SERIAL_0	equ	0000000000000000b
   250                                  SERIAL_1	equ	0000001000000000b
   251                                  SERIAL_2	equ	0000010000000000b
   252                                  SERIAL_3	equ	0000011000000000b
   253                                  SERIAL_4	equ	0000100000000000b
   254                                  SERIAL_5	equ	0000101000000000b
   255                                  SERIAL_6	equ	0000110000000000b
   256                                  SERIAL_7	equ	0000111000000000b
   257                                  PARALLEL_0	equ	0000000000000000b
   258                                  PARALLEL_1	equ	0100000000000000b
   259                                  PARALLEL_2	equ	1000000000000000b
   260                                  PARALLEL_3	equ	1100000000000000b
   261                                  
   262                                  
   263                                  ; setup BIOS data area
   264 00000088 6A40                    	push	bios_data_seg
   265 0000008A 1F                      	popm	ds
   266 0000008B C606AE0000              	mov	byte [lock_count],0	; zap the @enable/@disable lock count
   267                                  ; no serial interface -- it is used for the video driver
   268 00000090 B83100                  	mov	ax,PARALLEL_0|SERIAL_0|FLOPPIES_1|VIDEO_MONO|HAS_FLOPPY
   269                                  %if FPEM
   270 00000093 83C802                          or      ax,HAS_FPU              ; a bit of a lie
   271                                  %endif
   272 00000096 A31000                  	mov	word [equipment_flag],ax
   273                                  
   274                                  	extern	_cpu_speed
   275 00000099 E8(0000)                	call	_cpu_speed
   276 0000009C 055802                  	add	ax,600
   277 0000009F B9E204                  	mov	cx,1250
   278 000000A2 31D2                    	xor	dx,dx
   279 000000A4 F7F1                    	div	cx
   280 000000A6 A2FF00                  	mov	byte [cpu_xtal],al	; CPU oscillator frequency
   281                                  
   282 000000A9 FF361300                	push	word [memory_size]
   283                                  
   284 000000AD 68[ssss]                	push	DGROUP
   285 000000B0 1F                      	popm	ds			; This is for the C-programs
   286                                  
   287 000000B1 50                      	push	ax
   288                                  	extern	@timer_init
   289 000000B2 E8(0000)                	call	@timer_init
   290 000000B5 58                      	pop	ax
   291                                  
   292 000000B6 1E                      	push	ds
   293 000000B7 A90100                  	test	ax,1
   294 000000BA 7505                    	jnz	.cpu_clock_05
   295 000000BC 68[6D01]                	push	msg_cpu_clock_00
   296 000000BF EB03                    	jmp	.print_cpu_clock
   297                                  .cpu_clock_05:
   298 000000C1 68[6A01]                	push	msg_cpu_clock_05
   299                                  .print_cpu_clock:
   300 000000C4 D1E8                    	shr	ax,1
   301 000000C6 50                      	push	ax
   302 000000C7 1E                      	push	ds
   303 000000C8 68[3201]                	push	msg_cpu_memory
   304 000000CB E8(0000)                	call	_cprintf
   305 000000CE 83C40A                  	add	sp,12-2
   306                                  %if 1
   307 000000D1 58                              pop     ax                      ; memory size in K
   308 000000D2 E89A03                          call    POST_memory             ; Power On Self Test
   309                                  
   310 000000D5 36C70672003412             ss	mov	word [warm_boot],1234h	; set warm boot code
   311                                  
   312                                  %endif
   313 000000DC E80F00                  	call	nvram_init
   314                                  
   315 000000DF 1E                      	push	ds		; DS = DGROUP (CONST)
   316 000000E0 68[B901]                	push	msg_floppy
   317 000000E3 E8(0000)                	call	_cprintf
   318 000000E6 83C404                  	add	sp,4
   319                                  
   320                                  	extern	@floppy_init
   321 000000E9 E8(0000)                	call	@floppy_init
   322                                  
   323 000000EC EB62                    	jmp	boot_the_OS
   324                                  
   325                                  
   326                                  ;========================================================================
   327                                  ; nvram_init - check NVRAM checksum, prompt for NVRAM setup, apply NVRAM configuration
   328                                  ;========================================================================
   329                                  nvram_init:
   330                                  	extern	@nvram_check
   331 000000EE E8(0000)                	call	@nvram_check
   332 000000F1 09C0                    	or	ax,ax
   333 000000F3 740C                    	jz	.ask_setup
   334                                  
   335 000000F5 1E                      	push	ds
   336 000000F6 68[8F01]                	push	msg_nvram_bad
   337 000000F9 E8(0000)                	call	_cprintf
   338 000000FC 83C404                  	add	sp,4
   339 000000FF EB2D                    	jmp	.run_setup
   340                                  
   341                                  .ask_setup:
   342 00000101 1E                      	push	ds
   343 00000102 68[6E01]                	push	msg_setup
   344 00000105 E8(0000)                	call	_cprintf
   345 00000108 83C404                  	add	sp,4
   346                                  
   347 0000010B B400                    	mov	ah,0
   348 0000010D CD1A                    	int	1Ah
   349 0000010F 89D3                    	mov	bx,dx
   350 00000111 83C324                  	add	bx,18*2		; wait 2 seconds
   351                                  .wait_setup:
   352 00000114 B401                    	mov	ah,1
   353 00000116 CD16                    	int	16h
   354 00000118 740A                    	jz	.wait_setup_1
   355 0000011A B400                    	mov	ah,0
   356 0000011C CD16                    	int	16h
   357 0000011E 0C20                    	or	al,'s'^'S'
   358 00000120 3C73                    	cmp	al,'s'
   359 00000122 740A                    	je	.run_setup
   360                                  
   361                                  .wait_setup_1:
   362 00000124 B400                    	mov	ah,0
   363 00000126 CD1A                    	int	1Ah
   364 00000128 39DA                    	cmp	dx,bx
   365 0000012A 72E8                    	jb	.wait_setup
   366 0000012C EB03                    	jmp	.skip_setup
   367                                  
   368                                  .run_setup:
   369                                  	extern	@nvram_setup
   370 0000012E E8(0000)                	call	@nvram_setup
   371                                  
   372                                  .skip_setup:
   373                                  	extern	@nvram_apply
   374 00000131 E8(0000)                	call	@nvram_apply
   375                                  
   376 00000134 E8EB01                          call    ticktime                ; set the tick clock
   377                                  
   378 00000137 C3                      	ret
   379                                  
   380                                  ;========================================================================
   381                                  ; BIOS_call_18h - Start ROM Basic
   382                                  ; Note:
   383                                  ;	In this BIOS it prints a "no Basic" message and tries to boot the OS
   384                                  ;	or it will run tests if tests are enabled
   385                                  ;========================================================================
   386                                  BIOS_call_18h:
   387 00000138 FB                      	sti
   388                                  %ifdef TESTS
   389                                  	extern	tests
   390                                  	call	tests
   391                                  %else	; TESTS
   392                                  
   393                                  %if TBASIC
   394                                  ;;;        extern  cbasic
   395                                  ;;;        extern  end_cbasic
   396                                  ;;;	jmp	seg cbasic:cbasic
   397 00000139 EA000000F0              	jmp	0F000h:0000h
   398                                  %else
   399                                  	mov	ax,bios_data_seg
   400                                  	mov	ss,ax			; Reset SS
   401                                  	mov	sp,7000h		; and SP
   402                                  	push	DGROUP			; just in case DS is not pointing
   403                                  	popm	ds			; were it should
   404                                  
   405                                  	push	ds
   406                                  	push	msg_no_basic
   407                                  	call	_cprintf
   408                                  	add	sp,4
   409                                  	mov	ah,0			; get any keystroke; jrc 2012/12/02
   410                                  	int	16h
   411                                  	int	19h			; reboot the OS
   412                                  %endif  ; TBASIC
   413                                  
   414                                  %endif	; TESTS
   415                                  .1:
   416 0000013E F4                      	hlt				; we should never get here
   417 0000013F EBFD                    	jmp	.1
   418                                  
   419                                  ;========================================================================
   420                                  ; BIOS_call_19h  - re-Boot the OS
   421                                  ;========================================================================
   422                                  BIOS_call_19h:
   423 00000141 6A40                    	push	bios_data_seg
   424 00000143 1F                      	popm	ds
   425 00000144 C70672003412            	mov	word [warm_boot],1234h	; set warm boot flag
   426 0000014A FA                      	cli				; disable interrupts
   427 0000014B EA0000FFFF              	jmp	0FFFFh:0000h		; go to STARTUP.BIN code
   428                                  
   429                                  
   430                                  
   431                                  
   432                                  ;========================================================================
   433                                  ;========================================================================
   434                                  boot_the_OS:
   435 00000150 B84000                  	mov	ax,bios_data_seg
   436 00000153 8ED0                    	mov	ss,ax			; Reset SS
   437 00000155 BC0070                  	mov	sp,7000h		; and SP
   438 00000158 68[ssss]                	push	DGROUP			; just in case DS is not pointing
   439 0000015B 1F                      	popm	ds			; were it should
   440 0000015C FB                      	sti
   441                                  
   442 0000015D 6A41                    	push	'A'
   443 0000015F 1E                      	push	ds
   444 00000160 68[D201]                	push	msg_booting
   445 00000163 E8(0000)                	call	_cprintf
   446 00000166 83C406                  	add	sp,6
   447                                  
   448 00000169 B200                    	mov	dl,0
   449 0000016B E81600                  	call	boot_drive
   450                                  
   451 0000016E 6A43                    	push	'C'
   452 00000170 1E                      	push	ds
   453 00000171 68[D201]                	push	msg_booting
   454 00000174 E8(0000)                	call	_cprintf
   455 00000177 83C406                  	add	sp,6
   456                                  %if SOFT_DEBUG>1
   457                                  	int 0
   458                                  %endif
   459 0000017A B280                    	mov	dl,80h
   460 0000017C E80500                  	call	boot_drive
   461                                  
   462 0000017F CD18                    	int	18h			; failed to boot, start ROM Basic
   463                                  
   464                                  .1:
   465 00000181 F4                      	hlt				; we should never get here
   466 00000182 EBFD                    	jmp	.1
   467                                  
   468                                  ;========================================================================
   469                                  ; boot_drive - try to boot from the drive
   470                                  ; Input:
   471                                  ;	DL = drive number (00h = first floppy, 80h = first HDD)
   472                                  ;========================================================================
   473                                  boot_drive:
   474 00000184 BE0300                  	mov	si,3			; make 3 tries before giving up
   475                                  
   476                                  %if SOFT_DEBUG>1
   477                                  	nop
   478                                  	int 0
   479                                  %endif
   480                                  .1:					; loop comes back here
   481 00000187 B400                    	mov	ah,0			; reset the Disk Controller
   482 00000189 CD13                    	int	13h
   483                                  
   484 0000018B 52                      	push	dx
   485 0000018C B408                    	mov	ah,8			; get drive parameters
   486 0000018E CD13                    	int	13h
   487 00000190 88D0                    	mov	al,dl			; number of drives
   488 00000192 5A                      	pop	dx
   489 00000193 7213                    	jc	.fn8_error
   490                                  
   491                                  
   492                                  %if SOFT_DEBUG > 2
   493                                  	nop
   494                                  	int	0
   495                                  
   496                                          mov     ax,0401h                ; verify sector
   497                                  	mov	cx,1			; track 0, sector 1
   498                                  	mov	dh,0			; head 0
   499                                          int     13h
   500                                  
   501                                          nop
   502                                          int     0
   503                                  %endif
   504                                  
   505 00000195 B80102                  	mov	ax,0201h		; read one sector
   506 00000198 B90100                  	mov	cx,1			; track 0, sector 1
   507 0000019B B600                    	mov	dh,0			; head 0
   508 0000019D 31DB                    	xor	bx,bx
   509 0000019F 8EC3                    	mov	es,bx			; ES = 0
   510 000001A1 BB007C                  	mov	bx,7C00h		; ES:BX = 0000:7C00
   511 000001A4 CD13                    	int	13h
   512 000001A6 730F                    	jnc	.read_ok
   513                                  
   514                                  .fn8_error:
   515 000001A8 4E                      	dec	si			; go back and reset the controller
   516 000001A9 75DC                    	jnz	.1			; make several tries
   517                                  
   518 000001AB 50                      	push	ax
   519 000001AC 1E                      	push	ds
   520 000001AD 68[F101]                	push	msg_boot_err
   521 000001B0 E8(0000)                	call	_cprintf
   522 000001B3 83C406                  	add	sp,4+2
   523 000001B6 C3                      	ret
   524                                  
   525                                  .read_ok:
   526 000001B7 52                      	push	dx
   527                                  
   528 000001B8 B80480                          mov     ax,8004h                ; NVRAM bits
   529 000001BB E8B603                          call    rtc_get_loc
   530 000001BE A802                            test    al,2            ; RAM_bits_AA55 flag
   531 000001C0 7538                            jnz     .cpm_bootsec
   532 000001C2 26813EFE7D55AA              es	cmp	word [7C00h+1FEh],0AA55h
   533 000001C9 7415                    	je	.good_signature
   534 000001CB 26813EBC7D55AA              es	cmp	word [7C00h+1BCh],0AA55h
   535 000001D2 7420                        	je	.minix_bootsec
   536 000001D4 1E                      	push	ds
   537 000001D5 68[0C02]                	push	msg_no_boot
   538 000001D8 E8(0000)                	call	_cprintf
   539 000001DB 83C404                  	add	sp,4		; remove DX also
   540 000001DE 5A                      	pop	dx		; **
   541 000001DF C3                      	ret
   542                                  .good_signature:
   543 000001E0 26833E007C00                es	cmp	word [7C00h+000h],0
   544 000001E6 751C                    	jne	.good_bootsec
   545 000001E8 1E                      	push	ds
   546 000001E9 68[2602]                	push	msg_no_loader
   547 000001EC E8(0000)                	call	_cprintf
   548 000001EF 83C404                  	add	sp,4		; remove DX also
   549 000001F2 5A                      	pop	dx		; **
   550 000001F3 C3                      	ret
   551                                  
   552                                  .minix_bootsec:
   553 000001F4 1E                      	push	ds		; alternate boot signature
   554 000001F5 68[5C02]                	push	msg_alt_disk
   555 000001F8 EB04                    	jmp	short .cpmbs2
   556                                  .cpm_bootsec:
   557 000001FA 1E                              push    ds
   558 000001FB 68[4802]                        push    msg_cpm_disk
   559 000001FE E8(0000)                .cpmbs2:  call    _cprintf
   560 00000201 83C404                  	add	sp,4
   561                                  .good_bootsec:
   562 00000204 1E                      	push	ds
   563 00000205 68[4402]                	push	msg_boot_ok
   564 00000208 E8(0000)                	call	_cprintf
   565 0000020B 83C404                  	add	sp,4
   566                                  
   567 0000020E 5A                      	pop	dx
   568                                  
   569                                  %if SOFT_DEBUG>1
   570                                  	global	major_debug
   571                                  major_debug:
   572                                  	cmp	dl,0
   573                                  	jne	.999
   574                                  
   575                                  	xor	bx,bx
   576                                  	push	bx
   577                                  	popm	es			; ES = 0
   578                                  	mov	bx,7C00h		; ES:BX = 0000:7C00
   579                                  	int	0
   580                                  
   581                                  	mov	ax,0201h
   582                                  	inc	cl
   583                                  	int	13h
   584                                  
   585                                  	mov	ax,0201h
   586                                  	mov	cl,10h
   587                                  	int	13h
   588                                  
   589                                  	mov	ax,0201h
   590                                  	mov	dh,1
   591                                  	int	13h
   592                                  
   593                                  	mov	ax,0201h
   594                                  	mov	ch,1		; cylinder 1
   595                                  	int	13h
   596                                  
   597                                  	mov	ax,0201h
   598                                  	mov	ch,23h
   599                                  	int	13h
   600                                  
   601                                  	mov	ax,0201h
   602                                  	mov	cx,1
   603                                  	mov	dh,0
   604                                  	int	13h
   605                                  
   606                                  .999:
   607                                  %endif
   608                                  %if SOFT_DEBUG
   609                                  	push	7
   610                                  	call	lites
   611                                  	int 0
   612                                  %endif
   613 0000020F EA007C0000              	jmp	0000:7C00h		; execute the boot sector
   614                                  
   615                                  
   616                                  
   617                                  %if 0		; now part of 2P1S from R. Cini (RAC)
   618                                  ;========================================================================
   619                                  ; BIOS_call_14h  - Serial port communication services
   620                                  ;========================================================================
   621                                  BIOS_call_14h:
   622                                  %if TRACE
   623                                  	call	int_trace
   624                                  %endif	; TRACE
   625                                  	xor	ax,ax
   626                                  	iret
   627                                  
   628                                  ;========================================================================
   629                                  ; BIOS_call_17h  - Print services
   630                                  ;========================================================================
   631                                  BIOS_call_17h:
   632                                  %if TRACE
   633                                  	call	int_trace
   634                                  %endif	; TRACE
   635                                  	mov	ah,0
   636                                  	iret
   637                                  
   638                                  %endif
   639                                  ;========================================================================
   640                                  
   641                                  interrupt_table:
   642                                  
   643                                  %if SOFT_DEBUG
   644                                  	db	0			; Int 0 - divide by zero
   645                                  	extern	zero_divide
   646                                  	dw	zero_divide
   647                                  
   648                                  	db	1			; Int 1 - single step
   649                                  	extern	single_step
   650                                  	dw	single_step
   651                                  
   652                                  	db	2			; Int 2 - NMI interrupt
   653                                  	extern	nmi_interrupt
   654                                  	dw	nmi_interrupt
   655                                  
   656                                  	db	3			; Int 3 - breakpoint
   657                                  	extern	breakpoint
   658                                  	dw	breakpoint
   659                                  
   660                                  	db	4			; Int 4 - interrupt on overflow (INTO instruction)
   661                                  	extern	INTO_trap
   662                                  	dw	INTO_trap
   663                                  
   664                                  	db	5			; Int 5 - bound check error
   665                                  	extern	bound_trap
   666                                  	dw	bound_trap
   667                                  
   668                                  	db	6			; Int 6 - invalid opcode
   669                                  	extern	undefined_op
   670                                  	dw	undefined_op
   671                                  %endif	; SOFT_DEBUG
   672                                  
   673                                  %if FPEM
   674                                  %if 0
   675                                  	db	7			; ESC opcode / Floating Point
   676                                  	extern	vector7
   677                                  	dw	vector7
   678                                  %endif
   679                                  %else
   680                                  %if SOFT_DEBUG
   681                                  	db	7			; Int 7 - math coprocessor not present
   682                                  	dw	undefined_op
   683                                  %endif	; SOFT_DEBUG
   684                                  %endif
   685                                  
   686 00000214 08                      	db	8			; Timer 0 interrupt
   687                                  	extern	timer0_interrupt
   688 00000215 [0000]                  	dw	timer0_interrupt
   689                                  
   690 00000217 0A                      	db	0Ah			; DMA 0 interrupt
   691                                  	extern	dma0_interrupt
   692 00000218 [0000]                  	dw	dma0_interrupt
   693                                  
   694 0000021A 0B                      	db	0Bh			; DMA 1 interrupt
   695 0000021B [4D02]                  	dw	end_of_interrupt
   696                                  
   697 0000021D 0C                      	db	0Ch			; INT0 - UART
   698                                  ; eventually this will be PIC code here
   699                                  %if UART
   700                                  	extern	uart_int
   701 0000021E [0000]                  	dw	uart_int
   702                                  %else
   703                                  	dw	end_of_interrupt
   704                                  %endif
   705                                  
   706 00000220 0D                      	db	0Dh			; INT1- external bus INT
   707                                  	%if CVDU_8242 & (1-CVDU_USE_KBD_HOOK)
   708                                  	extern	cvdu_kbd_int
   709                                  	dw	cvdu_kbd_int
   710                                  %else
   711 00000221 [4D02]                  	dw	end_of_interrupt
   712                                  %endif
   713 00000223 0F                      	db	0Fh
   714                                  	extern	fdc_interrupt_level
   715 00000224 [0000]                  	dw	fdc_interrupt_level	; INT3 - FDC
   716                                  
   717 00000226 10                      	db	10h			; BIOS - Video display services
   718                                  	extern	BIOS_call_10h
   719 00000227 [0000]                  	dw	BIOS_call_10h
   720                                  
   721 00000229 11                      	db	11h			; BIOS - Return equipment list
   722 0000022A [DC03]                  	dw	BIOS_call_11h		; in memory.asm
   723                                  
   724 0000022C 12                      	db	12h			; BIOS - Return conventional memory size
   725 0000022D [E603]                  	dw	BIOS_call_12h		; (shared with Timer 1)
   726                                  ;;;	dw	timer1_interrupt	; non INT 12h passed to timer1
   727                                  
   728 0000022F 13                      	db	13h			; BIOS - Disk services
   729                                  %if PPIDE_driver
   730                                  	extern	FIXED_BIOS_call_13h
   731 00000230 [0000]                  	dw	FIXED_BIOS_call_13h     ; (shared with Timer 2, prescaler, NOT USED)
   732                                  
   733 00000232 40                              db      40h                     ; Floppy Driver
   734                                  %endif
   735                                  	extern	BIOS_call_13h
   736 00000233 [0000]                          dw      BIOS_call_13h
   737                                  
   738 00000235 14                      	db	14h			; BIOS - Serial port communication
   739                                  	extern	BIOS_call_14h
   740 00000236 [0000]                  	dw	BIOS_call_14h
   741                                  
   742 00000238 15                      	db	15h			; BIOS - Miscellaneous system services support routines
   743                                  	extern	BIOS_call_15h
   744 00000239 [0000]                  	dw	BIOS_call_15h
   745                                  
   746 0000023B 16                      	db	16h			; BIOS - Keyboard services
   747                                  	extern	BIOS_call_16h
   748 0000023C [0000]                  	dw	BIOS_call_16h
   749                                  
   750 0000023E 17                      	db	17h
   751                                  	extern	BIOS_call_17h
   752 0000023F [0000]                  	dw	BIOS_call_17h		; BIOS - Print services
   753                                  
   754                                  %if TBASIC==0
   755                                  	db	18h			; BIOS - Start ROM Basic
   756                                  	dw	BIOS_call_18h
   757                                  %endif
   758                                  
   759 00000241 19                      	db	19h			; BIOS - Boot the OS
   760 00000242 [4101]                  	dw	BIOS_call_19h
   761                                  
   762 00000244 1A                      	db	1Ah			; BIOS - RTC (real time clock) services
   763                                  	extern	BIOS_call_1Ah
   764 00000245 [0000]                  	dw	BIOS_call_1Ah
   765                                  
   766 00000247 1C                      	db	1Ch
   767                                  	extern	BIOS_call_1Ch
   768 00000248 [0000]                  	dw	BIOS_call_1Ch
   769                                  
   770 0000024A 70                      	db	70h			; RTC timer tick on IRQ8
   771                                  	extern	rtc_interrupt
   772 0000024B [0000]                  	dw	rtc_interrupt		; 1024 Hz timer
   773                                  
   774                                  num_vectors	equ     (($-interrupt_table)/3)
   775                                  
   776                                  ;========================================================================
   777                                  ; end_of_interrupt - signal end of interrupt to the interrupt controller
   778                                  ;========================================================================
   779                                  end_of_interrupt:
   780 0000024D 5250                            pushm   ax,dx
   781 0000024F BA22FF                          mov     dx,PIC_EOI              ; EOI register
   782 00000252 B80080                          mov     ax,EOI_NSPEC            ; non-specific end of interrupt
   783 00000255 EF                              out     dx,ax                   ; signal it
   784 00000256 585A                            popm    ax,dx
   785 00000258 CF                      	iret
   786                                  
   787                                  skip_trap:
   788                                  %if TRACE
   789                                  	call	int_trace
   790                                  %endif	; TRACE
   791 00000259 CF                              iret            ; return from interrupt is a null trap
   792                                  
   793                                  
   794                                  ;========================================================================
   795                                  ;  Interrupt priority re-assignments
   796                                  ;========================================================================
   797                                  MASK		equ	08h	; mask interrupt
   798                                  LTM		equ	10h	; Level Trigger Mode
   799                                  interrupt_priority:
   800 0000025A 0E                      	db	6 | MASK	; Timers -- timer_init clears the mask
   801 0000025B 02                      	db	2		; DMA0
   802 0000025C 0A                      	db	2 | MASK	; DMA1
   803 0000025D 0C                      	db	4 | MASK	; INT0 -- external /INT (keyboard)
   804 0000025E 04                      	db	4		; INT1 -- UART
   805 0000025F 0F                      	db	7 | MASK	; INT2
   806 00000260 1B                      	db	3 | LTM+MASK	; INT3 -- floppy disk
   807                                  lth_int_priority   equ	$-interrupt_priority
   808                                  
   809                                  set_interrupt_priority:
   810                                  %if 0
   811                                  /* for now */
   812                                  	mov	dx,PIC_TCR
   813                                  	mov	si,interrupt_priority
   814                                  	xor	ax,ax		; zap AH
   815                                  	mov	cx,lth_int_priority
   816                                  sip_loop:
   817                                     cs	lodsb			; get priority level
   818                                     	out	dx,ax
   819                                  	add	dx,2		; PIC control regs are even
   820                                  	loop	sip_loop
   821                                  %endif
   822 00000261 C3                      	ret
   823                                  
   824                                  ;========================================================================
   825                                  ; set_traps - setup interrupt table
   826                                  ;========================================================================
   827                                  set_traps:
   828 00000262 1E                              push    ds
   829                                  
   830 00000263 8CCA                    	mov	dx,cs
   831 00000265 B90001                  	mov	cx,0100h	; number of interrupt vectors
   832 00000268 B300                    	mov	bl,0		; start with int 0
   833 0000026A B8[5902]                	mov	ax,skip_trap
   834                                  .set_default_loop:
   835 0000026D E83E00                  	call	set_vector
   836 00000270 FEC3                    	inc	bl
   837 00000272 E2F9                    	loop	.set_default_loop
   838                                  
   839 00000274 8EDA                            mov     ds,dx           ; for LODS  CS==DX==DS
   840                                          cnop
   841 00000276 BE[1402]                        mov     si,interrupt_table	; load address to start
   842 00000279 B91300                  	mov	cx,num_vectors
   843                                  				; note DX = CS
   844                                  .set_vectors_loop:
   845 0000027C AC                      	lodsb
   846 0000027D 88C3                    	mov	bl,al
   847 0000027F AD                      	lodsw
   848 00000280 E82B00                  	call	set_vector
   849 00000283 E2F7                    	loop	.set_vectors_loop
   850                                  
   851                                  %if TBASIC
   852 00000285 B318                    	mov	bl,18h		; int 18h is Tiny Basic
   853 00000287 31C0                    	xor	ax,ax
   854 00000289 BA00F0                  	mov	dx,0F000h	; absolute segment load @ 00K
   855 0000028C E81F00                  	call	set_vector
   856                                  %endif
   857                                  %if FPEM
   858 0000028F B307                    	mov	bl,07h		; vector 7 is FPU emulator
   859 00000291 31C0                    	xor	ax,ax
   860 00000293 BA80F4                  	mov	dx,0F480h	; absolute segment load @ 18K
   861 00000296 E81500                  	call	set_vector
   862                                  %endif
   863                                  
   864 00000299 1F                              popm     ds
   865 0000029A C3                              ret
   866                                  
   867                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   868                                  ;  get_vector
   869                                  ;       Get an interrupt vector
   870                                  ;
   871                                  ;       Enter with vector number in BL
   872                                  ;       Exit with vector in DX:AX
   873                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   874                                          global  get_vector
   875                                  get_vector:
   876 0000029B 1E53                            pushm   bx,ds		; register saves
   877                                  
   878 0000029D 31C0                            xor     ax,ax           ; zero BX
   879 0000029F 8ED8                            mov     ds,ax           ; set DS=0
   880                                          cnop
   881 000002A1 B700                    	mov	bh,0
   882 000002A3 C1E302                          shl     bx,2            ; index * 4
   883                                  
   884 000002A6 8B07                            mov     ax,[bx]         ; load the vector
   885 000002A8 8B5702                          mov     dx,[bx+2]       ;
   886                                  
   887 000002AB 5B1F                            popm    bx,ds		; register restores
   888 000002AD C3                              ret                     ; result in DX:AX
   889                                  
   890                                  
   891                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   892                                  ;  set_vector
   893                                  ;       Set an interrupt vector
   894                                  ;
   895                                  ;       Enter with vector number in BL
   896                                  ;               vector in DX:AX
   897                                  ;
   898                                  ;       All registers preserved
   899                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   900                                          global  set_vector
   901                                  set_vector:
   902 000002AE 1E5351                          pushm   cx,bx,ds	; register saves
   903                                  
   904 000002B1 31C9                    	xor	cx,cx
   905 000002B3 8ED9                            mov     ds,cx           ; set DS=0
   906                                          cnop
   907 000002B5 B700                    	mov	bh,0
   908 000002B7 C1E302                          shl     bx,2            ; index * 4
   909                                  
   910 000002BA 8907                            mov     [bx],ax         ; set offset
   911 000002BC 895702                          mov     [bx+2],dx       ; set segment
   912                                  
   913 000002BF 595B1F                          popm    cx,bx,ds	; register restores
   914 000002C2 C3                              ret                     ; return
   915                                  
   916                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   917                                  ;  cpu_table_init
   918                                  ;
   919                                  ;       call    cpu_table_init
   920                                  ;       dw      <table>         ; table in the Code segment
   921                                  ;       <return here>
   922                                  ;               AX, CX, DX are trashed
   923                                  ;
   924                                  ;
   925                                  ; table:
   926                                  ;       db_lo   <cpu_register>
   927                                  ;       dw      <contents>
   928                                  ;       ...
   929                                  ;       db      0       ; ends table
   930                                  ;
   931                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   932                                          global  cpu_table_init
   933                                  cpu_table_init:
   934                                  ; get the table address
   935 000002C3 89F1                            mov     cx,si           ; save SI
   936 000002C5 5E                              pop     si              ; get the return address
   937 000002C6 2EAD                        cs  lodsw                   ; get the table address
   938 000002C8 56                              push    si              ; save incremented return address
   939 000002C9 51                              push    cx              ; save former SI
   940                                  
   941 000002CA 89C6                            mov     si,ax           ; CS:SI is table pointer
   942 000002CC B6FF                            mov     dh,cpu_relocation>>8
   943                                  .1:
   944 000002CE 2EAC                        cs  lodsb                   ; get low device code
   945 000002D0 84C0                            test    al,al
   946 000002D2 7407                            jz      .9              ; done with table on zero low device code
   947 000002D4 88C2                            mov     dl,al
   948 000002D6 2EAD                        cs  lodsw                   ; get cpu register data
   949 000002D8 EF                              out     dx,ax           ; output a full word
   950 000002D9 EBF3                            jmp     .1
   951                                  .9:
   952 000002DB 5E                              pop     si              ; restore SI
   953 000002DC C3                              ret                     ;
   954                                  
   955                                  
   956                                  %if 1
   957                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   958                                  ;  C-callable:
   959                                  ;       dword __fastcall divLS(dword dividend, word divisor);
   960                                  ;
   961                                  ;       double word  divided by  word
   962                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   963                                          global  @divLS
   964                                  @divLS:
   965                                          ; DX:AX is dividend
   966                                          ; BX is divisor
   967 000002DD 09D2                            or      dx,dx
   968 000002DF 7505                            jnz     .3
   969 000002E1 F7F3                            div     bx
   970 000002E3 31D2                            xor     dx,dx
   971 000002E5 C3                              ret
   972                                  
   973 000002E6 89C1                    .3:     mov     cx,ax           ; save low dividend in CX
   974 000002E8 89D0                            mov     ax,dx
   975 000002EA 31D2                            xor     dx,dx           ; 0:DX div BX
   976 000002EC F7F3                            div     bx
   977 000002EE 91                              xchg    cx,ax           ; CX is high quotient
   978 000002EF F7F3                            div     bx
   979 000002F1 89CA                            mov     dx,cx
   980 000002F3 C3                              ret
   981                                  
   982                                  %ifndef HAS_FASTCALL
   983                                          global  _divLS
   984                                  _divLS: push    bp
   985                                          mov     bp,sp
   986                                          mov     ax,ARG(1)
   987                                          mov     dx,ARG(2)
   988                                          mov     bx,ARG(3)
   989                                          call    @divLS
   990                                          leave
   991                                          ret
   992                                  
   993                                          global  _remLS
   994                                  _remLS: push    bp
   995                                          mov     bp,sp
   996                                          mov     ax,ARG(1)
   997                                          mov     dx,ARG(2)
   998                                          mov     bx,ARG(3)
   999                                          call    @remLS
  1000                                          leave
  1001                                          ret
  1002                                  %endif
  1003                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1004                                  ;  C-callable:
  1005                                  ;       word __fastcall remLS(dword dividend, word divisor);
  1006                                  ;
  1007                                  ;       remainder of:
  1008                                  ;       double word  divided by  word
  1009                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1010                                          global  @remLS
  1011                                  @remLS:
  1012                                          ; DX:AX is dividend
  1013                                          ; BX is divisor
  1014 000002F4 09D2                            or      dx,dx
  1015 000002F6 740A                            jz      .5
  1016 000002F8 89C1                            mov     cx,ax           ; save low dividend in CX
  1017 000002FA 89D0                            mov     ax,dx
  1018 000002FC 31D2                            xor     dx,dx           ; 0:DX div BX
  1019 000002FE F7F3                            div     bx              ; discard quotient in AX
  1020 00000300 89C8                            mov     ax,cx           ; restore low dividend
  1021 00000302 F7F3                    .5:     div     bx
  1022 00000304 89D0                            mov     ax,dx           ; remainder to AX
  1023 00000306 C3                              ret
  1024                                  
  1025                                  
  1026                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1027                                  ;  C-callable:
  1028                                  ;       dword __fastcall mulLS(dword factor1, word factor2);
  1029                                  ;
  1030                                  ;       double word  multiplied by  word
  1031                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1032                                  	global	@mulLS
  1033                                  @mulLS:
  1034                                  	; DX:AX is factor1
  1035                                  	; BX is factor2
  1036 00000307 09D2                            or      dx,dx
  1037 00000309 7503                            jnz     .1		; dx != 0
  1038 0000030B F7E3                            mul     bx
  1039 0000030D C3                              ret
  1040 0000030E 89C1                    .1:     mov     cx,ax           ; save low part of factor1 in CX
  1041 00000310 89D0                            mov     ax,dx
  1042 00000312 F7E3                            mul     bx
  1043 00000314 91                              xchg    cx,ax           ; CX is a product of high part of factor1 and factor2
  1044 00000315 F7E3                            mul	bx
  1045 00000317 01CA                            add     dx,cx
  1046 00000319 C3                              ret
  1047                                  %endif
  1048                                  
  1049                                  
  1050                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1051                                  ;  microsecond
  1052                                  ;       Enter with CX = delay time in microseconds
  1053                                  ;       Exit with CX = 0
  1054                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1055                                          global  @microsecond
  1056                                          global  microsecond
  1057                                  @microsecond:		; C-callable with __fastcall
  1058 0000031A 89C1                    	mov	cx,ax
  1059                                  microsecond:
  1060 0000031C E303                            jcxz    .9
  1061 0000031E 90                      .1:     nop		; 4 clocks
  1062 0000031F E2FD                            loop    .1	; 15 clocks	loop is 19 clocks (approx.)
  1063 00000321 C3                      .9:     ret
  1064                                  
  1065                                  
  1066                                  %if 0
  1067                                  ;========================================================================
  1068                                  ; wout - nobody calls it, but unasm defines it as an extenal symbol
  1069                                  ; XXX: Need to recompile unasm and kill it
  1070                                  ;========================================================================
  1071                                  	global	wout
  1072                                  wout:
  1073                                  	ret
  1074                                  %endif
  1075                                  
  1076                                  
  1077                                  %macro  binary  1
  1078                                          mov     ah,%1
  1079                                          shr     ax,4
  1080                                          shr     al,4
  1081                                          aad
  1082                                          mov     %1,al
  1083                                  %endm
  1084                                  
  1085                                  
  1086                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1087                                  ;  ticktime -- set the tick count from the CMOS clock
  1088                                  ;
  1089                                  ;       Preserves all registers
  1090                                  ;
  1091                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1092                                          global  ticktime
  1093                                  ticktime:
  1094 00000322 60                              pushm   ALL
  1095                                  
  1096 00000323 B402                            mov     ah,2            ; get Time
  1097 00000325 CD1A                            int     1Ah
  1098                                  
  1099                                          binary  dh
  1078 00000327 88F4                <1>  mov ah,%1
  1079 00000329 C1E804              <1>  shr ax,4
  1080 0000032C C0E804              <1>  shr al,4
  1081 0000032F D50A                <1>  aad
  1082 00000331 88C6                <1>  mov %1,al
  1100                                          binary  cl
  1078 00000333 88CC                <1>  mov ah,%1
  1079 00000335 C1E804              <1>  shr ax,4
  1080 00000338 C0E804              <1>  shr al,4
  1081 0000033B D50A                <1>  aad
  1082 0000033D 88C1                <1>  mov %1,al
  1101                                          binary  ch
  1078 0000033F 88EC                <1>  mov ah,%1
  1079 00000341 C1E804              <1>  shr ax,4
  1080 00000344 C0E804              <1>  shr al,4
  1081 00000347 D50A                <1>  aad
  1082 00000349 88C5                <1>  mov %1,al
  1102                                  ;       mov     al,ch
  1103 0000034B 88E5                            mov     ch,ah           ; CH = 0
  1104 0000034D B23C                            mov     dl,60           ; 60 min / hr,  60 sec / min
  1105 0000034F F6E2                            mul     dl
  1106 00000351 01C8                            add     ax,cx           ; AX = hr*60 + min
  1107 00000353 88F1                            mov     cl,dh           ; CX = sec
  1108 00000355 88EE                            mov     dh,ch           ; DH = 0
  1109 00000357 F7E2                            mul     dx              ;
  1110 00000359 01C8                            add     ax,cx
  1111 0000035B 83D200                          adc     dx,0            ; DX:AX = time in seconds
  1112                                  
  1113 0000035E BBFA00                          mov     bx,250
  1114 00000361 89D1                            mov     cx,dx           ; CX:AX is time in seconds
  1115 00000363 F7E3                            mul     bx
  1116 00000365 91                              xchg    ax,cx           ; CX is low result
  1117 00000366 F6E3                            mul     bl
  1118 00000368 01D0                            add     ax,dx           ; AX:CX is 250*maxseconds
  1119                                  
  1120 0000036A C1E302                          shl     bx,2            ; BX = 1000
  1121 0000036D 91                              xchg    ax,cx           ; CX:AX is 250*maxseconds
  1122 0000036E F7E3                            mul     bx              ; DX:AX is partial product
  1123 00000370 91                              xchg    ax,cx
  1124 00000371 87D3                            xchg    dx,bx           ; BX:CX is partial product
  1125 00000373 F7E2                            mul     dx
  1126 00000375 01D8                            add     ax,bx
  1127 00000377 83D200                          adc     dx,0            ; DX:AX:CX is product
  1128                                  
  1129 0000037A BBA335                          mov     bx,54924/4      ; = 13731       (divisor)
  1130 0000037D F7F3                            div     bx
  1131 0000037F 91                              xchg    ax,cx           ; CX is high quotient
  1132 00000380 F7F3                            div     bx              ; CX:AX is quotient, DX is remainder
  1133                                  ; round the result
  1134 00000382 29D3                            sub     bx,dx           ; if DX > BX/2
  1135 00000384 39D3                            cmp     bx,dx           ;
  1136 00000386 7706                            ja      .3
  1137 00000388 83C001                          add     ax,1
  1138 0000038B 83D100                          adc     cx,0
  1139                                  .3:
  1140 0000038E 92                              xchg    ax,dx           ; CX:DX is tick count to set
  1141 0000038F B401                            mov     ah,1
  1142 00000391 CD1A                            int     1Ah             ; set tick count
  1143                                  
  1144 00000393 61                              popm    ALL
  1145 00000394 C3                              ret
  1146                                  
  1147                                  
  1148                                  
  1149                                  
  1150                                  ;========================================================================
  1151                                  
  1152                                  %include        "memory.asm"
  1153                              <1> ;========================================================================
  1154                              <1> ; MEMORY.ASM -- Memory management routines
  1155                              <1> ;========================================================================
  1156                              <1> ;
  1157                              <1> ;   This version is for assembly by  NASM
  1158                              <1> ;
  1159                              <1> ; Copyright (C) 2011   John R. Coffman
  1160                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board
  1161                              <1> ;
  1162                              <1> ; This program is free software: you can redistribute it and/or modify
  1163                              <1> ; it under the terms of the GNU General Public License as published by
  1164                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1165                              <1> ; (at your option) any later version.
  1166                              <1> ;
  1167                              <1> ; This program is distributed in the hope that it will be useful,
  1168                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1169                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1170                              <1> ; GNU General Public License for more details.
  1171                              <1> ;
  1172                              <1> ; You should have received a copy of the GNU General Public License
  1173                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1174                              <1> ;
  1175                              <1> ;========================================================================
  1176                              <1> 
  1177                              <1>         segment         _TEXT
  1178                              <1> 
  1179                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1180                              <1> ;  get_ramsize
  1181                              <1> ;
  1182                              <1> ;       Return the number of 1k blocks of RAM in AX
  1183                              <1> ;
  1184                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1185                              <1> get_ramsize:
  1186 00000395 1E                  <1>         push    ds
  1187 00000396 53                  <1>         push    bx
  1188 00000397 51                  <1>         push    cx
  1189 00000398 31C0                <1>         xor     ax,ax           ; count of 1k intervals
  1190 0000039A 89C3                <1>         mov     bx,ax           ; segment address
  1191                              <1> .1:
  1192 0000039C 8EDB                <1>         mov     ds,bx           ; set pointer
  1193                              <1>         cnop
  1194 0000039E 8B0E0000            <1>         mov     cx,word [0]     ; save contents
  1195 000003A2 C70600006CA5        <1>         mov     word [0],0a56ch ; addressing is [DS:0]
  1196 000003A8 89DB                <1>         mov     bx,bx
  1197 000003AA 89C0                <1>         mov     ax,ax           ; waste time
  1198 000003AC 813E00006CA5        <1>         cmp     word [0],0a56ch ; see if it is the same
  1199 000003B2 7524                <1>         jne     .9
  1200 000003B4 890E0000            <1>         mov     word [0],cx     ; restore
  1201 000003B8 8B0EFC03            <1>         mov     cx,word [1020]
  1202 000003BC C706FC03325A        <1>         mov     word [1020],05a32h  ; address [DS:1020]
  1203 000003C2 89C0                <1>         mov     ax,ax
  1204 000003C4 89DB                <1>         mov     bx,bx
  1205 000003C6 813EFC03325A        <1>         cmp     word [1020],05a32h
  1206 000003CC 750A                <1>         jne     .9
  1207 000003CE 890EFC03            <1>         mov     word [1020],cx  ; restore
  1208                              <1> 
  1209                              <1> ; Memory test succeeded at the address
  1210                              <1> 
  1211 000003D2 40                  <1>         inc     ax              ; count 1k
  1212 000003D3 83C340              <1>         add     bx,1024/16      ; increment segment register by paragraphs
  1213 000003D6 EBC4                <1>         jmp     .1
  1214                              <1> 
  1215                              <1> .9:
  1216 000003D8 59                  <1>         pop     cx
  1217 000003D9 5B                  <1>         pop     bx
  1218 000003DA 1F                  <1>         pop     ds
  1219 000003DB C3                  <1>         ret
  1220                              <1> 
  1221                              <1> 
  1222                              <1> 
  1223                              <1> 
  1224                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1225                              <1> ;  BIOS_call_11h
  1226                              <1> ;
  1227                              <1> ;       Get Equipment Configuration
  1228                              <1> ;
  1229                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1230                              <1> BIOS_call_11h:
  1231 000003DC FB                  <1>         sti
  1232 000003DD 1E                  <1>         push    ds
  1233 000003DE 6A40                <1>         push    bios_data_seg
  1234 000003E0 1F                  <1>         pop     ds
  1235 000003E1 A11000              <1>         mov     ax,[equipment_flag]     ; pick it out of the BDA
  1236 000003E4 1F                  <1>         pop     ds
  1237 000003E5 CF                  <1>         iret
  1238                              <1> 
  1239                              <1> 
  1240                              <1> 
  1241                              <1> 
  1242                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1243                              <1> ;  BIOS_call_12h
  1244                              <1> ;
  1245                              <1> ;       Get Conventional Memory Size
  1246                              <1> ;
  1247                              <1> ;  N.B.:  This BIOS call shares the interrupt vector with Timer 1.
  1248                              <1> ;       Thus we need to see if an "int 12h" called us, otherwise
  1249                              <1> ;       we assume this was a Timer 1 interrupt.
  1250                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1251                              <1> ; stack
  1252                              <1> offset_SI	equ	0
  1253                              <1> offset_DS	equ	offset_SI+2
  1254                              <1> offset_IP       equ     offset_DS+2
  1255                              <1> offset_CS       equ     offset_IP+2
  1256                              <1> offset_FLAGS    equ     offset_CS+2
  1257                              <1> 
  1258                              <1> BIOS_call_12h:
  1259 000003E6 1E                  <1>         push    ds
  1260 000003E7 56                  <1>         push    si
  1261 000003E8 89E6                <1>         mov     si,sp           ; establish stack addressing
  1262 000003EA 36C57404            <1>    ss   lds     si,[offset_IP+si]
  1263                              <1>         cnop
  1264 000003EE 817CFECD12          <1>         cmp     word [si-2],12CDh       ; int 12h
  1265 000003F3 5E                  <1>         pop     si
  1266 000003F4 7404                <1>         je      .4
  1267 000003F6 1F                  <1>         popm	ds
  1268                              <1> ; since the segment is already correct...
  1269                              <1> 	extern	timer1_interrupt
  1270 000003F7 E9(0000)            <1> 	jmp	timer1_interrupt
  1271                              <1> 
  1272 000003FA 6A40                <1> .4:     push    bios_data_seg
  1273 000003FC 1F                  <1>         pop     ds
  1274 000003FD A11300              <1>         mov     ax,[memory_size]
  1275 00000400 1F                  <1>         pop     ds
  1276 00000401 CF                  <1>         iret
  1277                              <1> 
  1278                              <1> 
  1279                              <1> 
  1280                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1281                              <1> ;  Memory Test
  1282                              <1> ;       Enter with segment to test in AX
  1283                              <1> ;
  1284                              <1> ;       Return: C=1 if error, (DI==loc)
  1285                              <1> ;               C=0 if no error
  1286                              <1> ;
  1287                              <1> ;       AX, CX, DX, BP, DI, ES are all destroyed
  1288                              <1> ;       DS, BX & SI are preserved
  1289                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1290                              <1> memtest:
  1291 00000402 5D                  <1>         pop     bp              ; save return address in BP
  1292                              <1> memtest0:                       ; entry to test page 0
  1293 00000403 FC                  <1>         cld                     ; clear the direction flag
  1294 00000404 8EC0                <1>         mov     es,ax           ; set segment
  1295 00000406 31FF                <1>         xor     di,di
  1296 00000408 B85AA5              <1>         mov     ax,0A55Ah       ; alternating bits in alternating bytes
  1297 0000040B B90080              <1>         mov     cx,8000h        ; test 64K (2 x 32K)
  1298 0000040E F3AB                <1>         rep stosw               ;
  1299 00000410 B580                <1>         mov     ch,80h          ; 32K count of words
  1300 00000412 F3AF                <1>         repe scasw
  1301 00000414 754F                <1>         jne     .3
  1302                              <1> 
  1303 00000416 86C4                <1>         xchg    al,ah           ; second pattern
  1304 00000418 B580                <1>         mov     ch,80h          ; 32K count of words
  1305 0000041A F3AB                <1>         rep stosw
  1306 0000041C B580                <1>         mov     ch,80h          ; 32K count of words
  1307 0000041E F3AF                <1>         repe scasw
  1308 00000420 7543                <1>         jne     .3
  1309                              <1> %if 1
  1310                              <1> seed1   equ     47F8h           ; NOT a random value
  1311                              <1>                                 ; Seed values are chosen to have a relatively
  1312                              <1>                                 ; prime cycle length, and to never produce a zero
  1313                              <1>                                 ; Most random values will produce a zero!!!!
  1314                              <1> 
  1315 00000422 B8F847              <1>         mov     ax,seed1        ; seed value (critical)
  1316                              <1>                                 ; cycle is 111 locations, relative prime to 2**15
  1317 00000425 B580                <1>         mov     ch,80h          ; 32K words
  1318                              <1> .t1:
  1319 00000427 268905              <1>     es  mov     [di],ax         ; store the value
  1320 0000042A F7E0                <1>         mul     ax
  1321 0000042C 47                  <1>         inc     di
  1322 0000042D 88E0                <1>         mov     al,ah           ; generate the next bit pattern
  1323 0000042F 47                  <1>         inc     di
  1324 00000430 88D4                <1>         mov     ah,dl
  1325                              <1> %if 0
  1326                              <1> .t102:  or      ax,ax           ; trap a bad seed value
  1327                              <1>         jz      .t102
  1328                              <1> %endif
  1329 00000432 E2F3                <1>         loop    .t1             ; fill memory with the pattern
  1330                              <1> 
  1331 00000434 B8F847              <1>         mov     ax,seed1
  1332 00000437 B580                <1>         mov     ch,80h          ; 32K words
  1333                              <1> .t11:
  1334 00000439 263B05              <1>     es  cmp     ax,[di]
  1335 0000043C 8D7D02              <1>         lea     di,[di+2]       ; don't touch the Zero flag
  1336 0000043F 7524                <1>         jne     .3
  1337 00000441 F7E0                <1>         mul     ax
  1338 00000443 88E0                <1>         mov     al,ah
  1339 00000445 88D4                <1>         mov     ah,dl
  1340 00000447 E2F0                <1>         loop    .t11
  1341                              <1> 
  1342                              <1> %endif
  1343 00000449 B8FFFF              <1>         mov     ax,0FFFFh       ; solid pattern of 1's
  1344 0000044C B580                <1>         mov     ch,80h          ; 32K count of words
  1345 0000044E F3AB                <1>         rep stosw
  1346 00000450 B580                <1>         mov     ch,80h          ; 32K count of words
  1347 00000452 F3AF                <1>         repe scasw
  1348 00000454 750F                <1>         jne     .3
  1349                              <1> 
  1350 00000456 31C0                <1>         xor     ax,ax           ; solid pattern of 0's
  1351 00000458 B580                <1>         mov     ch,80h          ; 32K count of words
  1352 0000045A F3AB                <1>         rep stosw
  1353 0000045C B580                <1>         mov     ch,80h          ; 32K count of words
  1354 0000045E F3AF                <1>         repe scasw
  1355 00000460 7503                <1>         jne     .3
  1356                              <1> 
  1357 00000462 F8                  <1>         clc                     ; no error
  1358 00000463 FFE5                <1>         jmp     bp
  1359                              <1> 
  1360                              <1> .3: ; ERROR in scan string
  1361 00000465 4F                  <1>         dec     di
  1362 00000466 263A25              <1>    es   cmp     ah,[di]
  1363 00000469 7401                <1>         je      .4
  1364 0000046B 4F                  <1>         dec     di
  1365                              <1> .4:
  1366 0000046C F9                  <1>         stc
  1367 0000046D FFE5                <1>         jmp     bp
  1368                              <1> 
  1369                              <1> 
  1370                              <1> 
  1371                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1372                              <1> ; POST_memory -- Power On Self Test of Memory
  1373                              <1> ;
  1374                              <1> ;
  1375                              <1> ;  Enter with:
  1376                              <1> ;       AX = memory limit in kilobytes
  1377                              <1> ;	DS = DGROUP
  1378                              <1> ;	SS = bios_data_seg
  1379                              <1> ;
  1380                              <1> ;  Watch out, "memtest" clobbers segment registers
  1381                              <1> ;
  1382                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1383                              <1> POST_memory:
  1384 0000046F 0660                <1>         pushm   ALL,es	; ,ds
  1385 00000471 36813E72003412      <1>     ss	cmp	word [warm_boot],1234h
  1386 00000478 36C70672007856      <1>     ss 	mov	word [warm_boot],5678h	; non-magic value!!!
  1387 0000047F 7507                <1>     	jne	.001
  1388 00000481 1E                  <1> 	push	ds
  1389 00000482 68[5000]            <1> 	push	msg_mem_bypass
  1390 00000485 E99800              <1> 	jmp	.print
  1391                              <1> .001:
  1392 00000488 C1E006              <1>         shl     ax,6                    ; memory size in paragraphs
  1393 0000048B 89C3                <1>         mov     bx,ax                   ; save in BX
  1394                              <1> .1:
  1395 0000048D BA0010              <1>         mov     dx,1000h                ; seg. 0000:xxxx has been tested
  1396 00000490 29D3                <1>         sub     bx,dx
  1397 00000492 7432                <1>         jz      .8                      ; done if down to zero
  1398 00000494 39D3                <1>         cmp     bx,dx
  1399 00000496 7302                <1>         jae     .2
  1400 00000498 89D3                <1>         mov     bx,dx
  1401                              <1> .2:
  1402 0000049A 53                  <1>         push    bx
  1403                              <1> 
  1404 0000049B 53                  <1>         push    bx
  1405 0000049C 1E                  <1>         push    ds		;DGROUP
  1406 0000049D 68[0000]            <1>         push    msg_mem_test
  1407 000004A0 E8(0000)            <1>         call    _cprintf
  1408 000004A3 83C406              <1>         add     sp,6
  1409                              <1> 
  1410 000004A6 5B                  <1>         pop     bx
  1411 000004A7 89D8                <1>         mov     ax,bx                   ; AX is segment tested
  1412 000004A9 E856FF              <1>         call    memtest
  1413                              <1> 
  1414                              <1> %if 0
  1415                              <1> ;  induce an error to see printout
  1416                              <1>         mov     di,3465h
  1417                              <1>         stc
  1418                              <1> %endif
  1419 000004AC 73DF                <1>         jnc     .1
  1420                              <1> ; make an error report
  1421                              <1> 
  1422 000004AE 89FA                <1>         mov     dx,di           ; copy byte address
  1423 000004B0 C1EF04              <1>         shr     di,4            ; convert to paragraphs
  1424 000004B3 01DF                <1>         add     di,bx           ; DI is total paragraphs
  1425 000004B5 83E20F              <1>         and     dx,0Fh          ; single-byte byte address
  1426 000004B8 52                  <1>         push    dx
  1427 000004B9 57                  <1>         push    di
  1428 000004BA 1E                  <1>         push    ds		; DGROUP
  1429 000004BB 68[7400]            <1>         push    msg_mem_error
  1430 000004BE E8(0000)            <1>         call    _cprintf
  1431 000004C1 83C408              <1>         add     sp,8
  1432                              <1> 
  1433 000004C4 EBC7                <1>         jmp     .1
  1434                              <1> 
  1435                              <1> .8:
  1436                              <1> %if SOFT_DEBUG==0
  1437                              <1> ; tested down to 1000:0000
  1438                              <1> ; now do the test at loc. 0  (watch out for the stack)
  1439 000004C6 53                  <1>         push    bx                      ; BX is zero
  1440 000004C7 1E                  <1>         push    ds		; DGROUP
  1441 000004C8 68[0000]            <1>         push    msg_mem_test
  1442 000004CB E8(0000)            <1>         call    _cprintf
  1443 000004CE 83C406              <1>         add     sp,6
  1444                              <1> 
  1445 000004D1 1E9C                <1>         pushm   f,ds
  1446 000004D3 FA                  <1>         cli                             ; disable interrupts
  1447                              <1> 
  1448 000004D4 6A00                <1>         push    0
  1449 000004D6 1F                  <1>         pop     ds                      ; source is 0000:xxxx
  1450 000004D7 680010              <1>         push    1000h
  1451 000004DA 07                  <1>         pop     es                      ; dest. is 1000:xxxx (save area)
  1452 000004DB 31F6                <1>         xor     si,si
  1453 000004DD 31FF                <1>         xor     di,di
  1454 000004DF B90080              <1>         mov     cx,8000h                ; 32k words == 64K bytes
  1455 000004E2 F3A5                <1>         rep movsw
  1456                              <1> 
  1457 000004E4 31C0                <1>         xor     ax,ax
  1458 000004E6 BD[EC04]            <1>         mov     bp,.85
  1459 000004E9 E917FF              <1>         jmp     memtest0
  1460                              <1> .85:
  1461                              <1> %if 0
  1462                              <1>         stc
  1463                              <1>         mov     di,8765h                ; force error reporting
  1464                              <1> %endif
  1465 000004EC 19D2                <1>         sbb     dx,dx                   ; grab the returned carry
  1466 000004EE 89FB                <1>         mov     bx,di                   ; save error location
  1467                              <1> 
  1468 000004F0 680010              <1>         push    1000h                   ; source is 1000:xxxx
  1469 000004F3 1F                  <1>         pop     ds
  1470 000004F4 6A00                <1>         push    0
  1471 000004F6 07                  <1>         pop     es                      ; restore 0000:xxxx
  1472 000004F7 31F6                <1>         xor     si,si
  1473 000004F9 31FF                <1>         xor     di,di
  1474 000004FB B90080              <1>         mov     cx,8000h                ; 32k words == 64K bytes
  1475 000004FE F3A5                <1>         rep movsw
  1476                              <1> 
  1477 00000500 1E                  <1>         push    ds
  1478 00000501 07                  <1>         pop     es
  1479 00000502 31C0                <1>         xor     ax,ax
  1480 00000504 B580                <1>         mov     ch,80h                  ; re-zero 1000:0000 ...
  1481 00000506 F3AB                <1>         rep stosw
  1482                              <1> 
  1483 00000508 9D1F                <1>         popm    f,ds
  1484                              <1> %endif
  1485 0000050A D1EA                <1>         shr     dx,1                    ; set the carry
  1486 0000050C 730E                <1>         jnc     .89
  1487                              <1> 
  1488                              <1> ; make the page 0 error report
  1489 0000050E 53                  <1>         push    bx
  1490 0000050F 1E                  <1>         push    ds			; DGROUP
  1491 00000510 68[9200]            <1>         push    msg_mem_error0
  1492 00000513 E8(0000)            <1>         call    _cprintf
  1493 00000516 83C406              <1>         add     sp,6
  1494                              <1> 
  1495 00000519 F4                  <1> .88:    hlt
  1496 0000051A EBFD                <1>         jmp     .88
  1497                              <1> 
  1498                              <1> .89:
  1499 0000051C 1E                  <1>         push    ds			; DGROUP
  1500 0000051D 68[2000]            <1>         push    msg_mem_done
  1501                              <1> .print:
  1502 00000520 E8(0000)            <1>         call    _cprintf
  1503 00000523 83C404              <1>         add     sp,4
  1504                              <1> .9:
  1505 00000526 6107                <1>         popm    ALL,es ; ,ds
  1506 00000528 C3                  <1>         ret
  1507                              <1> 
  1508                              <1> 
  1509                              <1>         segment CONST
  1510                              <1> msg_mem_test:
  1511 00000000 0D2538615465737469- <1>         db      CR,"%8aTesting memory at %7a%04x:0",NUL
  1511 00000009 6E67206D656D6F7279- <1>
  1511 00000012 206174202537612530- <1>
  1511 0000001B 34783A3000          <1>
  1512                              <1> msg_mem_done:
  1513 00000020 0D253261502E4F2E53- <1>         db      CR,"%2aP.O.S.T. of memory %10aSUCCESSFUL        "
  1513 00000029 2E542E206F66206D65- <1>
  1513 00000032 6D6F72792025313061- <1>
  1513 0000003B 535543434553534655- <1>
  1513 00000044 4C2020202020202020  <1>
  1514                              <1> msg_mem_double:
  1515 0000004D 0A0A00              <1>         db      NL,NL,NUL
  1516                              <1> msg_mem_bypass:
  1517 00000050 0D253861502E4F2E53- <1> 	db	CR,"%8aP.O.S.T. of memory BYPASSED  ",NL,NL,NUL
  1517 00000059 2E542E206F66206D65- <1>
  1517 00000062 6D6F72792042595041- <1>
  1517 0000006B 5353454420200A0A00  <1>
  1518                              <1> msg_mem_error:
  1519 00000074 070A253134614D656D- <1>         db      BEL,NL,"%14aMemory error at %04x%x",NL,NUL
  1519 0000007D 6F7279206572726F72- <1>
  1519 00000086 206174202530347825- <1>
  1519 0000008F 780A00              <1>
  1520                              <1> msg_mem_error0:
  1521 00000092 070A253134614D656D- <1>         db      BEL,NL,"%14aMemory error at 0%04x",NL,NL
  1521 0000009B 6F7279206572726F72- <1>
  1521 000000A4 206174203025303478- <1>
  1521 000000AD 0A0A                <1>
  1522 000000AF 2A2A2A2A2A2A2A2A2A- <1>         db      "**************************",NL
  1522 000000B8 2A2A2A2A2A2A2A2A2A- <1>
  1522 000000C1 2A2A2A2A2A2A2A2A0A  <1>
  1523 000000CA 2A2020202020434154- <1>         db      "*     CATASTROPHE!!!     *",NL
  1523 000000D3 415354524F50484521- <1>
  1523 000000DC 212120202020202A0A  <1>
  1524 000000E5 2A2A2A2A2A2A2A2A2A- <1>         db      "**************************",NL,NL
  1524 000000EE 2A2A2A2A2A2A2A2A2A- <1>
  1524 000000F7 2A2A2A2A2A2A2A2A0A- <1>
  1524 00000100 0A                  <1>
  1525 00000101 48616C74696E672064- <1>         db      "Halting due to error in segment 0000:xxxx",BEL,NL
  1525 0000010A 756520746F20657272- <1>
  1525 00000113 6F7220696E20736567- <1>
  1525 0000011C 6D656E742030303030- <1>
  1525 00000125 3A78787878070A      <1>
  1526 0000012C 00                  <1>         db      NUL
  1527 0000012D 00                  <1> 	db	0
  1153                                  %include        "ds1302.asm"
  1154                              <1> ;========================================================================
  1155                              <1> ; DS1302.ASM -- support on the SBC-188 for the DS1302 chip
  1156                              <1> ;========================================================================
  1157                              <1> ;
  1158                              <1> ;   This version is for assembly by  NASM 2.08
  1159                              <1> ;
  1160                              <1> ; Copyright (C) 2010   John R. Coffman
  1161                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board
  1162                              <1> ;
  1163                              <1> ; This program is free software: you can redistribute it and/or modify
  1164                              <1> ; it under the terms of the GNU General Public License as published by
  1165                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1166                              <1> ; (at your option) any later version.
  1167                              <1> ;
  1168                              <1> ; This program is distributed in the hope that it will be useful,
  1169                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1170                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1171                              <1> ; GNU General Public License for more details.
  1172                              <1> ;
  1173                              <1> ; You should have received a copy of the GNU General Public License
  1174                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1175                              <1> ;
  1176                              <1> ;========================================================================
  1177                              <1> 
  1178                              <1>         segment         _TEXT
  1179                              <1> 
  1180                              <1> rtc_data        equ     80H             ; Data mask bit
  1181                              <1> rtc_wren        equ     20H             ; Write enable bit
  1182                              <1> rtc_clk         equ     40H             ; Clock signal
  1183                              <1> rtc_rst         equ     10H             ; Reset bit
  1184                              <1> 
  1185                              <1> 
  1186                              <1> ;        global  _rtc_reset
  1187                              <1> rtc_reset:
  1188 00000529 BA9404              <1>         mov     dx,RTC              ; set the device code
  1189 0000052C B010                <1>         mov     al,rtc_rst              ; Reset, enable read
  1190 0000052E EB05                <1>         jmp     rtc_out
  1191                              <1> 
  1192                              <1> 
  1193                              <1> ;        global  _rtc_reset_off
  1194                              <1> rtc_reset_off:
  1195 00000530 BA9404              <1>         mov     dx,RTC
  1196 00000533 B000                <1>         mov     al,0                    ; Reset Off, enable read
  1197                              <1> rtc_out:
  1198 00000535 EE                  <1>         out     dx,al
  1199 00000536 B91000              <1>         mov     cx,16
  1200 00000539 E9E0FD              <1>         jmp     microsecond             ; delay 16 us
  1201                              <1> 
  1202                              <1> 
  1203                              <1> ;        global  @rtc_write
  1204                              <1> @rtc_write:
  1205                              <1> rtc_write:
  1206 0000053C 53                  <1>         push    bx
  1207                              <1> 
  1208 0000053D BA9404              <1>         mov     dx,RTC
  1209 00000540 88C3                <1>         mov     bl,al                   ; save data in BL
  1210 00000542 B408                <1>         mov     ah,8                    ; set loop count
  1211                              <1> .1:
  1212 00000544 B020                <1>         mov     al,rtc_wren             ; write enable, reset off, clock off
  1213 00000546 D0EB                <1>         shr     bl,1                    ; data bit to Carry
  1214 00000548 1400                <1>         adc     al,0                    ; data to BIT 0
  1215 0000054A E8E8FF              <1>         call    rtc_out                 ; put out the data
  1216                              <1> 
  1217 0000054D 0C40                <1>         or      al,rtc_clk              ; set the clock bit
  1218 0000054F E8E3FF              <1>         call    rtc_out                 ; put out the data
  1219                              <1> 
  1220 00000552 FECC                <1>         dec     ah                      ; count a bit
  1221 00000554 75EE                <1>         jnz     .1
  1222                              <1> 
  1223                              <1> ; rtc_write ends with the clock high
  1224 00000556 5B                  <1>         pop     bx
  1225 00000557 C3                  <1>         ret
  1226                              <1> 
  1227                              <1> 
  1228                              <1> 
  1229                              <1> 
  1230                              <1> rtc_read:
  1231 00000558 53                  <1>         push    bx
  1232                              <1> 
  1233 00000559 BA9404              <1>         mov     dx,RTC
  1234 0000055C B308                <1>         mov     bl,8                    ; bit count
  1235                              <1> .1:
  1236 0000055E B000                <1>         mov     al,0                    ; clock off, reset off, read enable
  1237 00000560 E8D2FF              <1>         call    rtc_out
  1238                              <1> ; delay was included in the above output call
  1239 00000563 EC                  <1>         in      al,dx                   ; read a bit
  1240 00000564 D1C8                <1>         ror     ax,1                    ; rotate data into AH left to right
  1241                              <1> 
  1242 00000566 B040                <1>         mov     al,rtc_clk              ; set to clock next data bit
  1243 00000568 E8CAFF              <1>         call    rtc_out
  1244 0000056B FECB                <1>         dec     bl
  1245 0000056D 75EF                <1>         jnz     .1
  1246                              <1> 
  1247 0000056F C1E808              <1>         shr     ax,8                    ; return data in AL,  AH=0
  1248                              <1> 
  1249 00000572 5B                  <1>         pop     bx
  1250 00000573 C3                  <1>         ret
  1251                              <1> 
  1252                              <1> 
  1253                              <1> 
  1254                              <1> 
  1255                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1256                              <1> ;  rtc_get_loc          RTC get location as addressed
  1257                              <1> ;       Enter with      AL = address of the location to get
  1258                              <1> ;                       AH = Flag RAM/clock  (RAM=!0, clock=0)
  1259                              <1> ;       Exit with data in AL
  1260                              <1> ;               All other registers are preserved
  1261                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1262                              <1>         global  @rtc_get_loc
  1263                              <1>         global  rtc_get_loc
  1264                              <1> @rtc_get_loc:
  1265                              <1> rtc_get_loc:
  1266 00000574 52                  <1>         push    dx
  1267 00000575 51                  <1>         push    cx              ; 3 register saves
  1268 00000576 53                  <1>         push    bx
  1269                              <1> 
  1270 00000577 08E4                <1>         or      ah,ah           ; test flag
  1271 00000579 7402                <1>         jz      .1
  1272 0000057B B440                <1>         mov     ah,040h         ; RAM flag
  1273 0000057D 88E7                <1> .1:     mov     bh,ah           ; save flag in BH
  1274 0000057F 241F                <1>         and     al,31           ; mask address to 5 bits
  1275 00000581 00C0                <1>         add     al,al           ; shift left
  1276 00000583 08C7                <1>         or      bh,al           ; form command
  1277 00000585 80CF81              <1>         or      bh,81h          ; Clock Command / READ bit = 01h
  1278                              <1> 
  1279 00000588 BA9404              <1>         mov     dx,RTC
  1280 0000058B E89BFF              <1>         call    rtc_reset
  1281 0000058E E89FFF              <1>         call    rtc_reset_off   ; signal that a command is coming
  1282 00000591 88F8                <1>         mov     al,bh
  1283 00000593 E8A6FF              <1>         call    rtc_write       ; write out the command
  1284 00000596 E8BFFF              <1>         call    rtc_read        ; read the data location
  1285 00000599 50                  <1>         push    ax              ; save the result
  1286 0000059A E893FF              <1>         call    rtc_reset_off
  1287 0000059D E889FF              <1>         call    rtc_reset       ; and finish up
  1288                              <1> 
  1289 000005A0 58                  <1>         pop     ax              ; return value
  1290                              <1> 
  1291 000005A1 5B                  <1>         pop     bx
  1292 000005A2 59                  <1>         pop     cx              ; plus 3 register restores
  1293 000005A3 5A                  <1>         pop     dx
  1294 000005A4 C3                  <1>         ret
  1295                              <1> 
  1296                              <1> 
  1297                              <1> 
  1298                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1299                              <1> ;  rtc_set_loc          RTC set location as addressed
  1300                              <1> ;       Enter with      AL = address of the location to set
  1301                              <1> ;                       AH = Flag RAM/clock  (RAM=!0, clock=0)
  1302                              <1> ;                       DL = data to write to location
  1303                              <1> ;               AX is undefined on return
  1304                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1305                              <1>         global  @rtc_set_loc
  1306                              <1>         global  rtc_set_loc
  1307                              <1> @rtc_set_loc:
  1308                              <1> rtc_set_loc:
  1309 000005A5 52                  <1>         push    dx
  1310 000005A6 51                  <1>         push    cx              ; 3 register saves
  1311 000005A7 53                  <1>         push    bx
  1312                              <1> 
  1313 000005A8 52                  <1>         push    dx              ; save data
  1314                              <1> 
  1315 000005A9 08E4                <1>         or      ah,ah           ; test flag
  1316 000005AB 7402                <1>         jz      .1
  1317 000005AD B440                <1>         mov     ah,040h         ; RAM flag
  1318 000005AF 88E7                <1> .1:     mov     bh,ah           ; save flag in BH
  1319 000005B1 241F                <1>         and     al,31           ; mask address to 5 bits
  1320 000005B3 00C0                <1>         add     al,al           ; shift left
  1321 000005B5 08C7                <1>         or      bh,al           ; form command
  1322 000005B7 80CF80              <1>         or      bh,80h          ; Clock Command / WRITE bit = 00h
  1323                              <1> 
  1324 000005BA BA9404              <1>         mov     dx,RTC
  1325 000005BD E869FF              <1>         call    rtc_reset
  1326 000005C0 E86DFF              <1>         call    rtc_reset_off   ; signal that a command is coming
  1327 000005C3 88F8                <1>         mov     al,bh           ; command to AL
  1328 000005C5 E874FF              <1>         call    rtc_write       ; write out the command
  1329 000005C8 58                  <1>         pop     ax              ; get the data value
  1330 000005C9 E870FF              <1>         call    rtc_write       ; write the data
  1331 000005CC E861FF              <1>         call    rtc_reset_off   ; end of command
  1332 000005CF E857FF              <1>         call    rtc_reset
  1333                              <1> 
  1334 000005D2 5B                  <1>         pop     bx
  1335 000005D3 59                  <1>         pop     cx              ; plus 3 register restores
  1336 000005D4 5A                  <1>         pop     dx
  1337 000005D5 C3                  <1>         ret
  1154                                  
  1155                                  %if SOFT_DEBUG+1
  1156                                          global  lites
  1157                                  ; call with:
  1158                                  ;       push    code    ; code in AL
  1159                                  ;       call    lites
  1160                                  ;
  1161 000005D6 55                      lites:  push    bp
  1162 000005D7 89E5                            mov     bp,sp           ; establish stack frame
  1163 000005D9 5250                            pushm   ax,dx
  1164 000005DB 8A4604                          mov     al,[bp+4]
  1165 000005DE BA3006                          mov     dx,FRONT_PANEL_LED
  1166 000005E1 EE                              out     dx,al
  1167 000005E2 585A                            popm    ax,dx
  1168 000005E4 5D                              pop     bp
  1169 000005E5 C20200                          ret     2               ; remove argument
  1170                                  %endif
  1171                                  
  1172                                  %if 0
  1173                                  ; _FPSIGNAL:
  1174                                  ;   Enter with AL = condensed error code
  1175                                  ;
  1176                                  	global	_FPSIGNAL
  1177                                  _FPSIGNAL:
  1178                                  	xor	ah,ah
  1179                                  	push	ax
  1180                                  	push	DGROUP
  1181                                  	push	msg_fpu_err
  1182                                  	call	_cprintf
  1183                                  	add	sp,6
  1184                                  	ret
  1185                                  %endif
  1186                                  
  1187                                  
  1188                                  
  1189                                  
  1190                                  ident3:
  1191                                  %if SOFT_DEBUG
  1192                                          db      NL
  1193                                  	db	"%7a"
  1194                                          db      "             ***** SOFT BIOS *****"
  1195                                          db      NL
  1196                                  %endif
  1197                                  %ifdef __DATE__
  1198                                  %ifdef __TIME__
  1199 000005E8 0A                              db      NL
  1200 000005E9 25313461                	db	"%14a"
  1201 000005ED 546869732042494F53-             db      "This BIOS copy was built at ",__TIME__," ",TIMEZONE
  1201 000005F6 20636F707920776173-
  1201 000005FF 206275696C74206174-
  1201 00000608 2030323A35393A3332-
  1201 00000611 20435354           
  1202 00000615 206F6E20323032342D-             db      " on ", __DATE__
  1202 0000061E 31302D3238         
  1203                                  %endif
  1204                                  %endif
  1205 00000623 2E2020202020202020-             db      ".                    [%d]",NL
  1205 0000062C 202020202020202020-
  1205 00000635 2020205B25645D0A   
  1206 0000063D 00                              db      0
  1207                                  
  1208                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1209                                  ;  This is the banner which prints out first.
  1210                                  ;  The letters are variable width; B is wide; -, and 1 are kerned.
  1211                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1212                                  ident1:
  1213 0000063E 0A253961                        db      NL,"%9a"
  1214 00000642 20205F5F5F5F5F2020-             DB      "  _____                  _ ",	NL
  1214 0000064B 202020202020202020-
  1214 00000654 202020202020205F20-
  1214 0000065D 0A                 
  1215 0000065E 207C20205F5F205C20-             DB      " |  __ \                | |",	NL
  1215 00000667 202020202020202020-
  1215 00000670 2020202020207C207C-
  1215 00000679 0A                 
  1216 0000067A 207C207C20207C207C-             DB      " | |  | |_   _  ___   __| |_   _ _ __   ___ ",	NL
  1216 00000683 5F2020205F20205F5F-
  1216 0000068C 5F2020205F5F7C207C-
  1216 00000695 5F2020205F205F205F-
  1216 0000069E 5F2020205F5F5F200A 
  1217 000006A7 207C207C20207C207C-             DB      " | |  | | | | |/ _ \ / _` | | | | '_ \ / _ \ ",	NL
  1217 000006B0 207C207C207C2F205F-
  1217 000006B9 205C202F205F60207C-
  1217 000006C2 207C207C207C20275F-
  1217 000006CB 205C202F205F205C20-
  1217 000006D4 0A                 
  1218 000006D5 207C207C5F5F7C207C-             DB      " | |__| | |_| | (_) | (_| | |_| | | | |  __/",	NL
  1218 000006DE 207C5F7C207C20285F-
  1218 000006E7 29207C20285F7C207C-
  1218 000006F0 207C5F7C207C207C20-
  1218 000006F9 7C207C20205F5F2F0A 
  1219 00000702 207C5F5F5F5F5F2F20-             DB      " |_____/ \__,_|\___/ \__,_|\__, |_| |_|\___|",	NL
  1219 0000070B 5C5F5F2C5F7C5C5F5F-
  1219 00000714 5F2F205C5F5F2C5F7C-
  1219 0000071D 5C5F5F2C207C5F7C20-
  1219 00000726 7C5F7C5C5F5F5F7C0A 
  1220 0000072F 202020203830633138-             DB      "    80c188 pcb              __/ |  rev. ", VERSION, NL
  1220 00000738 382070636220202020-
  1220 00000741 202020202020202020-
  1220 0000074A 205F5F2F207C202072-
  1220 00000753 65762E20332E352D31-
  1220 0000075C 0A                 
  1221 0000075D 202020202020202020-             DB      "                           |___/   of   ", DATE, NL
  1221 00000766 202020202020202020-
  1221 0000076F 202020202020202020-
  1221 00000778 7C5F5F5F2F2020206F-
  1221 00000781 6620202032392D4170-
  1221 0000078A 722D323032310A     
  1222 00000791 202020202020202020-             db      "                                   ("
  1222 0000079A 202020202020202020-
  1222 000007A3 202020202020202020-
  1222 000007AC 202020202020202028 
  1223                                  %if ANSI
  1224 000007B5 414E5349                        db      "ANSI"
  1225                                  %elif DUMB
  1226                                          db      "dumb"
  1227                                  %elif TTY
  1228                                          db      "tty"
  1229                                  %else
  1230                                          db      "???"
  1231                                  %endif
  1232 000007B9 290A                            db      ")",NL
  1233                                  
  1234 000007BB 00                      	db      0
  1235                                  
  1236                                  
  1237 000007BC 90<rep 4h>              	align	16
  1238                                  
  1239                                  bulk_of_code_end        equ     $
  1240                                  
  1241                                  
  1242                                  
  1243                                          segment CONST
  1244                                  
  1245                                          global  _bios_data_area_ptr
  1246                                  _bios_data_area_ptr:
  1247 0000012E 00004000                        dw      0000h,bios_data_seg     ; pointer 40:0
  1248                                  
  1249                                  
  1250                                  msg_cpu_memory:
  1251 00000132 253135612564257320-     	db	"%15a%d%s %2aMhz CPU clock, %15a%u%2aK memory installed"
  1251 0000013B 2532614D687A204350-
  1251 00000144 5520636C6F636B2C20-
  1251 0000014D 253135612575253261-
  1251 00000156 4B206D656D6F727920-
  1251 0000015F 696E7374616C6C6564 
  1252 00000168 0A00                    	db	NL, 0
  1253                                  msg_cpu_clock_05:
  1254 0000016A 2E3500                  	db	".5", 0
  1255                                  msg_cpu_clock_00:
  1256 0000016D 00                      	db	0
  1257                                  msg_setup:
  1258 0000016E 507265737320277327-     	db	"Press 's' to run NVRAM setup...", NL, 0
  1258 00000177 20746F2072756E204E-
  1258 00000180 5652414D2073657475-
  1258 00000189 702E2E2E0A00       
  1259                                  msg_nvram_bad:
  1260 0000018F 4E5652414D20636865-     	db	"NVRAM checksum is invalid, running setup", NL, 0
  1260 00000198 636B73756D20697320-
  1260 000001A1 696E76616C69642C20-
  1260 000001AA 72756E6E696E672073-
  1260 000001B3 657475700A00       
  1261                                  msg_floppy:
  1262 000001B9 4E6F7720696E697469-     	db	"Now initializing floppy", NL, 0
  1262 000001C2 616C697A696E672066-
  1262 000001CB 6C6F7070790A00     
  1263                                  %if 0
  1264                                  msg_fpu_err:
  1265                                  	db	NL, "EM187 has signalled error 0x%02x.", NL, 0
  1266                                  %endif
  1267                                  msg_booting:
  1268 000001D2 547279696E6720746F-     	db	"Trying to boot from drive %c: ", 0
  1268 000001DB 20626F6F742066726F-
  1268 000001E4 6D2064726976652025-
  1268 000001ED 633A2000           
  1269                                  msg_boot_err:
  1270 000001F1 4469736B2072656164-     	db	"Disk read failed  AX=%04x", NL, 0
  1270 000001FA 206661696C65642020-
  1270 00000203 41583D253034780A00 
  1271                                  msg_no_boot:
  1272 0000020C 426F6F74207369676E-     	db	"Boot signature not found", NL, 0
  1272 00000215 6174757265206E6F74-
  1272 0000021E 20666F756E640A00   
  1273                                  msg_no_loader:
  1274 00000226 4D617374657220626F-     	db	"Master boot loader not found", NL, 0
  1274 0000022F 6F74206C6F61646572-
  1274 00000238 206E6F7420666F756E-
  1274 00000241 640A00             
  1275                                  msg_boot_ok:
  1276 00000244 4F4B0A00                	db	"OK", NL, 0
  1277                                  msg_cpm_disk:
  1278 00000248 6E6F207369676E6174-             db      "no signature check ", 0
  1278 00000251 75726520636865636B-
  1278 0000025A 2000               
  1279                                  msg_alt_disk:
  1280 0000025C 4D494E495820626F6F-     	db	"MINIX boot signature ",0
  1280 00000265 74207369676E617475-
  1280 0000026E 72652000           
  1281                                  
  1282                                  
  1283                                  
  1284                                  %if TBASIC
  1285                                  %else
  1286                                  msg_no_basic:
  1287                                  	db	"No ROM Basic. Please implement one :-)", NL
  1288                                  	db	"Press any key to try again...", NL, 0
  1289                                  %endif
  1290                                  
  1291                                  
  1292                                  %if SOFT_DEBUG
  1293                                  	global	cout,bout,wout,boutsp,crlf
  1294                                  ; NewLine
  1295                                  crlf:
  1296                                  	mov	al,0Dh
  1297                                  	call	cout
  1298                                  	mov	al,0Ah
  1299                                  	call	cout
  1300                                  	ret
  1301                                  
  1302                                  
  1303                                  ; output byte from AL, then a space
  1304                                  boutsp:
  1305                                  	call	bout
  1306                                  	mov	al,20h
  1307                                  	call	cout
  1308                                  	ret
  1309                                  ; word output from AX
  1310                                  wout:
  1311                                  	xchg	al,ah
  1312                                  	call	bout
  1313                                  	xchg	al,ah
  1314                                  ; byte output from AL
  1315                                  bout:
  1316                                  	rol	al,4
  1317                                  	call	nout
  1318                                  	rol	al,4
  1319                                  ; nibble output from low nibble in AL
  1320                                  nout:
  1321                                  	push	ax
  1322                                  	and	al,0Fh		; mask nibble
  1323                                  	daa			; convert to decimal
  1324                                  	add	al,0F0h		; overflow to Carry
  1325                                  	adc	al,040h		; convert to ASCII decimal or hex digit
  1326                                  	call	cout
  1327                                  	pop	ax
  1328                                  	ret
  1329                                  
  1330                                  ; character output from AL
  1331                                  cout:
  1332                                  %if 0
  1333                                  	pushm	ax,bx
  1334                                  	mov	ah,0Eh		; write character in AL
  1335                                  	mov	bx,0007h
  1336                                  	int	10h
  1337                                  	popm	ax,bx
  1338                                  %else
  1339                                  THRE	EQU	1<<5		; Transmit holding register empty
  1340                                  	pushm	ax,dx
  1341                                  .1:	mov	dx,uart_lsr
  1342                                  	in	al,dx
  1343                                  	test	al,THRE
  1344                                  	jz	.1
  1345                                  	mov	dx,uart_thr
  1346                                  	popm	ax
  1347                                  	out	dx,al
  1348                                  	popm	dx
  1349                                  %endif
  1350                                  	ret
  1351                                  %endif
