     1                                  %ifndef SOFT_DEBUG
     2                                  ;;%define SOFT_DEBUG 1
     3                                  %endif
     4                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     5                                  ; RBIOS.ASM -- Relocatable BIOS for the RetroBrew SBC-188 v.0.4 to 3.1
     6                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     7                                  ;
     8                                  ;   This version is for assembly by  NASM 0.98.39 or later
     9                                  ;
    10                                  ; Copyright (C) 2011-2017 John R. Coffman.  All rights reserved.
    11                                  ; Provided for hobbyist use on the RetroBrew SBC-188 board.
    12                                  ;
    13                                  ; This program is free software: you can redistribute it and/or modify
    14                                  ; it under the terms of the GNU General Public License as published by
    15                                  ; the Free Software Foundation, either version 3 of the License, or
    16                                  ; (at your option) any later version.
    17                                  ;
    18                                  ; This program is distributed in the hope that it will be useful,
    19                                  ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    20                                  ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    21                                  ; GNU General Public License for more details.
    22                                  ;
    23                                  ; You should have received a copy of the GNU General Public License
    24                                  ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    25                                  ;
    26                                  ;
    27                                  ; SBC-188 board revisions:
    28                                  ;       1.0     production board
    29                                  ;	2.0	production board with errata
    30                                  ;------------------------------------------------------------------------
    31                                  ;	3.0	2 x 512k SRAM chips, GALs for glue logic
    32                                  ;	3.1	4-layer board (proposed)
    33                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    34                                  
    35                                  	cpu	186
    36                                  
    37                                  
    38                                  
    39                                  
    40                                  %include	"config.asm"
    41                              <1> ;/*
    42                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    43                              <1> ; ANSI.CFG
    44                              <1> ;   Copied to CONFIG.ASM for general release.
    45                              <1> ;
    46                              <1> ;       Modify the parameters below to reflect your system
    47                              <1> ;
    48                              <1> ;
    49                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    50                              <1> ;
    51                              <1> ;   Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    52                              <1> ;   Provided for hobbyist use on the N8VEM SBC-188 board.
    53                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    54                              <1> ;
    55                              <1> ; Define the serial terminal that the Video BIOS must emulate
    56                              <1> ; Set one of the following to 1
    57                              <1> ; If you have no idea what to choose, set TTY to 1
    58                              <1> TTY     equ     0       ; hardcopy -- cannot position the cursor
    59                              <1> DUMB    equ     0       ; dumb CRT -- ^H, ^J, ^K, ^L can move the cursor
    60                              <1> ANSI    equ     1       ; very smart, like a VT-100
    61                              <1> WYSE    equ     0       ; very smart Wyse series (30, 50, ...)
    62                              <1> ; others may get added in the future
    63                              <1> ;  ONE OF THE ABOVE must BE SET TO 1!!!!!
    64                              <1> ;
    65                              <1> ; Does the hardware configuration contain the Color Video Display Unit?
    66                              <1> ; Both the 8563 and the 8242 are used.  The default is CVDU=0
    67                              <1> CVDU	equ	0	; system does not have the CVDU
    68                              <1> ;
    69                              <1> ; Does the hardware configuration contain the VGA3 a/n Video card?
    70                              <1> ; The 8563 will be disabled, but the 8242 code is shared with the CVDU
    71                              <1> ; The default is VGA3=0
    72                              <1> VGA3    equ     0       ; system does not have the VGA3
    73                              <1> %if 0
    74                              <1> 	*/
    75                              <1> #define VGA3 0
    76                              <1> /*
    77                              <1> %endif
    78                              <1> ;
    79                              <1> ; Boot up keyboard mode:  20h for NumLock on
    80                              <1> ;CVDU_KEYBOARD_STATUS	equ	0	; NumLock OFF
    81                              <1> CVDU_KEYBOARD_STATUS	equ	20h	; NumLock ON
    82                              <1> 
    83                              <1> ; Define the UART startup bit rate - 1200-19200 are most common
    84                              <1> ;UART_RATE	equ	0		; 1200
    85                              <1> ;UART_RATE	equ	1		; 2400
    86                              <1> ;UART_RATE	equ	2		; 4800
    87                              <1> UART_RATE	equ	3		; 9600
    88                              <1> ;UART_RATE	equ	4		; 19200
    89                              <1> ;UART_RATE	equ	5		; 38400
    90                              <1> ;UART_RATE	equ	6		; 57600
    91                              <1> ;UART_RATE	equ	7		; 115200
    92                              <1> 
    93                              <1> ; Does the serial terminal use the DSR/DTR protocol for flow control?
    94                              <1> ;UART_DSR_PROTOCOL	equ		1	; Yes!
    95                              <1> UART_DSR_PROTOCOL       equ             WYSE    ; Wyse always uses it
    96                              <1> 						; but not ANSI
    97                              <1> ; Define the size of the ROM image on the system in Kilobytes
    98                              <1> ; It may be smaller than the actual EPROM in use.
    99                              <1> ; The following sizes are supported:  32, 64, 128, and 256
   100                              <1> %ifndef ROM
   101                              <1> ROM             equ     32              ; 64 is the default
   102                              <1> %endif
   103                              <1> 
   104                              <1> ; Define the number of Wait States at which the ROM operates
   105                              <1> ROM_WS          equ     1               ; 0..3  (1 is the default)
   106                              <1> 
   107                              <1> ; Define the size in Kilobytes of DOS RAM (low SRAM plus EMM allocate RAM)
   108                              <1> ; This is a desired size and will only be present if a 4MEM board is added
   109                              <1> RAM_DOS         equ     640
   110                              <1> 
   111                              <1> ; Define the size of the low SRAM on the system in Kilobytes
   112                              <1> ; the default is 512 kilobytes
   113                              <1> RAM             equ     512             ; (512 is the default)
   114                              <1> 
   115                              <1> ; Define the number of Wait States at which the RAM operates
   116                              <1> RAM_WS          equ     0               ; 0..3  (0 is the default)
   117                              <1> 
   118                              <1> ; Define the number of Wait States for Local Peripheral devices (600-7FF)
   119                              <1> LCL_IO_WS       equ     1               ; 0..3  (1 is the default)
   120                              <1> 
   121                              <1> ; Define the number of Wait States for ECB BUS peripheral devices (4xx)
   122                              <1> BUS_IO_WS       equ     3               ; 0..3  (3 is the default)
   123                              <1> 
   124                              <1> ; Define the time zone in which we build the Relocatable BIOS
   125                              <1> %ifndef TIMEZONE
   126                              <1> %define TIMEZONE "PST"
   127                              <1> %endif
   128                              <1> 
   129                              <1> ; Has the REDBUG debugger been loaded?
   130                              <1> %ifndef SOFT_DEBUG
   131                              <1> %define SOFT_DEBUG 0
   132                              <1> %endif
   133                              <1> 
   134                              <1> ; Should the BIOS include "Tiny BASIC" in the image?
   135                              <1> %ifndef TBASIC
   136                              <1> TBASIC          equ     1		; default is 1
   137                              <1> %endif
   138                              <1> 
   139                              <1> ; Should the BIOS include the Floating Point Emulator?  The 80188 does
   140                              <1> ; not allow a floating point co-processor, so this is probably a good idea.
   141                              <1> %ifndef FPEM
   142                              <1> FPEM            equ     1               ; default is 1
   143                              <1> %endif
   144                              <1> 
   145                              <1> ; Define the maximum number of EMM (4MEM) boards supported
   146                              <1> EMM_BOARDS      equ     4
   147                              <1> 
   148                              <1> ; Should the Floating Point Emulator use temporary storage in the EBDA
   149                              <1> ; or at locations 0280h..3FFh in low memory?
   150                              <1> %if SOFT_DEBUG
   151                              <1> FPEM_USE_EBDA   equ     FPEM            ; default is 0
   152                              <1> %else
   153                              <1> FPEM_USE_EBDA   equ     0; FPEM            ; default is 0
   154                              <1> %endif
   155                              <1> 
   156                              <1> ; Define the size of the EPROM that is to be installed on the system
   157                              <1> ; It may be larger than the actual ROM image to be generated.
   158                              <1> %ifndef CHIP
   159                              <1> CHIP            equ     64
   160                              <1> %endif
   161                              <1> 
   162                              <1> ; Does the SBC-188 00.4 board have the LS138/LS08 piggyback fix
   163                              <1> ; Set to 1 for the SBC-188 v1.0 and later production boards
   164                              <1> ;FDC_PIGGYBACK_FIX       equ     0       ; Fix not installed
   165                              <1> FDC_PIGGYBACK_FIX       equ     1       ; fix  IS  installed
   166                              <1> 
   167                              <1> ; On SBC-188 rev 00.4 board, there is a published hardware fix (2010-09-18).
   168                              <1> ; If the wiring update is installed, or you have a later board, then
   169                              <1> ; set this to 0.  If you are using the software workaround, then set this
   170                              <1> ; to 1.  The rev 1.0 board has this fix already.
   171                              <1> NEED_TIMER_FIX  equ     0               ; have revised hardware
   172                              <1> ;NEED_TIMER_FIX  equ     1               ; use workaround
   173                              <1> 
   174                              <1> ; Define the UART oscillator speed
   175                              <1> UART_OSC        equ     1843200         ; 1.8432 Mhz is specified
   176                              <1> 
   177                              <1> 
   178                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   179                              <1> ; end of the User configuration
   180                              <1> ;       Do Not modify anything below this point
   181                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   182                              <1> 
   183                              <1> CVDU_8563	equ	CVDU		; separate inits
   184                              <1> CVDU_8242	equ	CVDU|VGA3 	; separate inits
   185                              <1> VGA3_6445       equ     VGA3            ; separate inits
   186                              <1> ; Suppress all UART output in color video Mode 3
   187                              <1> UART_MODE3_SUPPRESS	equ	CVDU_8563
   188                              <1> CVDU_USE_MSDOS_KLUDGE	equ	0; CVDU_8242	; bad, bad MSDOS
   189                              <1> CVDU_USE_KBD_HOOK		equ	CVDU_8242
   190                              <1> 
   191                              <1> ; Define existence of any uart chip
   192                              <1> UART		equ	TTY+DUMB+ANSI+WYSE
   193                              <1> startuplength   equ     512                     ; may be up to 1024
   194                              <1> startseg        equ     0FFFFh - (ROM*64) + 1
   195                              <1> highrom         equ     (ROM*400h)&0FFFFh
   196                              <1> startupseg      equ     0FFFFh - (startuplength>>4) + 1
   197                              <1> bios_data_seg   equ     040h            ; segment of BIOS data area
   198                              <1> 
   199                              <1> 
   200                              <1> %define ARG(n) [bp+2+(n)*2]
   201                              <1> 
   202                              <1> %macro  check   1.nolist
   203                              <1>  %if (%1)
   204                              <1>    %error Check Failure: %1
   205                              <1>  %endif
   206                              <1> %endm
   207                              <1> %macro  range   3.nolist
   208                              <1>  %if (%1)<(%2)
   209                              <1>    %error Out of Range: %1
   210                              <1>  %elif (%1)>(%3)
   211                              <1>    %error Out of Range: %1
   212                              <1>  %endif
   213                              <1> %endm
   214                              <1> _terminal equ UART+CVDU
   215                              <1>  check   RAM_DOS&15
   216                              <1>  check   RAM&(RAM-1)
   217                              <1>  check   ROM&(ROM-1)
   218                              <1>  range   RAM,32,512
   219                              <1>  range   ROM,32,256
   220                              <1>  range   RAM_WS,0,3
   221                              <1>  range   ROM_WS,0,3
   222                              <1>  range   RAM_DOS,RAM,(1024-ROM)
   223                              <1>  range   LCL_IO_WS,0,3
   224                              <1>  range   BUS_IO_WS,0,3
   225                              <1>  range   UART_OSC,500000,16000000
   226                              <1>  range   UART_RATE,0,7
   227                              <1>  range	 UART,0,1
   228                              <1>  range	 _terminal,1,2
   229                              <1> 
   230                              <1> %ifndef SOFT_DEBUG
   231                              <1> %define SOFT_DEBUG 0
   232                              <1> %endif
   233                              <1> 
   234                              <1> %ifndef TRACE
   235                              <1> %define TRACE 0
   236                              <1> %endif
   237                              <1> 
   238                              <1> %ifdef MAKE_OBJECT_FILE
   239                              <1>         segment _DATA WORD PUBLIC CLASS=DATA
   240                              <1>         export _ROMsize
   241                              <1>         export _CHIPsize
   242                              <1> _ROMsize        dw      ROM
   243                              <1> _CHIPsize       dw      CHIP
   244                              <1> %endif
   245                              <1> ; end of the Hardware configuration file
   246                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   247                              <1> ;*/
    41                                  %include	"cpuregs.asm"
    42                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    43                              <1> ; CPUREGS.ASM
    44                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    45                              <1> ;
    46                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    47                              <1> ;
    48                              <1> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    49                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    50                              <1> ;
    51                              <1> ; This program is free software: you can redistribute it and/or modify
    52                              <1> ; it under the terms of the GNU General Public License as published by
    53                              <1> ; the Free Software Foundation, either version 3 of the License, or
    54                              <1> ; (at your option) any later version.
    55                              <1> ;
    56                              <1> ; This program is distributed in the hope that it will be useful,
    57                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    58                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    59                              <1> ; GNU General Public License for more details.
    60                              <1> ;
    61                              <1> ; You should have received a copy of the GNU General Public License
    62                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    63                              <1> ;
    64                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    65                              <1> %include	"macros.inc"
    66                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    67                              <2> ; MACROS.INC  
    68                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    69                              <2> ;
    70                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    71                              <2> ;
    72                              <2> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    73                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    74                              <2> ;
    75                              <2> ; This program is free software: you can redistribute it and/or modify
    76                              <2> ; it under the terms of the GNU General Public License as published by
    77                              <2> ; the Free Software Foundation, either version 3 of the License, or
    78                              <2> ; (at your option) any later version.
    79                              <2> ;
    80                              <2> ; This program is distributed in the hope that it will be useful,
    81                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    82                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    83                              <2> ; GNU General Public License for more details.
    84                              <2> ;
    85                              <2> ; You should have received a copy of the GNU General Public License
    86                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    87                              <2> ;
    88                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    89                              <2> 
    90                              <2> ; general macros for the SBC188 BIOS ASSEMBLY
    91                              <2> ;
    92                              <2> ;
    93                              <2> %ifndef __MACROS_DEFINED_
    94                              <2> %define __MACROS_DEFINED_ 1
    95                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    96                              <2> ;
    97                              <2> ; some useful macros:
    98                              <2> ;
    99                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   100                              <2> ;
   101                              <2> 	cpu	186
   102                              <2> 
   103                              <2> %imacro setloc  1.nolist
   104                              <2>  times   (%1-($-$$)) db 0FFh
   105                              <2> %endm
   106                              <2> 
   107                              <2> %imacro db_lo   1
   108                              <2>  db (%1)&255
   109                              <2> %endm
   110                              <2> 
   111                              <2> %imacro cnop    0.nolist
   112                              <2> %if SOFT_DEBUG
   113                              <2>         nop
   114                              <2> %endif
   115                              <2> %endm
   116                              <2> 
   117                              <2> %imacro popm 1-*.nolist
   118                              <2> %rep %0
   119                              <2> %ifidni %1,ALL
   120                              <2>  popa
   121                              <2> %elifidni %1,F
   122                              <2>  popf
   123                              <2> %else
   124                              <2>  pop %1
   125                              <2> %ifidni %1,DS
   126                              <2>  cnop
   127                              <2> %elifidni %1,ES
   128                              <2>  cnop
   129                              <2> %endif
   130                              <2> %endif
   131                              <2> %rotate 1
   132                              <2> %endrep
   133                              <2> %endm
   134                              <2> 
   135                              <2> %imacro pushm 1-*.nolist
   136                              <2> %rep %0
   137                              <2> %rotate -1
   138                              <2> %ifidni %1,ALL
   139                              <2>  pusha
   140                              <2> %elifidni %1,F
   141                              <2>  pushf
   142                              <2> %else
   143                              <2>  push %1
   144                              <2> %endif
   145                              <2> %endrep
   146                              <2> %endm
   147                              <2> 
   148                              <2> ;
   149                              <2> ; added from the 386EX project
   150                              <2> ;
   151                              <2> 
   152                              <2> ; call arguments
   153                              <2> %define ARG(n) [bp+2+(n)*2]
   154                              <2> 
   155                              <2> ;
   156                              <2> ; format of the BYTE initialization table:  address, byte
   157                              <2> ;
   158                              <2> %imacro  binit 2
   159                              <2>         dw      %1
   160                              <2>         db      %2
   161                              <2> %endmacro
   162                              <2> ; end with DW -1
   163                              <2> 
   164                              <2> ;
   165                              <2> ; format of the WORD initialization table:  address, word
   166                              <2> ;
   167                              <2> %imacro  winit 2
   168                              <2>         dw      %1
   169                              <2>         dw      %2
   170                              <2> %endmacro
   171                              <2> ; end with DW -1
   172                              <2> 
   173                              <2> 
   174                              <2> ; get the BIOS Data Area segment pointer to a [segment] register
   175                              <2> %imacro get_bda	1.nolist
   176                              <2> 	push	0x0040
   177                              <2> 	pop	%1
   178                              <2> 	cnop
   179                              <2> %endm
   180                              <2> 
   181                              <2> 
   182                              <2> %endif
    66                              <1> 
    67                              <1> 	cpu     186
    68                              <1> ;
    69                              <1> ;
    70                              <1> ; IBM model byte -- must be less than a 286
    71                              <1> ;
    72                              <1> ;MODEL_BYTE		equ	0FEh	; PC-XT
    73                              <1> ;SUBMODEL_BYTE		equ	0FFh	; not used
    74                              <1> 
    75                              <1> MODEL_BYTE		equ	0FEh	; PC-XT
    76                              <1> SUBMODEL_BYTE		equ	00h	;  "
    77                              <1> 
    78                              <1> 
    79                              <1> ; 80188 peripheral control register block address
    80                              <1> CPU_CSCR	        equ	0FF00h
    81                              <1> 
    82                              <1> ; Compatible Mode registers
    83                              <1> 
    84                              <1> cpu_relocation          equ     CPU_CSCR+0FEh
    85                              <1> 
    86                              <1> ; The memory and peripheral chip select register offsets from 0FF00h
    87                              <1> 
    88                              <1> cpu_umcs                equ     CPU_CSCR+0A0h          ; Upper memory select
    89                              <1> cpu_lmcs                equ     CPU_CSCR+0A2h          ; Lower memory select
    90                              <1> cpu_pacs                equ     CPU_CSCR+0A4h          ; Peripheral select
    91                              <1> cpu_mmcs                equ     CPU_CSCR+0A6h          ; Middle memory base
    92                              <1> cpu_mpcs                equ     CPU_CSCR+0A8h          ; Mid mem. & peripherals
    93                              <1> 
    94                              <1> ; Enhanced Mode registers
    95                              <1> 
    96                              <1> cpu_mdram               equ     CPU_CSCR+0E0h          ; memory partition reg.
    97                              <1> cpu_cdram               equ     CPU_CSCR+0E2h          ; clock prescaler
    98                              <1> cpu_edram               equ     CPU_CSCR+0E4h          ; Enable refresh reg.
    99                              <1> cpu_pdcon               equ     CPU_CSCR+0F0h          ; Power-Save control
   100                              <1> 
   101                              <1> 
   102                              <1> ; On-board internal peripheral equates
   103                              <1> ; Programmable Interrupt Controller
   104                              <1> PIC	        equ	CPU_CSCR+020H
   105                              <1> PIC_EOI	        equ	PIC+2           ; End Of Interrupt
   106                              <1> PIC_POLLR	equ	PIC+4
   107                              <1> PIC_POLLSR	equ	PIC+6
   108                              <1> PIC_IMASK	equ	PIC+8
   109                              <1> PIC_PMREG	equ	PIC+0AH
   110                              <1> PIC_SRVR	equ	PIC+0CH
   111                              <1> PIC_IRQR	equ	PIC+0EH
   112                              <1> PIC_IRQSR	equ	PIC+10H
   113                              <1> PIC_TCR	        equ	PIC+12H
   114                              <1> PIC_DMA0CR	equ	PIC+14H
   115                              <1> PIC_DMA1CR	equ	PIC+16H
   116                              <1> PIC_I0CON	equ	PIC+18H
   117                              <1> PIC_I1CON	equ	PIC+1AH
   118                              <1> PIC_I2CON	equ	PIC+1CH
   119                              <1> PIC_I3CON	equ	PIC+1EH
   120                              <1> 
   121                              <1> EOI_NSPEC       equ     8000h           ; Non-Specific EOI
   122                              <1> 
   123                              <1> ; Interrupt masks (Master Mode)
   124                              <1> ;
   125                              <1> mask_timer_all          equ     0001h
   126                              <1> mask_dma0               equ     0004h
   127                              <1> mask_dma1               equ     0008h
   128                              <1> mask_int0               equ     0010h
   129                              <1> mask_int1               equ     0020h
   130                              <1> mask_int2               equ     0040h
   131                              <1> mask_int3               equ     0080h
   132                              <1> 
   133                              <1> 
   134                              <1> 
   135                              <1> ; Timers
   136                              <1> TIM0	        equ	CPU_CSCR+050H
   137                              <1> TIM1	        equ	CPU_CSCR+058H
   138                              <1> TIM2	        equ	CPU_CSCR+060H
   139                              <1> 
   140                              <1> TCNT	        equ	0	; count register
   141                              <1> CMPA	        equ	2	; max count A
   142                              <1> CMPB	        equ	4	; max count B (not present on TIM2)
   143                              <1> TCON	        equ	6	; mode/control word
   144                              <1> 
   145                              <1> ; Timer control bits:
   146                              <1> tc_EN           equ     8000h   ; Enable bit
   147                              <1> tc_nINH         equ     4000h   ; not Inhibit Enable
   148                              <1> tc_INT          equ     2000h   ; Interrupt Enable
   149                              <1> tc_RIU          equ     1000h   ; Register A/B (0/1) in Use
   150                              <1> tc_MC           equ     0020h   ; Maximum Count reached
   151                              <1> tc_RTG          equ     0010h   ; Retrigger (internal source)
   152                              <1> tc_P            equ     0008h   ; Prescale internal clock (timers 0 & 1 only)
   153                              <1> tc_EXT          equ     0004h   ; External clock
   154                              <1> tc_ALT          equ     0002h   ; Alternate between A & B max count registers
   155                              <1> tc_CONT         equ     0001h   ; Continuous: continue after max count
   156                              <1> 
   157                              <1> 
   158                              <1> 
   159                              <1> 
   160                              <1> ; DMA
   161                              <1> DMA0	        equ	CPU_CSCR+0C0H
   162                              <1> DMA1	        equ	CPU_CSCR+0D0H
   163                              <1> DMASPL	        equ	0	; source pointer low
   164                              <1> DMASPU	        equ	2	; source pointer high
   165                              <1> DMADPL	        equ	4	; destination pointer low
   166                              <1> DMADPU	        equ	6	; destination pointer high
   167                              <1> DMATC	        equ	8	; terminal count
   168                              <1> DMACW	        equ	0AH	; control word
   169                              <1> 
   170                              <1> 
   171                              <1> 
   172                              <1> 
   173                              <1> 
   174                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   175                              <1> ;
   176                              <1> ;       SBC-188 external devices
   177                              <1> ;
   178                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   179                              <1> 
   180                              <1> IO_BASE			equ	0400h
   181                              <1> 
   182                              <1> 
   183                              <1> 
   184                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   185                              <1> ; The UART registers
   186                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   187                              <1> 
   188                              <1> uart_base               equ     IO_BASE+0280h
   189                              <1> uart_rbr                equ     uart_base       ;Rcvr Buffer / read only
   190                              <1> uart_thr                equ     uart_base       ;Transmit Holding / write only
   191                              <1> uart_ier                equ     uart_base+1     ;Interrupt Enable
   192                              <1> uart_iir                equ     uart_base+2     ;Interrupt Ident / read only
   193                              <1> uart_fcr                equ     uart_base+2     ;FIFO Control / write only
   194                              <1> uart_lcr                equ     uart_base+3     ;Line Control
   195                              <1> uart_mcr                equ     uart_base+4     ;Modem Control
   196                              <1> uart_lsr                equ     uart_base+5     ;Line Status
   197                              <1> uart_msr                equ     uart_base+6     ;Modem Status
   198                              <1> uart_sr			equ	uart_base+7	;Scratch
   199                              <1> 
   200                              <1> uart_dll                equ     uart_base       ;Divisor Latch LS Byte
   201                              <1> uart_dlm                equ     uart_base+1     ;Divisor Latch MS Byte
   202                              <1> 
   203                              <1> 
   204                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   205                              <1> ; Floppy controller
   206                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   207                              <1> FDC	        equ	IO_BASE+0200H
   208                              <1> FDC_MSR         equ     FDC
   209                              <1> FDC_DATA        equ     FDC_MSR+1
   210                              <1> FDC_DACK        equ	FDC+10H
   211                              <1> FDC_LDOR	equ	FDC+20H
   212                              <1> FDC_LDCR	equ	FDC+30H
   213                              <1> FDC_TC	        equ	FDC+40H
   214                              <1> FDC_DACK_TC     equ     FDC_DACK | FDC_TC
   215                              <1> 
   216                              <1> 
   217                              <1> %if SBC188==1
   218                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   219                              <1> ;DS1302 RTC
   220                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   221                              <1> RTC	equ	IO_BASE+0300H
   222                              <1> %endif
   223                              <1> 
   224                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   225                              <1> ; PIO 82C55 I/O 
   226                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   227                              <1> ; for the SBCv1/v2 with PPIDE adapter board
   228                              <1> ; and for the SBCv3 with PPIDE connector
   229                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   230                              <1> PPI	        equ	IO_BASE+0260H
   231                              <1> 
   232                              <1> PIO_A	        equ	PPI+0	; (OUTPUT)
   233                              <1> PIO_B	        equ	PPI+1	; (INPUT)
   234                              <1> PIO_C	        equ	PPI+2	; (CENTRONICS control low nibble)  
   235                              <1> PIO_CTRL	equ	PPI+3	; CONTROL BYTE PIO 82C55
   236                              <1> 
   237                              <1> portA           equ     PPI+0   ;
   238                              <1> portB           equ     PPI+1   ;
   239                              <1> portC           equ     PPI+2   ;
   240                              <1> 
   241                              <1> 
   242                              <1> 
   243                              <1> ;;;%if SBC188==3   startup.asm is universal
   244                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   245                              <1> ; CONTROL LS259 PORT ON SBC188 V3
   246                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   247                              <1> CTRL259		equ	IO_BASE+0270H
   248                              <1> ; LEDS are at addresses 0..3
   249                              <1> ; other control ports on 4..7
   250                              <1> LED0		equ	CTRL259+0
   251                              <1> LED1		equ	LED0+1
   252                              <1> LED2		equ	LED0+2
   253                              <1> LED3		equ	LED0+3
   254                              <1> T1OSC18		equ	CTRL259+4	; ON=1.8432mhz, OFF="1" (for use of TIMER2)
   255                              <1> ;unused		equ	CTRL259+5
   256                              <1> FDC_RES		equ	CTRL259+6	; RESET IS ACTIVE HIGH
   257                              <1> IDE8_RES	equ	CTRL259+7	; fast IDE RESET IS ACTIVE LOW
   258                              <1> 
   259                              <1> 
   260                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   261                              <1> ; FIDE8 8-bit IDE on the 80C188 bus
   262                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   263                              <1> FIDE_BASE       equ     IO_BASE+2C0h
   264                              <1> 
   265                              <1> IDE8_CS0        equ     FIDE_BASE
   266                              <1> IDE8_CS1        equ     FIDE_BASE+0x10
   267                              <1> 
   268                              <1> ;;;%endif   startup.asm is universal
   269                              <1> 
   270                              <1> 
   271                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   272                              <1> ; Dual [DMA] IDE devices
   273                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   274                              <1> DIDE		equ	IO_BASE + 20H	; range 0x20..0x3F
   275                              <1> 
   276                              <1> DIDE0		equ	DIDE		; first interface (master & slave)
   277                              <1> DIDE1		equ	DIDE+10h	; second interface (master & slave)
   278                              <1> 
   279                              <1> 
   280                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   281                              <1> ; DISK I/O v3 device codes (PPIDE only)
   282                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   283                              <1> DISKIO		equ	IO_BASE + 20h	; range 0x20..0x3F
   284                              <1> 
   285                              <1> DISKIO_PPIDE	equ	DISKIO		; 82c55
   286                              <1> DISKIO_FDC	equ	DISKIO + 10h	; FDC 9266
   287                              <1> DISKIO_DOR	equ	DISKIO + 18h	; OPERATION REGISTER	
   288                              <1> 
   289                              <1> 
   290                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   291                              <1> ; MF/PIC interfaces
   292                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   293                              <1> MFPIC		equ	IO_BASE + 40h	; range 0x40..0x4F
   294                              <1> 
   295                              <1> ;MFPIC_202	equ	MFPIC		; NS32202 is not usable on SBC-188
   296                              <1> MFPIC_PPIDE	equ	MFPIC + 4	; PPIDE disk interface
   297                              <1> MFPIC_UART	equ	MFPIC + 8	; TL16Cx50 SIO chip
   298                              <1> 
   299                              <1> 
   300                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   301                              <1> ; Cassette I/O
   302                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   303                              <1> cuart_base	EQU 	IO_BASE+80H	; BASE IO ADDRESS OF CASSETTE UART
   304                              <1> cuart_rbr	equ     cuart_base	;Rcvr Buffer / read only
   305                              <1> cuart_thr	equ     cuart_base	;Transmit Holding / write only
   306                              <1> cuart_ier	equ     cuart_base+1	;Interrupt Enable
   307                              <1> cuart_iir	equ     cuart_base+2	;Interrupt Ident / read only
   308                              <1> cuart_fcr	equ     cuart_base+2	;FIFO Control / write only
   309                              <1> cuart_lcr	equ     cuart_base+3	;Line Control
   310                              <1> cuart_mcr	equ     cuart_base+4	;Modem Control
   311                              <1> cuart_lsr	equ     cuart_base+5	;Line Status
   312                              <1> cuart_msr	equ     cuart_base+6	;Modem Status
   313                              <1> cuart_sr	equ	cuart_base+7	;Scratch
   314                              <1> 
   315                              <1> cuart_dll	equ     cuart_base	;Divisor Latch LS Byte
   316                              <1> cuart_dlm	equ	cuart_base+1	;Divisor Latch MS Byte
   317                              <1> 
   318                              <1> 
   319                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   320                              <1> ;
   321                              <1> ;       4MEM control registers
   322                              <1> ;
   323                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   324                              <1> EMM_addr        equ     1               ; high 6 bits of 20-bit address
   325                              <1> EMM_page        equ     0               ; 4MEM page in [0..254]
   326                              <1> 
   327                              <1> EMM_BASE        equ     IO_BASE + 000h          ; first EMM (4MEM) board
   328                              <1> EMM_unmapped    equ     255             ; unmapped 4MEM page
   329                              <1> 
   330                              <1> EMM0            equ     EMM_BASE        ; first  EMM board
   331                              <1> EMM1            equ     EMM0 + 2        ; second EMM board
   332                              <1> EMM2            equ     EMM1 + 2        ; third  EMM board
   333                              <1> EMM3            equ     EMM2 + 2        ; fourth EMM board
   334                              <1> 
   335                              <1> 
   336                              <1> 
   337                              <1> 
   338                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   339                              <1> ;
   340                              <1> ;	ColorVDU devices
   341                              <1> ;
   342                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   343                              <1> ;
   344                              <1> ;	major select on the Z80 bus
   345                              <1> ;
   346                              <1> devCVDU_8bit	equ	0xE0		; this may change to 0x10
   347                              <1> 
   348                              <1> devCVDUbase 	equ	IO_BASE + devCVDU_8bit
   349                              <1> 
   350                              <1> M8563status	equ	devCVDUbase + 4		; 4 == bitrev(2)
   351                              <1> M8563register	equ	devCVDUbase + 4
   352                              <1> M8563data	equ	devCVDUbase + 12	; 12 == bitrev(3)
   353                              <1> 
   354                              <1> %if CVDU_8563
   355                              <1> I8242status	equ	devCVDUbase + 10	; 10 == bitrev(5)
   356                              <1> I8242command	equ	devCVDUbase + 10
   357                              <1> I8242data	equ	devCVDUbase + 2		; 2 == bitrev(4)
   358                              <1> %endif
   359                              <1> 
   360                              <1> 
   361                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   362                              <1> ;
   363                              <1> ;	VGA3 devices
   364                              <1> ;
   365                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   366                              <1> ;
   367                              <1> ;	major select on the Z80 bus
   368                              <1> ;
   369                              <1> devVGA3_8bit    equ     0xE0                    ; same as CVDU
   370                              <1> 
   371                              <1> devVGA3base       equ     IO_BASE + devVGA3_8bit
   372                              <1> 
   373                              <1> %if VGA3_6445
   374                              <1> I8242status	equ	devVGA3base + 1
   375                              <1> I8242command	equ	devVGA3base + 1
   376                              <1> I8242data	equ	devVGA3base + 0
   377                              <1> %endif
   378                              <1> HD6445addr	equ	devVGA3base + 2		; to address the HD6445 registers
   379                              <1> HD6445reg	equ	devVGA3base + 3		; to r/w a register on the CRTC
   380                              <1> 
   381                              <1> vga3cfg		equ	devVGA3base + 4
   382                              <1> ; the following are probably not used on the SBC-188, except for testing/checking
   383                              <1> vga3adhi	equ	devVGA3base + 5
   384                              <1> vga3adlo	equ	devVGA3base + 6
   385                              <1> vga3data	equ	devVGA3base + 7
   386                              <1> 
   387                              <1> 
   388                              <1> 
   389                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   390                              <1> ;
   391                              <1> ;       2S1P registers
   392                              <1> ;
   393                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   394                              <1> dev_2S1P_loc		equ	0xC0	; same as 4UART !!!
   395                              <1> 
   396                              <1> dev_2S1P_base		equ	IO_BASE + dev_2S1P_loc	
   397                              <1> 
   398                              <1> dev_2S1P_A		equ	dev_2S1P_base		; serial port
   399                              <1> dev_2S1P_B		equ	dev_2S1P_base + 8h	; serial port
   400                              <1> 
   401                              <1> dev_2S1P_C		equ	dev_2S1P_base + 10h	; parallel port
   402                              <1> 
   403                              <1> 
   404                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   405                              <1> ;
   406                              <1> ;       4UART registers
   407                              <1> ;
   408                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   409                              <1> dev_4UART_loc		equ	0xC0	; same as 2S1P !!!
   410                              <1> ;				0xA0	; possible alternate
   411                              <1> dev_4UART_alt_offset	equ	0xA0 - dev_4UART_loc
   412                              <1> 
   413                              <1> dev_4UART_base		equ	IO_BASE + dev_4UART_loc	
   414                              <1> 
   415                              <1> dev_4UART_A		equ	dev_4UART_base
   416                              <1> dev_4UART_B		equ	dev_4UART_base + 8h
   417                              <1> dev_4UART_C		equ	dev_4UART_base + 10h
   418                              <1> dev_4UART_D		equ	dev_4UART_base + 18h
   419                              <1> 
   420                              <1> dev_4UART_config	equ	dev_4UART_B + 7		; overlays scratch register
   421                              <1> 
   422                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   423                              <1> ; debug port -- JRC only
   424                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   425                              <1> portD		equ	IO_BASE + 0FFh		; 0x04FF
   426                              <1> ;portD		equ	portB		     ; older 8255 output on PPI
   427                              <1> 
   428                              <1> ; end CPUREGS.ASM
   429                              <1> 
    42                                  %include	"date.asm"
    43                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    44                              <1> ; date.asm
    45                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    46                              <1> ; string 0 is for "startup.asm" inclusion; must be 8 chars exactly
    47                              <1> ; string 1 is for RBIOS.ASM inclusion; should be very readable
    48                              <1> ;
    49                              <1> ; N.B.  version 46 is Rich Cini's version for the 2S1P board
    50                              <1> ;
    51                              <1> ; so we jump from BIOS 045 to 047, the first BIOS to support
    52                              <1> ; the Version 3.0 board (with 1024K memory on-board)
    53                              <1> ;
    54                              <1> ; Definitions for version 3.5-2:
    55                              <1> ;
    56                              <1> 
    57                              <1> 
    58                              <1> %define DATE_STRING0	"04/29/21"
    59                              <1> %define DATE_STRING1	"29-Apr-2021"
    60                              <1> 
    61                              <1> %define VERSION_MAJOR		3
    62                              <1> %define VERSION_MINOR		5
    63                              <1> %define VERSION_REVISION	1
    64                              <1> %define VERSION_SUFFIX		""
    65                              <1> %define VERSION_SEQUENCE	55
    66                              <1> 
    67                              <1> %define VERSION_STRING		"3.5-1",VERSION_SUFFIX
    68                              <1> 
    69                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    70                              <1> ; Revision information:
    71                              <1> ;  ver.	2.1 -- table-driven support for all IBM floppy types
    72                              <1> ;	2.2 -- Dual IDE driver; CVDU memory sizing
    73                              <1> ;	2.3 -- font_vga corrects (i grave) (n_tilde)
    74                              <1> ;	    &  Dual SDcard & Minix boot
    75                              <1> ;	2.4 -- Int 15h multiprogramming hooks: fn90, fn91 (never done)
    76                              <1> ;	3.0 -- VGA3 support
    77                              <1> ;	3.1 -- SBC-188 v.3 board support
    78                              <1> ;	3.2 -- IDE8 support on the v.3 board
    79                              <1> ;	3.3 -- add 2S1P board support (2 SIO & PPort)
    80                              <1> ;	3.4 -- floppy drives did not work
    81                              <1> ;	3.5 -- back to 3.3, sequence #51
    82                              <1> ;		change NVRAM battery backup setup to #53
    83                              <1> ;		re-install 3.4 boot fix for FreeDOS
    84                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    43                                  %include	"equates.asm"
    44                              <1> ;========================================================================
    45                              <1> ; EQUATES.ASM -- Lots of Defintions for Relocatable BIOS
    46                              <1> ;========================================================================
    47                              <1> ;   for the N8VEM SBC-188 v.00.4 and 00.5
    48                              <1> ;
    49                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    50                              <1> ;
    51                              <1> ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
    52                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    53                              <1> ;
    54                              <1> ; This program is free software: you can redistribute it and/or modify
    55                              <1> ; it under the terms of the GNU General Public License as published by
    56                              <1> ; the Free Software Foundation, either version 3 of the License, or
    57                              <1> ; (at your option) any later version.
    58                              <1> ;
    59                              <1> ; This program is distributed in the hope that it will be useful,
    60                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    61                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    62                              <1> ; GNU General Public License for more details.
    63                              <1> ;
    64                              <1> ; You should have received a copy of the GNU General Public License
    65                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    66                              <1> ;
    67                              <1> ;========================================================================
    68                              <1> 
    69                              <1>         global  FPEM_segment
    70                              <1> 
    71                              <1> 
    72                              <1> %include "segdef.asm"
    73                              <2> ;========================================================================
    74                              <2> ; SEGDEF.ASM -- Lots of Defintions for Relocatable BIOS
    75                              <2> ;========================================================================
    76                              <2> ;   for the N8VEM SBC-188 v.00.4 and 00.5
    77                              <2> ;
    78                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    79                              <2> ;
    80                              <2> ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
    81                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    82                              <2> ;
    83                              <2> ; This program is free software: you can redistribute it and/or modify
    84                              <2> ; it under the terms of the GNU General Public License as published by
    85                              <2> ; the Free Software Foundation, either version 3 of the License, or
    86                              <2> ; (at your option) any later version.
    87                              <2> ;
    88                              <2> ; This program is distributed in the hope that it will be useful,
    89                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    90                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    91                              <2> ; GNU General Public License for more details.
    92                              <2> ;
    93                              <2> ; You should have received a copy of the GNU General Public License
    94                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    95                              <2> ;
    96                              <2> ;========================================================================
    97                              <2> 
    98                              <2> %ifndef __SEGDEF_
    99                              <2> %define __SEGDEF_
   100                              <2> 
   101                              <2> 	SEGMENT  _TEXT ALIGN=2 PUBLIC CLASS=CODE
   102                              <2>         SEGMENT  CONST ALIGN=2 PUBLIC CLASS=DATA
   103                              <2>         SEGMENT  CONST2 ALIGN=2 PUBLIC CLASS=DATA
   104                              <2> 	SEGMENT  _DATA ALIGN=16 PUBLIC CLASS=DATA
   105                              <2> 	SEGMENT  _BSS  ALIGN=2 PUBLIC CLASS=BSS
   106                              <2> ;;;        SEGMENT  _BASIC ALIGN=16 PUBLIC CLASS=BASIC
   107                              <2> 
   108                              <2> 	GROUP	DGROUP CONST CONST2 _DATA _BSS
   109                              <2> 
   110                              <2> %endif
   111                              <2> 
    73                              <1> %include "ascii.asm"
    74                              <2> ; ascii.asm
    75                              <2> ;
    76                              <2> CTRL            equ     1Fh     ; masks a character to CTRL-x
    77                              <2> 
    78                              <2> NUL     equ     00h
    79                              <2> BEL     equ     (CTRL & 'G')
    80                              <2> BS      equ     08h		; ^H
    81                              <2> HT      equ     09h		; ^I
    82                              <2> LF	equ	0Ah		; ^J
    83                              <2> NL      equ     LF
    84                              <2> VT	equ	0Bh		; ^K
    85                              <2> FWD	equ	0Ch		; ^L
    86                              <2> CR	equ	0Dh
    87                              <2> XON     equ     (CTRL & 'Q')
    88                              <2> XOFF    equ     (CTRL & 'S')
    89                              <2> DC1     equ     XON
    90                              <2> DC3     equ     XOFF
    91                              <2> ESC     equ	1Bh
    92                              <2> 
    93                              <2> 
    74                              <1> 
    75                              <1> 
    76                              <1> ; POST error codes. Presently one byte but can expand to word.
    77                              <1> ER_BIOS equ	01h		; Bad ROM bios checksum, patch last byte
    78                              <1> ER_RAM	equ	02h		; Bad RAM in main memory, replace
    79                              <1> ER_CRT	equ	04h		; Bad RAM in video card, replace
    80                              <1> ER_FDC	equ	08h		; Bad FDC
    81                              <1> ER_UNK1	equ	10h		; {unassigned}
    82                              <1> ER_MEM	equ	20h		; Bad RAM in vector area, replace
    83                              <1> ER_ROM	equ	40h		; Bad ROM in expansion area, bad checksum
    84                              <1> ER_UNK2	equ	80h		; {unassigned}
    85                              <1> 
    86                              <1> 
    87                              <1> 
    88                              <1> ;; ************************ BIOS Data Segment ******************************
    89                              <1> ;; BIOS data segment - not all will  be used
    90                              <1> ;                struc   BIOS_DATA_AREA  ; at 0040:0000
    91                              <1> %include "bda.inc"
    92                              <2> ;/*======================================================================
    93                              <2> ; bda.inc -- BIOS data area definitions
    94                              <2> ;========================================================================
    95                              <2> ;   for the N8VEM SBC-188
    96                              <2> ;
    97                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    98                              <2> ;
    99                              <2> ; Copyright (C) 2013 John R. Coffman.  All rights reserved.
   100                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
   101                              <2> ;
   102                              <2> ; This program is free software: you can redistribute it and/or modify
   103                              <2> ; it under the terms of the GNU General Public License as published by
   104                              <2> ; the Free Software Foundation, either version 3 of the License, or
   105                              <2> ; (at your option) any later version.
   106                              <2> ;
   107                              <2> ; This program is distributed in the hope that it will be useful,
   108                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   109                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   110                              <2> ; GNU General Public License for more details.
   111                              <2> ;
   112                              <2> ; You should have received a copy of the GNU General Public License
   113                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   114                              <2> ;
   115                              <2> ;========================================================================
   116                              <2> 
   117                              <2> 			;*/ extern				/*
   118                              <2> 	ABSOLUTE  0	;*/ struct BDA {			/*
   119 00000000 ????????????????    <2> serial_ports    resw    4	;*/	word	serial_ports[4];	/*
   120 00000008 ????????????????    <2> parallel_ports  resw    4	;*/	word	parallel_ports[4];	/*
   121 00000010 ????                <2> equipment_flag  resw    1	;*/	EQFL	equipment_flag;		/*
   122                              <2> ;	dw	?		; 40:10 	; Equipment present word
   123                              <2> ;  						;  = (1 iff floppies) *     1.
   124                              <2> ;                                               ;  + (1 iff 187     ) *     2.
   125                              <2> ;  						;  + (#+1 64K sys ram) *    4.
   126                              <2> ;  						;  + (init crt mode ) *    16.
   127                              <2> ;  						;  + (# of floppies ) *    64.
   128                              <2> ;  						;  + (# serial ports) *   512.
   129                              <2> ;  						;  + (1 iff toy port) *  4096.
   130                              <2> ;                                               ;  + (1 iff modem   ) *  8192.
   131                              <2> ;  						;  + (# parallel LPT) * 16384.
   132 00000012 ??                  <2> mfg_test_flags  resb    1	;*/	byte	mfg_test_flags;	/* 40:12 unused by us
   133 00000013 ????                <2> memory_size     resw    1	;*/	word	memory_size;	/* 40:13 kilobytes
   134                              <2> uart_kbd_ctrl_R	equ	$	;*/				/*** JRC: count of ctrl-R's for reboot
   135 00000015 ??                  <2> IPL_errors      resb    1	;*/	byte	IPL_errors;	/* 40:15 IPL errors<-table/scratchpad
   136 00000016 ??                  <2> sbc188_rev       resb    1	;*/	byte	sbc188_rev;	/* was 'unused_01' before BIOS047
   137                              <2> ;;---------------[Keyboard data area]------------;
   138 00000017 ????                <2> keyboard_flags_0 resw   1	;*/	word	keyboard_flags_0;  /* 40:17 Shift/Alt/etc. keyboard flags
   139                              <2> keyboard_flags_1 equ	$-1	;     2nd byte	keyboard_flags_1;  
   140 00000019 ??                  <2> keypad_char	resb	1	;*/	byte	keypad_char;	/* 40:19 Alt-KEYPAD char. goes here
   141 0000001A ????                <2> kbd_buffer_head resw    1	;*/	word	kbd_buffer_head;   /* 40:1A --> keyboard buffer head
   142 0000001C ????                <2> kbd_buffer_tail resw    1	;*/	word	kbd_buffer_tail;   /* 40:1C --> keyboard buffer tail
   143 0000001E <res 20h>           <2> kbd_buffer      resw    16	;*/	word	kbd_buffer[16];	/* 40:1E Keyboard Buffer (Scan,Value)
   144                              <2> kbd_buffer_last	equ	$	;*/				/*
   145                              <2> ;;---------------[Diskette data area]------------;
   146 0000003E ??                  <2> fdc_drv_calib   resb    1	;*/	byte	fdc_drive_calib;   /* 40:3E
   147 0000003F ??                  <2> fdc_motor_LDOR  resb    1	;*/	byte	fdc_motor_LDOR;	   /* 40:3F Motor, DMA, select control
   148 00000040 ??                  <2> fdc_motor_ticks resb    1	;*/	byte	fdc_motor_ticks;   /* 40:40 ticks til motor off
   149 00000041 ??                  <2> fdc_status      resb    1	;*/	byte	fdc_status;	   /* 40:41
   150                              <2> ;				Floppy return code stat byte
   151                              <2> ;				;  1 = bad ic 765 command req.
   152                              <2> ;				;  2 = address mark not found
   153                              <2> ;				;  3 = write to protected disk
   154                              <2> ;				;  4 = sector not found
   155                              <2> ;				;  8 = data late (DMA overrun)
   156                              <2> ;				;  9 = DMA failed 64K page end
   157                              <2> ;				; 16 = bad CRC on floppy read
   158                              <2> ;				; 32 = bad NEC 765 controller
   159                              <2> ;				; 64 = seek operation failed
   160                              <2> ;				;128 = disk drive timed out
   161 00000042 ??????????????      <2> fdc_ctrl_status resb    7	;*/	byte	fdc_ctrl_status[7];  /* 40:42 Status bytes from NEC 765
   162                              <2> ;;---------------[Video display area]------------;
   163 00000049 ??                  <2> video_mode      resb    1	;*/	byte	video_mode;	/* 40:49
   164                              <2> ;			 	; Current CRT mode  (software)
   165                              <2> ;				;  0 = 40 x 25 text (no color)
   166                              <2> ;				;  1 = 40 x 25 text (16 color)
   167                              <2> ;				;  2 = 80 x 25 text (no color)
   168                              <2> ;				;  3 = 80 x 25 text (16 color)
   169                              <2> ;				;  4 = 320 x 200 grafix 4 color
   170                              <2> ;				;  5 = 320 x 200 grafix 0 color
   171                              <2> ;				;  6 = 640 x 200 grafix 0 color
   172                              <2> ;				;  7 = 80 x 25 text (mono card)
   173 0000004A ????                <2> video_columns   resw    1	;*/	word video_columns;	/* 40:4A Columns on CRT screen
   174 0000004C ????                <2> video_regen_bytes  resw 1	;*/	word video_regen_bytes;	/* 40:4C Bytes in the regen region
   175 0000004E ????                <2> video_regen_offset resw 1	;*/	word video_regen_offset;/* 40:4E Byte offset in regen region
   176 00000050 <res 10h>           <2> video_cursor_pos  resw  8	;*/	word video_cursor_pos[8];  /* 40:50 Cursor pos for up to 8 pages
   177 00000060 ????                <2> video_cursor_mode resw  1	;*/	word video_cursor_mode;	/* 40:60 Current cursor mode setting
   178 00000062 ??                  <2> video_page      resb    1	;*/	byte video_page;	/* 40:62 Current page on display
   179 00000063 ????                <2> video_base_seg  resw    1	;*/	word video_base_seg;	/* 40:63 Base address (B000h or B800h)
   180 00000065 ??                  <2> video_hw_mode   resb    1	;*/	byte video_hw_mode;	/* 40:65 ic 6845 mode reg. (hardware)
   181 00000066 ??                  <2> video_cga_palette resb  1	;*/	byte video_cga_palette;	/* 40:66 Current CGA palette
   182                              <2> ;;---------------[Used to setup ROM]-------------;
   183 00000067 ????????            <2> eprom_address   resd    1	;*/	dword eprom_address;	/* 40:67 Eprom base Offset,Segment
   184 0000006B ??                  <2> spurious_irq    resb    1	;*/	byte spurious_irq;	/* 40:6B Last spurious interrupt IRQ
   185                              <2> ;;---------------[Timer data area]---------------;
   186 0000006C ????????            <2> timer_ticks     resd    1	;*/	dword timer_ticks;	/* 40:6C Ticks since midnight (lo,hi)
   187 00000070 ??                  <2> timer_new_day   resb    1	;*/	byte timer_new_day;	/* 40:70 Non-zero if new day
   188                              <2> ;;---------------[System data area]--------------;
   189 00000071 ??                  <2> break_flag      resb    1	;*/	byte break_flag;	/* 40:71 Sign bit set iff break
   190 00000072 ????                <2> warm_boot       resw    1	;*/	word warm_boot;		/* 40:72 Warm boot iff==1234h
   191                              <2> ;;---------------[Hard disk scratchpad]----------;
   192 00000074 ????????            <2> hdd_scratch     resd    1	;*/	word hdd_scratch[2];	/* 40:74
   193                              <2> ;;---------------[Timout areas/PRT/LPT]----------;
   194 00000078 ????????            <2> lpt_timeout     resb    4	;*/	byte lpt_timeout[4];	/* 40:78 Ticks for LPT 1-4 timeouts
   195 0000007C ????????            <2> com_timeout     resb    4	;*/	byte com_timeout[4];	/* 40:7C Ticks for COM 1-4 timeouts
   196                              <2> ;;---obsolete----[Keyboard buf start/end]---jrc--;
   197 00000080 ????                <2> kbd_buffer_start resw   1	;*/	word kbd_buffer_start;	/* 40:80 KBD buffer head (PC/AT)
   198 00000082 ????                <2> kbd_buffer_end  resw    1	;*/	word kbd_buffer_end;	/* 40:82 KBD buffer tail (PC/AT)
   199                              <2> ;;---------------[EGA stuff]---------------------;
   200 00000084 ??????????????      <2> EGA_stuff	resb	7	;*/	byte EGA_stuff[7];	/* 40:84 Unspecified EGA data
   201                              <2> ;;---------------[Floppy/Fixed Media Info]-------------;
   202 0000008B ??                  <2> fdc_last_rate	resb	1	;*/	byte fdc_last_rate;	/* 40:8B Last floppy step rate/data rate?
   203 0000008C ????????            <2> fx_misc_unused	resb	4	;*/	byte fx_misc_unused[4];	/* 40:8C Fixed disk miscellaneous ???
   204 00000090 ????                <2> fdc_disk_state	resb	2	;*/	byte fdc_disk_state[2];	/* 40:90 Floppy disk state
   205 00000092 ????                <2> fdc_op_start	resb	2	;*/	byte fdc_op_start[2];	/* 40:92 Floppy operation start state machine
   206 00000094 ????                <2> fdc_cylinder	resb	2	;*/	byte fdc_cylinder[2];	/* 40:94 Floppy present cylinder
   207                              <2> ;;---------------[Additional KBD flags]----------------;
   208 00000096 ??                  <2> kbd_flag_3	resb	1	;*/	byte kbd_flag_3;	/* 40:96 kbd ???
   209 00000097 ??                  <2> kbd_flag_2	resb	1	;*/	byte kbd_flag_2;	/* 40:97 kbd ???
   210                              <2> ;;---------------[RTC/timer1 data]---------------------;
   211 00000098 ????????            <2> user_semaphore	resw	2	;*/	byte *user_semaphore;	/* 40:98 User semaphore in (bit 7)
   212 0000009C ????????            <2> rtc_count	resd	1	;*/	dword rtc_count;	/* 40:9C RTC tick counter
   213 000000A0 ??                  <2> rtc_wait_active	resb	1	;*/	byte rtc_wait_active;	/* 40:A0 Busy=01, Posted=80h, 
   214                              <2> ;;---------------[Cassette I/O stuff]------------------;
   215 000000A1 ??                  <2> last_val	resb	1	;*/	byte last_val;		/* 40:A1 Last byte read value
   216 000000A2 ????                <2> crc_reg		resw	1	;*/	word crc_reg;		/* 40:A2 CRC accumulation area
   217                              <2> ;									Post Acknowleged=00;
   218 000000A4 ??                  <2> EGA_data	resb	1	;*/	byte EGA_data;		/* 40:A4 Various usage
   219 000000A5 ????                <2> SDstatus	resb	2	;*/	byte SDstatus[2];	/* 40:A5 Status byte from command
   220 000000A7 ????                <2> SDcardtype	resb	2	;*/	byte SDcardtype[2];	/* 40:A7 SDcard type SDSC=2, HC=3, ...
   221                              <2> ;
   222 000000A9 ????????            <2> fixed_disk_tab	resb	4	;*/	byte fixed_disk_tab[4];	/* dispatch table to fixed disk drivers
   223 000000AD ??                  <2> wait12_count	resb	1	;*/	byte wait12_count;	/* 40:AD 12usec CX count
   224 000000AE ??                  <2> lock_count	resb	1	;*/	byte lock_count;	/* 40:AE lock level counter
   225 000000AF ??                  <2> EMS_start       resb    1	;*/	byte EMS_start;		/* start EMS allocation from here
   226                              <2> fx80		equ	$	;*/	struct EDD_disk fx80;	/* fixed disk parameter area 0
   227 000000B0 ????                <2> fx_log_cylinders resw   1	;	word fx_log_cylinders;	 logical number of cylinders
   228 000000B2 ??                  <2> fx_log_heads    resb    1	;	byte fx_log_heads;	 logical number of heads
   229 000000B3 ??                  <2> fx_signature	resb	1	;	byte fx_signature;	 A0h signature = translated geom
   230 000000B4 ??                  <2> fx_phys_sectors	resb    1       ;	byte fx_phys_sectors;	 physical number of sectors per track
   231 000000B5 ????                <2> fx_LBA_high     resw    1       ;	word fx_LBA_high;	 high word of LBA28 number of sectors
   232 000000B7 ??                  <2> fx_reserved	resb	1	;	byte fx_reserved;	 reserved for future use
   233 000000B8 ??                  <2> fx_drive_control resb   1       ;	byte fx_drive_control;	 flag bits for IDE head register
   234 000000B9 ????                <2> fx_phys_cylinders resw	1	;	word fx_phys_cylinders;	 physical number of cylinders
   235 000000BB ??                  <2> fx_phys_heads	resb	1	;	byte fx_phys_heads;	 physical number of heads
   236 000000BC ????                <2> fx_LBA_low	resw	1	;	word fx_LBA_low;	 low word of LBA28 number of sectors
   237 000000BE ??                  <2> fx_log_sectors	resb	1	;	byte fx_log_sectors;	 logical number of sectors per track
   238 000000BF ??                  <2> fx_checksum	resb	1	;	byte fx_checksum;	 checksum, dunno how to compute
   239 000000C0 <res 10h>           <2> fx81            resb    16	;*/	struct EDD_disk fx81;	/* fixed disk parameter area 1
   240 000000D0 <res 10h>           <2> fx82            resb    16	;*/	struct EDD_disk fx82;	/* fixed disk parameter area 2
   241 000000E0 <res 10h>           <2> fx83            resb    16	;*/	struct EDD_disk fx83;	/* fixed disk parameter area 3
   242                              <2> ;
   243                              <2> ;
   244                              <2> 
   245 000000F0 ????                <2> FPEM_segment    resw    1       ;*/	word FPEM_segment;	/* FPEM data segment
   246                              <2> 
   247 000000F2 ????                <2> EBDA_paragraph  resw    1       ;*/	word EBDA_paragraph;	/* lowest EBDA paragraph
   248                              <2> 
   249 000000F4 ????                <2> dma0_cw         resw    1       ;*/	word dma0_cw;		/* end of dma control word
   250 000000F6 ????                <2> dma1_cw         resw    1       ;*/	word dma1_cw;		/*   ditto
   251                              <2> 
   252 000000F8 ????                <2> fdc_type	resb	2	;*/	byte fdc_type[2];	/* disk type in low nibble, alternate in hi nib 
   253                              <2> 
   254 000000FA ????????            <2> debug_static_ptr  resw	2	;*/	void *debug_static_ptr;	/* pointer to debug static area
   255                              <2> 
   256 000000FE ??                  <2> n_fixed_disks   resb    1       ;*/	byte n_fixed_disks;	/* number of fixed disks
   257                              <2> 
   258 000000FF ??                  <2> cpu_xtal        resb    1       ;*/	byte cpu_xtal;		/* CPU crystal frequency in Mhz 
   259                              <2> ;								   CPU clock is half of this
   260                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   261                              <2> ;
   262                              <2> ;  System configuration stuff below
   263                              <2> ;	c.f., CONFIG.ASM (ANSI.CFG, CVDU.CFG, etc.), User configuration stuff
   264                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   265                              <2> %if 0				;*/
   266                              <2> #define FIXED_DISK_MAX 4		/*
   267                              <2> %else
   268                              <2> %define FIXED_DISK_MAX 4
   269                              <2> %endif
   270                              <2> %if 0				;*/
   271                              <2> #define PPIDE_driver 1		/*
   272                              <2> %else
   273                              <2> %define PPIDE_driver 1
   274                              <2> %endif
   275                              <2> %if 0				;*/
   276                              <2> #define DIDE_driver 0		/*
   277                              <2> %else
   278                              <2> %define DIDE_driver 0
   279                              <2> %endif
   280                              <2> %if 0				;*/
   281                              <2> #define DISKIO_driver 1		/*
   282                              <2> %else
   283                              <2> %define DISKIO_driver 1
   284                              <2> %endif
   285                              <2> %if 0				;*/
   286                              <2> #define MFPIC_driver 1		/*
   287                              <2> %else
   288                              <2> %define MFPIC_driver 1
   289                              <2> %endif
   290                              <2> %if 0				;*/
   291                              <2> #define DSD_driver 1		/*
   292                              <2> %else
   293                              <2> %define DSD_driver 1
   294                              <2> %endif
   295                              <2> %if 0				;*/
   296                              <2> #define V3IDE8_driver (SBC188==3)		/*
   297                              <2> %else
   298                              <2> %define V3IDE8_driver (SBC188==3)
   299                              <2> %endif
   300                              <2> 				;*/
    92                              <1> 
    93                              <1> ;  this must be the same in EQUATES.H */
    94                              <1> %if SOFT_DEBUG
    95                              <1> %define NBREAK  8
    96                              <1> %endif
    97                              <1> 
    98                              <1> 
    99                              <1> %if 0
   100                              <1>         segment _TEXT
   101                              <1> ;; *************************************************************************
   102                              <1> 
   103                              <1> 
   104                              <1> 
   105                              <1> 
   106                              <1> ;; ************************ DOS Data Segment *******************************
   107                              <1> ;dosdir	SEGMENT at 50h				; Boot disk directory from IPL
   108                              <1> ;xerox	label	byte				;  0 if Print Screen idle
   109                              <1> ;						;  1 if PrtSc xeroxing screen
   110                              <1> ;						;255 if PrtSc error in xerox
   111                              <1> ;						;  ...non-grafix PrtSc in bios
   112                              <1> ;	db	200h dup(?)			; PC-DOS bootstrap procedure
   113                              <1> ;						;  ...IBMBIO.COM buffers the
   114                              <1> ;						;  ...directory of the boot
   115                              <1> ;						;  ...device here at IPL time
   116                              <1> ;						;  ...when locating the guts
   117                              <1> ;						;  ...of the operating system
   118                              <1> ;						;  ...filename "IBMDOS.COM"
   119                              <1> ;dosdir	ends
   120                              <1> ;; *************************************************************************
   121                              <1> ;; ************************ DOS IPL Segment ********************************
   122                              <1> ;dosseg	SEGMENT at 70h				; "Kernel" of PC-DOS op sys
   123                              <1> ;;IBMBIO.COM file loaded by boot block. Device Drivers/Bootstrap. CONTIGUOUS<---
   124                              <1> ;;IBMDOS.COM operating system nucleus immediately follows IBMBIO.COM and       !
   125                              <1> ;;     doesn`t have to be contiguous.  The IBMDOS operating system nucleus     !
   126                              <1> ;;     binary image is loaded by transient code in IBMBIO binary image	      !
   127                              <1> ;dosseg	ends					;			      !
   128                              <1> ;iplseg	SEGMENT at 0h				; Segment for boot block      !
   129                              <1> ;;The following boot block is loaded with 512 bytes on the first sector of     !
   130                              <1> ;;the bootable device by code resident in the ROM-resident bios.  Control is   !
   131                              <1> ;;then transferred to the first word 0000:7C00 of the disk-resident bootstrap  !
   132                              <1> ;	ORG	07C00h				;  ..offset for boot block    !
   133                              <1> ;boot	db	200h dup(?)			;  ..start disk resident boot--
   134                              <1> ;iplseg	ends
   135                              <1> 
   136                              <1> %endif
    44                                  
    45                                  %define	VERSION	VERSION_STRING
    46                                  %define	DATE	DATE_STRING1
    47                                  
    48                                  ;;      global  begin_here
    49                                  	global	cold_boot
    50                                          global  initialization
    51                                  	extern	ident2
    52                                          extern  _cprintf
    53                                  %if TRACE
    54                                  	extern	int_trace
    55                                  %endif	; TRACE
    56                                  
    57                                  
    58                                  	segment         _TEXT
    59                                  
    60                                  cold_boot:
    61 00000000 FA                              cli                     ; Should be clear already
    62 00000001 89C3                    	mov	bx,ax		; save board revision in BX
    63                                  %if SOFT_DEBUG
    64                                          mov     dx,portD
    65                                          mov     al,0A5h         ; A5 to the LITES
    66                                          out     dx,al
    67                                  %endif
    68 00000003 B84000                          mov     ax,bios_data_seg
    69 00000006 8ED0                            mov     ss,ax
    70 00000008 BC0070                          mov     sp,7000h        ; Stack should be out of the way
    71                                  ; cannot use the stack yet, since memory is not tested
    72                                  %if 0
    73                                      ss	mov	bx,word [warm_boot]	; check for 1234h == Warm Boot
    74                                  %else
    75 0000000B 30FF                    	xor	bh,bh			; not warm boot
    76 0000000D 36813E72003412              ss  cmp	word [warm_boot],1234h
    77 00000014 7504                    	jne	.1
    78 00000016 FEC7                    	inc	bh			; it IS a warm boot
    79 00000018 EB08                    	jmp	cold_continue		; JRC - DEBUG test
    80                                  .1:
    81                                  %endif
    82                                  %if SOFT_DEBUG
    83                                  	push	5Ah
    84                                  	call	lites
    85                                  %endif
    86                                  memory_testing:
    87                                  ; Immediately test low memory
    88 0000001A 31C0                            xor     ax,ax           ; Segment 0
    89 0000001C BD[2200]                        mov     bp,.0           ; return address
    90 0000001F E9F003                          jmp     memtest0        ; don't use the stack
    91                                  .0:
    92                                  ; BX was preserved by 'memtest0'
    93                                  
    94                                  %if SOFT_DEBUG
    95                                          jnc     cold_continue
    96                                          mov     dx,portD
    97                                          mov     al,0F1h         ; F1 to the LITES
    98                                          out     dx,al
    99                                  .1:
   100                                          hlt
   101                                          jmp     .1              ; solid halt on error
   102                                  %endif
   103                                  
   104                                  cold_continue:
   105 00000022 FC                              cld                     ; Clear the direction flag
   106 00000023 31C0                            xor     ax,ax
   107 00000025 8EC0                            mov     es,ax
   108                                          cnop
   109 00000027 89C7                            mov     di,ax
   110 00000029 B90003                          mov     cx,600h/2       ; clear segments 00h, 040h and 050h
   111 0000002C F3AB                       rep  stosw                   ; clear out BIOS DATA AREA
   112                                  
   113                                  %if 0
   114                                     ss	mov	word [warm_boot],bx	; save only warm boot flag
   115                                  %else
   116 0000002E 36881E1600                 ss	mov	byte [sbc188_rev],bl	; save board revision
   117 00000033 36891E7200                 ss	mov	word [warm_boot],bx	; save warm boot garbage
   118 00000038 08FF                       	or	bh,bh			; test for warm boot
   119 0000003A 7407                    	jz	.3
   120 0000003C 36C70672003412             ss	mov	word [warm_boot],1234h	; restore warm boot code
   121                                  .3:
   122                                  %endif
   123                                  %if EMM_BOARDS
   124 00000043 E8F204                          call    EMM_init0       ; disable all EMM boards
   125                                  %endif
   126 00000046 E85B03                          call    get_ramsize
   127 00000049 C1E006                          shl     ax,6            ; convert to Segment address
   128                                  %if SOFT_DEBUG
   129                                  	mov	cx,_BSS		; paragraph of _BSS segment
   130                                  ; since the BSS is of length 0000, this is beyond all data
   131                                  
   132                                          mov     bx,cs           ; Code Segment
   133                                          sub     cx,bx           ; Code paragraphs
   134                                          push    cx
   135                                          mov     bx,ax           ; Save HMA in K
   136                                          sub     bx,cx           ; new Code segment
   137                                          mov     es,bx           ; Destination
   138                                          cnop
   139                                          mov     ax,bx           ; Paragraph address to AX
   140                                  
   141                                          push    cs
   142                                          popm     ds              ; Source
   143                                          xor     si,si
   144                                          xor     di,di
   145                                          pop     cx              ; Code length in Paragraphs
   146                                          shl     cx,3            ; Code length in words
   147                                     rep  movsw                   ; move all of it
   148                                          push    es              ; new Code segment
   149                                          push    word SOFT_continue   ; IP
   150                                          retf
   151                                  
   152                                          global  SOFT_continue
   153                                  SOFT_continue:                  ; Continue here in soft memory
   154                                  ;
   155                                  ;  Allocate the DEBUG static area
   156                                  ;
   157                                  	mov	cx,(NBREAK+1)*8 + 15
   158                                  	shr	cx,4		; CX=needed paragraphs
   159                                  	sub	ax,cx		; allocate space
   160                                    ss	mov	[debug_static_ptr+2],ax	 	; setup static area segment
   161                                    ss	mov	word [debug_static_ptr],0	; and offset
   162                                    	shl	cx,4		; word count
   163                                  	pushm	ax,ax		; save segment, twice
   164                                  	popm	es		; set segment to zap
   165                                  	xor	di,di		; start at offset 0
   166                                  	mov	ax,di		; AL=0
   167                                    rep	stosb	    		; Zap memory
   168                                  	popm	ax		; restore AX, EBDA paragraph segment
   169                                  %endif
   170                                  ;
   171                                  ; Save the memory pointers
   172                                  ;
   173 0000004C 36A3F200                    ss  mov     [EBDA_paragraph],ax
   174 00000050 C1E806                          shr     ax,6
   175 00000053 36A31300                    ss  mov     [memory_size],ax
   176                                  
   177 00000057 68[ssss]                        push    DGROUP
   178 0000005A 1F                              popm    ds              ; This is for the C-programs
   179                                  
   180 0000005B E81302                          call    set_traps	; setup interrupt table
   181 0000005E E80F02                  	call	set_interrupt_priority ; set default interrupt priorities
   182                                  
   183 00000061 B80300                  	mov	ax,UART_RATE	; set the default rate
   184                                  	extern	@nvram_get_video
   185 00000064 E8(0000)                	call	@nvram_get_video
   186                                  				; get RAM_serial byte - UART speed
   187                                  				; returned in AL
   188                                  %if SOFT_DEBUG
   189                                  	PUSH	3
   190                                  	CALL	lites
   191                                  %endif
   192                                  	extern	video_init
   193 00000067 E8(0000)                	call	video_init
   194                                  
   195                                  %if SOFT_DEBUG
   196                                  	PUSH	4
   197                                  	CALL	lites
   198                                  %endif
   199                                  	extern	keyboard_init
   200 0000006A E8(0000)                	call	keyboard_init
   201                                  
   202                                  %if SOFT_DEBUG
   203                                  	PUSH	5
   204                                  	CALL	lites
   205                                  %endif
   206 0000006D FB                      	sti                     ; enable interrupts
   207                                  %if FPEM
   208 0000006E 9BDBE3                  	finit			; will allocate memory
   209                                  %endif
   210                                  %if SOFT_DEBUG
   211                                  	PUSH	1
   212                                  	CALL	lites
   213                                  %endif
   214                                  
   215 00000071 6A37                    	push	VERSION_SEQUENCE
   216 00000073 0E                      	push	cs
   217 00000074 68[B706]                	push	ident1
   218 00000077 E8(0000)                	call	_cprintf
   219 0000007A 58                      	pop     ax
   220 0000007B 68[0000]                	push	ident2
   221 0000007E E8(0000)                	call	_cprintf
   222 00000081 58                      	pop     ax
   223 00000082 68[6106]                	push	ident3
   224 00000085 E8(0000)                	call	_cprintf
   225 00000088 58                      	pop     ax
   226 00000089 58                      	pop     ax
   227 0000008A 58                      	pop	ax
   228                                  
   229                                  %if SOFT_DEBUG
   230                                  %if SOFT_DEBUG>1
   231                                  	PUSH	2
   232                                  	CALL	lites
   233                                  %endif
   234                                          extern     redbug
   235                                  
   236                                          pushf           ; push the flags
   237                                          push    cs      ; simulate a far call
   238                                          call    redbug  ; call our weak debugger
   239                                     es   mov     cx,[bp+si+4]
   240                                  %if SOFT_DEBUG>1
   241                                  	PUSH	3
   242                                  	CALL	lites
   243                                  %endif
   244                                  
   245                                  %endif
   246                                  
   247                                  HAS_FLOPPY	equ	0000000000000001b
   248                                  HAS_FPU		equ	0000000000000010b
   249                                  HAS_MOUSE	equ	0000000000000100b
   250                                  VIDEO_EGA	equ	0000000000000000b
   251                                  VIDEO_COLOR_40	equ	0000000000010000b
   252                                  VIDEO_COLOR_80	equ	0000000000100000b
   253                                  VIDEO_MONO	equ	0000000000110000b
   254                                  FLOPPIES_1	equ	0000000000000000b
   255                                  FLOPPIES_2	equ	0000000001000000b
   256                                  FLOPPIES_3	equ	0000000010000000b
   257                                  FLOPPIES_4	equ	0000000011000000b
   258                                  SERIAL_0	equ	0000000000000000b
   259                                  SERIAL_1	equ	0000001000000000b
   260                                  SERIAL_2	equ	0000010000000000b
   261                                  SERIAL_3	equ	0000011000000000b
   262                                  SERIAL_4	equ	0000100000000000b
   263                                  SERIAL_5	equ	0000101000000000b
   264                                  SERIAL_6	equ	0000110000000000b
   265                                  SERIAL_7	equ	0000111000000000b
   266                                  PARALLEL_0	equ	0000000000000000b
   267                                  PARALLEL_1	equ	0100000000000000b
   268                                  PARALLEL_2	equ	1000000000000000b
   269                                  PARALLEL_3	equ	1100000000000000b
   270                                  
   271                                  
   272                                  ; setup BIOS data area
   273 0000008B 6A40                    	push	bios_data_seg
   274 0000008D 1F                      	popm	ds
   275 0000008E C606AE0000              	mov	byte [lock_count],0	; zap the @enable/@disable lock count
   276                                  ; no serial interface -- it is used for the video driver
   277 00000093 B83100                  	mov	ax,PARALLEL_0|SERIAL_0|FLOPPIES_1|VIDEO_MONO|HAS_FLOPPY
   278                                  %if FPEM
   279 00000096 83C802                          or      ax,HAS_FPU              ; a bit of a lie
   280                                  %endif
   281 00000099 A31000                  	mov	word [equipment_flag],ax
   282                                  
   283                                  	extern	_cpu_speed
   284 0000009C E8(0000)                	call	_cpu_speed
   285 0000009F 055802                  	add	ax,600
   286 000000A2 B9E204                  	mov	cx,1250
   287 000000A5 31D2                    	xor	dx,dx
   288 000000A7 F7F1                    	div	cx
   289 000000A9 A2FF00                  	mov	byte [cpu_xtal],al	; CPU oscillator frequency
   290                                  
   291                                  %if CVDU_8563
   292                                  	xor	dx,dx
   293                                  	mov	dl,[video_cga_palette]
   294                                  	push	dx			; CVDU memory size
   295                                  %endif
   296 000000AC FF361300                	push	word [memory_size]
   297                                  
   298 000000B0 68[ssss]                	push	DGROUP
   299 000000B3 1F                      	popm	ds			; This is for the C-programs
   300                                  
   301 000000B4 50                      	push	ax
   302                                  	extern	@timer_init
   303 000000B5 E8(0000)                	call	@timer_init
   304 000000B8 58                      	pop	ax
   305                                  
   306 000000B9 1E                      	push	ds
   307 000000BA A90100                  	test	ax,1
   308 000000BD 7505                    	jnz	.cpu_clock_05
   309 000000BF 68[7701]                	push	msg_cpu_clock_00
   310 000000C2 EB03                    	jmp	.print_cpu_clock
   311                                  .cpu_clock_05:
   312 000000C4 68[7401]                	push	msg_cpu_clock_05
   313                                  .print_cpu_clock:
   314 000000C7 D1E8                    	shr	ax,1
   315 000000C9 50                      	push	ax
   316 000000CA 1E                      	push	ds
   317 000000CB 68[3C01]                	push	msg_cpu_memory
   318 000000CE E8(0000)                	call	_cprintf
   319 000000D1 83C40A                  	add	sp,12-2
   320                                  %if 1
   321 000000D4 58                              pop     ax                      ; memory size in K
   322 000000D5 E8A603                          call    POST_memory             ; Power On Self Test
   323                                  
   324 000000D8 36C70672003412             ss	mov	word [warm_boot],1234h	; set warm boot code
   325                                  
   326                                  %endif
   327                                  %if CVDU_8563
   328                                  	inc	sp
   329                                  	inc	sp			; remove CVDU memory size
   330                                  %endif
   331 000000DF E81B00                  	call	nvram_init
   332                                  
   333 000000E2 1E                      	push	ds		; DS = DGROUP (CONST)
   334 000000E3 68[C301]                	push	msg_floppy
   335 000000E6 E8(0000)                	call	_cprintf
   336 000000E9 83C404                  	add	sp,4
   337                                  
   338                                  %if SBC188==3
   339 000000EC BA7606                  	mov	dx,FDC_RES	; FDC reset (active high)
   340 000000EF 30C0                    	xor	al,al
   341 000000F1 EE                      	out	dx,al		; remove FDC reset
   342                                  
   343 000000F2 BA7706                  	mov	dx,IDE8_RES	; IDE8 (fast) interface
   344 000000F5 B001                    	mov	al,1		; remove reset
   345 000000F7 EE                      	out	dx,al
   346                                  %endif
   347                                  
   348                                  
   349                                  
   350                                  	extern	@floppy_init
   351 000000F8 E8(0000)                	call	@floppy_init
   352                                  
   353 000000FB EB62                    	jmp	boot_the_OS
   354                                  
   355                                  
   356                                  ;========================================================================
   357                                  ; nvram_init - check NVRAM checksum, prompt for NVRAM setup, apply NVRAM configuration
   358                                  ;========================================================================
   359                                  nvram_init:
   360                                  	extern	@nvram_check
   361 000000FD E8(0000)                	call	@nvram_check
   362 00000100 09C0                    	or	ax,ax
   363 00000102 740C                    	jz	.ask_setup
   364                                  
   365 00000104 1E                      	push	ds
   366 00000105 68[9901]                	push	msg_nvram_bad
   367 00000108 E8(0000)                	call	_cprintf
   368 0000010B 83C404                  	add	sp,4
   369 0000010E EB2D                    	jmp	.run_setup
   370                                  
   371                                  .ask_setup:
   372 00000110 1E                      	push	ds
   373 00000111 68[7801]                	push	msg_setup
   374 00000114 E8(0000)                	call	_cprintf
   375 00000117 83C404                  	add	sp,4
   376                                  
   377 0000011A B400                    	mov	ah,0
   378 0000011C CD1A                    	int	1Ah
   379 0000011E 89D3                    	mov	bx,dx
   380 00000120 83C324                  	add	bx,18*2		; wait 2 seconds
   381                                  .wait_setup:
   382 00000123 B401                    	mov	ah,1
   383 00000125 CD16                    	int	16h
   384 00000127 740A                    	jz	.wait_setup_1
   385 00000129 B400                    	mov	ah,0
   386 0000012B CD16                    	int	16h
   387 0000012D 0C20                    	or	al,'s'^'S'
   388 0000012F 3C73                    	cmp	al,'s'
   389 00000131 740A                    	je	.run_setup
   390                                  
   391                                  .wait_setup_1:
   392 00000133 B400                    	mov	ah,0
   393 00000135 CD1A                    	int	1Ah
   394 00000137 39DA                    	cmp	dx,bx
   395 00000139 72E8                    	jb	.wait_setup
   396 0000013B EB03                    	jmp	.skip_setup
   397                                  
   398                                  .run_setup:
   399                                  	extern	@nvram_setup
   400 0000013D E8(0000)                	call	@nvram_setup
   401                                  
   402                                  .skip_setup:
   403                                  	extern	@nvram_apply
   404 00000140 E8(0000)                	call	@nvram_apply
   405                                  
   406 00000143 E8EB01                          call    ticktime                ; set the tick clock
   407                                  
   408 00000146 C3                      	ret
   409                                  
   410                                  ;========================================================================
   411                                  ; BIOS_call_18h - Start ROM Basic
   412                                  ; Note:
   413                                  ;	In this BIOS it prints a "no Basic" message and tries to boot the OS
   414                                  ;	or it will run tests if tests are enabled
   415                                  ;========================================================================
   416                                  BIOS_call_18h:
   417 00000147 FB                      	sti
   418                                  %ifdef TESTS
   419                                  	extern	tests
   420                                  	call	tests
   421                                  %else	; TESTS
   422                                  
   423                                  %if TBASIC
   424                                  ;;;        extern  cbasic
   425                                  ;;;        extern  end_cbasic
   426                                  ;;;	jmp	seg cbasic:cbasic
   427 00000148 EA000000F0              	jmp	0F000h:0000h
   428                                  %else
   429                                  	mov	ax,bios_data_seg
   430                                  	mov	ss,ax			; Reset SS
   431                                  	mov	sp,7000h		; and SP
   432                                  	push	DGROUP			; just in case DS is not pointing
   433                                  	popm	ds			; were it should
   434                                  
   435                                  	push	ds
   436                                  	push	msg_no_basic
   437                                  	call	_cprintf
   438                                  	add	sp,4
   439                                  	mov	ah,0			; get any keystroke; jrc 2012/12/02
   440                                  	int	16h
   441                                  	int	19h			; reboot the OS
   442                                  %endif  ; TBASIC
   443                                  
   444                                  %endif	; TESTS
   445                                  .1:
   446 0000014D F4                      	hlt				; we should never get here
   447 0000014E EBFD                    	jmp	.1
   448                                  
   449                                  ;========================================================================
   450                                  ; BIOS_call_19h  - re-Boot the OS
   451                                  ;========================================================================
   452                                  BIOS_call_19h:
   453 00000150 6A40                    	push	bios_data_seg
   454 00000152 1F                      	popm	ds
   455 00000153 C70672003412            	mov	word [warm_boot],1234h	; set warm boot flag
   456 00000159 FA                      	cli				; disable interrupts
   457 0000015A EA0000FFFF              	jmp	0FFFFh:0000h		; go to STARTUP.BIN code
   458                                  
   459                                  
   460                                  
   461                                  
   462                                  ;========================================================================
   463                                  ;========================================================================
   464                                  boot_the_OS:
   465 0000015F B84000                  	mov	ax,bios_data_seg
   466 00000162 8ED0                    	mov	ss,ax			; Reset SS
   467 00000164 BC0070                  	mov	sp,7000h		; and SP
   468 00000167 68[ssss]                	push	DGROUP			; just in case DS is not pointing
   469 0000016A 1F                      	popm	ds			; were it should
   470 0000016B FB                      	sti
   471                                  
   472                                  %if CVDU_8242
   473                                      ss	or	byte [keyboard_flags_0],CVDU_KEYBOARD_STATUS ; NumLock?
   474                                  	extern	I8242UpdateLites_
   475                                  	call	I8242UpdateLites_
   476                                  %endif
   477                                  
   478 0000016C 6A41                    	push	'A'
   479 0000016E 1E                      	push	ds
   480 0000016F 68[DC01]                	push	msg_booting
   481 00000172 E8(0000)                	call	_cprintf
   482 00000175 83C406                  	add	sp,6
   483                                  
   484 00000178 B200                    	mov	dl,0
   485 0000017A E81600                  	call	boot_drive
   486                                  
   487 0000017D 6A43                    	push	'C'
   488 0000017F 1E                      	push	ds
   489 00000180 68[DC01]                	push	msg_booting
   490 00000183 E8(0000)                	call	_cprintf
   491 00000186 83C406                  	add	sp,6
   492                                  %if SOFT_DEBUG>1
   493                                  	int 0
   494                                  %endif
   495 00000189 B280                    	mov	dl,80h
   496 0000018B E80500                  	call	boot_drive
   497                                  
   498 0000018E CD18                    	int	18h			; failed to boot, start ROM Basic
   499                                  
   500                                  .1:
   501 00000190 F4                      	hlt				; we should never get here
   502 00000191 EBFD                    	jmp	.1
   503                                  
   504                                  ;========================================================================
   505                                  ; boot_drive - try to boot from the drive
   506                                  ; Input:
   507                                  ;	DL = drive number (00h = first floppy, 80h = first HDD)
   508                                  ;========================================================================
   509                                  boot_drive:
   510 00000193 BE0300                  	mov	si,3			; make 3 tries before giving up
   511                                  
   512                                  %if SOFT_DEBUG>1
   513                                  	nop
   514                                  	int 0
   515                                  %endif
   516                                  .1:					; loop comes back here
   517 00000196 B400                    	mov	ah,0			; reset the Disk Controller
   518 00000198 CD13                    	int	13h
   519                                  	
   520 0000019A 52                      	push	dx
   521 0000019B B408                    	mov	ah,8			; get drive parameters
   522 0000019D CD13                    	int	13h
   523 0000019F 88D0                    	mov	al,dl			; number of drives
   524 000001A1 5A                      	pop	dx
   525 000001A2 7213                    	jc	.fn8_error
   526                                  
   527                                  
   528                                  %if SOFT_DEBUG > 2
   529                                  	nop
   530                                  	int	0
   531                                  
   532                                          mov     ax,0401h                ; verify sector
   533                                  	mov	cx,1			; track 0, sector 1
   534                                  	mov	dh,0			; head 0
   535                                          int     13h
   536                                  
   537                                          nop
   538                                          int     0
   539                                  %endif
   540                                  
   541 000001A4 B80102                  	mov	ax,0201h		; read one sector
   542 000001A7 B90100                  	mov	cx,1			; track 0, sector 1
   543 000001AA B600                    	mov	dh,0			; head 0
   544 000001AC 31DB                    	xor	bx,bx
   545 000001AE 8EC3                    	mov	es,bx			; ES = 0
   546 000001B0 BB007C                  	mov	bx,7C00h		; ES:BX = 0000:7C00
   547 000001B3 CD13                    	int	13h
   548 000001B5 730F                    	jnc	.read_ok
   549                                  
   550                                  .fn8_error:
   551 000001B7 4E                      	dec	si			; go back and reset the controller
   552 000001B8 75DC                    	jnz	.1			; make several tries
   553                                  
   554 000001BA 50                      	push	ax
   555 000001BB 1E                      	push	ds
   556 000001BC 68[FB01]                	push	msg_boot_err
   557 000001BF E8(0000)                	call	_cprintf
   558 000001C2 83C406                  	add	sp,4+2
   559 000001C5 C3                      	ret
   560                                  
   561                                  .read_ok:
   562 000001C6 52                      	push	dx
   563                                  
   564 000001C7 B80480                          mov     ax,8004h                ; NVRAM bits
   565 000001CA E82604                          call    rtc_get_loc
   566 000001CD A802                            test    al,2            ; RAM_bits_AA55 flag
   567 000001CF 7538                            jnz     .cpm_bootsec
   568 000001D1 26813EFE7D55AA              es	cmp	word [7C00h+1FEh],0AA55h
   569 000001D8 7415                    	je	.good_signature
   570 000001DA 26813EBC7D55AA              es	cmp	word [7C00h+1BCh],0AA55h
   571 000001E1 7420                        	je	.minix_bootsec
   572 000001E3 1E                      	push	ds
   573 000001E4 68[1602]                	push	msg_no_boot
   574 000001E7 E8(0000)                	call	_cprintf
   575 000001EA 83C404                  	add	sp,4		; remove DX also
   576 000001ED 5A                      	pop	dx		; **
   577 000001EE C3                      	ret
   578                                  .good_signature:
   579 000001EF 26833E007C00                es	cmp	word [7C00h+000h],0
   580 000001F5 751C                    	jne	.good_bootsec
   581 000001F7 1E                      	push	ds
   582 000001F8 68[3002]                	push	msg_no_loader
   583 000001FB E8(0000)                	call	_cprintf
   584 000001FE 83C404                  	add	sp,4		; remove DX also
   585 00000201 5A                      	pop	dx		; **
   586 00000202 C3                      	ret
   587                                  
   588                                  .minix_bootsec:
   589 00000203 1E                      	push	ds		; alternate boot signature
   590 00000204 68[6602]                	push	msg_alt_disk
   591 00000207 EB04                    	jmp	short .cpmbs2
   592                                  .cpm_bootsec:
   593 00000209 1E                              push    ds
   594 0000020A 68[5202]                        push    msg_cpm_disk
   595 0000020D E8(0000)                .cpmbs2:  call    _cprintf
   596 00000210 83C404                  	add	sp,4
   597                                  .good_bootsec:
   598 00000213 1E                      	push	ds
   599 00000214 68[4E02]                	push	msg_boot_ok
   600 00000217 E8(0000)                	call	_cprintf
   601 0000021A 83C404                  	add	sp,4
   602                                  
   603 0000021D 5A                      	pop	dx
   604                                  
   605                                  %if SOFT_DEBUG>1
   606                                  	global	major_debug
   607                                  major_debug:
   608                                  	cmp	dl,0
   609                                  	jne	.999
   610                                  
   611                                  	xor	bx,bx
   612                                  	push	bx
   613                                  	popm	es			; ES = 0
   614                                  	mov	bx,7C00h		; ES:BX = 0000:7C00
   615                                  	int	0
   616                                  
   617                                  	mov	ax,0201h
   618                                  	inc	cl
   619                                  	int	13h
   620                                  
   621                                  	mov	ax,0201h
   622                                  	mov	cl,10h
   623                                  	int	13h
   624                                  
   625                                  	mov	ax,0201h
   626                                  	mov	dh,1
   627                                  	int	13h
   628                                  
   629                                  	mov	ax,0201h
   630                                  	mov	ch,1		; cylinder 1
   631                                  	int	13h
   632                                  
   633                                  	mov	ax,0201h
   634                                  	mov	ch,23h
   635                                  	int	13h
   636                                  
   637                                  	mov	ax,0201h
   638                                  	mov	cx,1
   639                                  	mov	dh,0
   640                                  	int	13h
   641                                  
   642                                  .999:
   643                                  %endif
   644                                  %if SOFT_DEBUG
   645                                  	push	7
   646                                  	call	lites
   647                                  	int 0
   648                                  %endif
   649 0000021E EA007C0000              	jmp	0000:7C00h		; execute the boot sector
   650                                  
   651                                  
   652                                  
   653                                  %if 0		; now part of 2P1S from R. Cini (RAC)
   654                                  ;========================================================================
   655                                  ; BIOS_call_14h  - Serial port communication services
   656                                  ;========================================================================
   657                                  BIOS_call_14h:
   658                                  %if TRACE
   659                                  	call	int_trace
   660                                  %endif	; TRACE
   661                                  	xor	ax,ax
   662                                  	iret
   663                                  
   664                                  ;========================================================================
   665                                  ; BIOS_call_17h  - Print services
   666                                  ;========================================================================
   667                                  BIOS_call_17h:
   668                                  %if TRACE
   669                                  	call	int_trace
   670                                  %endif	; TRACE
   671                                  	mov	ah,0
   672                                  	iret
   673                                  
   674                                  %endif
   675                                  ;========================================================================
   676                                  
   677                                  interrupt_table:
   678                                  
   679                                  %if SOFT_DEBUG
   680                                  	db	0			; Int 0 - divide by zero
   681                                  	extern	zero_divide
   682                                  	dw	zero_divide
   683                                  
   684                                  	db	1			; Int 1 - single step
   685                                  	extern	single_step
   686                                  	dw	single_step
   687                                  
   688                                  	db	2			; Int 2 - NMI interrupt
   689                                  	extern	nmi_interrupt
   690                                  	dw	nmi_interrupt
   691                                  
   692                                  	db	3			; Int 3 - breakpoint
   693                                  	extern	breakpoint
   694                                  	dw	breakpoint
   695                                  
   696                                  	db	4			; Int 4 - interrupt on overflow (INTO instruction)
   697                                  	extern	INTO_trap
   698                                  	dw	INTO_trap
   699                                  
   700                                  	db	5			; Int 5 - bound check error
   701                                  	extern	bound_trap
   702                                  	dw	bound_trap
   703                                  
   704                                  	db	6			; Int 6 - invalid opcode
   705                                  	extern	undefined_op
   706                                  	dw	undefined_op
   707                                  %endif	; SOFT_DEBUG
   708                                  
   709                                  %if FPEM
   710                                  %if 0
   711                                  	db	7			; ESC opcode / Floating Point
   712                                  	extern	vector7
   713                                  	dw	vector7
   714                                  %endif
   715                                  %else
   716                                  %if SOFT_DEBUG
   717                                  	db	7			; Int 7 - math coprocessor not present
   718                                  	dw	undefined_op
   719                                  %endif	; SOFT_DEBUG
   720                                  %endif
   721                                  
   722 00000223 08                      	db	8			; Timer 0 interrupt
   723                                  	extern	timer0_interrupt
   724 00000224 [0000]                  	dw	timer0_interrupt
   725                                  
   726 00000226 0A                      	db	0Ah			; DMA 0 interrupt
   727                                  	extern	dma0_interrupt
   728 00000227 [0000]                  	dw	dma0_interrupt
   729                                  
   730 00000229 0B                      	db	0Bh			; DMA 1 interrupt
   731 0000022A [5C02]                  	dw	end_of_interrupt
   732                                  
   733 0000022C 0C                      	db	0Ch			; INT0 - external bus INT
   734                                  %if CVDU_8242 & (1-CVDU_USE_KBD_HOOK)
   735                                  	extern	cvdu_kbd_int
   736                                  	dw	cvdu_kbd_int
   737                                  %else
   738 0000022D [5C02]                  	dw	end_of_interrupt
   739                                  %endif
   740                                  
   741 0000022F 0D                      	db	0Dh			; INT1 - UART
   742                                  %if UART
   743                                  	extern	uart_int
   744 00000230 [0000]                  	dw	uart_int
   745                                  %else
   746                                  	dw	end_of_interrupt
   747                                  %endif
   748                                  
   749 00000232 0F                      	db	0Fh
   750                                  	extern	fdc_interrupt_level
   751 00000233 [0000]                  	dw	fdc_interrupt_level	; INT3 - FDC
   752                                  
   753 00000235 10                      	db	10h			; BIOS - Video display services
   754                                  	extern	BIOS_call_10h
   755 00000236 [0000]                  	dw	BIOS_call_10h
   756                                  
   757 00000238 11                      	db	11h			; BIOS - Return equipment list
   758 00000239 [EB03]                  	dw	BIOS_call_11h		; in memory.asm
   759                                  
   760 0000023B 12                      	db	12h			; BIOS - Return conventional memory size
   761 0000023C [F503]                  	dw	BIOS_call_12h		; (shared with Timer 1)
   762                                  ;;;	dw	timer1_interrupt	; non INT 12h passed to timer1
   763                                  
   764 0000023E 13                      	db	13h			; BIOS - Disk services
   765                                  %if PPIDE_driver | DIDE_driver | DSD_driver
   766                                  	extern	FIXED_BIOS_call_13h
   767 0000023F [0000]                  	dw	FIXED_BIOS_call_13h     ; (shared with Timer 2, prescaler, NOT USED)
   768                                  
   769 00000241 40                              db      40h                     ; Floppy Driver
   770                                  %endif
   771                                  	extern	BIOS_call_13h
   772 00000242 [0000]                          dw      BIOS_call_13h
   773                                  
   774 00000244 14                      	db	14h			; BIOS - Serial port communication
   775                                  	extern	BIOS_call_14h
   776 00000245 [0000]                  	dw	BIOS_call_14h
   777                                  
   778 00000247 15                      	db	15h			; BIOS - Miscellaneous system services support routines
   779                                  	extern	BIOS_call_15h
   780 00000248 [0000]                  	dw	BIOS_call_15h
   781                                  
   782 0000024A 16                      	db	16h			; BIOS - Keyboard services
   783                                  	extern	BIOS_call_16h
   784 0000024B [0000]                  	dw	BIOS_call_16h
   785                                  
   786 0000024D 17                      	db	17h
   787                                  	extern	BIOS_call_17h
   788 0000024E [0000]                  	dw	BIOS_call_17h		; BIOS - Print services
   789                                  
   790                                  %if TBASIC==0 
   791                                  	db	18h			; BIOS - Start ROM Basic
   792                                  	dw	BIOS_call_18h
   793                                  %endif
   794                                  
   795 00000250 19                      	db	19h			; BIOS - Boot the OS
   796 00000251 [5001]                  	dw	BIOS_call_19h
   797                                  
   798 00000253 1A                      	db	1Ah			; BIOS - RTC (real time clock) services
   799                                  	extern	BIOS_call_1Ah
   800 00000254 [0000]                  	dw	BIOS_call_1Ah
   801                                  
   802 00000256 1C                      	db	1Ch
   803                                  	extern	BIOS_call_1Ch
   804 00000257 [0000]                  	dw	BIOS_call_1Ch
   805                                  
   806 00000259 70                      	db	70h			; RTC timer tick on IRQ8
   807                                  	extern	rtc_interrupt
   808 0000025A [0000]                  	dw	rtc_interrupt		; 1024 Hz timer
   809                                  
   810                                  num_vectors	equ     (($-interrupt_table)/3)
   811                                  
   812                                  ;========================================================================
   813                                  ; end_of_interrupt - signal end of interrupt to the interrupt controller
   814                                  ;========================================================================
   815                                  end_of_interrupt:
   816 0000025C 5250                            pushm   ax,dx
   817 0000025E BA22FF                          mov     dx,PIC_EOI              ; EOI register
   818 00000261 B80080                          mov     ax,EOI_NSPEC            ; non-specific end of interrupt
   819 00000264 EF                              out     dx,ax                   ; signal it
   820 00000265 585A                            popm    ax,dx
   821 00000267 CF                      	iret
   822                                  
   823                                  skip_trap:
   824                                  %if TRACE
   825                                  	call	int_trace
   826                                  %endif	; TRACE
   827 00000268 CF                              iret            ; return from interrupt is a null trap
   828                                  
   829                                  
   830                                  ;========================================================================
   831                                  ;  Interrupt priority re-assignments
   832                                  ;========================================================================
   833                                  MASK		equ	08h	; mask interrupt
   834                                  LTM		equ	10h	; Level Trigger Mode
   835                                  interrupt_priority:
   836 00000269 0E                      	db	6 | MASK	; Timers -- timer_init clears the mask
   837 0000026A 02                      	db	2		; DMA0
   838 0000026B 0A                      	db	2 | MASK	; DMA1
   839 0000026C 0C                      	db	4 | MASK	; INT0 -- external /INT (keyboard)
   840 0000026D 04                      	db	4		; INT1 -- UART
   841 0000026E 0F                      	db	7 | MASK	; INT2
   842 0000026F 1B                      	db	3 | LTM+MASK	; INT3 -- floppy disk
   843                                  lth_int_priority   equ	$-interrupt_priority
   844                                  
   845                                  set_interrupt_priority:
   846                                  %if 0
   847                                  /* for now */
   848                                  	mov	dx,PIC_TCR
   849                                  	mov	si,interrupt_priority
   850                                  	xor	ax,ax		; zap AH
   851                                  	mov	cx,lth_int_priority
   852                                  sip_loop:
   853                                     cs	lodsb			; get priority level
   854                                     	out	dx,ax
   855                                  	add	dx,2		; PIC control regs are even
   856                                  	loop	sip_loop
   857                                  %endif
   858 00000270 C3                      	ret
   859                                  
   860                                  ;========================================================================
   861                                  ; set_traps - setup interrupt table
   862                                  ;========================================================================
   863                                  set_traps:
   864 00000271 1E                              push    ds
   865                                  
   866 00000272 8CCA                    	mov	dx,cs
   867 00000274 B90001                  	mov	cx,0100h	; number of interrupt vectors
   868 00000277 B300                    	mov	bl,0		; start with int 0
   869 00000279 B8[6802]                	mov	ax,skip_trap
   870                                  .set_default_loop:
   871 0000027C E83E00                  	call	set_vector
   872 0000027F FEC3                    	inc	bl
   873 00000281 E2F9                    	loop	.set_default_loop
   874                                  	
   875 00000283 8EDA                            mov     ds,dx           ; for LODS  CS==DX==DS
   876                                          cnop
   877 00000285 BE[2302]                        mov     si,interrupt_table	; load address to start
   878 00000288 B91300                  	mov	cx,num_vectors
   879                                  				; note DX = CS
   880                                  .set_vectors_loop:
   881 0000028B AC                      	lodsb
   882 0000028C 88C3                    	mov	bl,al
   883 0000028E AD                      	lodsw
   884 0000028F E82B00                  	call	set_vector
   885 00000292 E2F7                    	loop	.set_vectors_loop
   886                                  
   887                                  %if TBASIC
   888 00000294 B318                    	mov	bl,18h		; int 18h is Tiny Basic
   889 00000296 31C0                    	xor	ax,ax
   890 00000298 BA00F0                  	mov	dx,0F000h	; absolute segment load @ 00K
   891 0000029B E81F00                  	call	set_vector
   892                                  %endif
   893                                  %if FPEM
   894 0000029E B307                    	mov	bl,07h		; vector 7 is FPU emulator
   895 000002A0 31C0                    	xor	ax,ax
   896 000002A2 BA80F4                  	mov	dx,0F480h	; absolute segment load @ 18K
   897 000002A5 E81500                  	call	set_vector
   898                                  %endif
   899                                  
   900 000002A8 1F                              popm     ds
   901 000002A9 C3                              ret
   902                                  
   903                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   904                                  ;  get_vector
   905                                  ;       Get an interrupt vector
   906                                  ;
   907                                  ;       Enter with vector number in BL
   908                                  ;       Exit with vector in DX:AX
   909                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   910                                          global  get_vector
   911                                  get_vector:
   912 000002AA 1E53                            pushm   bx,ds		; register saves
   913                                  
   914 000002AC 31C0                            xor     ax,ax           ; zero BX
   915 000002AE 8ED8                            mov     ds,ax           ; set DS=0
   916                                          cnop
   917 000002B0 B700                    	mov	bh,0
   918 000002B2 C1E302                          shl     bx,2            ; index * 4
   919                                  
   920 000002B5 8B07                            mov     ax,[bx]         ; load the vector
   921 000002B7 8B5702                          mov     dx,[bx+2]       ;
   922                                  
   923 000002BA 5B1F                            popm    bx,ds		; register restores
   924 000002BC C3                              ret                     ; result in DX:AX
   925                                  
   926                                  
   927                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   928                                  ;  set_vector
   929                                  ;       Set an interrupt vector
   930                                  ;
   931                                  ;       Enter with vector number in BL
   932                                  ;               vector in DX:AX
   933                                  ;
   934                                  ;       All registers preserved
   935                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   936                                          global  set_vector
   937                                  set_vector:
   938 000002BD 1E5351                          pushm   cx,bx,ds	; register saves
   939                                  
   940 000002C0 31C9                    	xor	cx,cx
   941 000002C2 8ED9                            mov     ds,cx           ; set DS=0
   942                                          cnop
   943 000002C4 B700                    	mov	bh,0
   944 000002C6 C1E302                          shl     bx,2            ; index * 4
   945                                  
   946 000002C9 8907                            mov     [bx],ax         ; set offset
   947 000002CB 895702                          mov     [bx+2],dx       ; set segment
   948                                  
   949 000002CE 595B1F                          popm    cx,bx,ds	; register restores
   950 000002D1 C3                              ret                     ; return
   951                                          
   952                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   953                                  ;  cpu_table_init
   954                                  ;
   955                                  ;       call    cpu_table_init
   956                                  ;       dw      <table>         ; table in the Code segment
   957                                  ;       <return here>
   958                                  ;               AX, CX, DX are trashed
   959                                  ;
   960                                  ;
   961                                  ; table:
   962                                  ;       db_lo   <cpu_register>
   963                                  ;       dw      <contents>
   964                                  ;       ...
   965                                  ;       db      0       ; ends table
   966                                  ;
   967                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   968                                          global  cpu_table_init
   969                                  cpu_table_init:
   970                                  ; get the table address
   971 000002D2 89F1                            mov     cx,si           ; save SI
   972 000002D4 5E                              pop     si              ; get the return address
   973 000002D5 2EAD                        cs  lodsw                   ; get the table address
   974 000002D7 56                              push    si              ; save incremented return address
   975 000002D8 51                              push    cx              ; save former SI
   976                                  
   977 000002D9 89C6                            mov     si,ax           ; CS:SI is table pointer
   978 000002DB B6FF                            mov     dh,cpu_relocation>>8
   979                                  .1:
   980 000002DD 2EAC                        cs  lodsb                   ; get low device code
   981 000002DF 84C0                            test    al,al
   982 000002E1 7407                            jz      .9              ; done with table on zero low device code
   983 000002E3 88C2                            mov     dl,al
   984 000002E5 2EAD                        cs  lodsw                   ; get cpu register data
   985 000002E7 EF                              out     dx,ax           ; output a full word
   986 000002E8 EBF3                            jmp     .1
   987                                  .9:
   988 000002EA 5E                              pop     si              ; restore SI
   989 000002EB C3                              ret                     ;
   990                                          
   991                                  
   992                                  %if 1
   993                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   994                                  ;  C-callable:
   995                                  ;       dword __fastcall divLS(dword dividend, word divisor);
   996                                  ;
   997                                  ;       double word  divided by  word
   998                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   999                                          global  @divLS
  1000                                  @divLS:
  1001                                          ; DX:AX is dividend
  1002                                          ; BX is divisor
  1003 000002EC 09D2                            or      dx,dx
  1004 000002EE 7505                            jnz     .3
  1005 000002F0 F7F3                            div     bx
  1006 000002F2 31D2                            xor     dx,dx
  1007 000002F4 C3                              ret
  1008                                  
  1009 000002F5 89C1                    .3:     mov     cx,ax           ; save low dividend in CX
  1010 000002F7 89D0                            mov     ax,dx
  1011 000002F9 31D2                            xor     dx,dx           ; 0:DX div BX
  1012 000002FB F7F3                            div     bx
  1013 000002FD 91                              xchg    cx,ax           ; CX is high quotient
  1014 000002FE F7F3                            div     bx
  1015 00000300 89CA                            mov     dx,cx
  1016 00000302 C3                              ret
  1017                                  
  1018                                  %ifndef HAS_FASTCALL
  1019                                          global  _divLS
  1020                                  _divLS: push    bp
  1021                                          mov     bp,sp
  1022                                          mov     ax,ARG(1)
  1023                                          mov     dx,ARG(2)
  1024                                          mov     bx,ARG(3)
  1025                                          call    @divLS
  1026                                          leave
  1027                                          ret
  1028                                  
  1029                                          global  _remLS
  1030                                  _remLS: push    bp
  1031                                          mov     bp,sp
  1032                                          mov     ax,ARG(1)
  1033                                          mov     dx,ARG(2)
  1034                                          mov     bx,ARG(3)
  1035                                          call    @remLS
  1036                                          leave
  1037                                          ret
  1038                                  %endif
  1039                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1040                                  ;  C-callable:
  1041                                  ;       word __fastcall remLS(dword dividend, word divisor);
  1042                                  ;
  1043                                  ;       remainder of:
  1044                                  ;       double word  divided by  word
  1045                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1046                                          global  @remLS
  1047                                  @remLS:
  1048                                          ; DX:AX is dividend
  1049                                          ; BX is divisor
  1050 00000303 09D2                            or      dx,dx
  1051 00000305 740A                            jz      .5
  1052 00000307 89C1                            mov     cx,ax           ; save low dividend in CX
  1053 00000309 89D0                            mov     ax,dx
  1054 0000030B 31D2                            xor     dx,dx           ; 0:DX div BX
  1055 0000030D F7F3                            div     bx              ; discard quotient in AX
  1056 0000030F 89C8                            mov     ax,cx           ; restore low dividend
  1057 00000311 F7F3                    .5:     div     bx
  1058 00000313 89D0                            mov     ax,dx           ; remainder to AX
  1059 00000315 C3                              ret
  1060                                  
  1061                                  
  1062                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1063                                  ;  C-callable:
  1064                                  ;       dword __fastcall mulLS(dword factor1, word factor2);
  1065                                  ;
  1066                                  ;       double word  multiplied by  word
  1067                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1068                                  	global	@mulLS
  1069                                  @mulLS:
  1070                                  	; DX:AX is factor1
  1071                                  	; BX is factor2
  1072 00000316 09D2                            or      dx,dx
  1073 00000318 7503                            jnz     .1		; dx != 0
  1074 0000031A F7E3                            mul     bx
  1075 0000031C C3                              ret
  1076 0000031D 89C1                    .1:     mov     cx,ax           ; save low part of factor1 in CX
  1077 0000031F 89D0                            mov     ax,dx
  1078 00000321 F7E3                            mul     bx
  1079 00000323 91                              xchg    cx,ax           ; CX is a product of high part of factor1 and factor2
  1080 00000324 F7E3                            mul	bx
  1081 00000326 01CA                            add     dx,cx
  1082 00000328 C3                              ret
  1083                                  %endif
  1084                                  
  1085                                  
  1086                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1087                                  ;  microsecond
  1088                                  ;       Enter with CX = delay time in microseconds
  1089                                  ;       Exit with CX = 0
  1090                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1091                                          global  @microsecond
  1092                                          global  microsecond
  1093                                  @microsecond:		; C-callable with __fastcall
  1094 00000329 89C1                    	mov	cx,ax
  1095                                  microsecond:
  1096 0000032B E303                            jcxz    .9
  1097 0000032D 90                      .1:     nop		; 4 clocks
  1098 0000032E E2FD                            loop    .1	; 15 clocks	loop is 19 clocks (approx.)
  1099 00000330 C3                      .9:     ret
  1100                                  
  1101                                  
  1102                                  %if 0
  1103                                  ;========================================================================
  1104                                  ; wout - nobody calls it, but unasm defines it as an extenal symbol
  1105                                  ; XXX: Need to recompile unasm and kill it
  1106                                  ;========================================================================
  1107                                  	global	wout
  1108                                  wout:
  1109                                  	ret
  1110                                  %endif
  1111                                  
  1112                                  
  1113                                  %macro  binary  1
  1114                                          mov     ah,%1
  1115                                          shr     ax,4
  1116                                          shr     al,4
  1117                                          aad
  1118                                          mov     %1,al
  1119                                  %endm
  1120                                          
  1121                                  
  1122                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1123                                  ;  ticktime -- set the tick count from the CMOS clock
  1124                                  ;
  1125                                  ;       Preserves all registers
  1126                                  ;
  1127                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1128                                          global  ticktime
  1129                                  ticktime:
  1130 00000331 60                              pushm   ALL
  1131                                  
  1132 00000332 B402                            mov     ah,2            ; get Time
  1133 00000334 CD1A                            int     1Ah
  1134                                  
  1135                                          binary  dh
  1114 00000336 88F4                <1>  mov ah,%1
  1115 00000338 C1E804              <1>  shr ax,4
  1116 0000033B C0E804              <1>  shr al,4
  1117 0000033E D50A                <1>  aad
  1118 00000340 88C6                <1>  mov %1,al
  1136                                          binary  cl
  1114 00000342 88CC                <1>  mov ah,%1
  1115 00000344 C1E804              <1>  shr ax,4
  1116 00000347 C0E804              <1>  shr al,4
  1117 0000034A D50A                <1>  aad
  1118 0000034C 88C1                <1>  mov %1,al
  1137                                          binary  ch
  1114 0000034E 88EC                <1>  mov ah,%1
  1115 00000350 C1E804              <1>  shr ax,4
  1116 00000353 C0E804              <1>  shr al,4
  1117 00000356 D50A                <1>  aad
  1118 00000358 88C5                <1>  mov %1,al
  1138                                  ;       mov     al,ch
  1139 0000035A 88E5                            mov     ch,ah           ; CH = 0
  1140 0000035C B23C                            mov     dl,60           ; 60 min / hr,  60 sec / min
  1141 0000035E F6E2                            mul     dl
  1142 00000360 01C8                            add     ax,cx           ; AX = hr*60 + min
  1143 00000362 88F1                            mov     cl,dh           ; CX = sec
  1144 00000364 88EE                            mov     dh,ch           ; DH = 0
  1145 00000366 F7E2                            mul     dx              ;
  1146 00000368 01C8                            add     ax,cx
  1147 0000036A 83D200                          adc     dx,0            ; DX:AX = time in seconds
  1148                                  
  1149 0000036D BBFA00                          mov     bx,250
  1150 00000370 89D1                            mov     cx,dx           ; CX:AX is time in seconds
  1151 00000372 F7E3                            mul     bx
  1152 00000374 91                              xchg    ax,cx           ; CX is low result
  1153 00000375 F6E3                            mul     bl
  1154 00000377 01D0                            add     ax,dx           ; AX:CX is 250*maxseconds
  1155                                  
  1156 00000379 C1E302                          shl     bx,2            ; BX = 1000
  1157 0000037C 91                              xchg    ax,cx           ; CX:AX is 250*maxseconds
  1158 0000037D F7E3                            mul     bx              ; DX:AX is partial product
  1159 0000037F 91                              xchg    ax,cx
  1160 00000380 87D3                            xchg    dx,bx           ; BX:CX is partial product
  1161 00000382 F7E2                            mul     dx
  1162 00000384 01D8                            add     ax,bx
  1163 00000386 83D200                          adc     dx,0            ; DX:AX:CX is product
  1164                                  
  1165 00000389 BBA335                          mov     bx,54924/4      ; = 13731       (divisor)
  1166 0000038C F7F3                            div     bx
  1167 0000038E 91                              xchg    ax,cx           ; CX is high quotient
  1168 0000038F F7F3                            div     bx              ; CX:AX is quotient, DX is remainder
  1169                                  ; round the result
  1170 00000391 29D3                            sub     bx,dx           ; if DX > BX/2
  1171 00000393 39D3                            cmp     bx,dx           ; 
  1172 00000395 7706                            ja      .3
  1173 00000397 83C001                          add     ax,1
  1174 0000039A 83D100                          adc     cx,0
  1175                                  .3:
  1176 0000039D 92                              xchg    ax,dx           ; CX:DX is tick count to set
  1177 0000039E B401                            mov     ah,1
  1178 000003A0 CD1A                            int     1Ah             ; set tick count
  1179                                  
  1180 000003A2 61                              popm    ALL
  1181 000003A3 C3                              ret
  1182                                  
  1183                                  
  1184                                  
  1185                                  
  1186                                  ;========================================================================
  1187                                  
  1188                                  %include        "memory.asm"
  1189                              <1> ;========================================================================
  1190                              <1> ; MEMORY.ASM -- Memory management routines
  1191                              <1> ;========================================================================
  1192                              <1> ;
  1193                              <1> ;   This version is for assembly by  NASM
  1194                              <1> ;
  1195                              <1> ; Copyright (C) 2011   John R. Coffman
  1196                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board
  1197                              <1> ;
  1198                              <1> ; This program is free software: you can redistribute it and/or modify
  1199                              <1> ; it under the terms of the GNU General Public License as published by
  1200                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1201                              <1> ; (at your option) any later version.
  1202                              <1> ;
  1203                              <1> ; This program is distributed in the hope that it will be useful,
  1204                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1205                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1206                              <1> ; GNU General Public License for more details.
  1207                              <1> ;
  1208                              <1> ; You should have received a copy of the GNU General Public License
  1209                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1210                              <1> ;
  1211                              <1> ;========================================================================
  1212                              <1> 
  1213                              <1>         segment         _TEXT
  1214                              <1> 
  1215                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1216                              <1> ;  get_ramsize
  1217                              <1> ;
  1218                              <1> ;       Return the number of 1k blocks of RAM in AX
  1219                              <1> ;
  1220                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1221                              <1> get_ramsize:
  1222 000003A4 1E                  <1>         push    ds
  1223 000003A5 53                  <1>         push    bx
  1224 000003A6 51                  <1>         push    cx
  1225 000003A7 31C0                <1>         xor     ax,ax           ; count of 1k intervals
  1226 000003A9 89C3                <1>         mov     bx,ax           ; segment address
  1227                              <1> .1:
  1228 000003AB 8EDB                <1>         mov     ds,bx           ; set pointer
  1229                              <1>         cnop
  1230 000003AD 8B0E0000            <1>         mov     cx,word [0]     ; save contents
  1231 000003B1 C70600006CA5        <1>         mov     word [0],0a56ch ; addressing is [DS:0]
  1232 000003B7 89DB                <1>         mov     bx,bx
  1233 000003B9 89C0                <1>         mov     ax,ax           ; waste time
  1234 000003BB 813E00006CA5        <1>         cmp     word [0],0a56ch ; see if it is the same
  1235 000003C1 7524                <1>         jne     .9
  1236 000003C3 890E0000            <1>         mov     word [0],cx     ; restore
  1237 000003C7 8B0EFC03            <1>         mov     cx,word [1020]
  1238 000003CB C706FC03325A        <1>         mov     word [1020],05a32h  ; address [DS:1020]
  1239 000003D1 89C0                <1>         mov     ax,ax
  1240 000003D3 89DB                <1>         mov     bx,bx
  1241 000003D5 813EFC03325A        <1>         cmp     word [1020],05a32h
  1242 000003DB 750A                <1>         jne     .9
  1243 000003DD 890EFC03            <1>         mov     word [1020],cx  ; restore
  1244                              <1> 
  1245                              <1> ; Memory test succeeded at the address
  1246                              <1> 
  1247 000003E1 40                  <1>         inc     ax              ; count 1k
  1248 000003E2 83C340              <1>         add     bx,1024/16      ; increment segment register by paragraphs
  1249 000003E5 EBC4                <1>         jmp     .1
  1250                              <1> 
  1251                              <1> .9:
  1252 000003E7 59                  <1>         pop     cx
  1253 000003E8 5B                  <1>         pop     bx
  1254 000003E9 1F                  <1>         pop     ds
  1255 000003EA C3                  <1>         ret
  1256                              <1>         
  1257                              <1> 
  1258                              <1> 
  1259                              <1> 
  1260                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1261                              <1> ;  BIOS_call_11h
  1262                              <1> ;
  1263                              <1> ;       Get Equipment Configuration
  1264                              <1> ;
  1265                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1266                              <1> BIOS_call_11h:          
  1267 000003EB FB                  <1>         sti
  1268 000003EC 1E                  <1>         push    ds
  1269 000003ED 6A40                <1>         push    bios_data_seg
  1270 000003EF 1F                  <1>         pop     ds
  1271 000003F0 A11000              <1>         mov     ax,[equipment_flag]     ; pick it out of the BDA
  1272 000003F3 1F                  <1>         pop     ds
  1273 000003F4 CF                  <1>         iret
  1274                              <1> 
  1275                              <1> 
  1276                              <1> 
  1277                              <1> 
  1278                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1279                              <1> ;  BIOS_call_12h
  1280                              <1> ;
  1281                              <1> ;       Get Conventional Memory Size
  1282                              <1> ;
  1283                              <1> ;  N.B.:  This BIOS call shares the interrupt vector with Timer 1.
  1284                              <1> ;       Thus we need to see if an "int 12h" called us, otherwise
  1285                              <1> ;       we assume this was a Timer 1 interrupt.
  1286                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1287                              <1> ; stack
  1288                              <1> offset_SI	equ	0
  1289                              <1> offset_DS	equ	offset_SI+2
  1290                              <1> offset_IP       equ     offset_DS+2
  1291                              <1> offset_CS       equ     offset_IP+2
  1292                              <1> offset_FLAGS    equ     offset_CS+2
  1293                              <1> 
  1294                              <1> BIOS_call_12h:
  1295 000003F5 1E                  <1>         push    ds
  1296 000003F6 56                  <1>         push    si
  1297 000003F7 89E6                <1>         mov     si,sp           ; establish stack addressing
  1298 000003F9 36C57404            <1>    ss   lds     si,[offset_IP+si]
  1299                              <1>         cnop
  1300 000003FD 817CFECD12          <1>         cmp     word [si-2],12CDh       ; int 12h
  1301 00000402 5E                  <1>         pop     si
  1302 00000403 7404                <1>         je      .4
  1303 00000405 1F                  <1>         popm	ds
  1304                              <1> ; since the segment is already correct...
  1305                              <1> 	extern	timer1_interrupt
  1306 00000406 E9(0000)            <1> 	jmp	timer1_interrupt
  1307                              <1> 
  1308 00000409 6A40                <1> .4:     push    bios_data_seg
  1309 0000040B 1F                  <1>         pop     ds
  1310 0000040C A11300              <1>         mov     ax,[memory_size]
  1311 0000040F 1F                  <1>         pop     ds
  1312 00000410 CF                  <1>         iret
  1313                              <1> 
  1314                              <1> 
  1315                              <1> 
  1316                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1317                              <1> ;  Memory Test
  1318                              <1> ;       Enter with segment to test in AX
  1319                              <1> ;
  1320                              <1> ;       Return: C=1 if error, (DI==loc)
  1321                              <1> ;               C=0 if no error
  1322                              <1> ;
  1323                              <1> ;       AX, CX, DX, BP, DI, ES are all destroyed
  1324                              <1> ;       DS, BX & SI are preserved
  1325                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1326                              <1> memtest:
  1327 00000411 5D                  <1>         pop     bp              ; save return address in BP
  1328                              <1> memtest0:                       ; entry to test page 0
  1329 00000412 FC                  <1>         cld                     ; clear the direction flag
  1330 00000413 8EC0                <1>         mov     es,ax           ; set segment
  1331 00000415 31FF                <1>         xor     di,di
  1332 00000417 B85AA5              <1>         mov     ax,0A55Ah       ; alternating bits in alternating bytes
  1333 0000041A B90080              <1>         mov     cx,8000h        ; test 64K (2 x 32K)
  1334 0000041D F3AB                <1>         rep stosw               ; 
  1335 0000041F B580                <1>         mov     ch,80h          ; 32K count of words
  1336 00000421 F3AF                <1>         repe scasw
  1337 00000423 754F                <1>         jne     .3
  1338                              <1> 
  1339 00000425 86C4                <1>         xchg    al,ah           ; second pattern
  1340 00000427 B580                <1>         mov     ch,80h          ; 32K count of words
  1341 00000429 F3AB                <1>         rep stosw
  1342 0000042B B580                <1>         mov     ch,80h          ; 32K count of words
  1343 0000042D F3AF                <1>         repe scasw
  1344 0000042F 7543                <1>         jne     .3
  1345                              <1> %if 1
  1346                              <1> seed1   equ     47F8h           ; NOT a random value
  1347                              <1>                                 ; Seed values are chosen to have a relatively
  1348                              <1>                                 ; prime cycle length, and to never produce a zero
  1349                              <1>                                 ; Most random values will produce a zero!!!!
  1350                              <1> 
  1351 00000431 B8F847              <1>         mov     ax,seed1        ; seed value (critical)
  1352                              <1>                                 ; cycle is 111 locations, relative prime to 2**15
  1353 00000434 B580                <1>         mov     ch,80h          ; 32K words
  1354                              <1> .t1:
  1355 00000436 268905              <1>     es  mov     [di],ax         ; store the value
  1356 00000439 F7E0                <1>         mul     ax
  1357 0000043B 47                  <1>         inc     di
  1358 0000043C 88E0                <1>         mov     al,ah           ; generate the next bit pattern
  1359 0000043E 47                  <1>         inc     di
  1360 0000043F 88D4                <1>         mov     ah,dl
  1361                              <1> %if 0
  1362                              <1> .t102:  or      ax,ax           ; trap a bad seed value
  1363                              <1>         jz      .t102
  1364                              <1> %endif
  1365 00000441 E2F3                <1>         loop    .t1             ; fill memory with the pattern
  1366                              <1> 
  1367 00000443 B8F847              <1>         mov     ax,seed1
  1368 00000446 B580                <1>         mov     ch,80h          ; 32K words
  1369                              <1> .t11:
  1370 00000448 263B05              <1>     es  cmp     ax,[di]
  1371 0000044B 8D7D02              <1>         lea     di,[di+2]       ; don't touch the Zero flag
  1372 0000044E 7524                <1>         jne     .3
  1373 00000450 F7E0                <1>         mul     ax
  1374 00000452 88E0                <1>         mov     al,ah
  1375 00000454 88D4                <1>         mov     ah,dl
  1376 00000456 E2F0                <1>         loop    .t11
  1377                              <1> 
  1378                              <1> %endif
  1379 00000458 B8FFFF              <1>         mov     ax,0FFFFh       ; solid pattern of 1's
  1380 0000045B B580                <1>         mov     ch,80h          ; 32K count of words
  1381 0000045D F3AB                <1>         rep stosw
  1382 0000045F B580                <1>         mov     ch,80h          ; 32K count of words
  1383 00000461 F3AF                <1>         repe scasw
  1384 00000463 750F                <1>         jne     .3
  1385                              <1>         
  1386 00000465 31C0                <1>         xor     ax,ax           ; solid pattern of 0's
  1387 00000467 B580                <1>         mov     ch,80h          ; 32K count of words
  1388 00000469 F3AB                <1>         rep stosw
  1389 0000046B B580                <1>         mov     ch,80h          ; 32K count of words
  1390 0000046D F3AF                <1>         repe scasw
  1391 0000046F 7503                <1>         jne     .3
  1392                              <1>         
  1393 00000471 F8                  <1>         clc                     ; no error
  1394 00000472 FFE5                <1>         jmp     bp
  1395                              <1> 
  1396                              <1> .3: ; ERROR in scan string
  1397 00000474 4F                  <1>         dec     di
  1398 00000475 263A25              <1>    es   cmp     ah,[di]
  1399 00000478 7401                <1>         je      .4
  1400 0000047A 4F                  <1>         dec     di
  1401                              <1> .4:
  1402 0000047B F9                  <1>         stc
  1403 0000047C FFE5                <1>         jmp     bp
  1404                              <1> 
  1405                              <1> 
  1406                              <1> 
  1407                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1408                              <1> ; POST_memory -- Power On Self Test of Memory
  1409                              <1> ;
  1410                              <1> ;
  1411                              <1> ;  Enter with:
  1412                              <1> ;       AX = memory limit in kilobytes
  1413                              <1> ;	DS = DGROUP
  1414                              <1> ;	SS = bios_data_seg
  1415                              <1> ;
  1416                              <1> ;  Watch out, "memtest" clobbers segment registers
  1417                              <1> ;
  1418                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1419                              <1> POST_memory:
  1420 0000047E 0660                <1>         pushm   ALL,es	; ,ds
  1421 00000480 36813E72003412      <1>     ss	cmp	word [warm_boot],1234h
  1422 00000487 36C70672007856      <1>     ss 	mov	word [warm_boot],5678h	; non-magic value!!!
  1423 0000048E 7507                <1>     	jne	.001
  1424 00000490 1E                  <1> 	push	ds
  1425 00000491 68[5000]            <1> 	push	msg_mem_bypass
  1426 00000494 E99800              <1> 	jmp	.print
  1427                              <1> .001:
  1428 00000497 C1E006              <1>         shl     ax,6                    ; memory size in paragraphs
  1429 0000049A 89C3                <1>         mov     bx,ax                   ; save in BX
  1430                              <1> .1:
  1431 0000049C BA0010              <1>         mov     dx,1000h                ; seg. 0000:xxxx has been tested
  1432 0000049F 29D3                <1>         sub     bx,dx
  1433 000004A1 7432                <1>         jz      .8                      ; done if down to zero
  1434 000004A3 39D3                <1>         cmp     bx,dx
  1435 000004A5 7302                <1>         jae     .2
  1436 000004A7 89D3                <1>         mov     bx,dx
  1437                              <1> .2:
  1438 000004A9 53                  <1>         push    bx
  1439                              <1> 
  1440 000004AA 53                  <1>         push    bx
  1441 000004AB 1E                  <1>         push    ds		;DGROUP
  1442 000004AC 68[0000]            <1>         push    msg_mem_test
  1443 000004AF E8(0000)            <1>         call    _cprintf
  1444 000004B2 83C406              <1>         add     sp,6 
  1445                              <1> 
  1446 000004B5 5B                  <1>         pop     bx
  1447 000004B6 89D8                <1>         mov     ax,bx                   ; AX is segment tested
  1448 000004B8 E856FF              <1>         call    memtest
  1449                              <1> 
  1450                              <1> %if 0
  1451                              <1> ;  induce an error to see printout
  1452                              <1>         mov     di,3465h
  1453                              <1>         stc
  1454                              <1> %endif
  1455 000004BB 73DF                <1>         jnc     .1
  1456                              <1> ; make an error report
  1457                              <1> 
  1458 000004BD 89FA                <1>         mov     dx,di           ; copy byte address
  1459 000004BF C1EF04              <1>         shr     di,4            ; convert to paragraphs
  1460 000004C2 01DF                <1>         add     di,bx           ; DI is total paragraphs
  1461 000004C4 83E20F              <1>         and     dx,0Fh          ; single-byte byte address
  1462 000004C7 52                  <1>         push    dx
  1463 000004C8 57                  <1>         push    di
  1464 000004C9 1E                  <1>         push    ds		; DGROUP
  1465 000004CA 68[7400]            <1>         push    msg_mem_error
  1466 000004CD E8(0000)            <1>         call    _cprintf
  1467 000004D0 83C408              <1>         add     sp,8
  1468                              <1> 
  1469 000004D3 EBC7                <1>         jmp     .1
  1470                              <1> 
  1471                              <1> .8:
  1472                              <1> %if SOFT_DEBUG==0
  1473                              <1> ; tested down to 1000:0000
  1474                              <1> ; now do the test at loc. 0  (watch out for the stack)
  1475 000004D5 53                  <1>         push    bx                      ; BX is zero
  1476 000004D6 1E                  <1>         push    ds		; DGROUP
  1477 000004D7 68[0000]            <1>         push    msg_mem_test
  1478 000004DA E8(0000)            <1>         call    _cprintf
  1479 000004DD 83C406              <1>         add     sp,6 
  1480                              <1> 
  1481 000004E0 1E9C                <1>         pushm   f,ds
  1482 000004E2 FA                  <1>         cli                             ; disable interrupts
  1483                              <1> 
  1484 000004E3 6A00                <1>         push    0
  1485 000004E5 1F                  <1>         pop     ds                      ; source is 0000:xxxx
  1486 000004E6 680010              <1>         push    1000h           
  1487 000004E9 07                  <1>         pop     es                      ; dest. is 1000:xxxx (save area)
  1488 000004EA 31F6                <1>         xor     si,si
  1489 000004EC 31FF                <1>         xor     di,di
  1490 000004EE B90080              <1>         mov     cx,8000h                ; 32k words == 64K bytes
  1491 000004F1 F3A5                <1>         rep movsw
  1492                              <1> 
  1493 000004F3 31C0                <1>         xor     ax,ax
  1494 000004F5 BD[FB04]            <1>         mov     bp,.85
  1495 000004F8 E917FF              <1>         jmp     memtest0
  1496                              <1> .85:
  1497                              <1> %if 0
  1498                              <1>         stc
  1499                              <1>         mov     di,8765h                ; force error reporting
  1500                              <1> %endif
  1501 000004FB 19D2                <1>         sbb     dx,dx                   ; grab the returned carry
  1502 000004FD 89FB                <1>         mov     bx,di                   ; save error location
  1503                              <1>         
  1504 000004FF 680010              <1>         push    1000h                   ; source is 1000:xxxx
  1505 00000502 1F                  <1>         pop     ds
  1506 00000503 6A00                <1>         push    0
  1507 00000505 07                  <1>         pop     es                      ; restore 0000:xxxx
  1508 00000506 31F6                <1>         xor     si,si
  1509 00000508 31FF                <1>         xor     di,di
  1510 0000050A B90080              <1>         mov     cx,8000h                ; 32k words == 64K bytes
  1511 0000050D F3A5                <1>         rep movsw
  1512                              <1> 
  1513 0000050F 1E                  <1>         push    ds
  1514 00000510 07                  <1>         pop     es
  1515 00000511 31C0                <1>         xor     ax,ax
  1516 00000513 B580                <1>         mov     ch,80h                  ; re-zero 1000:0000 ...
  1517 00000515 F3AB                <1>         rep stosw
  1518                              <1> 
  1519 00000517 9D1F                <1>         popm    f,ds
  1520                              <1> %endif
  1521 00000519 D1EA                <1>         shr     dx,1                    ; set the carry
  1522 0000051B 730E                <1>         jnc     .89
  1523                              <1> 
  1524                              <1> ; make the page 0 error report
  1525 0000051D 53                  <1>         push    bx
  1526 0000051E 1E                  <1>         push    ds			; DGROUP
  1527 0000051F 68[9200]            <1>         push    msg_mem_error0
  1528 00000522 E8(0000)            <1>         call    _cprintf
  1529 00000525 83C406              <1>         add     sp,6
  1530                              <1> 
  1531 00000528 F4                  <1> .88:    hlt
  1532 00000529 EBFD                <1>         jmp     .88
  1533                              <1> 
  1534                              <1> .89:
  1535 0000052B 1E                  <1>         push    ds			; DGROUP
  1536 0000052C 68[2000]            <1>         push    msg_mem_done
  1537                              <1> .print:
  1538 0000052F E8(0000)            <1>         call    _cprintf
  1539 00000532 83C404              <1>         add     sp,4
  1540                              <1> .9:
  1541 00000535 6107                <1>         popm    ALL,es ; ,ds
  1542 00000537 C3                  <1>         ret
  1543                              <1> 
  1544                              <1> 
  1545                              <1>         segment CONST
  1546                              <1> msg_mem_test:
  1547 00000000 0D2538615465737469- <1>         db      CR,"%8aTesting memory at %7a%04x:0",NUL
  1547 00000009 6E67206D656D6F7279- <1>
  1547 00000012 206174202537612530- <1>
  1547 0000001B 34783A3000          <1>
  1548                              <1> msg_mem_done:
  1549 00000020 0D253261502E4F2E53- <1>         db      CR,"%2aP.O.S.T. of memory %10aSUCCESSFUL        "
  1549 00000029 2E542E206F66206D65- <1>
  1549 00000032 6D6F72792025313061- <1>
  1549 0000003B 535543434553534655- <1>
  1549 00000044 4C2020202020202020  <1>
  1550                              <1> msg_mem_double:
  1551 0000004D 0A0A00              <1>         db      NL,NL,NUL
  1552                              <1> msg_mem_bypass:
  1553 00000050 0D253861502E4F2E53- <1> 	db	CR,"%8aP.O.S.T. of memory BYPASSED  ",NL,NL,NUL
  1553 00000059 2E542E206F66206D65- <1>
  1553 00000062 6D6F72792042595041- <1>
  1553 0000006B 5353454420200A0A00  <1>
  1554                              <1> msg_mem_error:
  1555 00000074 070A253134614D656D- <1>         db      BEL,NL,"%14aMemory error at %04x%x",NL,NUL
  1555 0000007D 6F7279206572726F72- <1>
  1555 00000086 206174202530347825- <1>
  1555 0000008F 780A00              <1>
  1556                              <1> msg_mem_error0:
  1557 00000092 070A253134614D656D- <1>         db      BEL,NL,"%14aMemory error at 0%04x",NL,NL
  1557 0000009B 6F7279206572726F72- <1>
  1557 000000A4 206174203025303478- <1>
  1557 000000AD 0A0A                <1>
  1558 000000AF 2A2A2A2A2A2A2A2A2A- <1>         db      "**************************",NL
  1558 000000B8 2A2A2A2A2A2A2A2A2A- <1>
  1558 000000C1 2A2A2A2A2A2A2A2A0A  <1>
  1559 000000CA 2A2020202020434154- <1>         db      "*     CATASTROPHE!!!     *",NL
  1559 000000D3 415354524F50484521- <1>
  1559 000000DC 212120202020202A0A  <1>
  1560 000000E5 2A2A2A2A2A2A2A2A2A- <1>         db      "**************************",NL,NL
  1560 000000EE 2A2A2A2A2A2A2A2A2A- <1>
  1560 000000F7 2A2A2A2A2A2A2A2A0A- <1>
  1560 00000100 0A                  <1>
  1561 00000101 48616C74696E672064- <1>         db      "Halting due to error in segment 0000:xxxx",BEL,NL
  1561 0000010A 756520746F20657272- <1>
  1561 00000113 6F7220696E20736567- <1>
  1561 0000011C 6D656E742030303030- <1>
  1561 00000125 3A78787878070A      <1>
  1562 0000012C 00                  <1>         db      NUL
  1563 0000012D 00                  <1> 	db	0
  1564                              <1> 
  1565                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1566                              <1> ;
  1567                              <1> ;       Expanded Memory (EMM/4MEM) support -- LIM EMS
  1568                              <1> ;
  1569                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1570                              <1> %if EMM_BOARDS
  1571                              <1> 
  1572                              <1>  %if SBC188<3
  1573                              <1> ; Define the UMB mask; '1' bit means allocate it
  1574                              <1> UMB_MASK_80     equ     ~(0FFFFh<<((RAM_DOS-RAM)/16))   ; segments 8000,9000
  1575                              <1>                                                         ; skip A000,B000
  1576                              <1> UMB_MASK_C0     equ     0FFFFh>>(CHIP/16)                ; segments C000,D000,...
  1577                              <1>                                                         ; up to start of ROM
  1578                              <1>  %else
  1579                              <1> UMB_MASK_80	equ	0000h
  1580                              <1> UMB_MASK_C0	equ	0000h		; nothing to allocate on v3 board
  1581                              <1>  %endif        
  1582                              <1> 
  1583                              <1>         segment CONST
  1584                              <1> emm_board_list:
  1585                              <1> 
  1586                              <1> %assign xemm EMM0
  1587                              <1> %rep    EMM_BOARDS
  1588                              <1>         dw      xemm
  1589                              <1> %assign xemm (xemm+EMM1-EMM0)
  1590                              <1> %endrep
  1588 0000012E 0004                <2>  dw xemm
  1589                              <2> %assign xemm (xemm+EMM1-EMM0)
  1588 00000130 0204                <2>  dw xemm
  1589                              <2> %assign xemm (xemm+EMM1-EMM0)
  1588 00000132 0404                <2>  dw xemm
  1589                              <2> %assign xemm (xemm+EMM1-EMM0)
  1588 00000134 0604                <2>  dw xemm
  1589                              <2> %assign xemm (xemm+EMM1-EMM0)
  1591 00000136 FFFF                <1>         dw      -1
  1592                              <1> 
  1593                              <1>         segment _TEXT
  1594                              <1> EMM_init0:
  1595 00000538 601E                <1>         pushm   ds,all
  1596                              <1> ;;        cld           ; already done!
  1597 0000053A 68[ssss]            <1>         push    DGROUP               ; address CONST segment
  1598 0000053D 1F                  <1>         popm    ds
  1599 0000053E BE[2E01]            <1>         mov     si,emm_board_list
  1600                              <1> 
  1601                              <1> ; clear all of the paging registers
  1602                              <1> ; with no reads, the board(s) remain disabled for now
  1603 00000541 AD                  <1> .0:     lodsw           ; get page data reg I/O code
  1604 00000542 40                  <1>         inc     ax      ; get address reg I/O code
  1605 00000543 7412                <1>         jz      .3
  1606 00000545 89C2                <1>         mov     dx,ax
  1607 00000547 B94000              <1>         mov     cx,64   ; number of address reg entries
  1608                              <1> .1:
  1609 0000054A 89C8                <1>         mov     ax,cx
  1610 0000054C 48                  <1>         dec     ax      ; 
  1611 0000054D EE                  <1>         out     dx,al   ; set the address
  1612 0000054E 4A                  <1>         dec     dx      ; get page data reg I/O code
  1613 0000054F B0FF                <1>         mov     al,EMM_unmapped
  1614 00000551 EE                  <1>         out     dx,al
  1615 00000552 42                  <1>         inc     dx      ; get address reg I/O code
  1616 00000553 E2F5                <1>         loop    .1
  1617 00000555 EBEA                <1>         jmp     .0      ; go on to the next board
  1618                              <1> 
  1619                              <1> ; assign memory above 512K, usually up to the 640K limit
  1620                              <1> .3:
  1621 00000557 8B16[2E01]          <1>         mov     dx,[emm_board_list]
  1622 0000055B BB2000              <1>         mov     bx,RAM/16       ; get size of physical RAM chip
  1623                              <1>  check  (RAM-512)
  1624 0000055E B90000              <1>         mov     cx,UMB_MASK_80 & 0FFFFh  ; bits to allocate
  1625 00000561 BE0000              <1>         mov     si,UMB_MASK_C0 & 0FFFFh  ; **
  1626                              <1> .4:
  1627 00000564 89CF                <1>         mov     di,cx           ; test for done
  1628 00000566 09F7                <1>         or      di,si
  1629 00000568 741A                <1>         jz      .6
  1630                              <1> 
  1631 0000056A D1EE                <1>         shr     si,1            ; shift bit into carry
  1632 0000056C D1D9                <1>         rcr     cx,1            ; carry is next to allocate
  1633 0000056E 7310                <1>         jnc     .5              ; skip allocation if zero
  1634                              <1> 
  1635 00000570 42                  <1>         inc     dx
  1636 00000571 88D8                <1>         mov     al,bl           ; page address
  1637 00000573 EE                  <1>         out     dx,al           ; set address
  1638 00000574 4A                  <1>         dec     dx
  1639 00000575 88F8                <1>         mov     al,bh
  1640 00000577 EE                  <1>         out     dx,al
  1641 00000578 90                  <1>         nop
  1642 00000579 EC                  <1>         in      al,dx           ; enable board
  1643 0000057A 38C7                <1>         cmp     bh,al
  1644 0000057C 750E                <1>         jne     .9
  1645                              <1> 
  1646 0000057E FEC7                <1>         inc     bh              ; increment page
  1647 00000580 FEC3                <1> .5:     inc     bl              ; increment address
  1648 00000582 EBE0                <1>         jmp     .4              ; loop back
  1649                              <1> ; all of the Upper Memory Blocks are allocated (no EMS yet)
  1650                              <1> .6:
  1651 00000584 EC                  <1>         in      al,dx           ; enable board if not done above
  1652                              <1>         
  1653 00000585 6A40                <1>         push    bios_data_seg
  1654 00000587 1F                  <1>         pop     ds
  1655 00000588 883EAF00            <1>         mov     [EMS_start],bh  ; save start page
  1656                              <1> .9:
  1657 0000058C 1F61                <1>         popm    ds,all
  1658 0000058E C3                  <1>         ret
  1659                              <1> %endif
  1660                              <1> 
  1189                                  
  1190                                  %if SBC188==1
  1191                                  %include        "ds1302.asm"
  1192                                  %elif SBC188==3
  1193                                  %include	"ds3uart.asm"
  1194                              <1> ;========================================================================
  1195                              <1> ; DS3UART.ASM -- support on the SBC-188v3 for the DS1302 chip
  1196                              <1> ;========================================================================
  1197                              <1> ;
  1198                              <1> ;   This version is for assembly by  NASM 2.08
  1199                              <1> ;
  1200                              <1> ; Copyright (C) 2010   John R. Coffman
  1201                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board
  1202                              <1> ;
  1203                              <1> ; This program is free software: you can redistribute it and/or modify
  1204                              <1> ; it under the terms of the GNU General Public License as published by
  1205                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1206                              <1> ; (at your option) any later version.
  1207                              <1> ;
  1208                              <1> ; This program is distributed in the hope that it will be useful,
  1209                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1210                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1211                              <1> ; GNU General Public License for more details.
  1212                              <1> ;
  1213                              <1> ; You should have received a copy of the GNU General Public License
  1214                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1215                              <1> ;
  1216                              <1> ;========================================================================
  1217                              <1> 
  1218                              <1>         segment         _TEXT
  1219                              <1> 
  1220                              <1> 
  1221                              <1> ; in the MCR - modem control register  (uart+4)
  1222                              <1> rtc_data        equ     1	;DTR	; Data mask bit
  1223                              <1> ;			2	;RTS
  1224                              <1> rtc_clk         equ     4	;OUT1	; Clock signal (true)
  1225                              <1> rtc_rst         equ     8	;OUT2	; Reset bit  (1=reset, 0=enable)
  1226                              <1> 
  1227                              <1> ; in the MSR - modem status register   (uart+6)
  1228                              <1> rtd_data_in	equ	128	;DCD	; Data in bit
  1229                              <1> 
  1230                              <1> 
  1231                              <1> 
  1232                              <1> ;        global  _rtc_reset
  1233                              <1> rtc_reset:
  1234 0000058F BA8406              <1>         mov     dx,uart_mcr             ; set the device code
  1235 00000592 EC                  <1> 	in	al,dx			; read current value
  1236 00000593 24FB                <1> 	and	al,~rtc_clk		; clock low
  1237 00000595 E80F00              <1> 	call	rtc_out
  1238                              <1> 
  1239 00000598 0C08                <1>         or      al,rtc_rst		; reset on
  1240                              <1> %if SOFT_DEBUG
  1241                              <1> 	test	al,2		; test if RTS is gone
  1242                              <1> 	jnz	rtc_out
  1243                              <1> 	push	dx
  1244                              <1> 	mov	dx,4FFh
  1245                              <1> 	out	dx,al
  1246                              <1> 	hlt
  1247                              <1> 	jmp	$-1
  1248                              <1> 	pop	dx
  1249                              <1> %endif
  1250 0000059A EB0B                <1>         jmp     rtc_out
  1251                              <1> 
  1252                              <1> 
  1253                              <1> ;        global  _rtc_reset_off
  1254                              <1> rtc_reset_off:
  1255 0000059C BA8406              <1>         mov     dx,uart_mcr
  1256 0000059F EC                  <1> 	in	al,dx
  1257 000005A0 24FB                <1> 	and	al,~rtc_clk		; set clock low
  1258 000005A2 E80200              <1> 	call	rtc_out
  1259 000005A5 24F7                <1> 	and	al,~rtc_rst		; turn reset off
  1260                              <1> ; assume clock is low from previous reset_on
  1261                              <1> 
  1262                              <1> rtc_out:
  1263 000005A7 BA8406              <1> 	mov	dx,uart_mcr	; insurance, for the moment
  1264 000005AA EE                  <1>         out     dx,al
  1265 000005AB B91000              <1>         mov     cx,16
  1266 000005AE E97AFD              <1>         jmp     microsecond             ; delay 16 us
  1267                              <1> 
  1268                              <1> 
  1269                              <1> ;        global  @rtc_write
  1270                              <1> @rtc_write:
  1271                              <1> rtc_write:
  1272 000005B1 53                  <1>         push    bx
  1273                              <1> 
  1274 000005B2 88C4                <1>         mov     ah,al                   ; save data in AH
  1275 000005B4 B308                <1>         mov     bl,8                    ; set loop count
  1276                              <1> 
  1277 000005B6 BA8406              <1>         mov     dx,uart_mcr
  1278 000005B9 EC                  <1> 	in	al,dx			; get current state
  1279                              <1> ; assume reset is off
  1280 000005BA 24FB                <1> .1:	and	al,~rtc_clk		; set clock low
  1281 000005BC E8E8FF              <1> 	call	rtc_out
  1282                              <1> 
  1283 000005BF D1E8                <1> 	shr	ax,1			; data to bit 7, old DTR to carry
  1284 000005C1 D0C0                <1> 	rol	al,1			; data to bit 0
  1285 000005C3 E8E1FF              <1>         call    rtc_out                 ; put out the data
  1286                              <1> 
  1287 000005C6 0C04                <1>         or      al,rtc_clk              ; set the clock bit
  1288 000005C8 E8DCFF              <1>         call    rtc_out                 ; put out the data
  1289                              <1> 
  1290 000005CB FECB                <1>         dec     bl                      ; count a bit
  1291 000005CD 75EB                <1>         jnz     .1
  1292                              <1> 
  1293                              <1> ; rtc_write ends with the reset off, clock high, data bit unknown
  1294                              <1> 
  1295 000005CF 5B                  <1>         pop     bx
  1296 000005D0 C3                  <1>         ret
  1297                              <1> 
  1298                              <1> 
  1299                              <1> 
  1300                              <1> 
  1301                              <1> rtc_read:
  1302 000005D1 53                  <1>         push    bx
  1303                              <1> 
  1304 000005D2 B308                <1>         mov     bl,8                    ; bit count
  1305                              <1> 
  1306 000005D4 BA8406              <1> .1:	mov     dx,uart_mcr
  1307 000005D7 EC                  <1> 	in	al,dx			; get current state
  1308 000005D8 0C05                <1> 	or	al,rtc_clk+rtc_data
  1309 000005DA E8CAFF              <1> 	call	rtc_out			; clock high, data high for read
  1310                              <1> 
  1311 000005DD 24F3                <1> 	and	al,~(rtc_rst+rtc_clk)	; reset off, clock off
  1312 000005DF E8C5FF              <1>         call    rtc_out
  1313                              <1> ; delay was included in the above output call
  1314 000005E2 BA8606              <1> 	mov	dx,uart_msr		; data is in bit 7
  1315 000005E5 EC                  <1>         in      al,dx                   ; read a data bit
  1316 000005E6 D0D0                <1> 	rcl	al,1			; shift into Carry
  1317 000005E8 D0DC                <1> 	rcr	ah,1			; and rotate into the left of AH
  1318                              <1> 
  1319 000005EA FECB                <1> 	dec     bl
  1320 000005EC 75E6                <1>         jnz     .1
  1321                              <1> 
  1322 000005EE C1E808              <1>         shr     ax,8                    ; return data in AL,  AH=0
  1323                              <1> 
  1324                              <1> ; rtc_read ends with reset off, clock low, data high
  1325                              <1> ; MSR, not MCR is in DX
  1326                              <1> 
  1327 000005F1 5B                  <1>         pop     bx
  1328 000005F2 C3                  <1>         ret
  1329                              <1> 
  1330                              <1> 
  1331                              <1> 
  1332                              <1> 
  1333                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1334                              <1> ;  rtc_get_loc          RTC get location as addressed
  1335                              <1> ;       Enter with      AL = address of the location to get
  1336                              <1> ;                       AH = Flag RAM/clock  (RAM=!0, clock=0)
  1337                              <1> ;       Exit with data in AL
  1338                              <1> ;               All other registers are preserved
  1339                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1340                              <1>         global  @rtc_get_loc
  1341                              <1>         global  rtc_get_loc
  1342                              <1> @rtc_get_loc:
  1343                              <1> rtc_get_loc:
  1344 000005F3 52                  <1>         push    dx
  1345 000005F4 51                  <1>         push    cx              ; 3 register saves
  1346 000005F5 53                  <1>         push    bx
  1347                              <1> 
  1348 000005F6 08E4                <1>         or      ah,ah           ; test flag
  1349 000005F8 7402                <1>         jz      .1
  1350 000005FA B440                <1>         mov     ah,040h         ; RAM flag
  1351 000005FC 88E7                <1> .1:     mov     bh,ah           ; save flag in BH
  1352 000005FE 241F                <1>         and     al,31           ; mask address to 5 bits
  1353 00000600 00C0                <1>         add     al,al           ; shift left
  1354 00000602 08C7                <1>         or      bh,al           ; form command
  1355 00000604 80CF81              <1>         or      bh,81h          ; Clock Command / READ bit = 01h
  1356                              <1> 
  1357 00000607 E885FF              <1>         call    rtc_reset
  1358 0000060A E88FFF              <1>         call    rtc_reset_off   ; signal that a command is coming
  1359 0000060D 88F8                <1>         mov     al,bh
  1360 0000060F E89FFF              <1>         call    rtc_write       ; write out the command
  1361 00000612 E8BCFF              <1>         call    rtc_read        ; read the data location
  1362 00000615 50                  <1>         push    ax              ; save the result
  1363 00000616 E883FF              <1> 	call	rtc_reset_off	;
  1364 00000619 E873FF              <1>         call    rtc_reset       ; and finish up  
  1365                              <1> 
  1366 0000061C 58                  <1>         pop     ax              ; return value
  1367                              <1> 
  1368 0000061D 5B                  <1>         pop     bx
  1369 0000061E 59                  <1>         pop     cx              ; plus 3 register restores
  1370 0000061F 5A                  <1>         pop     dx
  1371 00000620 C3                  <1>         ret
  1372                              <1> 
  1373                              <1> 
  1374                              <1> 
  1375                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1376                              <1> ;  rtc_set_loc          RTC set location as addressed
  1377                              <1> ;       Enter with      AL = address of the location to set
  1378                              <1> ;                       AH = Flag RAM/clock  (RAM=!0, clock=0)
  1379                              <1> ;                       DL = data to write to location
  1380                              <1> ;               AX is undefined on return
  1381                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1382                              <1>         global  @rtc_set_loc
  1383                              <1>         global  rtc_set_loc
  1384                              <1> @rtc_set_loc:
  1385                              <1> rtc_set_loc:
  1386 00000621 52                  <1>         push    dx
  1387 00000622 51                  <1>         push    cx              ; 3 register saves
  1388 00000623 53                  <1>         push    bx
  1389                              <1> 
  1390 00000624 52                  <1>         push    dx              ; save data
  1391                              <1> 
  1392 00000625 08E4                <1>         or      ah,ah           ; test flag
  1393 00000627 7402                <1>         jz      .1
  1394 00000629 B440                <1>         mov     ah,040h         ; RAM flag
  1395 0000062B 88E7                <1> .1:     mov     bh,ah           ; save flag in BH
  1396 0000062D 241F                <1>         and     al,31           ; mask address to 5 bits
  1397 0000062F 00C0                <1>         add     al,al           ; shift left
  1398 00000631 08C7                <1>         or      bh,al           ; form command
  1399 00000633 80CF80              <1>         or      bh,80h          ; Clock Command / WRITE bit = 00h
  1400                              <1> 
  1401 00000636 E856FF              <1>         call    rtc_reset
  1402 00000639 E860FF              <1>         call    rtc_reset_off   ; signal that a command is coming
  1403 0000063C 88F8                <1>         mov     al,bh           ; command to AL
  1404 0000063E E870FF              <1>         call    rtc_write       ; write out the command
  1405 00000641 58                  <1>         pop     ax              ; get the data value
  1406 00000642 E86CFF              <1>         call    rtc_write       ; write the data
  1407 00000645 E854FF              <1>         call    rtc_reset_off   ; end of command
  1408 00000648 E844FF              <1>         call    rtc_reset
  1409                              <1> 
  1410 0000064B 5B                  <1>         pop     bx
  1411 0000064C 59                  <1>         pop     cx              ; plus 3 register restores
  1412 0000064D 5A                  <1>         pop     dx
  1413 0000064E C3                  <1>         ret
  1414                              <1> 
  1415                              <1> 
  1416                              <1> 
  1417                              <1> 
  1418                              <1> 
  1194                                  %else
  1195                                  %error	"SBC188 is of unknown value
  1196                                  %endif
  1197                                  
  1198                                  %if SOFT_DEBUG+1
  1199                                          global  lites
  1200                                  ; call with:
  1201                                  ;       push    code    ; code in AL
  1202                                  ;       call    lites
  1203                                  ;
  1204 0000064F 55                      lites:  push    bp
  1205 00000650 89E5                            mov     bp,sp           ; establish stack frame
  1206 00000652 5250                            pushm   ax,dx
  1207 00000654 8A4604                          mov     al,[bp+4]
  1208 00000657 BAFF04                          mov     dx,portD
  1209 0000065A EE                              out     dx,al
  1210 0000065B 585A                            popm    ax,dx
  1211 0000065D 5D                              pop     bp
  1212 0000065E C20200                          ret     2               ; remove argument
  1213                                  %endif
  1214                                  
  1215                                  %if 0
  1216                                  ; _FPSIGNAL:
  1217                                  ;   Enter with AL = condensed error code
  1218                                  ;
  1219                                  	global	_FPSIGNAL
  1220                                  _FPSIGNAL:
  1221                                  	xor	ah,ah
  1222                                  	push	ax
  1223                                  	push	DGROUP
  1224                                  	push	msg_fpu_err
  1225                                  	call	_cprintf
  1226                                  	add	sp,6
  1227                                  	ret
  1228                                  %endif
  1229                                  
  1230                                  
  1231                                  
  1232                                  
  1233                                  ident3:
  1234                                  %if SOFT_DEBUG
  1235                                          db      NL
  1236                                  	db	"%7a"
  1237                                          db      "             ***** SOFT BIOS *****"
  1238                                          db      NL
  1239                                  %endif
  1240                                  %ifdef __DATE__
  1241                                  %ifdef __TIME__
  1242 00000661 0A                              db      NL
  1243 00000662 25313461                	db	"%14a"
  1244 00000666 546869732042494F53-             db      "This BIOS copy was built at ",__TIME__," ",TIMEZONE
  1244 0000066F 20636F707920776173-
  1244 00000678 206275696C74206174-
  1244 00000681 2032333A33353A3338-
  1244 0000068A 20505354           
  1245 0000068E 206F6E20323032342D-             db      " on ", __DATE__
  1245 00000697 30392D3134         
  1246                                  %endif
  1247                                  %endif
  1248 0000069C 2E2020202020202020-             db      ".                    [%d]",NL
  1248 000006A5 202020202020202020-
  1248 000006AE 2020205B25645D0A   
  1249 000006B6 00                              db      0
  1250                                  	
  1251                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1252                                  ;  This is the banner which prints out first.
  1253                                  ;  The letters are variable width; B is wide; -, and 1 are kerned.
  1254                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1255                                  ident1:
  1256 000006B7 0A253961                        db      NL,"%9a"
  1257 000006BB 202020535353202020-             db      "   SSS   BBBBB    CCC           1     888    888",	NL
  1257 000006C4 424242424220202020-
  1257 000006CD 434343202020202020-
  1257 000006D6 202020202031202020-
  1257 000006DF 202038383820202020-
  1257 000006E8 3838380A           
  1258 000006EC 202053202020532020-             db      "  S   S   B   B  C   C         11    8   8  8   8",	NL
  1258 000006F5 204220202042202043-
  1258 000006FE 202020432020202020-
  1258 00000707 202020203131202020-
  1258 00000710 203820202038202038-
  1258 00000719 202020380A         
  1259 0000071E 202020532020202020-             db      "   S      B   B  C              1    8   8  8   8",	NL
  1259 00000727 204220202042202043-
  1259 00000730 202020202020202020-
  1259 00000739 202020202031202020-
  1259 00000742 203820202038202038-
  1259 0000074B 202020380A         
  1260 00000750 202020205320202020-             db      "    S     BBBB   C      HHHH    1     888    888",	NL
  1260 00000759 204242424220202043-
  1260 00000762 202020202020484848-
  1260 0000076B 482020202031202020-
  1260 00000774 202038383820202020-
  1260 0000077D 3838380A           
  1261 00000781 202020202053202020-             db      "     S    B   B  C              1    8   8  8   8             rev. ", VERSION, NL
  1261 0000078A 204220202042202043-
  1261 00000793 202020202020202020-
  1261 0000079C 202020202031202020-
  1261 000007A5 203820202038202038-
  1261 000007AE 202020382020202020-
  1261 000007B7 202020202020202072-
  1261 000007C0 65762E20332E352D31-
  1261 000007C9 0A                 
  1262 000007CA 202053202020532020-             db      "  S   S   B   B  C   C          1    8   8  8   8             of ", DATE, NL   
  1262 000007D3 204220202042202043-
  1262 000007DC 202020432020202020-
  1262 000007E5 202020202031202020-
  1262 000007EE 203820202038202038-
  1262 000007F7 202020382020202020-
  1262 00000800 20202020202020206F-
  1262 00000809 662032392D4170722D-
  1262 00000812 323032310A         
  1263 00000817 202020535353202020-             db      "   SSS   BBBBB    CCC         11111   888    888                  ("
  1263 00000820 424242424220202020-
  1263 00000829 434343202020202020-
  1263 00000832 202020313131313120-
  1263 0000083B 202038383820202020-
  1263 00000844 383838202020202020-
  1263 0000084D 202020202020202020-
  1263 00000856 20202028           
  1264                                  %if ANSI
  1265 0000085A 414E5349                        db      "ANSI"
  1266                                  %elif WYSE
  1267                                          db      "Wyse"
  1268                                  %elif DUMB
  1269                                          db      "dumb"
  1270                                  %elif TTY
  1271                                          db      "tty"
  1272                                  %else
  1273                                          db      "???"
  1274                                  %endif
  1275 0000085E 290A                            db      ")",NL
  1276                                  
  1277                                  ;	db      NL
  1278                                  ;	db	"%12a"		; color for the Copyright notice
  1279                                  
  1280 00000860 00                      	db      0
  1281                                  
  1282                                  
  1283 00000861 90<rep Fh>              	align	16
  1284                                  
  1285                                  bulk_of_code_end        equ     $
  1286                                  
  1287                                  
  1288                                  
  1289                                          segment CONST
  1290                                  %if SOFT_DEBUG
  1291                                  %else
  1292                                  %if (CVDU_8563 | VGA3_6445)
  1293                                  	global	_Font
  1294                                  _Font	dw	0, 0F680h		; loaded at absolute location
  1295                                  %endif
  1296                                  %endif
  1297                                  
  1298                                  
  1299                                          global  _bios_data_area_ptr
  1300                                  _bios_data_area_ptr:
  1301 00000138 00004000                        dw      0000h,bios_data_seg     ; pointer 40:0
  1302                                  
  1303                                  
  1304                                  msg_cpu_memory:
  1305 0000013C 253135612564257320-     	db	"%15a%d%s %2aMhz CPU clock, %15a%u%2aK memory installed"
  1305 00000145 2532614D687A204350-
  1305 0000014E 5520636C6F636B2C20-
  1305 00000157 253135612575253261-
  1305 00000160 4B206D656D6F727920-
  1305 00000169 696E7374616C6C6564 
  1306                                  %if CVDU_8563
  1307                                  	db	", with %15a%d%2aK ColorVDU memory"
  1308                                  %endif
  1309                                  %if VGA3_6445
  1310                                  	db	", with %15a32%2aK VGA3 memory"
  1311                                  %endif
  1312 00000172 0A00                    	db	NL, 0
  1313                                  msg_cpu_clock_05:
  1314 00000174 2E3500                  	db	".5", 0
  1315                                  msg_cpu_clock_00:
  1316 00000177 00                      	db	0
  1317                                  msg_setup:
  1318 00000178 507265737320277327-     	db	"Press 's' to run NVRAM setup...", NL, 0
  1318 00000181 20746F2072756E204E-
  1318 0000018A 5652414D2073657475-
  1318 00000193 702E2E2E0A00       
  1319                                  msg_nvram_bad:
  1320 00000199 4E5652414D20636865-     	db	"NVRAM checksum is invalid, running setup", NL, 0
  1320 000001A2 636B73756D20697320-
  1320 000001AB 696E76616C69642C20-
  1320 000001B4 72756E6E696E672073-
  1320 000001BD 657475700A00       
  1321                                  msg_floppy:
  1322 000001C3 4E6F7720696E697469-     	db	"Now initializing floppy", NL, 0
  1322 000001CC 616C697A696E672066-
  1322 000001D5 6C6F7070790A00     
  1323                                  %if 0
  1324                                  msg_fpu_err:
  1325                                  	db	NL, "EM187 has signalled error 0x%02x.", NL, 0
  1326                                  %endif
  1327                                  msg_booting:
  1328 000001DC 547279696E6720746F-     	db	"Trying to boot from drive %c: ", 0
  1328 000001E5 20626F6F742066726F-
  1328 000001EE 6D2064726976652025-
  1328 000001F7 633A2000           
  1329                                  msg_boot_err:
  1330 000001FB 4469736B2072656164-     	db	"Disk read failed  AX=%04x", NL, 0
  1330 00000204 206661696C65642020-
  1330 0000020D 41583D253034780A00 
  1331                                  msg_no_boot:
  1332 00000216 426F6F74207369676E-     	db	"Boot signature not found", NL, 0
  1332 0000021F 6174757265206E6F74-
  1332 00000228 20666F756E640A00   
  1333                                  msg_no_loader:
  1334 00000230 4D617374657220626F-     	db	"Master boot loader not found", NL, 0
  1334 00000239 6F74206C6F61646572-
  1334 00000242 206E6F7420666F756E-
  1334 0000024B 640A00             
  1335                                  msg_boot_ok:
  1336 0000024E 4F4B0A00                	db	"OK", NL, 0
  1337                                  msg_cpm_disk:
  1338 00000252 6E6F207369676E6174-             db      "no signature check ", 0
  1338 0000025B 75726520636865636B-
  1338 00000264 2000               
  1339                                  msg_alt_disk:
  1340 00000266 4D494E495820626F6F-     	db	"MINIX boot signature ",0
  1340 0000026F 74207369676E617475-
  1340 00000278 72652000           
  1341                                  
  1342                                  
  1343                                  
  1344                                  %if TBASIC
  1345                                  %else
  1346                                  msg_no_basic:
  1347                                  	db	"No ROM Basic. Please implement one :-)", NL
  1348                                  	db	"Press any key to try again...", NL, 0
  1349                                  %endif
  1350                                  
  1351                                  
  1352                                  %if SOFT_DEBUG
  1353                                  	global	cout,bout,wout,boutsp,crlf
  1354                                  ; NewLine
  1355                                  crlf:
  1356                                  	mov	al,0Dh
  1357                                  	call	cout
  1358                                  	mov	al,0Ah
  1359                                  	call	cout
  1360                                  	ret
  1361                                  
  1362                                  
  1363                                  ; output byte from AL, then a space
  1364                                  boutsp:
  1365                                  	call	bout
  1366                                  	mov	al,20h
  1367                                  	call	cout
  1368                                  	ret
  1369                                  ; word output from AX
  1370                                  wout:
  1371                                  	xchg	al,ah
  1372                                  	call	bout
  1373                                  	xchg	al,ah
  1374                                  ; byte output from AL
  1375                                  bout:
  1376                                  	rol	al,4
  1377                                  	call	nout
  1378                                  	rol	al,4
  1379                                  ; nibble output from low nibble in AL
  1380                                  nout:
  1381                                  	push	ax
  1382                                  	and	al,0Fh		; mask nibble
  1383                                  	daa			; convert to decimal
  1384                                  	add	al,0F0h		; overflow to Carry
  1385                                  	adc	al,040h		; convert to ASCII decimal or hex digit
  1386                                  	call	cout
  1387                                  	pop	ax
  1388                                  	ret
  1389                                  	
  1390                                  ; character output from AL
  1391                                  cout:
  1392                                  %if 0
  1393                                  	pushm	ax,bx
  1394                                  	mov	ah,0Eh		; write character in AL
  1395                                  	mov	bx,0007h
  1396                                  	int	10h
  1397                                  	popm	ax,bx
  1398                                  %else
  1399                                  THRE	EQU	1<<5		; Transmit holding register empty
  1400                                  	pushm	ax,dx
  1401                                  .1:	mov	dx,uart_lsr
  1402                                  	in	al,dx
  1403                                  	test	al,THRE
  1404                                  	jz	.1
  1405                                  	mov	dx,uart_thr
  1406                                  	popm	ax
  1407                                  	out	dx,al
  1408                                  	popm	dx
  1409                                  %endif
  1410                                  	ret
  1411                                  %endif
