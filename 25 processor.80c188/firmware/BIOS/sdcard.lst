     1                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     2                                  ; SDcard.ASM -- Basic I/O routines for the Dual SDcard add-on board
     3                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     4                                  ;
     5                                  ;   This version is for assembly by  NASM 0.98.39 or later
     6                                  ;
     7                                  ; Copyright (c) 2013 John R. Coffman.  All rights reserved.
     8                                  ; Provided for hobbyist use on the N8VEM SBC-188 board.
     9                                  ;
    10                                  ; This program is free software: you can redistribute it and/or modify
    11                                  ; it under the terms of the GNU General Public License as published by
    12                                  ; the Free Software Foundation, either version 3 of the License, or
    13                                  ; (at your option) any later version.
    14                                  ;
    15                                  ; This program is distributed in the hope that it will be useful,
    16                                  ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    17                                  ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    18                                  ; GNU General Public License for more details.
    19                                  ;
    20                                  ; You should have received a copy of the GNU General Public License
    21                                  ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    22                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    23                                  %include	"config.asm"
    24                              <1> ;/*
    25                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    26                              <1> ; ANSI.CFG
    27                              <1> ;   Copied to CONFIG.ASM for general release.
    28                              <1> ;
    29                              <1> ;       Modify the parameters below to reflect your system
    30                              <1> ;
    31                              <1> ;
    32                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    33                              <1> ;
    34                              <1> ;   Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    35                              <1> ;   Provided for hobbyist use on the N8VEM SBC-188 board.
    36                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    37                              <1> ;
    38                              <1> ; Define the serial terminal that the Video BIOS must emulate
    39                              <1> ; Set one of the following to 1
    40                              <1> ; If you have no idea what to choose, set TTY to 1
    41                              <1> TTY     equ     0       ; hardcopy -- cannot position the cursor
    42                              <1> DUMB    equ     0       ; dumb CRT -- ^H, ^J, ^K, ^L can move the cursor
    43                              <1> ANSI    equ     1       ; very smart, like a VT-100
    44                              <1> WYSE    equ     0       ; very smart Wyse series (30, 50, ...)
    45                              <1> ; others may get added in the future
    46                              <1> ;  ONE OF THE ABOVE must BE SET TO 1!!!!!
    47                              <1> ;
    48                              <1> ; Does the hardware configuration contain the Color Video Display Unit?
    49                              <1> ; Both the 8563 and the 8242 are used.  The default is CVDU=0
    50                              <1> CVDU	equ	0	; system does not have the CVDU
    51                              <1> ;
    52                              <1> ; Does the hardware configuration contain the VGA3 a/n Video card?
    53                              <1> ; The 8563 will be disabled, but the 8242 code is shared with the CVDU
    54                              <1> ; The default is VGA3=0
    55                              <1> VGA3    equ     0       ; system does not have the VGA3
    56                              <1> %if 0
    57                              <1> 	*/
    58                              <1> #define VGA3 0
    59                              <1> /*
    60                              <1> %endif
    61                              <1> ;
    62                              <1> ; Boot up keyboard mode:  20h for NumLock on
    63                              <1> ;CVDU_KEYBOARD_STATUS	equ	0	; NumLock OFF
    64                              <1> CVDU_KEYBOARD_STATUS	equ	20h	; NumLock ON
    65                              <1> 
    66                              <1> ; Define the UART startup bit rate - 1200-19200 are most common
    67                              <1> ;UART_RATE	equ	0		; 1200
    68                              <1> ;UART_RATE	equ	1		; 2400
    69                              <1> ;UART_RATE	equ	2		; 4800
    70                              <1> UART_RATE	equ	3		; 9600
    71                              <1> ;UART_RATE	equ	4		; 19200
    72                              <1> ;UART_RATE	equ	5		; 38400
    73                              <1> ;UART_RATE	equ	6		; 57600
    74                              <1> ;UART_RATE	equ	7		; 115200
    75                              <1> 
    76                              <1> ; Does the serial terminal use the DSR/DTR protocol for flow control?
    77                              <1> ;UART_DSR_PROTOCOL	equ		1	; Yes!
    78                              <1> UART_DSR_PROTOCOL       equ             WYSE    ; Wyse always uses it
    79                              <1> 						; but not ANSI
    80                              <1> ; Define the size of the ROM image on the system in Kilobytes
    81                              <1> ; It may be smaller than the actual EPROM in use.
    82                              <1> ; The following sizes are supported:  32, 64, 128, and 256
    83                              <1> %ifndef ROM
    84                              <1> ROM             equ     64              ; 64 is the default
    85                              <1> %endif
    86                              <1> 
    87                              <1> ; Define the number of Wait States at which the ROM operates
    88                              <1> ROM_WS          equ     1               ; 0..3  (1 is the default)
    89                              <1> 
    90                              <1> ; Define the size in Kilobytes of DOS RAM (low SRAM plus EMM allocate RAM)
    91                              <1> ; This is a desired size and will only be present if a 4MEM board is added
    92                              <1> RAM_DOS         equ     640
    93                              <1> 
    94                              <1> ; Define the size of the low SRAM on the system in Kilobytes
    95                              <1> ; the default is 512 kilobytes
    96                              <1> RAM             equ     512             ; (512 is the default)
    97                              <1> 
    98                              <1> ; Define the number of Wait States at which the RAM operates
    99                              <1> RAM_WS          equ     0               ; 0..3  (0 is the default)
   100                              <1> 
   101                              <1> ; Define the number of Wait States for Local Peripheral devices (600-7FF)
   102                              <1> LCL_IO_WS       equ     1               ; 0..3  (1 is the default)
   103                              <1> 
   104                              <1> ; Define the number of Wait States for ECB BUS peripheral devices (4xx)
   105                              <1> BUS_IO_WS       equ     3               ; 0..3  (3 is the default)
   106                              <1> 
   107                              <1> ; Define the time zone in which we build the Relocatable BIOS
   108                              <1> %ifndef TIMEZONE
   109                              <1> %define TIMEZONE "CDT"
   110                              <1> %endif
   111                              <1> 
   112                              <1> ; Has the REDBUG debugger been loaded?
   113                              <1> %ifndef SOFT_DEBUG
   114                              <1> %define SOFT_DEBUG 1
   115                              <1> %endif
   116                              <1> 
   117                              <1> ; Should the BIOS include "Tiny BASIC" in the image?
   118                              <1> %ifndef TBASIC
   119                              <1> TBASIC          equ     1		; default is 1
   120                              <1> %endif
   121                              <1> 
   122                              <1> ; Should the BIOS include the Floating Point Emulator?  The 80188 does
   123                              <1> ; not allow a floating point co-processor, so this is probably a good idea.
   124                              <1> %ifndef FPEM
   125                              <1> FPEM            equ     1               ; default is 1
   126                              <1> %endif
   127                              <1> 
   128                              <1> ; Define the maximum number of EMM (4MEM) boards supported
   129                              <1> EMM_BOARDS      equ     0
   130                              <1> 
   131                              <1> ; Should the Floating Point Emulator use temporary storage in the EBDA
   132                              <1> ; or at locations 0280h..3FFh in low memory?
   133                              <1> %if SOFT_DEBUG
   134                              <1> FPEM_USE_EBDA   equ     FPEM            ; default is 0
   135                              <1> %else
   136                              <1> FPEM_USE_EBDA   equ     0; FPEM            ; default is 0
   137                              <1> %endif
   138                              <1> 
   139                              <1> ; Define the size of the EPROM that is to be installed on the system
   140                              <1> ; It may be larger than the actual ROM image to be generated.
   141                              <1> %ifndef CHIP
   142                              <1> CHIP            equ     64
   143                              <1> %endif
   144                              <1> 
   145                              <1> ; Does the SBC-188 00.4 board have the LS138/LS08 piggyback fix
   146                              <1> ; Set to 1 for the SBC-188 v1.0 and later production boards
   147                              <1> ;FDC_PIGGYBACK_FIX       equ     0       ; Fix not installed
   148                              <1> FDC_PIGGYBACK_FIX       equ     1       ; fix  IS  installed
   149                              <1> 
   150                              <1> ; On SBC-188 rev 00.4 board, there is a published hardware fix (2010-09-18).
   151                              <1> ; If the wiring update is installed, or you have a later board, then
   152                              <1> ; set this to 0.  If you are using the software workaround, then set this
   153                              <1> ; to 1.  The rev 1.0 board has this fix already.
   154                              <1> NEED_TIMER_FIX  equ     0               ; have revised hardware
   155                              <1> ;NEED_TIMER_FIX  equ     1               ; use workaround
   156                              <1> 
   157                              <1> ; Define the UART oscillator speed
   158                              <1> UART_OSC        equ     1843200         ; 1.8432 Mhz is specified
   159                              <1> 
   160                              <1> 
   161                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   162                              <1> ; end of the User configuration
   163                              <1> ;       Do Not modify anything below this point
   164                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   165                              <1> 
   166                              <1> CVDU_8563	equ	CVDU		; separate inits
   167                              <1> CVDU_8242	equ	CVDU|VGA3 	; separate inits
   168                              <1> VGA3_6445       equ     VGA3            ; separate inits
   169                              <1> ; Suppress all UART output in color video Mode 3
   170                              <1> UART_MODE3_SUPPRESS	equ	CVDU_8563
   171                              <1> CVDU_USE_MSDOS_KLUDGE	equ	0; CVDU_8242	; bad, bad MSDOS
   172                              <1> CVDU_USE_KBD_HOOK		equ	CVDU_8242
   173                              <1> 
   174                              <1> ; Define existence of any uart chip
   175                              <1> UART		equ	TTY+DUMB+ANSI+WYSE
   176                              <1> startuplength   equ     512                     ; may be up to 1024
   177                              <1> startseg        equ     0FFFFh - (ROM*64) + 1
   178                              <1> highrom         equ     (ROM*400h)&0FFFFh
   179                              <1> startupseg      equ     0FFFFh - (startuplength>>4) + 1
   180                              <1> bios_data_seg   equ     040h            ; segment of BIOS data area
   181                              <1> 
   182                              <1> 
   183                              <1> %define ARG(n) [bp+2+(n)*2]
   184                              <1> 
   185                              <1> %macro  check   1.nolist
   186                              <1>  %if (%1)
   187                              <1>    %error Check Failure: %1
   188                              <1>  %endif
   189                              <1> %endm
   190                              <1> %macro  range   3.nolist
   191                              <1>  %if (%1)<(%2)
   192                              <1>    %error Out of Range: %1
   193                              <1>  %elif (%1)>(%3)
   194                              <1>    %error Out of Range: %1
   195                              <1>  %endif
   196                              <1> %endm
   197                              <1> _terminal equ UART+CVDU
   198                              <1>  check   RAM_DOS&15
   199                              <1>  check   RAM&(RAM-1)
   200                              <1>  check   ROM&(ROM-1)
   201                              <1>  range   RAM,32,512
   202                              <1>  range   ROM,32,256
   203                              <1>  range   RAM_WS,0,3
   204                              <1>  range   ROM_WS,0,3
   205                              <1>  range   RAM_DOS,RAM,(1024-ROM)
   206                              <1>  range   LCL_IO_WS,0,3
   207                              <1>  range   BUS_IO_WS,0,3
   208                              <1>  range   UART_OSC,500000,16000000
   209                              <1>  range   UART_RATE,0,7
   210                              <1>  range	 UART,0,1
   211                              <1>  range	 _terminal,1,2
   212                              <1> 
   213                              <1> %ifndef SOFT_DEBUG
   214                              <1> %define SOFT_DEBUG 0
   215                              <1> %endif
   216                              <1> 
   217                              <1> %ifndef TRACE
   218                              <1> %define TRACE 0
   219                              <1> %endif
   220                              <1> 
   221                              <1> %ifdef MAKE_OBJECT_FILE
   222                              <1>         segment _DATA WORD PUBLIC CLASS=DATA
   223                              <1>         export _ROMsize
   224                              <1>         export _CHIPsize
   225                              <1> _ROMsize        dw      ROM
   226                              <1> _CHIPsize       dw      CHIP
   227                              <1> %endif
   228                              <1> ; end of the Hardware configuration file
   229                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   230                              <1> ;*/
    24                                  %include	"cpuregs.asm"
    25                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    26                              <1> ; CPUREGS.ASM
    27                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    28                              <1> ;
    29                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    30                              <1> ;
    31                              <1> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    32                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    33                              <1> ;
    34                              <1> ; This program is free software: you can redistribute it and/or modify
    35                              <1> ; it under the terms of the GNU General Public License as published by
    36                              <1> ; the Free Software Foundation, either version 3 of the License, or
    37                              <1> ; (at your option) any later version.
    38                              <1> ;
    39                              <1> ; This program is distributed in the hope that it will be useful,
    40                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    41                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    42                              <1> ; GNU General Public License for more details.
    43                              <1> ;
    44                              <1> ; You should have received a copy of the GNU General Public License
    45                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    46                              <1> ;
    47                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    48                              <1> %include	"macros.inc"
    49                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    50                              <2> ; MACROS.INC  
    51                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    52                              <2> ;
    53                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    54                              <2> ;
    55                              <2> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    56                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    57                              <2> ;
    58                              <2> ; This program is free software: you can redistribute it and/or modify
    59                              <2> ; it under the terms of the GNU General Public License as published by
    60                              <2> ; the Free Software Foundation, either version 3 of the License, or
    61                              <2> ; (at your option) any later version.
    62                              <2> ;
    63                              <2> ; This program is distributed in the hope that it will be useful,
    64                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    65                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    66                              <2> ; GNU General Public License for more details.
    67                              <2> ;
    68                              <2> ; You should have received a copy of the GNU General Public License
    69                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    70                              <2> ;
    71                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    72                              <2> 
    73                              <2> ; general macros for the SBC188 BIOS ASSEMBLY
    74                              <2> ;
    75                              <2> ;
    76                              <2> %ifndef __MACROS_DEFINED_
    77                              <2> %define __MACROS_DEFINED_ 1
    78                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    79                              <2> ;
    80                              <2> ; some useful macros:
    81                              <2> ;
    82                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    83                              <2> ;
    84                              <2> 	cpu	186
    85                              <2> 
    86                              <2> %imacro setloc  1.nolist
    87                              <2>  times   (%1-($-$$)) db 0FFh
    88                              <2> %endm
    89                              <2> 
    90                              <2> %imacro db_lo   1
    91                              <2>  db (%1)&255
    92                              <2> %endm
    93                              <2> 
    94                              <2> %imacro cnop    0.nolist
    95                              <2> %if SOFT_DEBUG
    96                              <2>         nop
    97                              <2> %endif
    98                              <2> %endm
    99                              <2> 
   100                              <2> %imacro popm 1-*.nolist
   101                              <2> %rep %0
   102                              <2> %ifidni %1,ALL
   103                              <2>  popa
   104                              <2> %elifidni %1,F
   105                              <2>  popf
   106                              <2> %else
   107                              <2>  pop %1
   108                              <2> %ifidni %1,DS
   109                              <2>  cnop
   110                              <2> %elifidni %1,ES
   111                              <2>  cnop
   112                              <2> %endif
   113                              <2> %endif
   114                              <2> %rotate 1
   115                              <2> %endrep
   116                              <2> %endm
   117                              <2> 
   118                              <2> %imacro pushm 1-*.nolist
   119                              <2> %rep %0
   120                              <2> %rotate -1
   121                              <2> %ifidni %1,ALL
   122                              <2>  pusha
   123                              <2> %elifidni %1,F
   124                              <2>  pushf
   125                              <2> %else
   126                              <2>  push %1
   127                              <2> %endif
   128                              <2> %endrep
   129                              <2> %endm
   130                              <2> 
   131                              <2> ;
   132                              <2> ; added from the 386EX project
   133                              <2> ;
   134                              <2> 
   135                              <2> ; call arguments
   136                              <2> %define ARG(n) [bp+2+(n)*2]
   137                              <2> 
   138                              <2> ;
   139                              <2> ; format of the BYTE initialization table:  address, byte
   140                              <2> ;
   141                              <2> %imacro  binit 2
   142                              <2>         dw      %1
   143                              <2>         db      %2
   144                              <2> %endmacro
   145                              <2> ; end with DW -1
   146                              <2> 
   147                              <2> ;
   148                              <2> ; format of the WORD initialization table:  address, word
   149                              <2> ;
   150                              <2> %imacro  winit 2
   151                              <2>         dw      %1
   152                              <2>         dw      %2
   153                              <2> %endmacro
   154                              <2> ; end with DW -1
   155                              <2> 
   156                              <2> 
   157                              <2> ; get the BIOS Data Area segment pointer to a [segment] register
   158                              <2> %imacro get_bda	1.nolist
   159                              <2> 	push	0x0040
   160                              <2> 	pop	%1
   161                              <2> 	cnop
   162                              <2> %endm
   163                              <2> 
   164                              <2> 
   165                              <2> %endif
    49                              <1> 
    50                              <1> 	cpu     186
    51                              <1> ;
    52                              <1> ;
    53                              <1> ; IBM model byte -- must be less than a 286
    54                              <1> ;
    55                              <1> ;MODEL_BYTE		equ	0FEh	; PC-XT
    56                              <1> ;SUBMODEL_BYTE		equ	0FFh	; not used
    57                              <1> 
    58                              <1> MODEL_BYTE		equ	0FEh	; PC-XT
    59                              <1> SUBMODEL_BYTE		equ	00h	;  "
    60                              <1> 
    61                              <1> 
    62                              <1> ; 80188 peripheral control register block address
    63                              <1> CPU_CSCR	        equ	0FF00h
    64                              <1> 
    65                              <1> ; Compatible Mode registers
    66                              <1> 
    67                              <1> cpu_relocation          equ     CPU_CSCR+0FEh
    68                              <1> 
    69                              <1> ; The memory and peripheral chip select register offsets from 0FF00h
    70                              <1> 
    71                              <1> cpu_umcs                equ     CPU_CSCR+0A0h          ; Upper memory select
    72                              <1> cpu_lmcs                equ     CPU_CSCR+0A2h          ; Lower memory select
    73                              <1> cpu_pacs                equ     CPU_CSCR+0A4h          ; Peripheral select
    74                              <1> cpu_mmcs                equ     CPU_CSCR+0A6h          ; Middle memory base
    75                              <1> cpu_mpcs                equ     CPU_CSCR+0A8h          ; Mid mem. & peripherals
    76                              <1> 
    77                              <1> ; Enhanced Mode registers
    78                              <1> 
    79                              <1> cpu_mdram               equ     CPU_CSCR+0E0h          ; memory partition reg.
    80                              <1> cpu_cdram               equ     CPU_CSCR+0E2h          ; clock prescaler
    81                              <1> cpu_edram               equ     CPU_CSCR+0E4h          ; Enable refresh reg.
    82                              <1> cpu_pdcon               equ     CPU_CSCR+0F0h          ; Power-Save control
    83                              <1> 
    84                              <1> 
    85                              <1> ; On-board internal peripheral equates
    86                              <1> ; Programmable Interrupt Controller
    87                              <1> PIC	        equ	CPU_CSCR+020H
    88                              <1> PIC_EOI	        equ	PIC+2           ; End Of Interrupt
    89                              <1> PIC_POLLR	equ	PIC+4
    90                              <1> PIC_POLLSR	equ	PIC+6
    91                              <1> PIC_IMASK	equ	PIC+8
    92                              <1> PIC_PMREG	equ	PIC+0AH
    93                              <1> PIC_SRVR	equ	PIC+0CH
    94                              <1> PIC_IRQR	equ	PIC+0EH
    95                              <1> PIC_IRQSR	equ	PIC+10H
    96                              <1> PIC_TCR	        equ	PIC+12H
    97                              <1> PIC_DMA0CR	equ	PIC+14H
    98                              <1> PIC_DMA1CR	equ	PIC+16H
    99                              <1> PIC_I0CON	equ	PIC+18H
   100                              <1> PIC_I1CON	equ	PIC+1AH
   101                              <1> PIC_I2CON	equ	PIC+1CH
   102                              <1> PIC_I3CON	equ	PIC+1EH
   103                              <1> 
   104                              <1> EOI_NSPEC       equ     8000h           ; Non-Specific EOI
   105                              <1> 
   106                              <1> ; Interrupt masks (Master Mode)
   107                              <1> ;
   108                              <1> mask_timer_all          equ     0001h
   109                              <1> mask_dma0               equ     0004h
   110                              <1> mask_dma1               equ     0008h
   111                              <1> mask_int0               equ     0010h
   112                              <1> mask_int1               equ     0020h
   113                              <1> mask_int2               equ     0040h
   114                              <1> mask_int3               equ     0080h
   115                              <1> 
   116                              <1> 
   117                              <1> 
   118                              <1> ; Timers
   119                              <1> TIM0	        equ	CPU_CSCR+050H
   120                              <1> TIM1	        equ	CPU_CSCR+058H
   121                              <1> TIM2	        equ	CPU_CSCR+060H
   122                              <1> 
   123                              <1> TCNT	        equ	0	; count register
   124                              <1> CMPA	        equ	2	; max count A
   125                              <1> CMPB	        equ	4	; max count B (not present on TIM2)
   126                              <1> TCON	        equ	6	; mode/control word
   127                              <1> 
   128                              <1> ; Timer control bits:
   129                              <1> tc_EN           equ     8000h   ; Enable bit
   130                              <1> tc_nINH         equ     4000h   ; not Inhibit Enable
   131                              <1> tc_INT          equ     2000h   ; Interrupt Enable
   132                              <1> tc_RIU          equ     1000h   ; Register A/B (0/1) in Use
   133                              <1> tc_MC           equ     0020h   ; Maximum Count reached
   134                              <1> tc_RTG          equ     0010h   ; Retrigger (internal source)
   135                              <1> tc_P            equ     0008h   ; Prescale internal clock (timers 0 & 1 only)
   136                              <1> tc_EXT          equ     0004h   ; External clock
   137                              <1> tc_ALT          equ     0002h   ; Alternate between A & B max count registers
   138                              <1> tc_CONT         equ     0001h   ; Continuous: continue after max count
   139                              <1> 
   140                              <1> 
   141                              <1> 
   142                              <1> 
   143                              <1> ; DMA
   144                              <1> DMA0	        equ	CPU_CSCR+0C0H
   145                              <1> DMA1	        equ	CPU_CSCR+0D0H
   146                              <1> DMASPL	        equ	0	; source pointer low
   147                              <1> DMASPU	        equ	2	; source pointer high
   148                              <1> DMADPL	        equ	4	; destination pointer low
   149                              <1> DMADPU	        equ	6	; destination pointer high
   150                              <1> DMATC	        equ	8	; terminal count
   151                              <1> DMACW	        equ	0AH	; control word
   152                              <1> 
   153                              <1> 
   154                              <1> 
   155                              <1> 
   156                              <1> 
   157                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   158                              <1> ;
   159                              <1> ;       SBC-188 external devices
   160                              <1> ;
   161                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   162                              <1> 
   163                              <1> IO_BASE			equ	0400h
   164                              <1> 
   165                              <1> 
   166                              <1> 
   167                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   168                              <1> ; The UART registers
   169                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   170                              <1> 
   171                              <1> uart_base               equ     IO_BASE+0280h
   172                              <1> uart_rbr                equ     uart_base       ;Rcvr Buffer / read only
   173                              <1> uart_thr                equ     uart_base       ;Transmit Holding / write only
   174                              <1> uart_ier                equ     uart_base+1     ;Interrupt Enable
   175                              <1> uart_iir                equ     uart_base+2     ;Interrupt Ident / read only
   176                              <1> uart_fcr                equ     uart_base+2     ;FIFO Control / write only
   177                              <1> uart_lcr                equ     uart_base+3     ;Line Control
   178                              <1> uart_mcr                equ     uart_base+4     ;Modem Control
   179                              <1> uart_lsr                equ     uart_base+5     ;Line Status
   180                              <1> uart_msr                equ     uart_base+6     ;Modem Status
   181                              <1> uart_sr			equ	uart_base+7	;Scratch
   182                              <1> 
   183                              <1> uart_dll                equ     uart_base       ;Divisor Latch LS Byte
   184                              <1> uart_dlm                equ     uart_base+1     ;Divisor Latch MS Byte
   185                              <1> 
   186                              <1> 
   187                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   188                              <1> ; Floppy controller
   189                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   190                              <1> FDC	        equ	IO_BASE+0200H
   191                              <1> FDC_MSR         equ     FDC
   192                              <1> FDC_DATA        equ     FDC_MSR+1
   193                              <1> FDC_DACK        equ	FDC+10H
   194                              <1> FDC_LDOR	equ	FDC+20H
   195                              <1> FDC_LDCR	equ	FDC+30H
   196                              <1> FDC_TC	        equ	FDC+40H
   197                              <1> FDC_DACK_TC     equ     FDC_DACK | FDC_TC
   198                              <1> 
   199                              <1> 
   200                              <1> %if SBC188==1
   201                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   202                              <1> ;DS1302 RTC
   203                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   204                              <1> RTC	equ	IO_BASE+0300H
   205                              <1> %endif
   206                              <1> 
   207                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   208                              <1> ; PIO 82C55 I/O 
   209                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   210                              <1> ; for the SBCv1/v2 with PPIDE adapter board
   211                              <1> ; and for the SBCv3 with PPIDE connector
   212                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   213                              <1> PPI	        equ	IO_BASE+0260H
   214                              <1> 
   215                              <1> PIO_A	        equ	PPI+0	; (OUTPUT)
   216                              <1> PIO_B	        equ	PPI+1	; (INPUT)
   217                              <1> PIO_C	        equ	PPI+2	; (CENTRONICS control low nibble)  
   218                              <1> PIO_CTRL	equ	PPI+3	; CONTROL BYTE PIO 82C55
   219                              <1> 
   220                              <1> portA           equ     PPI+0   ;
   221                              <1> portB           equ     PPI+1   ;
   222                              <1> portC           equ     PPI+2   ;
   223                              <1> 
   224                              <1> 
   225                              <1> 
   226                              <1> ;;;%if SBC188==3   startup.asm is universal
   227                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   228                              <1> ; CONTROL LS259 PORT ON SBC188 V3
   229                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   230                              <1> CTRL259		equ	IO_BASE+0270H
   231                              <1> ; LEDS are at addresses 0..3
   232                              <1> ; other control ports on 4..7
   233                              <1> LED0		equ	CTRL259+0
   234                              <1> LED1		equ	LED0+1
   235                              <1> LED2		equ	LED0+2
   236                              <1> LED3		equ	LED0+3
   237                              <1> T1OSC18		equ	CTRL259+4	; ON=1.8432mhz, OFF="1" (for use of TIMER2)
   238                              <1> ;unused		equ	CTRL259+5
   239                              <1> FDC_RES		equ	CTRL259+6	; RESET IS ACTIVE HIGH
   240                              <1> IDE8_RES	equ	CTRL259+7	; fast IDE RESET IS ACTIVE LOW
   241                              <1> 
   242                              <1> 
   243                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   244                              <1> ; FIDE8 8-bit IDE on the 80C188 bus
   245                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   246                              <1> FIDE_BASE       equ     IO_BASE+2C0h
   247                              <1> 
   248                              <1> IDE8_CS0        equ     FIDE_BASE
   249                              <1> IDE8_CS1        equ     FIDE_BASE+0x10
   250                              <1> 
   251                              <1> ;;;%endif   startup.asm is universal
   252                              <1> 
   253                              <1> 
   254                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   255                              <1> ; Dual [DMA] IDE devices
   256                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   257                              <1> DIDE		equ	IO_BASE + 20H	; range 0x20..0x3F
   258                              <1> 
   259                              <1> DIDE0		equ	DIDE		; first interface (master & slave)
   260                              <1> DIDE1		equ	DIDE+10h	; second interface (master & slave)
   261                              <1> 
   262                              <1> 
   263                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   264                              <1> ; DISK I/O v3 device codes (PPIDE only)
   265                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   266                              <1> DISKIO		equ	IO_BASE + 20h	; range 0x20..0x3F
   267                              <1> 
   268                              <1> DISKIO_PPIDE	equ	DISKIO		; 82c55
   269                              <1> DISKIO_FDC	equ	DISKIO + 10h	; FDC 9266
   270                              <1> DISKIO_DOR	equ	DISKIO + 18h	; OPERATION REGISTER	
   271                              <1> 
   272                              <1> 
   273                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   274                              <1> ; MF/PIC interfaces
   275                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   276                              <1> MFPIC		equ	IO_BASE + 40h	; range 0x40..0x4F
   277                              <1> 
   278                              <1> ;MFPIC_202	equ	MFPIC		; NS32202 is not usable on SBC-188
   279                              <1> MFPIC_PPIDE	equ	MFPIC + 4	; PPIDE disk interface
   280                              <1> MFPIC_UART	equ	MFPIC + 8	; TL16Cx50 SIO chip
   281                              <1> 
   282                              <1> 
   283                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   284                              <1> ; Cassette I/O
   285                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   286                              <1> cuart_base	EQU 	IO_BASE+80H	; BASE IO ADDRESS OF CASSETTE UART
   287                              <1> cuart_rbr	equ     cuart_base	;Rcvr Buffer / read only
   288                              <1> cuart_thr	equ     cuart_base	;Transmit Holding / write only
   289                              <1> cuart_ier	equ     cuart_base+1	;Interrupt Enable
   290                              <1> cuart_iir	equ     cuart_base+2	;Interrupt Ident / read only
   291                              <1> cuart_fcr	equ     cuart_base+2	;FIFO Control / write only
   292                              <1> cuart_lcr	equ     cuart_base+3	;Line Control
   293                              <1> cuart_mcr	equ     cuart_base+4	;Modem Control
   294                              <1> cuart_lsr	equ     cuart_base+5	;Line Status
   295                              <1> cuart_msr	equ     cuart_base+6	;Modem Status
   296                              <1> cuart_sr	equ	cuart_base+7	;Scratch
   297                              <1> 
   298                              <1> cuart_dll	equ     cuart_base	;Divisor Latch LS Byte
   299                              <1> cuart_dlm	equ	cuart_base+1	;Divisor Latch MS Byte
   300                              <1> 
   301                              <1> 
   302                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   303                              <1> ;
   304                              <1> ;       4MEM control registers
   305                              <1> ;
   306                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   307                              <1> EMM_addr        equ     1               ; high 6 bits of 20-bit address
   308                              <1> EMM_page        equ     0               ; 4MEM page in [0..254]
   309                              <1> 
   310                              <1> EMM_BASE        equ     IO_BASE + 000h          ; first EMM (4MEM) board
   311                              <1> EMM_unmapped    equ     255             ; unmapped 4MEM page
   312                              <1> 
   313                              <1> EMM0            equ     EMM_BASE        ; first  EMM board
   314                              <1> EMM1            equ     EMM0 + 2        ; second EMM board
   315                              <1> EMM2            equ     EMM1 + 2        ; third  EMM board
   316                              <1> EMM3            equ     EMM2 + 2        ; fourth EMM board
   317                              <1> 
   318                              <1> 
   319                              <1> 
   320                              <1> 
   321                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   322                              <1> ;
   323                              <1> ;	ColorVDU devices
   324                              <1> ;
   325                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   326                              <1> ;
   327                              <1> ;	major select on the Z80 bus
   328                              <1> ;
   329                              <1> devCVDU_8bit	equ	0xE0		; this may change to 0x10
   330                              <1> 
   331                              <1> devCVDUbase 	equ	IO_BASE + devCVDU_8bit
   332                              <1> 
   333                              <1> M8563status	equ	devCVDUbase + 4		; 4 == bitrev(2)
   334                              <1> M8563register	equ	devCVDUbase + 4
   335                              <1> M8563data	equ	devCVDUbase + 12	; 12 == bitrev(3)
   336                              <1> 
   337                              <1> %if CVDU_8563
   338                              <1> I8242status	equ	devCVDUbase + 10	; 10 == bitrev(5)
   339                              <1> I8242command	equ	devCVDUbase + 10
   340                              <1> I8242data	equ	devCVDUbase + 2		; 2 == bitrev(4)
   341                              <1> %endif
   342                              <1> 
   343                              <1> 
   344                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   345                              <1> ;
   346                              <1> ;	VGA3 devices
   347                              <1> ;
   348                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   349                              <1> ;
   350                              <1> ;	major select on the Z80 bus
   351                              <1> ;
   352                              <1> devVGA3_8bit    equ     0xE0                    ; same as CVDU
   353                              <1> 
   354                              <1> devVGA3base       equ     IO_BASE + devVGA3_8bit
   355                              <1> 
   356                              <1> %if VGA3_6445
   357                              <1> I8242status	equ	devVGA3base + 1
   358                              <1> I8242command	equ	devVGA3base + 1
   359                              <1> I8242data	equ	devVGA3base + 0
   360                              <1> %endif
   361                              <1> HD6445addr	equ	devVGA3base + 2		; to address the HD6445 registers
   362                              <1> HD6445reg	equ	devVGA3base + 3		; to r/w a register on the CRTC
   363                              <1> 
   364                              <1> vga3cfg		equ	devVGA3base + 4
   365                              <1> ; the following are probably not used on the SBC-188, except for testing/checking
   366                              <1> vga3adhi	equ	devVGA3base + 5
   367                              <1> vga3adlo	equ	devVGA3base + 6
   368                              <1> vga3data	equ	devVGA3base + 7
   369                              <1> 
   370                              <1> 
   371                              <1> 
   372                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   373                              <1> ;
   374                              <1> ;       2S1P registers
   375                              <1> ;
   376                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   377                              <1> dev_2S1P_loc		equ	0xC0	; same as 4UART !!!
   378                              <1> 
   379                              <1> dev_2S1P_base		equ	IO_BASE + dev_2S1P_loc	
   380                              <1> 
   381                              <1> dev_2S1P_A		equ	dev_2S1P_base		; serial port
   382                              <1> dev_2S1P_B		equ	dev_2S1P_base + 8h	; serial port
   383                              <1> 
   384                              <1> dev_2S1P_C		equ	dev_2S1P_base + 10h	; parallel port
   385                              <1> 
   386                              <1> 
   387                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   388                              <1> ;
   389                              <1> ;       4UART registers
   390                              <1> ;
   391                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   392                              <1> dev_4UART_loc		equ	0xC0	; same as 2S1P !!!
   393                              <1> ;				0xA0	; possible alternate
   394                              <1> dev_4UART_alt_offset	equ	0xA0 - dev_4UART_loc
   395                              <1> 
   396                              <1> dev_4UART_base		equ	IO_BASE + dev_4UART_loc	
   397                              <1> 
   398                              <1> dev_4UART_A		equ	dev_4UART_base
   399                              <1> dev_4UART_B		equ	dev_4UART_base + 8h
   400                              <1> dev_4UART_C		equ	dev_4UART_base + 10h
   401                              <1> dev_4UART_D		equ	dev_4UART_base + 18h
   402                              <1> 
   403                              <1> dev_4UART_config	equ	dev_4UART_B + 7		; overlays scratch register
   404                              <1> 
   405                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   406                              <1> ; debug port -- JRC only
   407                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   408                              <1> portD		equ	IO_BASE + 0FFh		; 0x04FF
   409                              <1> ;portD		equ	portB		     ; older 8255 output on PPI
   410                              <1> 
   411                              <1> ; end CPUREGS.ASM
   412                              <1> 
    25                                  %include	"equates.asm"
    26                              <1> ;========================================================================
    27                              <1> ; EQUATES.ASM -- Lots of Defintions for Relocatable BIOS
    28                              <1> ;========================================================================
    29                              <1> ;   for the N8VEM SBC-188 v.00.4 and 00.5
    30                              <1> ;
    31                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    32                              <1> ;
    33                              <1> ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
    34                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    35                              <1> ;
    36                              <1> ; This program is free software: you can redistribute it and/or modify
    37                              <1> ; it under the terms of the GNU General Public License as published by
    38                              <1> ; the Free Software Foundation, either version 3 of the License, or
    39                              <1> ; (at your option) any later version.
    40                              <1> ;
    41                              <1> ; This program is distributed in the hope that it will be useful,
    42                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    43                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    44                              <1> ; GNU General Public License for more details.
    45                              <1> ;
    46                              <1> ; You should have received a copy of the GNU General Public License
    47                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    48                              <1> ;
    49                              <1> ;========================================================================
    50                              <1> 
    51                              <1>         global  FPEM_segment
    52                              <1> 
    53                              <1> 
    54                              <1> %include "segdef.asm"
    55                              <2> ;========================================================================
    56                              <2> ; SEGDEF.ASM -- Lots of Defintions for Relocatable BIOS
    57                              <2> ;========================================================================
    58                              <2> ;   for the N8VEM SBC-188 v.00.4 and 00.5
    59                              <2> ;
    60                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    61                              <2> ;
    62                              <2> ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
    63                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    64                              <2> ;
    65                              <2> ; This program is free software: you can redistribute it and/or modify
    66                              <2> ; it under the terms of the GNU General Public License as published by
    67                              <2> ; the Free Software Foundation, either version 3 of the License, or
    68                              <2> ; (at your option) any later version.
    69                              <2> ;
    70                              <2> ; This program is distributed in the hope that it will be useful,
    71                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    72                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    73                              <2> ; GNU General Public License for more details.
    74                              <2> ;
    75                              <2> ; You should have received a copy of the GNU General Public License
    76                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    77                              <2> ;
    78                              <2> ;========================================================================
    79                              <2> 
    80                              <2> %ifndef __SEGDEF_
    81                              <2> %define __SEGDEF_
    82                              <2> 
    83                              <2> 	SEGMENT  _TEXT ALIGN=2 PUBLIC CLASS=CODE
    84                              <2>         SEGMENT  CONST ALIGN=2 PUBLIC CLASS=DATA
    85                              <2>         SEGMENT  CONST2 ALIGN=2 PUBLIC CLASS=DATA
    86                              <2> 	SEGMENT  _DATA ALIGN=16 PUBLIC CLASS=DATA
    87                              <2> 	SEGMENT  _BSS  ALIGN=2 PUBLIC CLASS=BSS
    88                              <2> ;;;        SEGMENT  _BASIC ALIGN=16 PUBLIC CLASS=BASIC
    89                              <2> 
    90                              <2> 	GROUP	DGROUP CONST CONST2 _DATA _BSS
    91                              <2> 
    92                              <2> %endif
    93                              <2> 
    55                              <1> %include "ascii.asm"
    56                              <2> ; ascii.asm
    57                              <2> ;
    58                              <2> CTRL            equ     1Fh     ; masks a character to CTRL-x
    59                              <2> 
    60                              <2> NUL     equ     00h
    61                              <2> BEL     equ     (CTRL & 'G')
    62                              <2> BS      equ     08h		; ^H
    63                              <2> HT      equ     09h		; ^I
    64                              <2> LF	equ	0Ah		; ^J
    65                              <2> NL      equ     LF
    66                              <2> VT	equ	0Bh		; ^K
    67                              <2> FWD	equ	0Ch		; ^L
    68                              <2> CR	equ	0Dh
    69                              <2> XON     equ     (CTRL & 'Q')
    70                              <2> XOFF    equ     (CTRL & 'S')
    71                              <2> DC1     equ     XON
    72                              <2> DC3     equ     XOFF
    73                              <2> ESC     equ	1Bh
    74                              <2> 
    75                              <2> 
    56                              <1> 
    57                              <1> 
    58                              <1> ; POST error codes. Presently one byte but can expand to word.
    59                              <1> ER_BIOS equ	01h		; Bad ROM bios checksum, patch last byte
    60                              <1> ER_RAM	equ	02h		; Bad RAM in main memory, replace
    61                              <1> ER_CRT	equ	04h		; Bad RAM in video card, replace
    62                              <1> ER_FDC	equ	08h		; Bad FDC
    63                              <1> ER_UNK1	equ	10h		; {unassigned}
    64                              <1> ER_MEM	equ	20h		; Bad RAM in vector area, replace
    65                              <1> ER_ROM	equ	40h		; Bad ROM in expansion area, bad checksum
    66                              <1> ER_UNK2	equ	80h		; {unassigned}
    67                              <1> 
    68                              <1> 
    69                              <1> 
    70                              <1> ;; ************************ BIOS Data Segment ******************************
    71                              <1> ;; BIOS data segment - not all will  be used
    72                              <1> ;                struc   BIOS_DATA_AREA  ; at 0040:0000
    73                              <1> %include "bda.inc"
    74                              <2> ;/*======================================================================
    75                              <2> ; bda.inc -- BIOS data area definitions
    76                              <2> ;========================================================================
    77                              <2> ;   for the N8VEM SBC-188
    78                              <2> ;
    79                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    80                              <2> ;
    81                              <2> ; Copyright (C) 2013 John R. Coffman.  All rights reserved.
    82                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    83                              <2> ;
    84                              <2> ; This program is free software: you can redistribute it and/or modify
    85                              <2> ; it under the terms of the GNU General Public License as published by
    86                              <2> ; the Free Software Foundation, either version 3 of the License, or
    87                              <2> ; (at your option) any later version.
    88                              <2> ;
    89                              <2> ; This program is distributed in the hope that it will be useful,
    90                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    91                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    92                              <2> ; GNU General Public License for more details.
    93                              <2> ;
    94                              <2> ; You should have received a copy of the GNU General Public License
    95                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    96                              <2> ;
    97                              <2> ;========================================================================
    98                              <2> 
    99                              <2> 			;*/ extern				/*
   100                              <2> 	ABSOLUTE  0	;*/ struct BDA {			/*
   101 00000000 ????????????????    <2> serial_ports    resw    4	;*/	word	serial_ports[4];	/*
   102 00000008 ????????????????    <2> parallel_ports  resw    4	;*/	word	parallel_ports[4];	/*
   103 00000010 ????                <2> equipment_flag  resw    1	;*/	EQFL	equipment_flag;		/*
   104                              <2> ;	dw	?		; 40:10 	; Equipment present word
   105                              <2> ;  						;  = (1 iff floppies) *     1.
   106                              <2> ;                                               ;  + (1 iff 187     ) *     2.
   107                              <2> ;  						;  + (#+1 64K sys ram) *    4.
   108                              <2> ;  						;  + (init crt mode ) *    16.
   109                              <2> ;  						;  + (# of floppies ) *    64.
   110                              <2> ;  						;  + (# serial ports) *   512.
   111                              <2> ;  						;  + (1 iff toy port) *  4096.
   112                              <2> ;                                               ;  + (1 iff modem   ) *  8192.
   113                              <2> ;  						;  + (# parallel LPT) * 16384.
   114 00000012 ??                  <2> mfg_test_flags  resb    1	;*/	byte	mfg_test_flags;	/* 40:12 unused by us
   115 00000013 ????                <2> memory_size     resw    1	;*/	word	memory_size;	/* 40:13 kilobytes
   116                              <2> uart_kbd_ctrl_R	equ	$	;*/				/*** JRC: count of ctrl-R's for reboot
   117 00000015 ??                  <2> IPL_errors      resb    1	;*/	byte	IPL_errors;	/* 40:15 IPL errors<-table/scratchpad
   118 00000016 ??                  <2> sbc188_rev       resb    1	;*/	byte	sbc188_rev;	/* was 'unused_01' before BIOS047
   119                              <2> ;;---------------[Keyboard data area]------------;
   120 00000017 ????                <2> keyboard_flags_0 resw   1	;*/	word	keyboard_flags_0;  /* 40:17 Shift/Alt/etc. keyboard flags
   121                              <2> keyboard_flags_1 equ	$-1	;     2nd byte	keyboard_flags_1;  
   122 00000019 ??                  <2> keypad_char	resb	1	;*/	byte	keypad_char;	/* 40:19 Alt-KEYPAD char. goes here
   123 0000001A ????                <2> kbd_buffer_head resw    1	;*/	word	kbd_buffer_head;   /* 40:1A --> keyboard buffer head
   124 0000001C ????                <2> kbd_buffer_tail resw    1	;*/	word	kbd_buffer_tail;   /* 40:1C --> keyboard buffer tail
   125 0000001E <res 20h>           <2> kbd_buffer      resw    16	;*/	word	kbd_buffer[16];	/* 40:1E Keyboard Buffer (Scan,Value)
   126                              <2> kbd_buffer_last	equ	$	;*/				/*
   127                              <2> ;;---------------[Diskette data area]------------;
   128 0000003E ??                  <2> fdc_drv_calib   resb    1	;*/	byte	fdc_drive_calib;   /* 40:3E
   129 0000003F ??                  <2> fdc_motor_LDOR  resb    1	;*/	byte	fdc_motor_LDOR;	   /* 40:3F Motor, DMA, select control
   130 00000040 ??                  <2> fdc_motor_ticks resb    1	;*/	byte	fdc_motor_ticks;   /* 40:40 ticks til motor off
   131 00000041 ??                  <2> fdc_status      resb    1	;*/	byte	fdc_status;	   /* 40:41
   132                              <2> ;				Floppy return code stat byte
   133                              <2> ;				;  1 = bad ic 765 command req.
   134                              <2> ;				;  2 = address mark not found
   135                              <2> ;				;  3 = write to protected disk
   136                              <2> ;				;  4 = sector not found
   137                              <2> ;				;  8 = data late (DMA overrun)
   138                              <2> ;				;  9 = DMA failed 64K page end
   139                              <2> ;				; 16 = bad CRC on floppy read
   140                              <2> ;				; 32 = bad NEC 765 controller
   141                              <2> ;				; 64 = seek operation failed
   142                              <2> ;				;128 = disk drive timed out
   143 00000042 ??????????????      <2> fdc_ctrl_status resb    7	;*/	byte	fdc_ctrl_status[7];  /* 40:42 Status bytes from NEC 765
   144                              <2> ;;---------------[Video display area]------------;
   145 00000049 ??                  <2> video_mode      resb    1	;*/	byte	video_mode;	/* 40:49
   146                              <2> ;			 	; Current CRT mode  (software)
   147                              <2> ;				;  0 = 40 x 25 text (no color)
   148                              <2> ;				;  1 = 40 x 25 text (16 color)
   149                              <2> ;				;  2 = 80 x 25 text (no color)
   150                              <2> ;				;  3 = 80 x 25 text (16 color)
   151                              <2> ;				;  4 = 320 x 200 grafix 4 color
   152                              <2> ;				;  5 = 320 x 200 grafix 0 color
   153                              <2> ;				;  6 = 640 x 200 grafix 0 color
   154                              <2> ;				;  7 = 80 x 25 text (mono card)
   155 0000004A ????                <2> video_columns   resw    1	;*/	word video_columns;	/* 40:4A Columns on CRT screen
   156 0000004C ????                <2> video_regen_bytes  resw 1	;*/	word video_regen_bytes;	/* 40:4C Bytes in the regen region
   157 0000004E ????                <2> video_regen_offset resw 1	;*/	word video_regen_offset;/* 40:4E Byte offset in regen region
   158 00000050 <res 10h>           <2> video_cursor_pos  resw  8	;*/	word video_cursor_pos[8];  /* 40:50 Cursor pos for up to 8 pages
   159 00000060 ????                <2> video_cursor_mode resw  1	;*/	word video_cursor_mode;	/* 40:60 Current cursor mode setting
   160 00000062 ??                  <2> video_page      resb    1	;*/	byte video_page;	/* 40:62 Current page on display
   161 00000063 ????                <2> video_base_seg  resw    1	;*/	word video_base_seg;	/* 40:63 Base address (B000h or B800h)
   162 00000065 ??                  <2> video_hw_mode   resb    1	;*/	byte video_hw_mode;	/* 40:65 ic 6845 mode reg. (hardware)
   163 00000066 ??                  <2> video_cga_palette resb  1	;*/	byte video_cga_palette;	/* 40:66 Current CGA palette
   164                              <2> ;;---------------[Used to setup ROM]-------------;
   165 00000067 ????????            <2> eprom_address   resd    1	;*/	dword eprom_address;	/* 40:67 Eprom base Offset,Segment
   166 0000006B ??                  <2> spurious_irq    resb    1	;*/	byte spurious_irq;	/* 40:6B Last spurious interrupt IRQ
   167                              <2> ;;---------------[Timer data area]---------------;
   168 0000006C ????????            <2> timer_ticks     resd    1	;*/	dword timer_ticks;	/* 40:6C Ticks since midnight (lo,hi)
   169 00000070 ??                  <2> timer_new_day   resb    1	;*/	byte timer_new_day;	/* 40:70 Non-zero if new day
   170                              <2> ;;---------------[System data area]--------------;
   171 00000071 ??                  <2> break_flag      resb    1	;*/	byte break_flag;	/* 40:71 Sign bit set iff break
   172 00000072 ????                <2> warm_boot       resw    1	;*/	word warm_boot;		/* 40:72 Warm boot iff==1234h
   173                              <2> ;;---------------[Hard disk scratchpad]----------;
   174 00000074 ????????            <2> hdd_scratch     resd    1	;*/	word hdd_scratch[2];	/* 40:74
   175                              <2> ;;---------------[Timout areas/PRT/LPT]----------;
   176 00000078 ????????            <2> lpt_timeout     resb    4	;*/	byte lpt_timeout[4];	/* 40:78 Ticks for LPT 1-4 timeouts
   177 0000007C ????????            <2> com_timeout     resb    4	;*/	byte com_timeout[4];	/* 40:7C Ticks for COM 1-4 timeouts
   178                              <2> ;;---obsolete----[Keyboard buf start/end]---jrc--;
   179 00000080 ????                <2> kbd_buffer_start resw   1	;*/	word kbd_buffer_start;	/* 40:80 KBD buffer head (PC/AT)
   180 00000082 ????                <2> kbd_buffer_end  resw    1	;*/	word kbd_buffer_end;	/* 40:82 KBD buffer tail (PC/AT)
   181                              <2> ;;---------------[EGA stuff]---------------------;
   182 00000084 ??????????????      <2> EGA_stuff	resb	7	;*/	byte EGA_stuff[7];	/* 40:84 Unspecified EGA data
   183                              <2> ;;---------------[Floppy/Fixed Media Info]-------------;
   184 0000008B ??                  <2> fdc_last_rate	resb	1	;*/	byte fdc_last_rate;	/* 40:8B Last floppy step rate/data rate?
   185 0000008C ????????            <2> fx_misc_unused	resb	4	;*/	byte fx_misc_unused[4];	/* 40:8C Fixed disk miscellaneous ???
   186 00000090 ????                <2> fdc_disk_state	resb	2	;*/	byte fdc_disk_state[2];	/* 40:90 Floppy disk state
   187 00000092 ????                <2> fdc_op_start	resb	2	;*/	byte fdc_op_start[2];	/* 40:92 Floppy operation start state machine
   188 00000094 ????                <2> fdc_cylinder	resb	2	;*/	byte fdc_cylinder[2];	/* 40:94 Floppy present cylinder
   189                              <2> ;;---------------[Additional KBD flags]----------------;
   190 00000096 ??                  <2> kbd_flag_3	resb	1	;*/	byte kbd_flag_3;	/* 40:96 kbd ???
   191 00000097 ??                  <2> kbd_flag_2	resb	1	;*/	byte kbd_flag_2;	/* 40:97 kbd ???
   192                              <2> ;;---------------[RTC/timer1 data]---------------------;
   193 00000098 ????????            <2> user_semaphore	resw	2	;*/	byte *user_semaphore;	/* 40:98 User semaphore in (bit 7)
   194 0000009C ????????            <2> rtc_count	resd	1	;*/	dword rtc_count;	/* 40:9C RTC tick counter
   195 000000A0 ??                  <2> rtc_wait_active	resb	1	;*/	byte rtc_wait_active;	/* 40:A0 Busy=01, Posted=80h, 
   196                              <2> ;;---------------[Cassette I/O stuff]------------------;
   197 000000A1 ??                  <2> last_val	resb	1	;*/	byte last_val;		/* 40:A1 Last byte read value
   198 000000A2 ????                <2> crc_reg		resw	1	;*/	word crc_reg;		/* 40:A2 CRC accumulation area
   199                              <2> ;									Post Acknowleged=00;
   200 000000A4 ??                  <2> EGA_data	resb	1	;*/	byte EGA_data;		/* 40:A4 Various usage
   201 000000A5 ????                <2> SDstatus	resb	2	;*/	byte SDstatus[2];	/* 40:A5 Status byte from command
   202 000000A7 ????                <2> SDcardtype	resb	2	;*/	byte SDcardtype[2];	/* 40:A7 SDcard type SDSC=2, HC=3, ...
   203                              <2> ;
   204 000000A9 ????????            <2> fixed_disk_tab	resb	4	;*/	byte fixed_disk_tab[4];	/* dispatch table to fixed disk drivers
   205 000000AD ??                  <2> wait12_count	resb	1	;*/	byte wait12_count;	/* 40:AD 12usec CX count
   206 000000AE ??                  <2> lock_count	resb	1	;*/	byte lock_count;	/* 40:AE lock level counter
   207 000000AF ??                  <2> EMS_start       resb    1	;*/	byte EMS_start;		/* start EMS allocation from here
   208                              <2> fx80		equ	$	;*/	struct EDD_disk fx80;	/* fixed disk parameter area 0
   209 000000B0 ????                <2> fx_log_cylinders resw   1	;	word fx_log_cylinders;	 logical number of cylinders
   210 000000B2 ??                  <2> fx_log_heads    resb    1	;	byte fx_log_heads;	 logical number of heads
   211 000000B3 ??                  <2> fx_signature	resb	1	;	byte fx_signature;	 A0h signature = translated geom
   212 000000B4 ??                  <2> fx_phys_sectors	resb    1       ;	byte fx_phys_sectors;	 physical number of sectors per track
   213 000000B5 ????                <2> fx_LBA_high     resw    1       ;	word fx_LBA_high;	 high word of LBA28 number of sectors
   214 000000B7 ??                  <2> fx_reserved	resb	1	;	byte fx_reserved;	 reserved for future use
   215 000000B8 ??                  <2> fx_drive_control resb   1       ;	byte fx_drive_control;	 flag bits for IDE head register
   216 000000B9 ????                <2> fx_phys_cylinders resw	1	;	word fx_phys_cylinders;	 physical number of cylinders
   217 000000BB ??                  <2> fx_phys_heads	resb	1	;	byte fx_phys_heads;	 physical number of heads
   218 000000BC ????                <2> fx_LBA_low	resw	1	;	word fx_LBA_low;	 low word of LBA28 number of sectors
   219 000000BE ??                  <2> fx_log_sectors	resb	1	;	byte fx_log_sectors;	 logical number of sectors per track
   220 000000BF ??                  <2> fx_checksum	resb	1	;	byte fx_checksum;	 checksum, dunno how to compute
   221 000000C0 <res 10h>           <2> fx81            resb    16	;*/	struct EDD_disk fx81;	/* fixed disk parameter area 1
   222 000000D0 <res 10h>           <2> fx82            resb    16	;*/	struct EDD_disk fx82;	/* fixed disk parameter area 2
   223 000000E0 <res 10h>           <2> fx83            resb    16	;*/	struct EDD_disk fx83;	/* fixed disk parameter area 3
   224                              <2> ;
   225                              <2> ;
   226                              <2> 
   227 000000F0 ????                <2> FPEM_segment    resw    1       ;*/	word FPEM_segment;	/* FPEM data segment
   228                              <2> 
   229 000000F2 ????                <2> EBDA_paragraph  resw    1       ;*/	word EBDA_paragraph;	/* lowest EBDA paragraph
   230                              <2> 
   231 000000F4 ????                <2> dma0_cw         resw    1       ;*/	word dma0_cw;		/* end of dma control word
   232 000000F6 ????                <2> dma1_cw         resw    1       ;*/	word dma1_cw;		/*   ditto
   233                              <2> 
   234 000000F8 ????                <2> fdc_type	resb	2	;*/	byte fdc_type[2];	/* disk type in low nibble, alternate in hi nib 
   235                              <2> 
   236 000000FA ????????            <2> debug_static_ptr  resw	2	;*/	void *debug_static_ptr;	/* pointer to debug static area
   237                              <2> 
   238 000000FE ??                  <2> n_fixed_disks   resb    1       ;*/	byte n_fixed_disks;	/* number of fixed disks
   239                              <2> 
   240 000000FF ??                  <2> cpu_xtal        resb    1       ;*/	byte cpu_xtal;		/* CPU crystal frequency in Mhz 
   241                              <2> ;								   CPU clock is half of this
   242                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   243                              <2> ;
   244                              <2> ;  System configuration stuff below
   245                              <2> ;	c.f., CONFIG.ASM (ANSI.CFG, CVDU.CFG, etc.), User configuration stuff
   246                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   247                              <2> %if 0				;*/
   248                              <2> #define FIXED_DISK_MAX 4		/*
   249                              <2> %else
   250                              <2> %define FIXED_DISK_MAX 4
   251                              <2> %endif
   252                              <2> %if 0				;*/
   253                              <2> #define PPIDE_driver 1		/*
   254                              <2> %else
   255                              <2> %define PPIDE_driver 1
   256                              <2> %endif
   257                              <2> %if 0				;*/
   258                              <2> #define DIDE_driver 0		/*
   259                              <2> %else
   260                              <2> %define DIDE_driver 0
   261                              <2> %endif
   262                              <2> %if 0				;*/
   263                              <2> #define DISKIO_driver 1		/*
   264                              <2> %else
   265                              <2> %define DISKIO_driver 1
   266                              <2> %endif
   267                              <2> %if 0				;*/
   268                              <2> #define MFPIC_driver 1		/*
   269                              <2> %else
   270                              <2> %define MFPIC_driver 1
   271                              <2> %endif
   272                              <2> %if 0				;*/
   273                              <2> #define DSD_driver 1		/*
   274                              <2> %else
   275                              <2> %define DSD_driver 1
   276                              <2> %endif
   277                              <2> %if 0				;*/
   278                              <2> #define V3IDE8_driver (SBC188==3)		/*
   279                              <2> %else
   280                              <2> %define V3IDE8_driver (SBC188==3)
   281                              <2> %endif
   282                              <2> 				;*/
    74                              <1> 
    75                              <1> ;  this must be the same in EQUATES.H */
    76                              <1> %if SOFT_DEBUG
    77                              <1> %define NBREAK  8
    78                              <1> %endif
    79                              <1> 
    80                              <1> 
    81                              <1> %if 0
    82                              <1>         segment _TEXT
    83                              <1> ;; *************************************************************************
    84                              <1> 
    85                              <1> 
    86                              <1> 
    87                              <1> 
    88                              <1> ;; ************************ DOS Data Segment *******************************
    89                              <1> ;dosdir	SEGMENT at 50h				; Boot disk directory from IPL
    90                              <1> ;xerox	label	byte				;  0 if Print Screen idle
    91                              <1> ;						;  1 if PrtSc xeroxing screen
    92                              <1> ;						;255 if PrtSc error in xerox
    93                              <1> ;						;  ...non-grafix PrtSc in bios
    94                              <1> ;	db	200h dup(?)			; PC-DOS bootstrap procedure
    95                              <1> ;						;  ...IBMBIO.COM buffers the
    96                              <1> ;						;  ...directory of the boot
    97                              <1> ;						;  ...device here at IPL time
    98                              <1> ;						;  ...when locating the guts
    99                              <1> ;						;  ...of the operating system
   100                              <1> ;						;  ...filename "IBMDOS.COM"
   101                              <1> ;dosdir	ends
   102                              <1> ;; *************************************************************************
   103                              <1> ;; ************************ DOS IPL Segment ********************************
   104                              <1> ;dosseg	SEGMENT at 70h				; "Kernel" of PC-DOS op sys
   105                              <1> ;;IBMBIO.COM file loaded by boot block. Device Drivers/Bootstrap. CONTIGUOUS<---
   106                              <1> ;;IBMDOS.COM operating system nucleus immediately follows IBMBIO.COM and       !
   107                              <1> ;;     doesn`t have to be contiguous.  The IBMDOS operating system nucleus     !
   108                              <1> ;;     binary image is loaded by transient code in IBMBIO binary image	      !
   109                              <1> ;dosseg	ends					;			      !
   110                              <1> ;iplseg	SEGMENT at 0h				; Segment for boot block      !
   111                              <1> ;;The following boot block is loaded with 512 bytes on the first sector of     !
   112                              <1> ;;the bootable device by code resident in the ROM-resident bios.  Control is   !
   113                              <1> ;;then transferred to the first word 0000:7C00 of the disk-resident bootstrap  !
   114                              <1> ;	ORG	07C00h				;  ..offset for boot block    !
   115                              <1> ;boot	db	200h dup(?)			;  ..start disk resident boot--
   116                              <1> ;iplseg	ends
   117                              <1> 
   118                              <1> %endif
    26                                  
    27                                  %define QUICK_VERIFY 1
    28                                  %define DEBUG 0
    29                                  %include	"sdcard.inc"
    30                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    31                              <1> ; SDcard.INC -- include file for Basic I/O routines for the Dual SDcard
    32                              <1> ;		add-on board
    33                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    34                              <1> ;
    35                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    36                              <1> ;
    37                              <1> ; Copyright (c) 2013 John R. Coffman.  All rights reserved.
    38                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    39                              <1> ;
    40                              <1> ; This program is free software: you can redistribute it and/or modify
    41                              <1> ; it under the terms of the GNU General Public License as published by
    42                              <1> ; the Free Software Foundation, either version 3 of the License, or
    43                              <1> ; (at your option) any later version.
    44                              <1> ;
    45                              <1> ; This program is distributed in the hope that it will be useful,
    46                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    47                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    48                              <1> ; GNU General Public License for more details.
    49                              <1> ;
    50                              <1> ; You should have received a copy of the GNU General Public License
    51                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    52                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    53                              <1> ;
    54                              <1> ;;;	cpu	186
    55                              <1> 
    56                              <1> %define	dev_SDcard	08h		; Dual SD card board device code
    57                              <1> 
    58                              <1> %define Z80	1
    59                              <1> %define SBC188	2
    60                              <1> %define M68K	3
    61                              <1> 
    62                              <1> %define TRUE	1
    63                              <1> %define FALSE	0
    64                              <1> 
    65                              <1> %if 0
    66                              <1>  %define CPU	SBC188
    67                              <1> 
    68                              <1>  %if	CPU==Z80
    69                              <1>   IO_BASE		equ	0
    70                              <1>  %elif	CPU==SBC188
    71                              <1>   IO_BASE		equ	0400h
    72                              <1>  %elif	CPU=M68K
    73                              <1>   IO_BASE		equ	0FFFF8000h
    74                              <1>  %else
    75                              <1>   IO_BASE		equ	0
    76                              <1>  %endif
    77                              <1> %endif
    78                              <1> 
    79                              <1> 
    80                              <1> SDoperation	equ	dev_SDcard + IO_BASE
    81                              <1> SDselect	equ	SDoperation + 1
    82                              <1> 
    83                              <1> 
    84                              <1> 
    85                              <1> ; Operation register bits
    86                              <1> CardDetect	equ	20h		; read-only
    87                              <1> WrProt		equ	10h		; read-only
    88                              <1> ChipSelect	equ	04h		; bit 2 (through an inverter)
    89                              <1> Clock		equ	02h		; bit 1
    90                              <1> DataIn		equ	01h
    91                              <1> DataOut		equ	01h		; all Data I/O through bit 0
    92                              <1> 
    93                              <1> ; Select register bits
    94                              <1> Unit		equ	01h		; read/write
    95                              <1> UnitMask	equ	Unit
    96                              <1> 
    97                              <1> WrProt0		equ	04h		; read-only
    98                              <1> WrProt1		equ	08h		; read-only
    99                              <1> 
   100                              <1> CardDetect0	equ	10h		; read/write	(ChangeBit must be set)
   101                              <1> CardDetect1	equ	20h		; read/write	( ditto )
   102                              <1> 
   103                              <1> IntEnable	equ	40h		; write-only	(ChangeBit must be set)
   104                              <1> ChangeBit	equ	80h		; write-only
   105                              <1> Pend0		equ	40h		; read-only
   106                              <1> Pend1		equ	80h		; read-only
   107                              <1> PendMask	equ	Pend0 | Pend1
   108                              <1> 
   109                              <1> CDupdateMask	equ	CardDetect1 | CardDetect0 | UnitMask
   110                              <1> 
   111                              <1> 
   112                              <1> ; Card types:
   113                              <1> SDtypeUnk	equ	0		; unknown card type
   114                              <1> SDtypeMMC	equ	1		; old MMC card
   115                              <1> SDtypeSDSC 	equ	2		; standard card
   116                              <1> SDtypeSDHC	equ	3		; HC card
   117                              <1> 
   118                              <1> 
   119                              <1> %if 1
   120                              <1> ; for the Tiny, Small, or Compact models:
   121                              <1> %define ARG(n) [bp+2+(n)*2]
   122                              <1> %endif
    30                                  
    31                                  ; Do we use CRC's with commands and data transfers?
    32                                  %define USE_CRCs	TRUE
    33                                  
    34                                          global  SDcard_BIOS_call_13h
    35                                          extern  @mulLS
    36                                          extern  microsecond
    37                                  
    38                                  	SEGMENT	_TEXT
    39                                  
    40                                  Zero:
    41                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    42                                  ;  BIOS call entry for Dual SD Card driver
    43                                  ;       int  13h
    44                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    45                                  SDcard_BIOS_call_13h:           ; SDcard driver entry
    46 00000000 FB                              sti                     ; Enable interrupts
    47 00000001 061E60                          pushm   all,ds,es       ; Standard register save
    48 00000004 89E5                            mov     bp,sp           ; establish stack addressing
    49 00000006 6A40                            push    bios_data_seg
    50 00000008 1F90                            popm    ds              ; establish addressability
    51 0000000A FC                              cld
    52                                  ; above done in general Fixed disk entry point
    53                                  
    54                                  
    55                                  	global	DSD_entry
    56                                  DSD_entry:
    57                                  %if SOFT_DEBUG & 0
    58                                  	int 5
    59                                  %endif
    60 0000000B 30FF                            xor     bh,bh           ; zero extend byte
    61 0000000D 88E3                            mov     bl,ah           ; set to index into dispatch table
    62 0000000F 80FC19                          cmp     ah,max/2
    63 00000012 7307                            jae     try_extended
    64 00000014 D1E3                            shl     bx,1            ; index words
    65                                  
    66 00000016 2EFFA7[4200]                cs  jmp     near [dispatch+bx]
    67                                  
    68                                  try_extended:
    69 0000001B 80EB41                          sub     bl,41h          ; start of extended calls
    70 0000001E 80FB0E                          cmp     bl,max41/2
    71 00000021 7307                            jae     undefined
    72 00000023 D1E3                            shl     bx,1            ; index word addresses
    73 00000025 2EFFA7[7400]                cs  jmp     near [dispatch41+bx]
    74                                  
    75                                  
    76                                  ;fn00:           ; Reset Disk System
    77                                  fn01:           ; Get Disk System Status
    78                                  ;fn02:           ; Read Sector
    79                                  ;fn03:           ; Write Sector
    80                                  ;fn04:           ; Verify Sector
    81                                  fn05:           ; Format Track
    82                                  fn06:           ; Format Bad Track (fixed disk) [PC]
    83                                  fn07:           ; Format Drive (fixed disk)     [PC]
    84                                  ;fn08:           ; Get Drive Parameters
    85                                  fn09:           ; Initialize Fixed Disk Characteristics [PC,AT,PS/2]
    86                                  fn0A:           ; Read Sector Long (fixed disk) [PC,AT,PS/2]
    87                                  fn0B:           ; Write Sector Long (fixed disk) [PC,AT,PS/2]
    88                                  fn0C:           ; Seek (fixed disk)
    89                                  fn0D:           ; Reset Fixed Disk System
    90                                  fn0E:           ; Read Sector Buffer (fixed disk) [PC only]
    91                                  fn0F:           ; Write Sector Buffer (fixed disk) [PC only]
    92                                  fn10:           ; Get Drive Status (fixed disk)
    93                                  fn11:           ; Recalibrate Drive (fixed disk)
    94                                  fn12:           ; Controller RAM Diagnostic (fixed disk) [PC/XT]
    95                                  fn13:           ; Controller Drive Diagnostic (fixed disk) [PC/XT]
    96                                  fn14:           ; Controller Internal Diagnostic (fixed disk) [PC,AT,PS/2]
    97                                  ;fn15:           ; Get Disk Type                 [AT]
    98                                  fn16:           ; Get Disk Change Status (floppy)
    99                                  fn17:           ; Set Disk Type (floppy)
   100                                  fn18:           ; Set Media Type for Format (floppy)
   101                                  
   102                                  ;fn41:           ; Check Extensions Present
   103                                  ;fn42:           ; Extended Read
   104                                  ;fn43:           ; Extended Write
   105                                  ;fn44:           ; Extended Verify
   106                                  fn45:           ; Lock/Unlock Drive
   107                                  fn46:           ; Eject Drive
   108                                  ;fn47:           ; Extended Seek
   109                                  ;fn48:           ; Get Drive Parameters
   110                                  fn49:           ; Get Extended Disk Change Status
   111                                  ;fn4E:           ; Set Hardware Configuration
   112                                  
   113                                  undefined:
   114                                  %if SOFT_DEBUG & 0
   115                                          int 5
   116                                  %endif
   117 0000002A B401                            mov     ah,ERR_invalid_command     ; Invalid command
   118 0000002C EB06                    	jmp	error_exit
   119                                  
   120                                  good_exit:
   121 0000002E 30E4                    	xor	ah,ah			; clear the carry, AH=0
   122                                  exit_sequence:
   123 00000030 08E4                            or      ah,ah
   124 00000032 7401                            jz     exit_pops
   125                                  error_exit:
   126 00000034 F9                      	stc				; set the carry
   127                                  exit_pops:
   128 00000035 88660F                          mov     [bp+offset_AH],ah          ; set the error code
   129 00000038 89EC                            mov     sp,bp			; deallocate any variables
   130 0000003A 611F900790                      popm    ALL,ds,es
   131                                  %if SOFT_DEBUG & 0
   132                                  	int 5
   133                                  %endif
   134 0000003F CA0200                          retf	2			; rather than IRET
   135                                  
   136                                  
   137                                  dispatch:
   138 00000042 [F807]                          dw      fn00    ; Reset Disk System
   139 00000044 [2A00]                          dw      fn01    ; 
   140 00000046 [0308]                          dw      fn02
   141 00000048 [0308]                          dw      fn03
   142 0000004A [0308]                          dw      fn04
   143 0000004C [2A00]                          dw      fn05
   144 0000004E [2A00]                          dw      fn06
   145 00000050 [2A00]                          dw      fn07
   146 00000052 [4F08]                          dw      fn08
   147 00000054 [2A00]                          dw      fn09
   148 00000056 [2A00]                          dw      fn0A
   149 00000058 [2A00]                          dw      fn0B
   150 0000005A [2A00]                          dw      fn0C
   151 0000005C [2A00]                          dw      fn0D
   152 0000005E [2A00]                          dw      fn0E
   153 00000060 [2A00]                          dw      fn0F
   154 00000062 [2A00]                          dw      fn10
   155 00000064 [2A00]                          dw      fn11
   156 00000066 [2A00]                          dw      fn12
   157 00000068 [2A00]                          dw      fn13
   158 0000006A [2A00]                          dw      fn14
   159 0000006C [7808]                          dw      fn15
   160 0000006E [2A00]                          dw      fn16
   161 00000070 [2A00]                          dw      fn17
   162 00000072 [2A00]                          dw      fn18
   163                                  max     equ     $-dispatch
   164                                  
   165                                  dispatch41:
   166 00000074 [9B08]                          dw      fn41
   167 00000076 [C208]                          dw      fn42
   168 00000078 [C208]                          dw      fn43
   169 0000007A [C208]                          dw      fn44
   170 0000007C [2A00]                          dw      fn45
   171 0000007E [2A00]                          dw      fn46
   172 00000080 [C208]                          dw      fn47
   173 00000082 [FF08]                          dw      fn48
   174 00000084 [2A00]                          dw      fn49
   175 00000086 [2A00]                          dw      undefined       ; 4A
   176 00000088 [2A00]                          dw      undefined       ; 4B
   177 0000008A [2A00]                          dw      undefined       ; 4C
   178 0000008C [2A00]                          dw      undefined       ; 4D
   179 0000008E [7409]                          dw      fn4E
   180                                  max41   equ     $-dispatch41
   181                                  
   182                                  
   183                                  
   184                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   185                                  ; SDsetunit	set the selected unit (0 or 1) in DI and in SDselect reg.
   186                                  ;
   187                                  ;  Enter with:
   188                                  ;	DS =	Bios Data Area pointer is set
   189                                  ;	DL =	hard drive specifier (80h..83h)
   190                                  ;
   191                                  ;  Return with:
   192                                  ;	DI = 	unit number selected in the h/w (0 or 1)
   193                                  ;	All other registers preserved, including AX
   194                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   195                                  SDsetunit:
   196 00000090 89D7                    	mov	di,dx			; device code to DI
   197 00000092 83E703                  	and	di,FIXED_DISK_MAX-1	; mask device code
   198 00000095 8BBDA900                	mov	di,[fixed_disk_tab+di]	; only the low byte matters
   199 00000099 83E701                  	and	di,UnitMask
   200 0000009C 52                      	push	dx   			; save DX
   201 0000009D 97                      	xchg	ax,di			; save AX and DI
   202 0000009E BA0904                  	mov	dx,SDselect		; unit selection register
   203 000000A1 EE                      	out	dx,al			; select unit 0 or 1
   204 000000A2 97                      	xchg	ax,di			; restore AX and DI
   205 000000A3 5A                      	pop	dx			; restore DX
   206 000000A4 C3                      	ret
   207                                  
   208                                  
   209                                  
   210                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   211                                  ; SDgetunit	get the selected unit# in DI
   212                                  ;
   213                                  ;  Enter with:
   214                                  ;	Nothing
   215                                  ;
   216                                  ;  Return with:
   217                                  ;	DI = 	unit number selected in the h/w (0 or 1)
   218                                  ;	DX =	Operation Register device code
   219                                  ;	All other registers preserved, including AX
   220                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   221                                  SDgetunit:
   222 000000A5 97                      	xchg	ax,di		; save AX in DI
   223 000000A6 BA0904                  	mov	dx,SDselect	; get Select register device code
   224 000000A9 EC                      	in	al,dx
   225 000000AA 83E001                  	and	ax,UnitMask
   226 000000AD 97                      	xchg	ax,di		; set DI, restore AX
   227 000000AE 4A                      	dec	dx		; set Operation Register device code
   228 000000AF C3                      	ret
   229                                  
   230                                  
   231                                  
   232                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   233                                  ; SDputchar	Put a byte to DATIN on the SD card
   234                                  ;
   235                                  ;  Enter with:
   236                                  ;	AL = byte to put out
   237                                  ;	DX = SDoperation register I/O device code
   238                                  ;  Assume:
   239                                  ;	Chip Select is already asserted
   240                                  ;	Clock may be high or low
   241                                  ;
   242                                  ;  Return with:
   243                                  ;	AX is trashed
   244                                  ;	Clock is deasserted, Chip Select is asserted
   245                                  ;
   246                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   247                                  	global	SDputchar
   248                                  SDputchar:
   249 000000B0 51                      	pushm	cx
   250                                  
   251 000000B1 88C4                    	mov	ah,al			; move character to AH
   252 000000B3 B90800                  	mov	cx,8			; count 8 bits
   253                                  
   254 000000B6 B002                    .1:	mov	al, ChipSelect / 2	; will shift it, no clock yet
   255 000000B8 D1C0                    	rol	ax,1			; rotate bit into register
   256 000000BA EE                      	out	dx,al			; output data, no clock
   257 000000BB 0C02                    	or	al, Clock		; rising clock edge
   258 000000BD EE                      	out	dx,al			; 
   259 000000BE E2F6                    	loop	.1
   260                                  
   261 000000C0 24FD                    	and	al,~Clock
   262 000000C2 EE                      	out	dx,al			; set clock low
   263                                  
   264 000000C3 59                      	popm	cx
   265 000000C4 C3                      	ret
   266                                  
   267                                  
   268                                  
   269                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   270                                  ; SDgetchar	Get a byte from DATOUT on the SD card
   271                                  ;
   272                                  ;  Enter with:
   273                                  ;	DX = SDoperation register I/O device code
   274                                  ;  Assume:
   275                                  ;	Chip Select is already asserted
   276                                  ;	Clock is low
   277                                  ;
   278                                  ;  Return with:
   279                                  ;	AL = the byte received
   280                                  ;	AH = copy of AL
   281                                  ;	Clock is low, Chip Select is still asserted
   282                                  ;
   283                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   284                                  	global	SDgetchar
   285                                  SDgetchar:
   286 000000C5 51                      	push	cx
   287                                  
   288 000000C6 B005                    	mov	al, ChipSelect | DataIn
   289 000000C8 EE                      	out	dx,al			; set clock low
   290                                  
   291 000000C9 B90800                  	mov	cx,8			; count 8 bits
   292 000000CC EC                      .1:	in	al,dx			; get input bit
   293 000000CD D0E8                    	shr	al,1
   294 000000CF D0D4                    	rcl	ah,1			; bit into AH
   295 000000D1 B007                    	mov	al,ChipSelect | Clock | DataIn
   296 000000D3 EE                      	out	dx,al			; acknowledge receipt of bit
   297 000000D4 B005                    	mov	al, ChipSelect | DataIn		; no clock
   298 000000D6 EE                      	out	dx,al
   299 000000D7 E2F3                    	loop	.1
   300                                  
   301 000000D9 88E0                    	mov	al,ah			; return byte in AL
   302 000000DB 59                      	pop	cx
   303 000000DC C3                      	ret
   304                                  
   305                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   306                                  ; spin		apply clock pulses to the SD card
   307                                  ;
   308                                  ;  Enter with:
   309                                  ;	CX = character count to spin
   310                                  ;
   311                                  ;  Exit with:
   312                                  ;	AX is trashed
   313                                  ;	CX = 0
   314                                  ;	DX = SDoperation register I/O device code
   315                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   316                                  spin:
   317 000000DD BA0804                  	mov	dx,SDoperation
   318 000000E0 B0FF                    .1:	mov	al,-1
   319 000000E2 E8CBFF                  	call	SDputchar
   320 000000E5 E2F9                      	loop	.1
   321 000000E7 C3                       	ret
   322                                  
   323                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   324                                  ; SDsendclks	send clock transitions to the card
   325                                  ;
   326                                  ;  Enter with:
   327                                  ;	AL = initial state of bits to bang
   328                                  ;	CX = transition count
   329                                  ;	DX = card Operation Register device code
   330                                  ;
   331                                  ;  Return with:
   332                                  ;	AL modified
   333                                  ;	CX = 0
   334                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   335                                  SDsendclks:
   336 000000E8 EE                      .1:	out	dx,al		; put out state of bits specified
   337 000000E9 3402                    	xor	al,Clock
   338 000000EB E2FB                    	loop	.1
   339 000000ED EE                      	out	dx,al		; put out last transition
   340 000000EE C3                      	ret
   341                                  
   342                                  
   343                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   344                                  ; SDdone	complete a transaction
   345                                  ;
   346                                  ;  Enter with:
   347                                  ;	DX = Operation Register device code
   348                                  ;
   349                                  ;  Return with:
   350                                  ;	All registers are preserved
   351                                  ;	Flags are preserved, too
   352                                  ;
   353                                  ;	The card is deselected!!!
   354                                  ;
   355                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   356                                  SDdone:
   357 000000EF 9C5150                  	pushm	ax,cx,f
   358                                  
   359 000000F2 B001                    	mov	al,DataIn	; no ChipSelect or Clock
   360 000000F4 B91000                  	mov	cx,16
   361 000000F7 E8EEFF                  	call	SDsendclks
   362                                  
   363 000000FA 58599D                  	popm	ax,cx,f
   364 000000FD C3                      	ret
   365                                  
   366                                  
   367                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   368                                  ; SDwaitrdy	wait for card to become ready
   369                                  ;
   370                                  ;  Enter with:
   371                                  ;	DX = Operation Register device code
   372                                  ;
   373                                  ;  Return with:
   374                                  ;	Carry = 0	Clear means no error	(AL = 0)
   375                                  ;	Carry = 1	Set means error		(AL = 0xFF)
   376                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   377                                  SDwaitrdy:
   378 000000FE 51                      	pushm	cx
   379                                  
   380 000000FF B005                    	mov	al, ChipSelect | DataIn
   381 00000101 EE                      	out	dx,al		; set clock to 0
   382                                  
   383 00000102 B9FF7F                  	mov	cx,7FFFh
   384                                  .1:
   385 00000105 E8BDFF                  	call	SDgetchar
   386 00000108 FEC0                    	inc	al		; 0FFh -> 00h
   387 0000010A 7407                    	jz	.9
   388 0000010C E2F7                    	loop	.1
   389                                  
   390 0000010E FEC8                    	dec	al		; return error byte
   391 00000110 F9                      	stc			; flag error
   392 00000111 EB01                    	jmp	.99		; error exit
   393                                  
   394 00000113 F8                      .9:	clc			; clear the carry
   395 00000114 98                      .99:	cbw			; extend byte to full word
   396 00000115 59                      	popm	cx
   397 00000116 C3                      	ret
   398                                  	
   399                                  
   400                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   401                                  ; SDgoidle	put card in the idle state
   402                                  ;
   403                                  ;  Enter with:
   404                                  ;	DX	Operation register device code
   405                                  ;
   406                                  ;  Return with:
   407                                  ;	AX	response to CMD0
   408                                  ;	Zero flag is set by compare to '01'
   409                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   410                                  SDgoidle:
   411 00000117 B98813                  	mov	cx,5000		; about 5 milliseconds
   412 0000011A 90                      .0:	nop
   413 0000011B E2FD                    	loop	.0
   414                                  
   415 0000011D BE[7B02]                	mov	si,CMD0
   416 00000120 0E                      	pushm	cs
   417 00000121 0790                    	popm	es
   418 00000123 E82502                  	call	cmd_R1
   419                                  
   420 00000126 E8C6FF                  	call	SDdone
   421 00000129 7402                    	jz	.5
   422 0000012B 3C01                    	cmp	al,01h
   423                                  .5:
   424 0000012D C3                      	ret
   425                                  
   426                                  
   427                                  
   428                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   429                                  ; SDcmdset	set up a command with parameters
   430                                  ;
   431                                  ;  Enter with:
   432                                  ;	BL	command byte (40h | ??)
   433                                  ;	DX:AX	4-byte parameter, DH is ms-byte, AL is ls-byte
   434                                  ;
   435                                  ;  Exit with:
   436                                  ;	SP	decreased by 6 bytes
   437                                  ;	ES:SI	(or SS:SP) points at command in the stack
   438                                  ;	AX,BX,CX  are all trashed
   439                                  ;	DX	is reset to Operation register device code
   440                                  ;
   441                                  ;  After the command is executed, the stack is cleared with
   442                                  ;	ADD	SP,6
   443                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   444                                  SDcmdset:
   445 0000012E 59                      	pop	cx		; pop return address
   446                                  
   447                                  ;  bl:dh:dl:ah:al:FF
   448 0000012F 86D3                    	xchg	dl,bl
   449                                  ;  dl:dh:bl:ah:al:FF
   450 00000131 86C3                    	xchg	al,bl
   451                                  ;  dl:dh:al:ah:bl:FF
   452                                  ;;;	mov	bh,0FFh
   453                                  ;  dl:dh:al:ah:bl:bh
   454 00000133 53                      	push	bx
   455 00000134 50                      	push	ax
   456 00000135 52                      	push	dx
   457 00000136 89E6                    	mov	si,sp
   458 00000138 16                      	pushm	ss
   459 00000139 0790                    	popm	es
   460 0000013B 51                      	push	cx		; reset return address
   461                                  %if USE_CRCs
   462 0000013C B90500                  	mov	cx,5		; CRC7 for 5 bytes
   463 0000013F E8F901                  	call	calcCRC7
   464 00000142 268804                    es	mov	[si],al		; store the CRC7
   465 00000145 83EE05                  	sub	si,5		; reset SI to point at CMD string
   466                                  %endif
   467 00000148 BA0804                  	mov	dx,SDoperation	; set for Operation Register device code
   468 0000014B C3                      	ret
   469                                  
   470                                  
   471                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   472                                  ; SDcmdset0	set up a command with no parameters
   473                                  ;
   474                                  ;  Enter with:
   475                                  ;	AL	command code
   476                                  ;
   477                                  ;  Return with:
   478                                  ;	SP	decreased by 6 bytes
   479                                  ;	ES:SI	(or SS:SP) points at command in the stack
   480                                  ;	DX	is reset to Operation register device code
   481                                  ;	AX	is destroyed
   482                                  ;
   483                                  ;  After the command is executed, the stack is cleared with
   484                                  ;	ADD	SP,6
   485                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   486                                  SDcmdset0:
   487 0000014C 5A                      	pop	dx		; save return address
   488 0000014D 6A00                    	push	0		; push 0,CRC
   489 0000014F 6A00                    	push	0		; push 0,0
   490 00000151 30E4                    	xor	ah,ah
   491 00000153 50                      	push	ax		; push CMDx,0
   492                                  	
   493 00000154 89E6                    	mov	si,sp		; set DS:SI to point at command
   494 00000156 16                      	pushm	ss
   495 00000157 0790                    	popm	es
   496 00000159 52                      	push	dx		; push return address
   497                                  
   498                                  %if USE_CRCs
   499 0000015A 5651                    	pushm	cx,si
   500 0000015C B90500                  	mov	cx,5		; CRC7 for 5 bytes
   501 0000015F E8D901                  	call	calcCRC7
   502 00000162 8804                    	mov	[si],al		; store the CRC7
   503 00000164 595E                    	popm	cx,si		; DS:SI set, DX=Oper. reg
   504                                  %endif
   505 00000166 BA0804                  	mov	dx,SDoperation	; set for Operation Register device code
   506 00000169 C3                      	ret
   507                                  
   508                                  
   509                                  
   510                                  
   511                                  
   512                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   513                                  ; SDinit	initialize card status to "init required"
   514                                  ;
   515                                  ;  Enter with:
   516                                  ;	nothing
   517                                  ;
   518                                  ;  Return with:
   519                                  ;	nothing
   520                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   521                                  	global	@SDinit		; C-fastcall
   522                                  @SDinit:
   523                                  SDinit:
   524 0000016A 1E                      	push	ds
   525 0000016B 6A40                    	push	bios_data_seg
   526 0000016D 1F                      	pop	ds
   527 0000016E C706A500FFFF            	mov	word [SDstatus], -1	; zap both status bytes to 0FFh
   528 00000174 1F                      	pop	ds
   529 00000175 C3                      	ret
   530                                  
   531                                  
   532                                  
   533                                  
   534                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   535                                  ; SDinitcard	initialize a newly inserted SD card
   536                                  ;
   537                                  ;  Enter with:
   538                                  ;	AX = card selection (0 or 1)
   539                                  ;
   540                                  ;  Return with:
   541                                  ;	AX = status	(0 means success)
   542                                  ;	Zero flag reflects status
   543                                  ;
   544                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   545                                  	global	@SDinitcard		; C-fastcall
   546                                  @SDinitcard:
   547 00000176 1E525153                	pushm	bx,cx,dx,ds
   548 0000017A 6A40                    	push	bios_data_seg		; get BDA on a C-call
   549 0000017C 1F                      	pop	ds
   550 0000017D E80600                  	call	SDinitcard
   551 00000180 5B595A1F90              	popm	bx,cx,dx,ds
   552 00000185 C3                      	ret
   553                                  
   554                                  SDinitcard:
   555 00000186 065756                  	pushm	si,di,es
   556                                  
   557 00000189 A9FEFF                  	test	ax,~UnitMask		; bits must not be set
   558 0000018C 7403E9E400              	jnz	.error1
   559                                  
   560 00000191 BA0904                  	mov	dx,SDselect
   561 00000194 EE                      	out	dx,al			; select card  1 or 0
   562 00000195 4A                      	dec	dx			; set to Operation Register
   563 00000196 89C7                    	mov	di,ax			; set Unit Index
   564                                  
   565                                  ; Check for card present
   566 00000198 EC                      	in	al,dx			; read Operation register
   567 00000199 A820                    	test	al,20h			; test for Card Detect bit
   568 0000019B B8FCFF                  	mov	ax,-4			; error code for No Card inserted
   569 0000019E 8885A500                	mov	[SDstatus + di],al	; say there is no card
   570 000001A2 7503E9CB00              	jz	.error			; set error code & return
   571                                   
   572 000001A7 E845FF                  	call	SDdone			; seems to help some cards
   573                                  
   574 000001AA B005                    	mov	al,ChipSelect | DataIn	; DataIn is into the SDcard
   575 000001AC B90001                  	mov	cx,256			; 256 clock transitions
   576 000001AF E836FF                  	call	SDsendclks
   577                                  
   578 000001B2 E849FF                  	call	SDwaitrdy		; wait for card to go ready
   579 000001B5 7303E9B000              	jc	.rdytimeout
   580                                  
   581                                  ;;;	call	SDgoidle
   582                                  ;;;	je	.okay
   583 000001BA E85AFF                  	call	SDgoidle		; only 1 needed
   584                                  ;;	mov	ah,$-Zero
   585 000001BD 7403E9B000              	jne	.error			; SDsendclks glitch fixed
   586                                  
   587 000001C2 0E                      	pushm	cs
   588 000001C3 0790                    	popm	es
   589 000001C5 BE[8102]                	mov	si,CMD8			; v.2 cards require CMD8
   590 000001C8 E88001                  	call	cmd_R1
   591 000001CB A8FE                    	test	al,~01h			; any error bits set (v.1 card)
   592 000001CD 750C                    	jnz	.0
   593 000001CF E8F3FE                  	call	SDgetchar		; v.2 card returns 4 more bytes
   594 000001D2 E8F0FE                  	call	SDgetchar
   595 000001D5 E8EDFE                  	call	SDgetchar
   596 000001D8 E8EAFE                  	call	SDgetchar
   597                                  .0:
   598 000001DB E811FF                  	call	SDdone
   599                                  
   600 000001DE B9FF7F                  	mov	cx,7FFFh	; init try counter
   601                                  .1:
   602 000001E1 51                      	pushm	cx
   603 000001E2 B98813                  	mov	cx,5000		; about 5 milliseconds
   604 000001E5 90                      .11:	nop
   605 000001E6 E2FD                    	loop	.11		; delay loop
   606 000001E8 59                      	popm	cx
   607                                  
   608 000001E9 0E                      	pushm	cs
   609 000001EA 0790                    	popm	es
   610 000001EC BE[9902]                	mov	si,CMD55
   611 000001EF E85901                  	call	cmd_R1
   612 000001F2 E8FAFE                  	call	SDdone
   613 000001F5 757B                    	jnz	.error
   614 000001F7 A8FE                    	test	al,~01h		; only 0 and 1 are okay responses
   615                                  ;;	mov	ah,$-Zero
   616 000001F9 7577                    	jnz	.error
   617                                  
   618 000001FB BE[9F02]                	mov	si,ACMD41
   619 000001FE E84A01                  	call	cmd_R1
   620 00000201 E8EBFE                  	call	SDdone
   621 00000204 08C0                    	or	al,al		; test for zero
   622 00000206 7408                    	jz	.2
   623 00000208 FEC8                    	dec	al		; test for 1
   624                                  ;;	mov	ah,$-Zero
   625 0000020A 7566                    	jnz	.error
   626 0000020C E2D3                    	loop	.1
   627                                  
   628 0000020E EB5F                    	jmp	.timeout
   629                                  
   630                                  .2:
   631                                  
   632 00000210 BE[A502]                	mov	si,CMD58
   633 00000213 E83501                  	call	cmd_R1
   634 00000216 754D                    	jnz	.err58			; must respond with a 00h
   635 00000218 E8AAFE                  	call	SDgetchar		; get command response
   636 0000021B B402                    	mov	ah,SDtypeSDSC		; assume standard card
   637 0000021D A840                    	test	al,40h			; test bit 30 of response
   638 0000021F 7402                    	jz	.21
   639 00000221 B403                    	mov	ah,SDtypeSDHC		; set HC card type
   640 00000223 E87FFE                  .21:	call	SDgetunit
   641 00000226 88A5A700                	mov	[SDcardtype + di],ah	; set card type
   642                                  
   643 0000022A E898FE                  	call	SDgetchar		; discard rest of the response
   644 0000022D E895FE                  	call	SDgetchar		; 
   645 00000230 E892FE                  	call	SDgetchar		; 
   646 00000233 E8B9FE                  	call	SDdone
   647                                  
   648                                  %if USE_CRCs
   649 00000236 B80100                  	mov	ax,1			; turn on CRC checking
   650 00000239 31D2                    	xor	dx,dx
   651 0000023B B37B                    	mov	bl, 40h | 59		; CMD59 (CRC on/off)
   652 0000023D E8EEFE                  	call	SDcmdset
   653 00000240 E80801                  	call	cmd_R1
   654 00000243 89F4                    	mov	sp,si			; clear command from stack
   655 00000245 E8A7FE                  	call	SDdone
   656                                  ;;	mov	ah,$-Zero
   657 00000248 7528                    	jnz	.error
   658                                  %endif
   659                                  
   660                                  ; set the desired block length -- CMD16(512)
   661 0000024A 0E                      	pushm	cs
   662 0000024B 0790                    	popm	es
   663 0000024D BE[9302]                	mov	si,CMD16
   664 00000250 E8F800                  	call	cmd_R1
   665 00000253 E899FE                  	call	SDdone
   666                                  ;;	mov	ah,$-Zero
   667 00000256 751A                    	jnz	.error
   668                                  
   669 00000258 31C0                    .okay:	xor	ax,ax			; clear the carry, too
   670                                  
   671                                  .exitstatus:
   672 0000025A 8885A500                	mov	[SDstatus + di], al	; save SD card status
   673                                  .exit:
   674 0000025E 5E5F0790                	popm	si,di,es
   675 00000262 08C0                    	or	al,al			; set the Z-flag
   676 00000264 C3                      	ret
   677                                  
   678                                  .err58:
   679 00000265 E887FE                  	call	SDdone
   680                                  ;;	mov	ah,$-Zero
   681 00000268 EB08                    	jmp	.error
   682                                  .rdytimeout:
   683 0000026A B8FEFF                  	mov	ax,-2
   684 0000026D EB03                    	jmp	.error
   685                                  .timeout:
   686 0000026F B8FFFF                  	mov	ax,-1
   687                                  ;;;	jmp	.error
   688                                  .error:	
   689 00000272 F9                      	stc
   690 00000273 EBE5                    	jmp	.exitstatus
   691                                  
   692                                  .error1:			; caution here, DI is not set up
   693 00000275 B8FDFF                  	mov	ax,-3
   694 00000278 F9                      	stc
   695 00000279 EBE3                    	jmp	.exit
   696                                  
   697                                  
   698                                  
   699                                  
   700                                  
   701                                  CRC_unknown	equ	0FFh
   702                                  
   703                                  ;ResetCommand:
   704 0000027B 400000000095            CMD0		db	40h | 0, 0, 0, 0, 0, 95h
   705 00000281 48000001AA87            CMD8		db	40h | 8, 0, 0, 01h, 0AAh, 87h
   706 00000287 4900000000AF            CMD9		db	40h | 9, 0, 0, 0, 0, 0AFh
   707 0000028D 4A000000001B            CMD10:		db	40h | 10, 0, 0, 0, 0, 01Bh
   708 00000293 500000020015            CMD16:		db	40h | 16, 0, 0, 512>>8, 512&0xFF, 015h
   709 00000299 770000000065            CMD55		db	40h | 55, 0, 0, 0, 0, 065h
   710 0000029F 694000000077            ACMD41		db	40h | 41, 40h, 0, 0, 0, 077h
   711 000002A5 7A00000000FD            CMD58		db	40h | 58, 0, 0, 0, 0, 0FDh
   712                                  
   713                                  
   714                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   715                                  ;  DSDgetInfo	C-callable routine to get OCR, CSD, & CID
   716                                  ;
   717                                  ;	byte DSDgetInfo(int unit, byte buffer[36]);
   718                                  ;
   719                                  ;  Return:
   720                                  ;	buffer filled with OCR, CSD, CID
   721                                  ;
   722                                  ;  Errors:
   723                                  ;	No Error	0
   724                                  ;	get OCR		1
   725                                  ;	get CSD		2
   726                                  ;	get CID		3
   727                                  ;
   728                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   729                                  	global	_DSDgetInfo
   730                                  _DSDgetInfo:
   731 000002AB 55                              push    bp
   732 000002AC 89E5                            mov     bp,sp
   733 000002AE 065657525153            	pushm	bx,cx,dx,di,si,es
   734                                  
   735 000002B4 8B4604                  	mov	ax,ARG(1)
   736 000002B7 BA0804                  	mov	dx,SDoperation
   737 000002BA EE                      	out	dx,al
   738                                  
   739 000002BB E840FE                  	call	SDwaitrdy	; wait for card to go ready
   740 000002BE C45E06                  	les	bx,ARG(2)
   741                                  
   742                                  ; get the OCR
   743 000002C1 06                      	push	es
   744 000002C2 0E                      	pushm	cs
   745 000002C3 07                      	pop	es
   746 000002C4 BE[A502]                	mov	si,CMD58
   747 000002C7 E88100                  	call	cmd_R1
   748 000002CA 07                      	pop	es
   749 000002CB B80101                  	mov	ax,0101h		; AH=1, AL=1
   750 000002CE 750E                          	jnz	.ocr2			; error if not Zero
   751 000002D0 B90400                  	mov	cx,4
   752 000002D3 E8EFFD                  .ocr	call	SDgetchar		; discard rest of the response
   753 000002D6 268807                    es	mov	[bx],al
   754 000002D9 43                        	inc	bx
   755 000002DA E2F7                    	loop	.ocr
   756 000002DC 31C0                    	xor	ax,ax			; set the Z flag
   757                                  .ocr2:
   758 000002DE E80EFE                  	call	SDdone
   759 000002E1 7532                    	jnz	.error
   760                                  
   761                                  ; get the Card Specific Data (CSD) register contents
   762 000002E3 06                      	push	es
   763 000002E4 0E                      	pushm	cs
   764 000002E5 07                      	pop	es
   765 000002E6 BE[8702]                	mov	si,CMD9
   766 000002E9 E85F00                  	call	cmd_R1
   767 000002EC 07                      	pop	es
   768 000002ED B91000                  	mov	cx,16
   769 000002F0 E8B500                  	call	SDgetdata
   770 000002F3 E8F9FD                  	call	SDdone
   771 000002F6 B80202                  	mov	ax,0202h		; AH=2, AL=2
   772 000002F9 751A                    	jnz	.error
   773                                  
   774                                  
   775                                  ; get the Card Identification Data (CID) register contents
   776 000002FB 06                      	push	es
   777                                  
   778 000002FC 0E                      	pushm	cs
   779 000002FD 07                      	pop	es
   780 000002FE BE[8D02]                	mov	si,CMD10
   781 00000301 E84700                  	call	cmd_R1
   782 00000304 07                      	pop	es
   783                                  
   784 00000305 B91000                  	mov	cx,16
   785 00000308 E89D00                  	call	SDgetdata
   786 0000030B E8E1FD                  	call	SDdone
   787 0000030E B80303                  	mov	ax,0303h		; AH=3, AL=3
   788 00000311 7502                    	jnz	.error
   789                                  
   790 00000313 31C0                    	xor	ax,ax		; signal No Error
   791                                  .error:
   792                                  
   793 00000315 5B595A5F5E0790          	popm	bx,cx,dx,di,si,es
   794 0000031C 89EC                    	mov	sp,bp
   795 0000031E 5D                      	pop	bp
   796 0000031F C3                      	ret
   797                                  
   798                                  
   799                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   800                                  ; stepCRC7	include a byte in a CRC7 polynomial
   801                                  ;
   802                                  ;  Enter with:
   803                                  ;	DL = partial CRC calculation
   804                                  ;	AL = character to add into the calculation
   805                                  ;
   806                                  ;  Return with:
   807                                  ;	DL = updated CRC calculation
   808                                  ;	AX is trashed
   809                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   810                                  CRC7poly	equ	00001001b
   811                                  CRC7poly2	equ	CRC7poly*2	; 7 bits only
   812                                  
   813                                  	 global stepCRC7, @stepCRC7
   814                                  stepCRC7:
   815                                  @stepCRC7:
   816 00000320 51                      	push	cx
   817                                  
   818 00000321 B90800                  	mov	cx,8 			; 8 bits in AL
   819                                  .1:	
   820 00000324 88D4                    	mov	ah,dl			; copy CRC to AH
   821 00000326 30C4                    	xor	ah,al			; Sign bit is 0 or 1
   822 00000328 D1E0                    	shl	ax,1
   823 0000032A 18E4                    	sbb	ah,ah			; AH is 0 or -1
   824 0000032C D0E2                    	shl	dl,1			; shift polynomial
   825 0000032E 80E412                  	and	ah,CRC7poly2		; get bits to add into the CRC
   826 00000331 30E2                    	xor	dl,ah			; update the polynomial
   827 00000333 E2EF                    	loop	.1
   828                                  	
   829 00000335 88D0                    	mov	al,dl			; return in AX also
   830 00000337 30E4                    	xor	ah,ah
   831 00000339 59                      	pop	cx
   832 0000033A C3                      	ret
   833                                  	
   834                                  
   835                                  
   836                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   837                                  ; calcCRC7	calculate a CRC7 polynomial (for a command)
   838                                  ;
   839                                  ;  Enter with:
   840                                  ;	ES:SI	points at a string of bytes
   841                                  ;	CX	count of bytes in the string
   842                                  ;	direction flag clear
   843                                  ;
   844                                  ;  Return with:
   845                                  ;	ES:SI	point at next byte beyond end of string
   846                                  ;	CX = 0
   847                                  ;	AL = CRC7 polynomial byte
   848                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   849                                  calcCRC7:
   850 0000033B 52                      	push	dx
   851 0000033C 31D2                    	xor	dx,dx		; start CRC7 at zero
   852                                  .1:
   853 0000033E 26AC                      es	lodsb
   854 00000340 E8DDFF                  	call	stepCRC7
   855 00000343 E2F9                    	loop	.1
   856                                  
   857 00000345 88D0                    	mov	al,dl		; final CRC7 to AL
   858 00000347 0C01                    	or	al,01h		; set the low bit
   859 00000349 5A                      	pop	dx
   860 0000034A C3                      	ret
   861                                  
   862                                  
   863                                  
   864                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   865                                  ; cmd_R1	issue command and get R1 response
   866                                  ;
   867                                  ;  Enter with:
   868                                  ;	ES:SI	far pointer to command string
   869                                  ;	DX	device code for Operation register
   870                                  ;
   871                                  ;  Exit with:
   872                                  ;	byte value of response to the command
   873                                  ;	-1 if error (such as no response)
   874                                  ;
   875                                  ;	SI	is incremented by 6, the length of a command
   876                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   877                                  cmd_R1:
   878 0000034B 51                      	pushm	cx
   879 0000034C B90600                  	mov	cx,6		; all commands are 6 bytes
   880                                  .1:
   881 0000034F 26AC                      es	lodsb
   882 00000351 E85CFD                  	call	SDputchar
   883 00000354 E2F9                    	loop	.1
   884                                  %if DEBUG>=4
   885                                  	pushm	bx,di,es
   886                                  
   887                                  	mov	bx,-1
   888                                  	mov	cx,lbuf
   889                                  	pushm	cs
   890                                  	popm	es
   891                                  	mov	di,buffer
   892                                  .2:
   893                                  	call	SDgetchar
   894                                  	stosb				; save for debug
   895                                  	test	al,80h
   896                                  	jz	.3
   897                                  	mov	bl,al
   898                                  	loop	.2
   899                                  	mov	ax,bx 
   900                                  .3:
   901                                  	popm	bx,di,es
   902                                  %else
   903 00000356 B90900                  	mov	cx,9			; response must come within 8 chars
   904 00000359 E869FD                  .2:	call	SDgetchar
   905 0000035C A880                    	test	al,80h			; check high bit for zero
   906 0000035E 7405                    	jz	.4			; 0xxx xxxxb is result byte
   907 00000360 E2F7                    	loop	.2
   908                                  %endif
   909 00000362 98                      	cbw				; extend to whole word
   910 00000363 08C0                    	or	al,al			; clear zero flag
   911                                  .4:				; Zero flag set if jumped here
   912 00000365 59                      	popm	cx
   913 00000366 C3                      	ret
   914                                  
   915                                  
   916                                  
   917                                  %if USE_CRCs
   918                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   919                                  ; crc_step	one step in CRC calculation
   920                                  ;
   921                                  ;  Enter with:
   922                                  ;	AL	byte to be added to the CRC computation
   923                                  ;	CX,DX	not to be touched
   924                                  ;	SI	partial CRC computation
   925                                  ;
   926                                  ;  Return with:
   927                                  ;	CX,DX	preserved
   928                                  ;	BX	is destroyed
   929                                  ;	SI	updated CRC computation
   930                                  ;
   931                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   932                                  crc_step:
   933 00000367 87CE                    	xchg	cx,si		; preserve CX in SI
   934                                  .2:
   935 00000369 88EB                    	mov	bl,ch		; form index into table
   936 0000036B 30FF                    	xor	bh,bh		; zap BH
   937 0000036D 30C3                    	xor	bl,al		; use current byte in AL
   938                                  
   939 0000036F 88CD                      	mov	ch,cl		; update CRC16
   940 00000371 30C9                    	xor	cl,cl
   941 00000373 D1E3                    	shl	bx,1
   942 00000375 2E338F[4305]              cs	xor	cx,[crc16tab + bx]
   943                                  
   944 0000037A 87CE                    	xchg	cx,si		; put new crc back in SI
   945 0000037C C3                      	ret
   946                                  %endif
   947                                  
   948                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   949                                  ; SDtestdata	test crc on a block of data
   950                                  ;
   951                                  ;  Enter with:
   952                                  ;	CX	count of data bytes to get
   953                                  ;	DX	set to Operation register device code
   954                                  ;
   955                                  ;  Return with:
   956                                  ;    Good return:
   957                                  ;	CX =	CRC16 returned by the call
   958                                  ;	AX =	0
   959                                  ;	Zero flag is set
   960                                  ;
   961                                  ;    Error return:
   962                                  ;	BX	not changed
   963                                  ;	CX	not changed
   964                                  ;	AX =	error code
   965                                  ;	Zero flag is clear
   966                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   967                                  SDtestdata:
   968 0000037D 5653                    	pushm	bx,si			; save BX, SI
   969                                  
   970 0000037F 51                      	pushm	cx			; save byte count
   971                                  
   972 00000380 B9FF7F                  	mov	cx,7FFFh		; timeout count
   973                                  .1:
   974 00000383 E83FFD                  	call	SDgetchar		; get an input byte
   975 00000386 3CFF                    	cmp	al,0FFh			; any return yet?
   976 00000388 7502                    	jne	.2			;
   977 0000038A E2F7                    	loop	.1
   978                                  .2:
   979 0000038C 59                      	popm	cx			; restore data count
   980                                  
   981 0000038D 3CFE                    	cmp	al,0FEh			; timeout or start of data?
   982 0000038F 7511                    	jne	.4			; jump if timeout
   983                                  
   984 00000391 31F6                    	xor	si,si			; start CRC at zero
   985 00000393 83C102                  	add	cx,2			; 
   986 00000396 E82CFD                  .3:	call	SDgetchar
   987                                  %if USE_CRCs
   988 00000399 E8CBFF                  	call	crc_step		; update the CRC in SI
   989                                  %endif
   990 0000039C E2F8                    	loop	.3			; get all the bytes
   991                                  
   992                                  .99:
   993 0000039E 89F1                    	mov	cx,si			; CRC to CX
   994 000003A0 31C0                    	xor	ax,ax			; good return
   995                                  .4:				; error return
   996 000003A2 98                      	cbw
   997 000003A3 08C0                    	or	al,al
   998 000003A5 5B5E                    	popm	bx,si			; restore regs
   999 000003A7 C3                      	ret
  1000                                  	global	verify_crc
  1001                                  verify_crc	equ	.99
  1002                                  
  1003                                  
  1004                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1005                                  ; SDgetdata	get a block of data
  1006                                  ;
  1007                                  ;  Enter with:
  1008                                  ;	ES:BX	points at buffer to receive data
  1009                                  ;	CX	count of data bytes to get
  1010                                  ;	DX	set to Operation register device code
  1011                                  ;
  1012                                  ;  Return with:
  1013                                  ;    Good return:
  1014                                  ;	CX =	CRC16 returned by the call
  1015                                  ;	AX =	0
  1016                                  ;	Zero flag is set
  1017                                  ;
  1018                                  ;    Error return:
  1019                                  ;	ES:BX	not changed
  1020                                  ;	CX	not changed
  1021                                  ;	AX =	error code
  1022                                  ;	Zero flag is clear
  1023                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1024                                  SDgetdata:
  1025 000003A8 51                      	pushm	cx			; save byte count
  1026                                  
  1027 000003A9 B9FF7F                  	mov	cx,7FFFh		; timeout count
  1028                                  .1:
  1029 000003AC E816FD                  	call	SDgetchar		; get an input byte
  1030 000003AF 3CFF                    	cmp	al,0FFh			; any return yet?
  1031 000003B1 7502                    	jne	.2			;
  1032 000003B3 E2F7                    	loop	.1
  1033                                  .2:
  1034 000003B5 59                      	popm	cx			; restore data count
  1035 000003B6 3CFE                    	cmp	al,0FEh			; timeout or start of data?
  1036 000003B8 7515                    	jne	.4			; jump if timeout
  1037                                  
  1038 000003BA E808FD                  .3:	call	SDgetchar
  1039 000003BD 268807                    es	mov	[bx],al			; store data read
  1040 000003C0 43                        	inc	bx
  1041 000003C1 E2F7                    	loop	.3			; get all the bytes
  1042                                  
  1043 000003C3 E8FFFC                  	call	SDgetchar		; get first CRC16 byte
  1044 000003C6 88C5                    	mov	ch,al
  1045 000003C8 E8FAFC                  	call	SDgetchar
  1046 000003CB 88C1                    	mov	cl,al			; low order CRC16 byte
  1047                                  
  1048 000003CD 31C0                    	xor	ax,ax
  1049                                  .4:				; error return
  1050 000003CF 98                      	cbw
  1051 000003D0 08C0                    	or	al,al
  1052 000003D2 C3                      	ret
  1053                                  
  1054                                  
  1055                                  
  1056                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1057                                  ; SDputdata	put out the data block
  1058                                  ;
  1059                                  ;  Enter with:
  1060                                  ;	AX	CRC16 bytes to send
  1061                                  ;	ES:BX	pointer to the data block to put out
  1062                                  ;	CX	count of data bytes to send
  1063                                  ;	DX	device code of Operation register
  1064                                  ;
  1065                                  ;  Return with:
  1066                                  ;	ES:BX	points beyond end of data
  1067                                  ;	CX	is trash
  1068                                  ;
  1069                                  ;	AX = 0, Z=1  means a good return
  1070                                  ;   or	Z=0, AX = error return byte
  1071                                  ;
  1072                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1073                                  SDputdata:
  1074 000003D3 50                      	pushm	ax			; save CRC16 bytes
  1075                                  
  1076 000003D4 B0FE                    	mov	al,0FEh			; start of data packet
  1077 000003D6 E8D7FC                  	call	SDputchar
  1078                                  .1:
  1079 000003D9 268A07                    es	mov	al,[bx]			; get data byte
  1080 000003DC 43                        	inc	bx
  1081 000003DD E8D0FC                  	call	SDputchar
  1082 000003E0 E2F7                    	loop	.1
  1083                                  
  1084 000003E2 59                      	popm	cx			; get CRC bytes
  1085 000003E3 88E8                    	mov	al,ch			; put out hi-CRC16
  1086 000003E5 E8C8FC                  	call	SDputchar
  1087 000003E8 88C8                    	mov	al,cl			; put out lo-CRC16
  1088 000003EA E8C3FC                  	call	SDputchar
  1089                                  
  1090 000003ED B9FF7F                  	mov	cx,7FFFh		; timeout count
  1091                                  .2:
  1092 000003F0 E8D2FC                  	call	SDgetchar		; get byte != FF
  1093 000003F3 3CFF                    	cmp	al,0FFh
  1094 000003F5 7502                    	jne	.3
  1095 000003F7 E2F7                    	loop	.2
  1096                                  .3:
  1097 000003F9 241F                    	and	al,1Fh			; mask return acknowledge
  1098 000003FB 98                      	cbw
  1099 000003FC 3C05                    	cmp	al,05h
  1100 000003FE 7502                           	jne	.error			; Z=0
  1101 00000400 31C0                    	xor	ax,ax			; Z=1, AX=0
  1102                                  .error:
  1103 00000402 C3                      	ret
  1104                                  
  1105                                  
  1106                                  %if SOFT_DEBUG
  1107                                  	global	SD_put_return
  1108                                  SD_put_return equ  .3
  1109                                  %endif
  1110                                  
  1111                                  
  1112                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1113                                  ; SDcheck	check for drive readable/writeable
  1114                                  ;
  1115                                  ;  Enter with:
  1116                                  ;	AH = 2	check for card readable
  1117                                  ;	AH = 3	check for card writeable
  1118                                  ;
  1119                                  ;  Return with:
  1120                                  ;	AX =	error code (0 means okay)
  1121                                  ;	Zero flag is set/reset per AX
  1122                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1123                                  SDcheck:
  1124 00000403 E89FFC                  	call	SDgetunit		; set up DX, DI
  1125                                  
  1126 00000406 EC                      	in	al,dx			; check HW status
  1127 00000407 A820                    	test	al,CardDetect		; card inserted?
  1128 00000409 741B                    	jz	.nocard
  1129 0000040B F6C401                  	test	ah,1			; test LSB of AH
  1130 0000040E 7404                    	jz	.0			; read test
  1131 00000410 A810                    	test	al,WrProt		; writeable?
  1132 00000412 7517                    	jnz	.wrprot			; not writeable
  1133                                  .0:
  1134 00000414 80BDA50000              	cmp	byte [SDstatus + di], 0	; check for unit initialized
  1135 00000419 7407                    	je	.1
  1136 0000041B 89F8                    	mov	ax,di
  1137 0000041D E866FD                  	call	SDinitcard
  1138 00000420 750E                    	jne	.ret			; return if error on init
  1139                                  .1:
  1140 00000422 31C0                    	xor	ax,ax			; good return
  1141 00000424 EB0A                    	jmp	.ret
  1142                                  
  1143                                  .nocard:
  1144 00000426 B8FAFF                  	mov	ax,-6			; no card inserted
  1145 00000429 EB03                    	jmp	.exit
  1146                                  .wrprot:
  1147 0000042B B8F9FF                  	mov	ax,-7			; card is write protected
  1148                                  
  1149 0000042E 09C0                    .exit:	or	ax,ax
  1150 00000430 C3                      .ret:	ret
  1151                                  
  1152                                  
  1153                                  
  1154                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1155                                  ; SDsetaddr	set up card sector address
  1156                                  ;
  1157                                  ;  Enter with:
  1158                                  ;	DX:AX	sector address (512 byte sectors)
  1159                                  ;	DI	unit number
  1160                                  ;
  1161                                  ;  Return with:
  1162                                  ;	DX:AX	byte address for SDSC cards
  1163                                  ;		unchanged for SDHC cards
  1164                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1165                                  SDsetaddr:
  1166 00000431 80BDA70003              	cmp	byte [SDcardtype + di], SDtypeSDHC
  1167 00000436 730C                    	jae	.6
  1168                                  ; SDSC cards and below use byte addressing
  1169                                  ; multiply DX:AX by 512
  1170 00000438 88D6                    	mov	dh,dl		; shift by 8
  1171 0000043A 88E2                    	mov	dl,ah
  1172 0000043C 88C4                    	mov	ah,al
  1173 0000043E 30C0                    	xor	al,al		; **
  1174 00000440 D1E0                    	shl	ax,1		; double shift by one more
  1175 00000442 D1D2                    	rcl	dx,1
  1176                                  				; all shifted by 9 (2**9 == 512)
  1177                                  .6:
  1178 00000444 C3                      	ret
  1179                                  
  1180                                  
  1181                                  
  1182                                  
  1183                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1184                                  ; SDread1sec	Read a single sector (of 512 bytes)
  1185                                  ;
  1186                                  ;  Enter with:
  1187                                  ;	DX:AX	sector number to read
  1188                                  ;	ES:BX	buffer to receive data
  1189                                  ;
  1190                                  ;  Return with:
  1191                                  ;	CL	error code (0 means success)
  1192                                  ;	DX:AX	preserved
  1193                                  ;	ES:BX	preserved
  1194                                  ;	SI, DI, CH are preserved
  1195                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1196                                  SDread1sec:
  1197 00000445 5756525350              	pushm	ax,bx,dx,si,di
  1198 0000044A 51                      	pushm	cx
  1199                                  
  1200 0000044B 0653                    	pushm	bx,es		; save buffer address
  1201 0000044D 5250                    	pushm	ax,dx		; save sector number
  1202                                  
  1203 0000044F B402                    	mov	ah,2		; show it is a read check
  1204 00000451 E8AFFF                  	call	SDcheck
  1205 00000454 753D                    	jnz	.err2
  1206                                  
  1207 00000456 E8A5FC                  	call	SDwaitrdy	; wait for card to go ready
  1208 00000459 7238                    	jc	.err2
  1209                                  
  1210 0000045B 585A                    	popm	ax,dx		; get sector address
  1211 0000045D E8D1FF                  	call	SDsetaddr	; set up card address in DX:AX
  1212                                  ; DX:AX is byte address (SDSC) or sector address (SDHC)
  1213 00000460 B351                    	mov	bl, 40h | 17	; CMD17 = read one sector
  1214 00000462 E8C9FC                  	call	SDcmdset	; CMD17 (DX:AX) crc
  1215 00000465 E8E3FE                  	call	cmd_R1		; execute the command
  1216 00000468 89F4                    	mov	sp,si		; purge command from the stack
  1217 0000046A 7405                    	jz	.3
  1218 0000046C E880FC                  	call	SDdone		; done if error
  1219 0000046F EB24                          	jmp	.err1		; exit on error
  1220                                  .3:
  1221 00000471 5B0790                  	popm	bx,es		; restore data pointer
  1222 00000474 B90002                  	mov	cx,512		; read 512 bytes
  1223 00000477 E82EFF                  	call	SDgetdata	; **
  1224 0000047A E872FC                  	call	SDdone		; end of command
  1225                                  %if USE_CRCs
  1226 0000047D 7518                    	jnz	.exit
  1227 0000047F 51                      	pushm	cx		; save CRC16 read in
  1228 00000480 B90002                  	mov	cx,512		; check 512 bytes
  1229 00000483 29CB                    	sub	bx,cx		; set ES:BX
  1230 00000485 31C0                    	xor	ax,ax		; start CRC16 at zero
  1231 00000487 E89D00                  	call	crc16
  1232 0000048A 59                      	popm	cx
  1233 0000048B 29C1                    	sub	cx,ax		; compare the two CRC16's
  1234 0000048D 7408                    	jz	.exit
  1235 0000048F B1F8                    	mov	cl,-8		; CRC error on read
  1236                                  %endif
  1237 00000491 EB04                    	jmp	.exit		; exit with error code
  1238                                  
  1239                                  .err2:
  1240 00000493 5E5F                    	popm	si,di		; clear sector number
  1241                                  .err1:
  1242 00000495 5E5F                    	popm	si,di		; clear buffer address
  1243                                  .exit:
  1244 00000497 58                      	popm	ax		; get CX saved
  1245 00000498 88E5                    	mov	ch,ah		; restore CH, CL is error code
  1246 0000049A 585B5A5E5F              	popm	ax,bx,dx,si,di
  1247 0000049F 08C9                    	or	cl,cl		; set the Z flag
  1248 000004A1 C3                      	ret
  1249                                  
  1250                                  
  1251                                  	
  1252                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1253                                  ; SDwrite1sec	write a sector
  1254                                  ;
  1255                                  ;  Enter with:
  1256                                  ;	DX:AX	sector number to write
  1257                                  ;	ES:BX	data buffer from which to write
  1258                                  ;
  1259                                  ;  Return with:
  1260                                  ;	CL	error code (0 means success)
  1261                                  ;	DX:AX	preserved
  1262                                  ;	ES:BX	preserved
  1263                                  ;	SI, DI, CH are preserved
  1264                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1265                                  SDwrite1sec:
  1266 000004A2 5756525350              	pushm	ax,bx,dx,si,di
  1267 000004A7 51                      	pushm	cx
  1268                                  
  1269 000004A8 0653                    	pushm	bx,es		; save buffer address
  1270 000004AA 5250                    	pushm	ax,dx		; save sector number
  1271                                  
  1272 000004AC B403                    	mov	ah,3		; show it is a write check
  1273 000004AE E852FF                  	call	SDcheck
  1274 000004B1 7533                    	jnz	.err2
  1275                                  
  1276 000004B3 E848FC                  	call	SDwaitrdy	; wait for card to go ready
  1277 000004B6 722E                    	jc	.err2
  1278                                  
  1279 000004B8 585A                    	popm	ax,dx		; get sector address
  1280 000004BA E874FF                  	call	SDsetaddr	; set up card address in DX:AX
  1281                                  ; DX:AX is byte address (SDSC) or sector address (SDHC)
  1282 000004BD B358                    	mov	bl, 40h | 24	; CMD24 = write one sector
  1283 000004BF E86CFC                  	call	SDcmdset	; CMD24 (DX:AX) crc
  1284 000004C2 E886FE                  	call	cmd_R1		; execute the command
  1285 000004C5 89F4                    	mov	sp,si		; purge command from the stack
  1286 000004C7 7405                    	jz	.3
  1287 000004C9 E823FC                  	call	SDdone		; done if error
  1288 000004CC EB1A                          	jmp	.err1		; exit on error
  1289                                  .3:
  1290 000004CE 5B0790                  	popm	bx,es		; restore data pointer
  1291                                  %if USE_CRCs
  1292 000004D1 31C0                    	xor	ax,ax		; start CRC16 at zero
  1293 000004D3 B90002                  	mov	cx,512		; write 512 bytes
  1294 000004D6 E84E00                  	call	crc16
  1295 000004D9 B90002                  	mov	cx,512		; write 512 bytes
  1296 000004DC 29CB                    	sub	bx,cx		; restore data pointer
  1297                                  %else
  1298                                  	mov	ax,0FFFFh	; dummy CRC16 
  1299                                  	mov	cx,512		; write 512 bytes
  1300                                  %endif
  1301 000004DE E8F2FE                  	call	SDputdata	; **
  1302 000004E1 E80BFC                  	call	SDdone		; end of command
  1303 000004E4 EB04                    	jmp	.exit
  1304                                  
  1305                                  .err2:
  1306 000004E6 5E5F                    	popm	si,di		; clear sector number
  1307                                  .err1:
  1308 000004E8 5E5F                    	popm	si,di		; clear buffer address
  1309                                  .exit:
  1310 000004EA 88C1                    	mov	cl,al		; move error code to CL
  1311 000004EC 58                      	popm	ax		; get CX saved
  1312 000004ED 88E5                    	mov	ch,ah		; restore CH, CL is error code
  1313 000004EF 585B5A5E5F              	popm	ax,bx,dx,si,di
  1314 000004F4 08C9                    	or	cl,cl		; set the Z flag
  1315 000004F6 C3                      	ret
  1316                                  
  1317                                  
  1318                                  
  1319                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1320                                  ; SDverify1sec	Verify a single sector (of 512 bytes)
  1321                                  ;
  1322                                  ;  Enter with:
  1323                                  ;	DX:AX	sector number to read
  1324                                  ;
  1325                                  ;  Return with:
  1326                                  ;	CL	error code (0 means success)
  1327                                  ;	DX:AX	preserved
  1328                                  ;	ES:BX	preserved
  1329                                  ;	SI, DI, CH are preserved
  1330                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1331                                  SDverify1sec:
  1332 000004F7 5756525350              	pushm	ax,bx,dx,si,di
  1333 000004FC 51                      	pushm	cx
  1334                                  
  1335 000004FD 5250                    	pushm	ax,dx		; save sector number
  1336                                  
  1337 000004FF B402                    	mov	ah,2		; show it is a read check
  1338 00000501 E8FFFE                  	call	SDcheck
  1339 00000504 7512                    	jnz	.err2
  1340                                  
  1341 00000506 E8F5FB                  	call	SDwaitrdy	; wait for card to go ready
  1342 00000509 720D                    	jc	.err2
  1343 0000050B 585A                    	popm	ax,dx		; get sector address
  1344                                  
  1345                                  %if QUICK_VERIFY
  1346 0000050D 31C9                    	xor	cx,cx
  1347                                  %else
  1348                                  	call	SDsetaddr	; set up card address in DX:AX
  1349                                  ; DX:AX is byte address (SDSC) or sector address (SDHC)
  1350                                  	mov	bl, 40h | 17	; CMD17 = read one sector
  1351                                  	call	SDcmdset	; CMD17 (DX:AX) crc
  1352                                  	call	cmd_R1		; execute the command
  1353                                  	mov	sp,si		; purge command from the stack
  1354                                  	jz	.3
  1355                                  	call	SDdone		; done if error
  1356                                        	jmp	.err1		; exit on error
  1357                                  .3:
  1358                                  	mov	cx,512		; read 512 bytes
  1359                                  	call	SDtestdata	; **
  1360                                  %endif
  1361 0000050F E8DDFB                  	call	SDdone		; end of command
  1362                                  
  1363 00000512 08E9                    	or	cl,ch		; is CRC zero, create error code
  1364 00000514 7406                    	jz	.exit
  1365                                  
  1366 00000516 B110                    	mov	cl, ERR_uncorrectable_CRC_error
  1367                                  .err2:
  1368 00000518 5E5F                    	popm	si,di		; clear sector number
  1369                                  .err1:
  1370                                  ;;;	popm	si,di		; clear buffer address
  1371 0000051A 88E1                    	mov	cl,ah		; error code to CL
  1372                                  .exit:
  1373 0000051C 58                      	popm	ax		; get CX saved
  1374 0000051D 88E5                    	mov	ch,ah		; restore CH, CL is error code
  1375 0000051F 585B5A5E5F              	popm	ax,bx,dx,si,di
  1376 00000524 08C9                    	or	cl,cl		; set the Z flag
  1377 00000526 C3                      	ret
  1378                                  
  1379                                  
  1380                                  	
  1381                                  
  1382                                  %if USE_CRCs
  1383                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1384                                  ; crc16		add data to the input CRC16 calculation
  1385                                  ;
  1386                                  ;  Enter with:
  1387                                  ;	ES:BX	data pointer
  1388                                  ;	CX	count of bytes
  1389                                  ;	AX	partial CRC16 sum
  1390                                  ;
  1391                                  ;  Return with:
  1392                                  ;	ES:BX	updated data pointer
  1393                                  ;	CX = 0
  1394                                  ;	AX	updated CRC16 sum
  1395                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1396                                  	global	crc16
  1397                                  crc16:
  1398 00000527 56                      	pushm	si		; save SI
  1399                                  
  1400 00000528 89DE                    	mov	si,bx		; use ES:SI to address data
  1401                                  .2:
  1402 0000052A 88E3                    	mov	bl,ah		; form index into table
  1403 0000052C 30FF                    	xor	bh,bh		; zap BH
  1404 0000052E 26321C                    es	xor	bl,[si]		; form table index
  1405 00000531 46                        	inc	si
  1406 00000532 88C4                      	mov	ah,al		; update CRC16
  1407 00000534 30C0                    	xor	al,al
  1408 00000536 D1E3                    	shl	bx,1
  1409 00000538 2E3387[4305]              cs	xor	ax,[crc16tab + bx]
  1410 0000053D E2EB                      	loop	.2
  1411                                  
  1412 0000053F 89F3                    	mov	bx,si		; updated BX value
  1413 00000541 5E                      	popm	si
  1414 00000542 C3                      	ret
  1415                                  
  1416                                  
  1417                                  %include "crc16tab.inc"
  1418                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1419                              <1> ; crc16tab.inc
  1420                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1421                              <1> ;
  1422                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
  1423                              <1> ;
  1424                              <1> ; Copyright (c) 2013 John R. Coffman.  All rights reserved.
  1425                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
  1426                              <1> ;
  1427                              <1> ; This program is free software: you can redistribute it and/or modify
  1428                              <1> ; it under the terms of the GNU General Public License as published by
  1429                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1430                              <1> ; (at your option) any later version.
  1431                              <1> ;
  1432                              <1> ; This program is distributed in the hope that it will be useful,
  1433                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1434                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1435                              <1> ; GNU General Public License for more details.
  1436                              <1> ;
  1437                              <1> ; You should have received a copy of the GNU General Public License
  1438                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1439                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1440                              <1> 
  1441                              <1> crc16tab:
  1442 00000543 000021104220633084- <1>   dw	0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50A5, 0x60C6, 0x70E7
  1442 0000054C 40A550C660E770      <1>
  1443 00000553 088129914AA16BB18C- <1>   dw	0x8108, 0x9129, 0xA14A, 0xB16B, 0xC18C, 0xD1AD, 0xE1CE, 0xF1EF
  1443 0000055C C1ADD1CEE1EFF1      <1>
  1444 00000563 3112100273325222B5- <1>   dw	0x1231, 0x0210, 0x3273, 0x2252, 0x52B5, 0x4294, 0x72F7, 0x62D6
  1444 0000056C 529442F772D662      <1>
  1445 00000573 399318837BB35AA3BD- <1>   dw	0x9339, 0x8318, 0xB37B, 0xA35A, 0xD3BD, 0xC39C, 0xF3FF, 0xE3DE
  1445 0000057C D39CC3FFF3DEE3      <1>
  1446 00000583 6224433420040114E6- <1>   dw	0x2462, 0x3443, 0x0420, 0x1401, 0x64E6, 0x74C7, 0x44A4, 0x5485
  1446 0000058C 64C774A4448554      <1>
  1447 00000593 6AA54BB528850995EE- <1>   dw	0xA56A, 0xB54B, 0x8528, 0x9509, 0xE5EE, 0xF5CF, 0xC5AC, 0xD58D
  1447 0000059C E5CFF5ACC58DD5      <1>
  1448 000005A3 5336722611163006D7- <1>   dw	0x3653, 0x2672, 0x1611, 0x0630, 0x76D7, 0x66F6, 0x5695, 0x46B4
  1448 000005AC 76F6669556B446      <1>
  1449 000005B3 5BB77AA719973887DF- <1>   dw	0xB75B, 0xA77A, 0x9719, 0x8738, 0xF7DF, 0xE7FE, 0xD79D, 0xC7BC
  1449 000005BC F7FEE79DD7BCC7      <1>
  1450 000005C3 C448E5588668A77840- <1>   dw	0x48C4, 0x58E5, 0x6886, 0x78A7, 0x0840, 0x1861, 0x2802, 0x3823
  1450 000005CC 08611802282338      <1>
  1451 000005D3 CCC9EDD98EE9AFF948- <1>   dw	0xC9CC, 0xD9ED, 0xE98E, 0xF9AF, 0x8948, 0x9969, 0xA90A, 0xB92B
  1451 000005DC 8969990AA92BB9      <1>
  1452 000005E3 F55AD44AB77A966A71- <1>   dw	0x5AF5, 0x4AD4, 0x7AB7, 0x6A96, 0x1A71, 0x0A50, 0x3A33, 0x2A12
  1452 000005EC 1A500A333A122A      <1>
  1453 000005F3 FDDBDCCBBFFB9EEB79- <1>   dw	0xDBFD, 0xCBDC, 0xFBBF, 0xEB9E, 0x9B79, 0x8B58, 0xBB3B, 0xAB1A
  1453 000005FC 9B588B3BBB1AAB      <1>
  1454 00000603 A66C877CE44CC55C22- <1>   dw	0x6CA6, 0x7C87, 0x4CE4, 0x5CC5, 0x2C22, 0x3C03, 0x0C60, 0x1C41
  1454 0000060C 2C033C600C411C      <1>
  1455 00000613 AEED8FFDECCDCDDD2A- <1>   dw	0xEDAE, 0xFD8F, 0xCDEC, 0xDDCD, 0xAD2A, 0xBD0B, 0x8D68, 0x9D49
  1455 0000061C AD0BBD688D499D      <1>
  1456 00000623 977EB66ED55EF44E13- <1>   dw	0x7E97, 0x6EB6, 0x5ED5, 0x4EF4, 0x3E13, 0x2E32, 0x1E51, 0x0E70
  1456 0000062C 3E322E511E700E      <1>
  1457 00000633 9FFFBEEFDDDFFCCF1B- <1>   dw	0xFF9F, 0xEFBE, 0xDFDD, 0xCFFC, 0xBF1B, 0xAF3A, 0x9F59, 0x8F78
  1457 0000063C BF3AAF599F788F      <1>
  1458 00000643 8891A981CAB1EBA10C- <1>   dw	0x9188, 0x81A9, 0xB1CA, 0xA1EB, 0xD10C, 0xC12D, 0xF14E, 0xE16F
  1458 0000064C D12DC14EF16FE1      <1>
  1459 00000653 8010A100C230E32004- <1>   dw	0x1080, 0x00A1, 0x30C2, 0x20E3, 0x5004, 0x4025, 0x7046, 0x6067
  1459 0000065C 50254046706760      <1>
  1460 00000663 B9839893FBA3DAB33D- <1>   dw	0x83B9, 0x9398, 0xA3FB, 0xB3DA, 0xC33D, 0xD31C, 0xE37F, 0xF35E
  1460 0000066C C31CD37FE35EF3      <1>
  1461 00000673 B1029012F322D23235- <1>   dw	0x02B1, 0x1290, 0x22F3, 0x32D2, 0x4235, 0x5214, 0x6277, 0x7256
  1461 0000067C 42145277625672      <1>
  1462 00000683 EAB5CBA5A89589856E- <1>   dw	0xB5EA, 0xA5CB, 0x95A8, 0x8589, 0xF56E, 0xE54F, 0xD52C, 0xC50D
  1462 0000068C F54FE52CD50DC5      <1>
  1463 00000693 E234C324A014810466- <1>   dw	0x34E2, 0x24C3, 0x14A0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405
  1463 0000069C 74476424540544      <1>
  1464 000006A3 DBA7FAB79987B8975F- <1>   dw	0xA7DB, 0xB7FA, 0x8799, 0x97B8, 0xE75F, 0xF77E, 0xC71D, 0xD73C
  1464 000006AC E77EF71DC73CD7      <1>
  1465 000006B3 D326F2369106B01657- <1>   dw	0x26D3, 0x36F2, 0x0691, 0x16B0, 0x6657, 0x7676, 0x4615, 0x5634
  1465 000006BC 66767615463456      <1>
  1466 000006C3 4CD96DC90EF92FE9C8- <1>   dw	0xD94C, 0xC96D, 0xF90E, 0xE92F, 0x99C8, 0x89E9, 0xB98A, 0xA9AB
  1466 000006CC 99E9898AB9ABA9      <1>
  1467 000006D3 4458654806782768C0- <1>   dw	0x5844, 0x4865, 0x7806, 0x6827, 0x18C0, 0x08E1, 0x3882, 0x28A3
  1467 000006DC 18E1088238A328      <1>
  1468 000006E3 7DCB5CDB3FEB1EFBF9- <1>   dw	0xCB7D, 0xDB5C, 0xEB3F, 0xFB1E, 0x8BF9, 0x9BD8, 0xABBB, 0xBB9A
  1468 000006EC 8BD89BBBAB9ABB      <1>
  1469 000006F3 754A545A376A167AF1- <1>   dw	0x4A75, 0x5A54, 0x6A37, 0x7A16, 0x0AF1, 0x1AD0, 0x2AB3, 0x3A92
  1469 000006FC 0AD01AB32A923A      <1>
  1470 00000703 2EFD0FED6CDD4DCDAA- <1>   dw	0xFD2E, 0xED0F, 0xDD6C, 0xCD4D, 0xBDAA, 0xAD8B, 0x9DE8, 0x8DC9
  1470 0000070C BD8BADE89DC98D      <1>
  1471 00000713 267C076C645C454CA2- <1>   dw	0x7C26, 0x6C07, 0x5C64, 0x4C45, 0x3CA2, 0x2C83, 0x1CE0, 0x0CC1
  1471 0000071C 3C832CE01CC10C      <1>
  1472 00000723 1FEF3EFF5DCF7CDF9B- <1>   dw	0xEF1F, 0xFF3E, 0xCF5D, 0xDF7C, 0xAF9B, 0xBFBA, 0x8FD9, 0x9FF8
  1472 0000072C AFBABFD98FF89F      <1>
  1473 00000733 176E367E554E745E93- <1>   dw	0x6E17, 0x7E36, 0x4E55, 0x5E74, 0x2E93, 0x3EB2, 0x0ED1, 0x1EF0
  1473 0000073C 2EB23ED10EF01E      <1>
  1474                              <1> 
  1475                              <1> ; end crc16tab.inc
  1418                                  %endif
  1419                                  
  1420                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1421                                  ; xbits		extract BigEndian bits
  1422                                  ;
  1423                                  ;  Enter with:
  1424                                  ;	ES:SI	points at byte containing bit 0
  1425                                  ;	CH:CL	hi-bit : lo-bit	 to be extracted
  1426                                  ;
  1427                                  ;  Exit with:
  1428                                  ;	AX	extracted value
  1429                                  ;	no other registers altered
  1430                                  ;
  1431                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1432                                  xbits:
  1433 00000743 565153                  	pushm	bx,cx,si
  1434 00000746 88C8                    	mov	al,cl
  1435 00000748 30E4                    	xor	ah,ah
  1436 0000074A C1E803                  	shr	ax,3			; AX is byte offset
  1437 0000074D 29C6                    	sub	si,ax			; SI points at first byte
  1438 0000074F 28CD                    	sub	ch,cl			; CH is bit count - 1
  1439 00000751 268A04                    es	mov	al,[si]
  1440 00000754 268A64FF                  es	mov	ah,[si-1]
  1441 00000758 268A5CFE                  es	mov	bl,[si-2]		; allow for max. of 12 bit field
  1442 0000075C 80E107                  	and	cl,7			; CL is bit offset
  1443 0000075F 7408                    	jz	.3
  1444 00000761 D0EB                    .1:	shr	bl,1
  1445 00000763 D1D8                    	rcr	ax,1
  1446 00000765 FEC9                    	dec	cl
  1447 00000767 75F8                    	jnz	.1
  1448 00000769 BBFEFF                  .3:	mov	bx,0FFFEh		; mask 1 bit
  1449 0000076C C1E908                  	shr	cx,8			; mov CH to CL, zero extended
  1450 0000076F D3E3                    	shl	bx,cl			; make BX into a mask
  1451 00000771 F7D3                    	not	bx
  1452 00000773 21D8                    	and	ax,bx			; mask bits in AX
  1453 00000775 5B595E                  	popm	bx,cx,si
  1454 00000778 C3                      	ret
  1455                                  
  1456                                  
  1457                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1458                                  ; _SDcsd	extract information from the CSD register
  1459                                  ;
  1460                                  ;  word __cdecl SDcsd(word what, byte *csd)
  1461                                  ;
  1462                                  ;  Enter with:
  1463                                  ;	arg1  = what: AH=hi-bit number, AL=lo-bit number
  1464                                  ;	arg2  = far pointer to CSD array
  1465                                  ;
  1466                                  ;  Exit with:
  1467                                  ;	AX = extracted value
  1468                                  ;
  1469                                  ;  Uses:
  1470                                  ;	xbits
  1471                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1472                                  	global	_SDcsd
  1473                                  _SDcsd:
  1474 00000779 55                      	push	bp
  1475 0000077A 89E5                    	mov	bp,sp
  1476 0000077C 065651                  	pushm	cx,si,es
  1477                                  
  1478 0000077F 8B4E04                  	mov	cx,ARG(1)
  1479 00000782 C47606                  	les	si,ARG(2)
  1480 00000785 83C60F                  	add	si,15		; point at end of array
  1481 00000788 E8B8FF                  	call	xbits
  1482                                  
  1483 0000078B 595E0790                	popm	cx,si,es
  1484 0000078F C9                      	leave
  1485 00000790 C3                      	ret
  1486                                  
  1487                                  
  1488                                  %if DEBUG>0
  1489                                  writeCSD:
  1490                                  	mov	si,SDcsd
  1491                                  	mov	cx,16
  1492                                  .1:	lodsb
  1493                                  	call	boutsp
  1494                                  	loop	.1
  1495                                  ; NewLine
  1496                                  crlf:
  1497                                  	mov	al,0Dh
  1498                                  	call	cout
  1499                                  	mov	al,0Ah
  1500                                  	call	cout
  1501                                  	ret
  1502                                  
  1503                                  
  1504                                  ; output byte from AL, then a space
  1505                                  boutsp:
  1506                                  	call	bout
  1507                                  	mov	al,20h
  1508                                  	call	cout
  1509                                  	ret
  1510                                  ; word output from AX
  1511                                  wout:
  1512                                  	xchg	al,ah
  1513                                  	call	bout
  1514                                  	xchg	al,ah
  1515                                  ; byte output from AL
  1516                                  bout:
  1517                                  	rol	al,4
  1518                                  	call	nout
  1519                                  	rol	al,4
  1520                                  ; nibble output from low nibble in AL
  1521                                  nout:
  1522                                  	push	ax
  1523                                  	and	al,0Fh		; mask nibble
  1524                                  	daa			; convert to decimal
  1525                                  	add	al,0F0h		; overflow to Carry
  1526                                  	adc	al,040h		; convert to ASCII decimal or hex digit
  1527                                  	call	cout
  1528                                  	pop	ax
  1529                                  	ret
  1530                                  	
  1531                                  ; character output from AL
  1532                                  cout:
  1533                                  	pushm	ax,bx
  1534                                  	mov	ah,0Eh		; write character in AL
  1535                                  	mov	bx,0007h
  1536                                  	int	10h
  1537                                  	popm	ax,bx
  1538                                  	ret
  1539                                  %endif
  1540                                  
  1541                                  	SEGMENT	_DATA
  1542                                  ;;;SDcardtype	db	0, 0		; SD card type SDtypeSDSC=2, HC=3, ...
  1543                                  ;;;SDstatus	db	0, 0		; status byte from command
  1544                                  
  1545                                  ;;;SDcsd		times 16 db 0		; SD card CSD
  1546                                  
  1547                                  %if DEBUG>=1
  1548                                  buffer:	
  1549                                  	times	512 db 0E7h
  1550                                  lbuf	equ	$-buffer
  1551                                  %endif
  1552                                  
  1553                                  
  1554                                  ;-------------------------------------------------------------------------------
  1555                                  
  1556                                  ;-----------------------------------------------------------------------------
  1557                                  ; End of SDcard disk driver
  1558                                  ;
  1559                                  ; Begin SBC-188 BIOS code
  1560                                  ;------------------------------------------------------------------------------------	
  1561                                  %ifndef STANDALONE
  1562                                  	
  1563                                  	SEGMENT	_TEXT
  1564                                  
  1565                                  
  1566                                  ; Standard int 13h stack frame layout is 
  1567                                  ; created by:   PUSHM  ALL,DS,ES
  1568                                  ;               MOV    BP,SP
  1569                                  ;
  1570                                  offset_DI       equ     0
  1571                                  offset_SI       equ     offset_DI+2
  1572                                  offset_BP       equ     offset_SI+2
  1573                                  offset_SP       equ     offset_BP+2
  1574                                  offset_BX       equ     offset_SP+2
  1575                                  offset_DX       equ     offset_BX+2
  1576                                  offset_CX       equ     offset_DX+2
  1577                                  offset_AX       equ     offset_CX+2
  1578                                  offset_DS       equ     offset_AX+2
  1579                                  offset_ES       equ     offset_DS+2
  1580                                  offset_IP       equ     offset_ES+2
  1581                                  offset_CS       equ     offset_IP+2
  1582                                  offset_FLAGS    equ     offset_CS+2
  1583                                  
  1584                                  ; The byte registers in the stack
  1585                                  offset_AL       equ     offset_AX
  1586                                  offset_AH       equ     offset_AX+1
  1587                                  offset_BL       equ     offset_BX
  1588                                  offset_BH       equ     offset_BX+1
  1589                                  offset_CL       equ     offset_CX
  1590                                  offset_CH       equ     offset_CX+1
  1591                                  offset_DL       equ     offset_DX
  1592                                  offset_DH       equ     offset_DX+1
  1593                                  
  1594                                  ; FDC error codes (returned in AH)
  1595                                  ;
  1596                                  ERR_no_error            equ     0       ; no error (return Carry clear)
  1597                                  ;   everything below returns with the Carry set to indicate an error
  1598                                  ERR_invalid_command     equ     1
  1599                                  ERR_address_mark_not_found      equ     2
  1600                                  ERR_write_protect       equ     3
  1601                                  ERR_sector_not_found    equ     4
  1602                                  ERR_disk_removed        equ     6
  1603                                  ERR_dma_overrun         equ     8
  1604                                  ERR_dma_crossed_64k     equ     9
  1605                                  ERR_media_type_not_found        equ     12
  1606                                  ERR_uncorrectable_CRC_error     equ     10h
  1607                                  ERR_controller_failure  equ     20h
  1608                                  ERR_seek_failed         equ     40h
  1609                                  ERR_disk_timeout        equ     80h
  1610                                  
  1611                                  
  1612                                  ; Packet call offsets
  1613                                  ;
  1614                                  pkt_size        equ     0       ; byte, size of packet (==16)
  1615                                  pkt_reserved1   equ     1       ; byte, reserved, must be zero
  1616                                  pkt_blocks      equ     2       ; byte, number of blocks to transfer
  1617                                                                  ; max is 127 (7Fh); 0 means no transfer
  1618                                  pkt_reserved3   equ     3       ; byte; reserved, must be zero
  1619                                  pkt_address     equ     4       ; dword; segment:offset of transfer
  1620                                  pkt_LBA         equ     8       ; qword; LBA of transfer
  1621                                  ; for convenience:
  1622                                  pkt_LBA0        equ     8       ; word
  1623                                  pkt_LBA1        equ     10      ; word
  1624                                  pkt_LBA2        equ     12      ; word          ; MBZ
  1625                                  pkt_LBA3        equ     14      ; word          ; MBZ
  1626                                  
  1627                                  ; Parameter Packet returns:
  1628                                  ;
  1629                                  ;pkt_size       equ     0       ; word
  1630                                  pkt_info        equ     2       ; word, information bits
  1631                                          ; bit   usage
  1632                                          ;  0    DMA boundary errors are handled transparently
  1633                                          ;  1    Geometry valid (bytes 8-12)
  1634                                          ;  2    Removable device (no)
  1635                                          ;  3    Supports Write with Verify (no)
  1636                                          ;  4    change line support (no)
  1637                                          ;  5    removable & lockable (no)
  1638                                          ;  6    max. geometry for a removable drive (no)
  1639                                          ;  7-15  MBZ
  1640                                  pkt_phys_cyl    equ     4       ; dword, physical cylinders
  1641                                  pkt_phys_hds    equ     8       ; dword, physical heads
  1642                                  pkt_phys_spt    equ     12      ; dword, sectors per track
  1643                                  pkt_sectors     equ     16      ; qword, total number of sectors
  1644                                  pkt_bytes       equ     24      ; word, bytes per sector
  1645                                  pkt_ptr         equ     26      ; dword, EDD configuration paramter pointer
  1646                                                                  ; FFFF:FFFF means invalid pointer
  1647                                  
  1648                                  
  1649                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1650                                  ; integrity:    Check integrity of fixed disk table
  1651                                  ;
  1652                                  ;  Call with:
  1653                                  ;       DL = device code (80h..83h)
  1654                                  ;       DS set to BIOS data area
  1655                                  ;
  1656                                  ;  Exit with:
  1657                                  ;       DS:SI points at the fixed disk table
  1658                                  ;	DI = unit number
  1659                                  ;
  1660                                  ;  Error Exit:
  1661                                  ;       If the disk table checksum is bad, give immediate error return
  1662                                  ;
  1663                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1664                                  integrity:
  1665 00000791 5150                            pushm   ax,cx
  1666                                  %if 0
  1667                                          mov     al,7Fh
  1668                                          and     al,dl                   ; mask out the high bit
  1669                                          cmp     al,[n_fixed_disks]
  1670                                  %else
  1671                                  	extern	get_IDE_num
  1672 00000793 E8(0000)                	call	get_IDE_num		; get number of IDE disks total
  1673 00000796 88C4                    	mov	ah,al
  1674 00000798 B07F                    	mov	al,7Fh
  1675 0000079A 20D0                            and     al,dl                   ; mask out the high bit
  1676 0000079C 38E0                    	cmp	al,ah			; compare against max
  1677                                  %endif
  1678 0000079E 7203E987F8                      jae     undefined               ; harsh error exit
  1679 000007A3 BEB000                          mov     si,fx80
  1680 000007A6 B91000                          mov     cx,fx81-fx80            ; size of fixed disk table
  1681 000007A9 84C0                    	test    al,al
  1682 000007AB 7406                            jz      .1
  1683 000007AD 01CE                    .0:	add     si,cx                   ; point at fx81
  1684 000007AF FEC8                    	dec	al
  1685 000007B1 75FA                    	jnz	.0
  1686                                  .1:
  1687 000007B3 56                              push    si
  1688 000007B4 B800EE                          mov     ax,0EE00h               ; error code and zero checksum
  1689                                  
  1690 000007B7 0204                    .2:     add     al,[si]                 ; compute checksum
  1691 000007B9 46                              inc     si
  1692 000007BA E2FB                            loop    .2                      ; loop back
  1693                                  
  1694 000007BC 5E                              pop     si
  1695 000007BD 08C0                            or      al,al                   ; test AL for zero
  1696 000007BF 7403E970F8                      jnz     error_exit              ; BIOS data area clobbered
  1697                                  
  1698 000007C4 E8C9F8                  	call	SDsetunit		; get DI as unit number
  1699                                  
  1700 000007C7 5859                            popm    ax,cx
  1701 000007C9 C3                              ret
  1702                                  
  1703                                  
  1704                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1705                                  ; cv_lba        Convert CHS in CX & DX to LBA address in DX:AX
  1706                                  ;
  1707                                  ;  Call with:
  1708                                  ;       DS:SI points to fixed disk table
  1709                                  ;       CX & DX are CHS input parameters
  1710                                  ;
  1711                                  ;  Exit with:
  1712                                  ;       DX:AX is the corresponding LBA address
  1713                                  ;       BX and CX are modified
  1714                                  ;
  1715                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1716                                  cv_lba:
  1717 000007CA 89C8                            mov     ax,cx           ; cylinder info to AX
  1718 000007CC C0C002                          rol     al,2            ; position high 2 bits
  1719 000007CF 2403                            and     al,3            ; mask 2 bits
  1720 000007D1 86C4                            xchg    al,ah           ; AX = cylinder number
  1721 000007D3 C1EA08                          shr     dx,8            ; heads to DL   DH=0
  1722                                  
  1723 000007D6 89D3                            mov     bx,dx           ; heads to BX
  1724 000007D8 8A5402                          mov     dl,[fx_log_heads - fx80 + si]   ; may be 0, meaning 256
  1725 000007DB FECA                            dec     dl
  1726 000007DD 42                              inc     dx              ; recover 256 !!!
  1727                                  
  1728 000007DE F7E2                            mul     dx
  1729 000007E0 01D8                            add     ax,bx           ; add in the head number
  1730 000007E2 83D200                          adc     dx,0            ; **
  1731                                  
  1732 000007E5 8A5C0E                          mov     bl,[fx_log_sectors - fx80 + si]    ; BH is already 0
  1733 000007E8 51                              push    cx
  1734 000007E9 E8(0000)                        call    @mulLS          ; DX:AX = DX:AX * BX
  1735 000007EC 59                              pop     cx
  1736 000007ED FEC9                            dec     cl              ; sector address is from 1, not 0
  1737 000007EF 83E13F                          and     cx,63
  1738 000007F2 01C8                            add     ax,cx           ; add in sector number
  1739 000007F4 83D200                          adc     dx,0            ; **
  1740 000007F7 C3                              ret
  1741                                  
  1742                                  
  1743                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1744                                  ; fn00 -- Reset the Disk Subsystem
  1745                                  ;
  1746                                  ;  Call with:
  1747                                  ;       AH = 0  function code
  1748                                  ;
  1749                                  ;  Exit with:
  1750                                  ;       Nothing
  1751                                  ;
  1752                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1753                                  fn00:
  1754 000007F8 E896FF                          call    integrity       ; perhaps no subsystem
  1755 000007FB E86CF9                  	call	SDinit		; no real init until referenced
  1756 000007FE B400                            mov     ah,0
  1757 00000800 E92DF8                          jmp     exit_sequence
  1758                                  
  1759                                  
  1760                                  
  1761                                  
  1762                                  
  1763                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1764                                  ; fn02 -- Disk Read
  1765                                  ; fn03 -- Disk Write
  1766                                  ; fn04 -- Disk Verify (future)
  1767                                  ;
  1768                                  ;  Enter with:
  1769                                  ;       AH = 2 (read)
  1770                                  ;       AH = 3 (write)
  1771                                  ;       AH = 4 (verify)
  1772                                  ;       AL = number of sectors to transfer
  1773                                  ;       CH = low 8 bits of cylinder number
  1774                                  ;       CL = sector number & high 2 bits of sector number
  1775                                  ;       DH = head number
  1776                                  ;       DL = device code
  1777                                  ;       ES:BX = buffer to receive/provide the data (except on verify)
  1778                                  ;
  1779                                  ;  Exit with:
  1780                                  ;       AH = success(0) or error code
  1781                                  ;       Carry flag set, if error; clear otherwise
  1782                                  ;
  1783                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1784                                  fn02:
  1785                                  fn03:
  1786                                  fn04:
  1787 00000803 E88BFF                          call    integrity       ; set pointer to Fixed Disk Table in SI
  1788 00000806 E8C1FF                          call    cv_lba          ; convert to LBA address in DX:AX
  1789 00000809 30C9                    	xor	cl,cl		; no error to begin
  1790                                  
  1791 0000080B 8A6E0E                          mov     ch,[bp + offset_AL]      ; get sector count
  1792 0000080E 8B5E08                          mov     bx,[bp + offset_BX]      ; get transfer address
  1793                                  
  1794                                  ; Enter here on Read, Write, Verify or
  1795                                  ;     extended  Read, Write, Verify, Seek
  1796                                  RWV: 
  1797 00000811 FEC5                            inc     ch                      ; zero is valid for no transfer
  1798 00000813 EB31                            jmp     .6              ; enter loop at the bottom
  1799                                  ; the read/write/verify loop
  1800                                  .1:
  1801                                  ; LBA call is okay
  1802 00000815 F6460F04                        test    byte [bp+offset_AH],04h         ; Seek/Verify?
  1803 00000819 7514                            jnz     .4
  1804 0000081B F6460F01                        test    byte [bp+offset_AH],01h         ; Write?
  1805 0000081F 7507                            jnz     .3
  1806                                  .2:				; READ operation
  1807 00000821 E821FC                  	call	SDread1sec
  1808 00000824 740E                    	jz	.5
  1809 00000826 EB22                    	jmp	.8		; error code in CL
  1810                                  
  1811                                  .3:
  1812 00000828 E877FC                  	call	SDwrite1sec
  1813 0000082B 7407                    	jz	.5
  1814 0000082D EB1B                            jmp     .8		; error code in CL
  1815                                  
  1816                                  .4:
  1817 0000082F E8C5FC                  	call	SDverify1sec
  1818 00000832 7516                    	jnz	.8		; error code is in CL
  1819                                  
  1820                                  .5:
  1821 00000834 83C001                          add     ax,1            ; increment the LBA address
  1822 00000837 83D200                          adc     dx,0            ; **
  1823 0000083A 80C702                          add     bh,2            ; add 512 == 200h to the BX
  1824 0000083D 7307                            jnc     .6
  1825 0000083F 8CC7                            mov     di,es
  1826 00000841 83C710                          add     di,10h
  1827 00000844 8EC7                            mov     es,di           ; update the segment register
  1828 00000846 FECD                    .6:     dec     ch
  1829 00000848 75CB                            jnz     .1
  1830                                  
  1831 0000084A 88CC                    .8:	mov	ah,cl		; error code to AH
  1832 0000084C E9E1F7                  	jmp     exit_sequence
  1833                                  
  1834                                  
  1835                                  
  1836                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1837                                  ; fn08  --  Get Drive Parameters
  1838                                  ;
  1839                                  ;  Call with:
  1840                                  ;       AH = 8  function code
  1841                                  ;       DL = drive code (80h, 81h, ...)
  1842                                  ;
  1843                                  ;  Exit with:
  1844                                  ;       CH = maximum cylinder number (low 8 bits)
  1845                                  ;       CL = max. sector number; max. cyl in high 2 bits
  1846                                  ;       DH = maximum head number
  1847                                  ;       DL = number of fixed disks
  1848                                  
  1849                                  ;       AH = 0  and Carry is clear on success
  1850                                  ;       AH = error code; Carry set on error
  1851                                  ;
  1852                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1853                                  fn08:           ; Get Drive Parameters
  1854 0000084F C6460A00                        mov     byte [bp + offset_DL],0         ; say no fixed disks
  1855                                  
  1856 00000853 E83BFF                          call    integrity       ; bad device code or no fixed disks
  1857                                  
  1858 00000856 8B04                            mov     ax,[fx_log_cylinders - fx80 + si]
  1859 00000858 48                              dec     ax
  1860 00000859 C0E406                          shl     ah,6
  1861 0000085C 0A640E                          or      ah,[fx_log_sectors - fx80 + si]
  1862 0000085F 86C4                            xchg    al,ah
  1863 00000861 89460C                          mov     [bp + offset_CX],ax
  1864 00000864 8A7402                          mov     dh,[fx_log_heads - fx80 + si]
  1865 00000867 FECE                            dec     dh
  1866                                  %if 0
  1867                                          mov     dl,[n_fixed_disks]      ; return parameter
  1868                                  %else
  1869 00000869 52                      	push	dx			; protect DH
  1870 0000086A E8(0000)                	call	get_IDE_num		; get number of IDE disks
  1871 0000086D 5A                      	pop	dx			; restore DH
  1872 0000086E 88C2                    	mov	dl,al
  1873                                  %endif
  1874 00000870 89560A                          mov     [bp + offset_DX],dx
  1875                                  
  1876 00000873 30E4                            xor     ah,ah
  1877 00000875 E9B8F7                          jmp     exit_sequence
  1878                                  
  1879                                  
  1880                                          
  1881                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1882                                  ; fn15 -- Get Disk Type
  1883                                  ;
  1884                                  ;  Call With:
  1885                                  ;       AH = 15   function code
  1886                                  ;       DL = device code (80h or 81h)
  1887                                  ;
  1888                                  ;  Exit With:
  1889                                  ;     If successful, Carry is clear
  1890                                  ;       AH = 3  indicating a hard disk
  1891                                  ;       CX:DX   number of hard disk sectors
  1892                                  ;
  1893                                  ;     If unsuccessful, Carry is set
  1894                                  ;
  1895                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1896                                  fn15:
  1897 00000878 E816FF                          call    integrity       ; sets DS:SI
  1898 0000087B 8B04                            mov     ax,[fx_log_cylinders - fx80 + si]
  1899 0000087D 8A5C02                          mov     bl,[fx_log_heads - fx80 + si]
  1900 00000880 30FF                            xor     bh,bh
  1901 00000882 FECB                            dec     bl              ; 00 means 256
  1902 00000884 43                              inc     bx              ; do the conversion
  1903 00000885 F7E3                            mul     bx              ; cyls * heads
  1904 00000887 8A5C0E                          mov     bl,[fx_log_sectors - fx80 + si]
  1905 0000088A 30FF                            xor     bh,bh
  1906 0000088C E8(0000)                        call    @mulLS          ; cyls * heads * sectors
  1907 0000088F 89560C                          mov     word [bp+offset_CX],dx  ; high order
  1908 00000892 89460A                          mov     word [bp+offset_DX],ax  ; low order word
  1909 00000895 B403                            mov     ah,3		   ; code for HARD DISK
  1910 00000897 F8                              clc
  1911 00000898 E99AF7                          jmp     exit_pops
  1912                                  
  1913                                  
  1914                                  
  1915                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1916                                  ; fn41 -- Check Extensions Present
  1917                                  ;
  1918                                  ;  Call With:
  1919                                  ;       AH = 41h        function code
  1920                                  ;       BX = 55AAh      magic number
  1921                                  ;       DL = drive code (80h or 81h)
  1922                                  ;
  1923                                  ;  Exit With:
  1924                                  ;     carry clear
  1925                                  ;       AH = 21h        version 1.1 support
  1926                                  ;       BX = AA55h      magic number II
  1927                                  ;       CX = 0001b  bit0=packet support; bit2=EDD drive support
  1928                                  ;
  1929                                  ;     carry set
  1930                                  ;       AH = 01h        Invalid Command
  1931                                  ;
  1932                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1933                                  fn41:
  1934 0000089B E8F3FE                          call    integrity       ; test drive number (sets DS:SI)
  1935 0000089E 817E08AA55                      cmp     word [offset_BX + bp],55AAh
  1936 000008A3 7403E982F7                      jne     undefined
  1937 000008A8 F6440840                        test    byte [fx_drive_control - fx80 + si],40h         ; test LBA bit
  1938 000008AC 7503E979F7                      jz      undefined
  1939                                  
  1940 000008B1 C6460F21                        mov     byte [offset_AH + bp],21h       ; version 1.1
  1941 000008B5 C7460855AA                      mov     word [offset_BX + bp],0AA55h    ; magic number II
  1942 000008BA C7460C0500                      mov     word [offset_CX + bp],00000101b       ; packet calls & EDD i/f
  1943 000008BF E96CF7                          jmp     good_exit
  1944                                  
  1945                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1946                                  ; fn42 -- Extended Read
  1947                                  ; fn43 -- Extended Write
  1948                                  ; fn44 -- Extended Verify
  1949                                  ; fn47 -- Extended Seek (implement as Verify)
  1950                                  ;
  1951                                  ;  Call With:
  1952                                  ;       AH = function code
  1953                                  ;       AL = 0,1 write with no verify; 2 write with verify
  1954                                  ;            not used for Read or Verify
  1955                                  ;       DL = drive number (80h or 81h)
  1956                                  ;       [DS:SI] was disk packet address; will be used in ES:BX
  1957                                  ;
  1958                                  ;  Exit With:
  1959                                  ;       AH = 0 (no error) and Carry Clear
  1960                                  ;       AH = error code and Carry Set
  1961                                  ;     The block count field is updated with the number of blocks
  1962                                  ;     correctly transferred/verified before the error occurred.
  1963                                  ;
  1964                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1965                                  fn42:
  1966                                  fn43:
  1967                                  fn44:
  1968                                  fn47:
  1969 000008C2 E8CCFE                          call    integrity       ; set pointer to Fixed Disk Table in SI
  1970 000008C5 8E4610                          mov     es,[bp + offset_DS]     ; packet pointer
  1971 000008C8 8B5E02                          mov     bx,[bp + offset_SI]     ; **
  1972 000008CB 26803F10                   es   cmp     byte [bx + pkt_size],16 ; check for correct size
  1973 000008CF 7303E956F7                      jb      undefined
  1974                                  
  1975 000008D4 268B470E                   es   mov     ax,[bx + pkt_LBA3]      ; LBA address
  1976 000008D8 260B470C                   es   or      ax,[bx + pkt_LBA2]      ; LBA address
  1977 000008DC 7403E949F7                      jnz     undefined
  1978 000008E1 268B4708                   es   mov     ax,[bx + pkt_LBA0]      ; LBA address
  1979 000008E5 268B570A                   es   mov     dx,[bx + pkt_LBA1]      ; LBA address hi
  1980                                  
  1981 000008E9 B501                            mov     ch,1                    ; assume Seek
  1982 000008EB 807E0F47                        cmp     byte [offset_AH + bp],47h       ; Seek?
  1983 000008EF 7404                            je      .7
  1984 000008F1 268A6F02                   es   mov     ch,[bx + pkt_blocks]    ; sector count
  1985                                  .7:
  1986 000008F5 8A4C08                          mov     cl,[fx_drive_control - fx80 + si]
  1987 000008F8 26C45F04                   es   les     bx,[bx + pkt_address]   ; get transfer address
  1988                                  
  1989 000008FC E912FF                          jmp     RWV             ; common read/write/verify code
  1990                                  
  1991                                  
  1992                                          
  1993                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1994                                  ; fn48 -- Get Drive Parameters
  1995                                  ;
  1996                                  ;  Call With:
  1997                                  ;       AH = 48h        function code
  1998                                  ;       DL = drive number
  1999                                  ;       DS:SI = pointer to return buffer (26 or 30 bytes)
  2000                                  ;
  2001                                  ;  Exit With:
  2002                                  ;       AH = 0 and carry clear
  2003                                  ;       results in the buffer
  2004                                  ;
  2005                                  ;       AH = error code and carry set
  2006                                  ;
  2007                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2008                                  fn48:
  2009 000008FF E88FFE                          call    integrity               ; set DS:SI
  2010 00000902 8E4610                          mov     es,[bp + offset_DS]     ; packet pointer
  2011 00000905 8B5E02                          mov     bx,[bp + offset_SI]     ; **
  2012 00000908 B9FFFF                          mov     cx,0FFFFh               ; CX = -1  (FFFFh)
  2013 0000090B B81A00                          mov     ax,pkt_ptr              ; AX = 26
  2014 0000090E 263907                     es   cmp     [bx + pkt_size],ax      ; check for correct size = 26
  2015 00000911 7303E914F7                      jb      undefined
  2016 00000916 83C004                          add     ax,4
  2017 00000919 263907                     es   cmp     [bx + pkt_size],ax      ; check for correct size = 30
  2018 0000091C 7208                            jb      .1
  2019 0000091E 26894F1A                   es   mov     [bx + pkt_ptr],cx       ; flag invalid pointer
  2020 00000922 26894F1C                   es   mov     [bx + pkt_ptr+2],cx     ; **
  2021                                  .1:
  2022 00000926 268907                     es   mov     [bx + pkt_size],ax      ; set the returned size
  2023                                  
  2024 00000929 41                              inc     cx                      ; CX = 0
  2025 0000092A 26C747020300               es   mov     word [bx + pkt_info], 000011b   ; DMA bound/ Geom OK
  2026                                  
  2027 00000930 8B4409                          mov     ax,[fx_phys_cylinders - fx80 + si]      ; cylinders
  2028 00000933 26894704                   es   mov     [bx + pkt_phys_cyl],ax  
  2029 00000937 26894F06                   es   mov     [bx + pkt_phys_cyl+2],cx
  2030                                  
  2031 0000093B 8A440B                          mov     al,[fx_phys_heads - fx80 + si]          ; heads
  2032 0000093E 88EC                            mov     ah,ch
  2033 00000940 26894708                   es   mov     [bx + pkt_phys_hds],ax  
  2034 00000944 26894F0A                   es   mov     [bx + pkt_phys_hds+2],cx
  2035                                  
  2036 00000948 8A4404                          mov     al,[fx_phys_sectors - fx80 + si]        ; sectors
  2037 0000094B 2689470C                   es   mov     [bx + pkt_phys_spt],ax  
  2038 0000094F 26894F0E                   es   mov     [bx + pkt_phys_spt+2],cx
  2039                                  
  2040 00000953 8B440C                          mov     ax,[fx_LBA_low - fx80 + si]             ; total LBA sectors
  2041 00000956 26894710                   es   mov     [bx + pkt_sectors],ax                   ; total sectors
  2042 0000095A 8B4405                          mov     ax,[fx_LBA_high - fx80 + si]            ; **
  2043 0000095D 26894712                   es   mov     [bx + pkt_sectors+2],ax                 ; **
  2044 00000961 26894F14                   es   mov     [bx + pkt_sectors+4],cx                 ; **
  2045 00000965 26894F16                   es   mov     [bx + pkt_sectors+6],cx                 ; **
  2046 00000969 26C747180002               es   mov     word [bx + pkt_bytes],512               ; sector size
  2047 0000096F B400                            mov     ah,0
  2048 00000971 E9BCF6                          jmp     exit_sequence
  2049                                  
  2050                                  
  2051                                  
  2052                                          
  2053                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2054                                  ; fn4E -- set hardware configuration
  2055                                  ;
  2056                                  ;  Call With:
  2057                                  ;       AH = 4Eh        function code
  2058                                  ;       AL = hardware function sub-code
  2059                                  ;       DL = drive number
  2060                                  ;
  2061                                  ;  Exit With:
  2062                                  ;       AH = 0          carry is clear
  2063                                  ;       AL = 1          other devices affected
  2064                                  ;
  2065                                  ;       AH = error code and carry is set
  2066                                  ;
  2067                                  ;  This operation is a complete No-Op for the DIDE
  2068                                  ;
  2069                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2070                                  fn4E:
  2071 00000974 E81AFE                          call    integrity
  2072 00000977 B80100                          mov     ax,0001h
  2073 0000097A E9B3F6                          jmp     exit_sequence
  2074                                  
  2075                                  
  2076                                  
  2077                                  
  2078                                  %endif  ; STANDALONE
  2079                                  
  2080                                  
  2081                                  
