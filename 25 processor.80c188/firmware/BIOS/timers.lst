     1                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     2                                  ; timers.asm
     3                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     4                                  ;
     5                                  ;   This version is for assembly by  NASM 0.98.39 or later
     6                                  ;
     7                                  ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
     8                                  ; Provided for hobbyist use on the N8VEM SBC-188 board.
     9                                  ;
    10                                  ; This program is free software: you can redistribute it and/or modify
    11                                  ; it under the terms of the GNU General Public License as published by
    12                                  ; the Free Software Foundation, either version 3 of the License, or
    13                                  ; (at your option) any later version.
    14                                  ;
    15                                  ; This program is distributed in the hope that it will be useful,
    16                                  ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    17                                  ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    18                                  ; GNU General Public License for more details.
    19                                  ;
    20                                  ; You should have received a copy of the GNU General Public License
    21                                  ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    22                                  ;
    23                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    24                                  
    25                                  %include        "config.asm"
    26                              <1> ;/*
    27                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    28                              <1> ; ANSI.CFG
    29                              <1> ;   Copied to CONFIG.ASM for general release.
    30                              <1> ;
    31                              <1> ;       Modify the parameters below to reflect your system
    32                              <1> ;
    33                              <1> ;
    34                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    35                              <1> ;
    36                              <1> ;   Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    37                              <1> ;   Provided for hobbyist use on the N8VEM SBC-188 board.
    38                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    39                              <1> ;
    40                              <1> ; Define the serial terminal that the Video BIOS must emulate
    41                              <1> ; Set one of the following to 1
    42                              <1> ; If you have no idea what to choose, set TTY to 1
    43                              <1> TTY     equ     0       ; hardcopy -- cannot position the cursor
    44                              <1> DUMB    equ     0       ; dumb CRT -- ^H, ^J, ^K, ^L can move the cursor
    45                              <1> ANSI    equ     1       ; very smart, like a VT-100
    46                              <1> WYSE    equ     0       ; very smart Wyse series (30, 50, ...)
    47                              <1> ; others may get added in the future
    48                              <1> ;  ONE OF THE ABOVE must BE SET TO 1!!!!!
    49                              <1> ;
    50                              <1> ; Does the hardware configuration contain the Color Video Display Unit?
    51                              <1> ; Both the 8563 and the 8242 are used.  The default is CVDU=0
    52                              <1> CVDU	equ	0	; system does not have the CVDU
    53                              <1> ;
    54                              <1> ; Does the hardware configuration contain the VGA3 a/n Video card?
    55                              <1> ; The 8563 will be disabled, but the 8242 code is shared with the CVDU
    56                              <1> ; The default is VGA3=0
    57                              <1> VGA3    equ     0       ; system does not have the VGA3
    58                              <1> %if 0
    59                              <1> 	*/
    60                              <1> #define VGA3 0
    61                              <1> /*
    62                              <1> %endif
    63                              <1> ;
    64                              <1> ; Boot up keyboard mode:  20h for NumLock on
    65                              <1> ;CVDU_KEYBOARD_STATUS	equ	0	; NumLock OFF
    66                              <1> CVDU_KEYBOARD_STATUS	equ	20h	; NumLock ON
    67                              <1> 
    68                              <1> ; Define the UART startup bit rate - 1200-19200 are most common
    69                              <1> ;UART_RATE	equ	0		; 1200
    70                              <1> ;UART_RATE	equ	1		; 2400
    71                              <1> ;UART_RATE	equ	2		; 4800
    72                              <1> UART_RATE	equ	3		; 9600
    73                              <1> ;UART_RATE	equ	4		; 19200
    74                              <1> ;UART_RATE	equ	5		; 38400
    75                              <1> ;UART_RATE	equ	6		; 57600
    76                              <1> ;UART_RATE	equ	7		; 115200
    77                              <1> 
    78                              <1> ; Does the serial terminal use the DSR/DTR protocol for flow control?
    79                              <1> ;UART_DSR_PROTOCOL	equ		1	; Yes!
    80                              <1> UART_DSR_PROTOCOL       equ             WYSE    ; Wyse always uses it
    81                              <1> 						; but not ANSI
    82                              <1> ; Define the size of the ROM image on the system in Kilobytes
    83                              <1> ; It may be smaller than the actual EPROM in use.
    84                              <1> ; The following sizes are supported:  32, 64, 128, and 256
    85                              <1> %ifndef ROM
    86                              <1> ROM             equ     64              ; 64 is the default
    87                              <1> %endif
    88                              <1> 
    89                              <1> ; Define the number of Wait States at which the ROM operates
    90                              <1> ROM_WS          equ     1               ; 0..3  (1 is the default)
    91                              <1> 
    92                              <1> ; Define the size in Kilobytes of DOS RAM (low SRAM plus EMM allocate RAM)
    93                              <1> ; This is a desired size and will only be present if a 4MEM board is added
    94                              <1> RAM_DOS         equ     640
    95                              <1> 
    96                              <1> ; Define the size of the low SRAM on the system in Kilobytes
    97                              <1> ; the default is 512 kilobytes
    98                              <1> RAM             equ     512             ; (512 is the default)
    99                              <1> 
   100                              <1> ; Define the number of Wait States at which the RAM operates
   101                              <1> RAM_WS          equ     0               ; 0..3  (0 is the default)
   102                              <1> 
   103                              <1> ; Define the number of Wait States for Local Peripheral devices (600-7FF)
   104                              <1> LCL_IO_WS       equ     1               ; 0..3  (1 is the default)
   105                              <1> 
   106                              <1> ; Define the number of Wait States for ECB BUS peripheral devices (4xx)
   107                              <1> BUS_IO_WS       equ     3               ; 0..3  (3 is the default)
   108                              <1> 
   109                              <1> ; Define the time zone in which we build the Relocatable BIOS
   110                              <1> %ifndef TIMEZONE
   111                              <1> %define TIMEZONE "CDT"
   112                              <1> %endif
   113                              <1> 
   114                              <1> ; Has the REDBUG debugger been loaded?
   115                              <1> %ifndef SOFT_DEBUG
   116                              <1> %define SOFT_DEBUG 1
   117                              <1> %endif
   118                              <1> 
   119                              <1> ; Should the BIOS include "Tiny BASIC" in the image?
   120                              <1> %ifndef TBASIC
   121                              <1> TBASIC          equ     1		; default is 1
   122                              <1> %endif
   123                              <1> 
   124                              <1> ; Should the BIOS include the Floating Point Emulator?  The 80188 does
   125                              <1> ; not allow a floating point co-processor, so this is probably a good idea.
   126                              <1> %ifndef FPEM
   127                              <1> FPEM            equ     1               ; default is 1
   128                              <1> %endif
   129                              <1> 
   130                              <1> ; Define the maximum number of EMM (4MEM) boards supported
   131                              <1> EMM_BOARDS      equ     0
   132                              <1> 
   133                              <1> ; Should the Floating Point Emulator use temporary storage in the EBDA
   134                              <1> ; or at locations 0280h..3FFh in low memory?
   135                              <1> %if SOFT_DEBUG
   136                              <1> FPEM_USE_EBDA   equ     FPEM            ; default is 0
   137                              <1> %else
   138                              <1> FPEM_USE_EBDA   equ     0; FPEM            ; default is 0
   139                              <1> %endif
   140                              <1> 
   141                              <1> ; Define the size of the EPROM that is to be installed on the system
   142                              <1> ; It may be larger than the actual ROM image to be generated.
   143                              <1> %ifndef CHIP
   144                              <1> CHIP            equ     64
   145                              <1> %endif
   146                              <1> 
   147                              <1> ; Does the SBC-188 00.4 board have the LS138/LS08 piggyback fix
   148                              <1> ; Set to 1 for the SBC-188 v1.0 and later production boards
   149                              <1> ;FDC_PIGGYBACK_FIX       equ     0       ; Fix not installed
   150                              <1> FDC_PIGGYBACK_FIX       equ     1       ; fix  IS  installed
   151                              <1> 
   152                              <1> ; On SBC-188 rev 00.4 board, there is a published hardware fix (2010-09-18).
   153                              <1> ; If the wiring update is installed, or you have a later board, then
   154                              <1> ; set this to 0.  If you are using the software workaround, then set this
   155                              <1> ; to 1.  The rev 1.0 board has this fix already.
   156                              <1> NEED_TIMER_FIX  equ     0               ; have revised hardware
   157                              <1> ;NEED_TIMER_FIX  equ     1               ; use workaround
   158                              <1> 
   159                              <1> ; Define the UART oscillator speed
   160                              <1> UART_OSC        equ     1843200         ; 1.8432 Mhz is specified
   161                              <1> 
   162                              <1> 
   163                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   164                              <1> ; end of the User configuration
   165                              <1> ;       Do Not modify anything below this point
   166                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   167                              <1> 
   168                              <1> CVDU_8563	equ	CVDU		; separate inits
   169                              <1> CVDU_8242	equ	CVDU|VGA3 	; separate inits
   170                              <1> VGA3_6445       equ     VGA3            ; separate inits
   171                              <1> ; Suppress all UART output in color video Mode 3
   172                              <1> UART_MODE3_SUPPRESS	equ	CVDU_8563
   173                              <1> CVDU_USE_MSDOS_KLUDGE	equ	0; CVDU_8242	; bad, bad MSDOS
   174                              <1> CVDU_USE_KBD_HOOK		equ	CVDU_8242
   175                              <1> 
   176                              <1> ; Define existence of any uart chip
   177                              <1> UART		equ	TTY+DUMB+ANSI+WYSE
   178                              <1> startuplength   equ     512                     ; may be up to 1024
   179                              <1> startseg        equ     0FFFFh - (ROM*64) + 1
   180                              <1> highrom         equ     (ROM*400h)&0FFFFh
   181                              <1> startupseg      equ     0FFFFh - (startuplength>>4) + 1
   182                              <1> bios_data_seg   equ     040h            ; segment of BIOS data area
   183                              <1> 
   184                              <1> 
   185                              <1> %define ARG(n) [bp+2+(n)*2]
   186                              <1> 
   187                              <1> %macro  check   1.nolist
   188                              <1>  %if (%1)
   189                              <1>    %error Check Failure: %1
   190                              <1>  %endif
   191                              <1> %endm
   192                              <1> %macro  range   3.nolist
   193                              <1>  %if (%1)<(%2)
   194                              <1>    %error Out of Range: %1
   195                              <1>  %elif (%1)>(%3)
   196                              <1>    %error Out of Range: %1
   197                              <1>  %endif
   198                              <1> %endm
   199                              <1> _terminal equ UART+CVDU
   200                              <1>  check   RAM_DOS&15
   201                              <1>  check   RAM&(RAM-1)
   202                              <1>  check   ROM&(ROM-1)
   203                              <1>  range   RAM,32,512
   204                              <1>  range   ROM,32,256
   205                              <1>  range   RAM_WS,0,3
   206                              <1>  range   ROM_WS,0,3
   207                              <1>  range   RAM_DOS,RAM,(1024-ROM)
   208                              <1>  range   LCL_IO_WS,0,3
   209                              <1>  range   BUS_IO_WS,0,3
   210                              <1>  range   UART_OSC,500000,16000000
   211                              <1>  range   UART_RATE,0,7
   212                              <1>  range	 UART,0,1
   213                              <1>  range	 _terminal,1,2
   214                              <1> 
   215                              <1> %ifndef SOFT_DEBUG
   216                              <1> %define SOFT_DEBUG 0
   217                              <1> %endif
   218                              <1> 
   219                              <1> %ifndef TRACE
   220                              <1> %define TRACE 0
   221                              <1> %endif
   222                              <1> 
   223                              <1> %ifdef MAKE_OBJECT_FILE
   224                              <1>         segment _DATA WORD PUBLIC CLASS=DATA
   225                              <1>         export _ROMsize
   226                              <1>         export _CHIPsize
   227                              <1> _ROMsize        dw      ROM
   228                              <1> _CHIPsize       dw      CHIP
   229                              <1> %endif
   230                              <1> ; end of the Hardware configuration file
   231                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   232                              <1> ;*/
    26                                  %include        "cpuregs.asm"
    27                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    28                              <1> ; CPUREGS.ASM
    29                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    30                              <1> ;
    31                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    32                              <1> ;
    33                              <1> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    34                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    35                              <1> ;
    36                              <1> ; This program is free software: you can redistribute it and/or modify
    37                              <1> ; it under the terms of the GNU General Public License as published by
    38                              <1> ; the Free Software Foundation, either version 3 of the License, or
    39                              <1> ; (at your option) any later version.
    40                              <1> ;
    41                              <1> ; This program is distributed in the hope that it will be useful,
    42                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    43                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    44                              <1> ; GNU General Public License for more details.
    45                              <1> ;
    46                              <1> ; You should have received a copy of the GNU General Public License
    47                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    48                              <1> ;
    49                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    50                              <1> %include	"macros.inc"
    51                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    52                              <2> ; MACROS.INC  
    53                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    54                              <2> ;
    55                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    56                              <2> ;
    57                              <2> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    58                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    59                              <2> ;
    60                              <2> ; This program is free software: you can redistribute it and/or modify
    61                              <2> ; it under the terms of the GNU General Public License as published by
    62                              <2> ; the Free Software Foundation, either version 3 of the License, or
    63                              <2> ; (at your option) any later version.
    64                              <2> ;
    65                              <2> ; This program is distributed in the hope that it will be useful,
    66                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    67                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    68                              <2> ; GNU General Public License for more details.
    69                              <2> ;
    70                              <2> ; You should have received a copy of the GNU General Public License
    71                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    72                              <2> ;
    73                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    74                              <2> 
    75                              <2> ; general macros for the SBC188 BIOS ASSEMBLY
    76                              <2> ;
    77                              <2> ;
    78                              <2> %ifndef __MACROS_DEFINED_
    79                              <2> %define __MACROS_DEFINED_ 1
    80                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    81                              <2> ;
    82                              <2> ; some useful macros:
    83                              <2> ;
    84                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    85                              <2> ;
    86                              <2> 	cpu	186
    87                              <2> 
    88                              <2> %imacro setloc  1.nolist
    89                              <2>  times   (%1-($-$$)) db 0FFh
    90                              <2> %endm
    91                              <2> 
    92                              <2> %imacro db_lo   1
    93                              <2>  db (%1)&255
    94                              <2> %endm
    95                              <2> 
    96                              <2> %imacro cnop    0.nolist
    97                              <2> %if SOFT_DEBUG
    98                              <2>         nop
    99                              <2> %endif
   100                              <2> %endm
   101                              <2> 
   102                              <2> %imacro popm 1-*.nolist
   103                              <2> %rep %0
   104                              <2> %ifidni %1,ALL
   105                              <2>  popa
   106                              <2> %elifidni %1,F
   107                              <2>  popf
   108                              <2> %else
   109                              <2>  pop %1
   110                              <2> %ifidni %1,DS
   111                              <2>  cnop
   112                              <2> %elifidni %1,ES
   113                              <2>  cnop
   114                              <2> %endif
   115                              <2> %endif
   116                              <2> %rotate 1
   117                              <2> %endrep
   118                              <2> %endm
   119                              <2> 
   120                              <2> %imacro pushm 1-*.nolist
   121                              <2> %rep %0
   122                              <2> %rotate -1
   123                              <2> %ifidni %1,ALL
   124                              <2>  pusha
   125                              <2> %elifidni %1,F
   126                              <2>  pushf
   127                              <2> %else
   128                              <2>  push %1
   129                              <2> %endif
   130                              <2> %endrep
   131                              <2> %endm
   132                              <2> 
   133                              <2> ;
   134                              <2> ; added from the 386EX project
   135                              <2> ;
   136                              <2> 
   137                              <2> ; call arguments
   138                              <2> %define ARG(n) [bp+2+(n)*2]
   139                              <2> 
   140                              <2> ;
   141                              <2> ; format of the BYTE initialization table:  address, byte
   142                              <2> ;
   143                              <2> %imacro  binit 2
   144                              <2>         dw      %1
   145                              <2>         db      %2
   146                              <2> %endmacro
   147                              <2> ; end with DW -1
   148                              <2> 
   149                              <2> ;
   150                              <2> ; format of the WORD initialization table:  address, word
   151                              <2> ;
   152                              <2> %imacro  winit 2
   153                              <2>         dw      %1
   154                              <2>         dw      %2
   155                              <2> %endmacro
   156                              <2> ; end with DW -1
   157                              <2> 
   158                              <2> 
   159                              <2> ; get the BIOS Data Area segment pointer to a [segment] register
   160                              <2> %imacro get_bda	1.nolist
   161                              <2> 	push	0x0040
   162                              <2> 	pop	%1
   163                              <2> 	cnop
   164                              <2> %endm
   165                              <2> 
   166                              <2> 
   167                              <2> %endif
    51                              <1> 
    52                              <1> 	cpu     186
    53                              <1> ;
    54                              <1> ;
    55                              <1> ; IBM model byte -- must be less than a 286
    56                              <1> ;
    57                              <1> ;MODEL_BYTE		equ	0FEh	; PC-XT
    58                              <1> ;SUBMODEL_BYTE		equ	0FFh	; not used
    59                              <1> 
    60                              <1> MODEL_BYTE		equ	0FEh	; PC-XT
    61                              <1> SUBMODEL_BYTE		equ	00h	;  "
    62                              <1> 
    63                              <1> 
    64                              <1> ; 80188 peripheral control register block address
    65                              <1> CPU_CSCR	        equ	0FF00h
    66                              <1> 
    67                              <1> ; Compatible Mode registers
    68                              <1> 
    69                              <1> cpu_relocation          equ     CPU_CSCR+0FEh
    70                              <1> 
    71                              <1> ; The memory and peripheral chip select register offsets from 0FF00h
    72                              <1> 
    73                              <1> cpu_umcs                equ     CPU_CSCR+0A0h          ; Upper memory select
    74                              <1> cpu_lmcs                equ     CPU_CSCR+0A2h          ; Lower memory select
    75                              <1> cpu_pacs                equ     CPU_CSCR+0A4h          ; Peripheral select
    76                              <1> cpu_mmcs                equ     CPU_CSCR+0A6h          ; Middle memory base
    77                              <1> cpu_mpcs                equ     CPU_CSCR+0A8h          ; Mid mem. & peripherals
    78                              <1> 
    79                              <1> ; Enhanced Mode registers
    80                              <1> 
    81                              <1> cpu_mdram               equ     CPU_CSCR+0E0h          ; memory partition reg.
    82                              <1> cpu_cdram               equ     CPU_CSCR+0E2h          ; clock prescaler
    83                              <1> cpu_edram               equ     CPU_CSCR+0E4h          ; Enable refresh reg.
    84                              <1> cpu_pdcon               equ     CPU_CSCR+0F0h          ; Power-Save control
    85                              <1> 
    86                              <1> 
    87                              <1> ; On-board internal peripheral equates
    88                              <1> ; Programmable Interrupt Controller
    89                              <1> PIC	        equ	CPU_CSCR+020H
    90                              <1> PIC_EOI	        equ	PIC+2           ; End Of Interrupt
    91                              <1> PIC_POLLR	equ	PIC+4
    92                              <1> PIC_POLLSR	equ	PIC+6
    93                              <1> PIC_IMASK	equ	PIC+8
    94                              <1> PIC_PMREG	equ	PIC+0AH
    95                              <1> PIC_SRVR	equ	PIC+0CH
    96                              <1> PIC_IRQR	equ	PIC+0EH
    97                              <1> PIC_IRQSR	equ	PIC+10H
    98                              <1> PIC_TCR	        equ	PIC+12H
    99                              <1> PIC_DMA0CR	equ	PIC+14H
   100                              <1> PIC_DMA1CR	equ	PIC+16H
   101                              <1> PIC_I0CON	equ	PIC+18H
   102                              <1> PIC_I1CON	equ	PIC+1AH
   103                              <1> PIC_I2CON	equ	PIC+1CH
   104                              <1> PIC_I3CON	equ	PIC+1EH
   105                              <1> 
   106                              <1> EOI_NSPEC       equ     8000h           ; Non-Specific EOI
   107                              <1> 
   108                              <1> ; Interrupt masks (Master Mode)
   109                              <1> ;
   110                              <1> mask_timer_all          equ     0001h
   111                              <1> mask_dma0               equ     0004h
   112                              <1> mask_dma1               equ     0008h
   113                              <1> mask_int0               equ     0010h
   114                              <1> mask_int1               equ     0020h
   115                              <1> mask_int2               equ     0040h
   116                              <1> mask_int3               equ     0080h
   117                              <1> 
   118                              <1> 
   119                              <1> 
   120                              <1> ; Timers
   121                              <1> TIM0	        equ	CPU_CSCR+050H
   122                              <1> TIM1	        equ	CPU_CSCR+058H
   123                              <1> TIM2	        equ	CPU_CSCR+060H
   124                              <1> 
   125                              <1> TCNT	        equ	0	; count register
   126                              <1> CMPA	        equ	2	; max count A
   127                              <1> CMPB	        equ	4	; max count B (not present on TIM2)
   128                              <1> TCON	        equ	6	; mode/control word
   129                              <1> 
   130                              <1> ; Timer control bits:
   131                              <1> tc_EN           equ     8000h   ; Enable bit
   132                              <1> tc_nINH         equ     4000h   ; not Inhibit Enable
   133                              <1> tc_INT          equ     2000h   ; Interrupt Enable
   134                              <1> tc_RIU          equ     1000h   ; Register A/B (0/1) in Use
   135                              <1> tc_MC           equ     0020h   ; Maximum Count reached
   136                              <1> tc_RTG          equ     0010h   ; Retrigger (internal source)
   137                              <1> tc_P            equ     0008h   ; Prescale internal clock (timers 0 & 1 only)
   138                              <1> tc_EXT          equ     0004h   ; External clock
   139                              <1> tc_ALT          equ     0002h   ; Alternate between A & B max count registers
   140                              <1> tc_CONT         equ     0001h   ; Continuous: continue after max count
   141                              <1> 
   142                              <1> 
   143                              <1> 
   144                              <1> 
   145                              <1> ; DMA
   146                              <1> DMA0	        equ	CPU_CSCR+0C0H
   147                              <1> DMA1	        equ	CPU_CSCR+0D0H
   148                              <1> DMASPL	        equ	0	; source pointer low
   149                              <1> DMASPU	        equ	2	; source pointer high
   150                              <1> DMADPL	        equ	4	; destination pointer low
   151                              <1> DMADPU	        equ	6	; destination pointer high
   152                              <1> DMATC	        equ	8	; terminal count
   153                              <1> DMACW	        equ	0AH	; control word
   154                              <1> 
   155                              <1> 
   156                              <1> 
   157                              <1> 
   158                              <1> 
   159                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   160                              <1> ;
   161                              <1> ;       SBC-188 external devices
   162                              <1> ;
   163                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   164                              <1> 
   165                              <1> IO_BASE			equ	0400h
   166                              <1> 
   167                              <1> 
   168                              <1> 
   169                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   170                              <1> ; The UART registers
   171                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   172                              <1> 
   173                              <1> uart_base               equ     IO_BASE+0280h
   174                              <1> uart_rbr                equ     uart_base       ;Rcvr Buffer / read only
   175                              <1> uart_thr                equ     uart_base       ;Transmit Holding / write only
   176                              <1> uart_ier                equ     uart_base+1     ;Interrupt Enable
   177                              <1> uart_iir                equ     uart_base+2     ;Interrupt Ident / read only
   178                              <1> uart_fcr                equ     uart_base+2     ;FIFO Control / write only
   179                              <1> uart_lcr                equ     uart_base+3     ;Line Control
   180                              <1> uart_mcr                equ     uart_base+4     ;Modem Control
   181                              <1> uart_lsr                equ     uart_base+5     ;Line Status
   182                              <1> uart_msr                equ     uart_base+6     ;Modem Status
   183                              <1> uart_sr			equ	uart_base+7	;Scratch
   184                              <1> 
   185                              <1> uart_dll                equ     uart_base       ;Divisor Latch LS Byte
   186                              <1> uart_dlm                equ     uart_base+1     ;Divisor Latch MS Byte
   187                              <1> 
   188                              <1> 
   189                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   190                              <1> ; Floppy controller
   191                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   192                              <1> FDC	        equ	IO_BASE+0200H
   193                              <1> FDC_MSR         equ     FDC
   194                              <1> FDC_DATA        equ     FDC_MSR+1
   195                              <1> FDC_DACK        equ	FDC+10H
   196                              <1> FDC_LDOR	equ	FDC+20H
   197                              <1> FDC_LDCR	equ	FDC+30H
   198                              <1> FDC_TC	        equ	FDC+40H
   199                              <1> FDC_DACK_TC     equ     FDC_DACK | FDC_TC
   200                              <1> 
   201                              <1> 
   202                              <1> %if SBC188==1
   203                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   204                              <1> ;DS1302 RTC
   205                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   206                              <1> RTC	equ	IO_BASE+0300H
   207                              <1> %endif
   208                              <1> 
   209                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   210                              <1> ; PIO 82C55 I/O 
   211                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   212                              <1> ; for the SBCv1/v2 with PPIDE adapter board
   213                              <1> ; and for the SBCv3 with PPIDE connector
   214                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   215                              <1> PPI	        equ	IO_BASE+0260H
   216                              <1> 
   217                              <1> PIO_A	        equ	PPI+0	; (OUTPUT)
   218                              <1> PIO_B	        equ	PPI+1	; (INPUT)
   219                              <1> PIO_C	        equ	PPI+2	; (CENTRONICS control low nibble)  
   220                              <1> PIO_CTRL	equ	PPI+3	; CONTROL BYTE PIO 82C55
   221                              <1> 
   222                              <1> portA           equ     PPI+0   ;
   223                              <1> portB           equ     PPI+1   ;
   224                              <1> portC           equ     PPI+2   ;
   225                              <1> 
   226                              <1> 
   227                              <1> 
   228                              <1> ;;;%if SBC188==3   startup.asm is universal
   229                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   230                              <1> ; CONTROL LS259 PORT ON SBC188 V3
   231                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   232                              <1> CTRL259		equ	IO_BASE+0270H
   233                              <1> ; LEDS are at addresses 0..3
   234                              <1> ; other control ports on 4..7
   235                              <1> LED0		equ	CTRL259+0
   236                              <1> LED1		equ	LED0+1
   237                              <1> LED2		equ	LED0+2
   238                              <1> LED3		equ	LED0+3
   239                              <1> T1OSC18		equ	CTRL259+4	; ON=1.8432mhz, OFF="1" (for use of TIMER2)
   240                              <1> ;unused		equ	CTRL259+5
   241                              <1> FDC_RES		equ	CTRL259+6	; RESET IS ACTIVE HIGH
   242                              <1> IDE8_RES	equ	CTRL259+7	; fast IDE RESET IS ACTIVE LOW
   243                              <1> 
   244                              <1> 
   245                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   246                              <1> ; FIDE8 8-bit IDE on the 80C188 bus
   247                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   248                              <1> FIDE_BASE       equ     IO_BASE+2C0h
   249                              <1> 
   250                              <1> IDE8_CS0        equ     FIDE_BASE
   251                              <1> IDE8_CS1        equ     FIDE_BASE+0x10
   252                              <1> 
   253                              <1> ;;;%endif   startup.asm is universal
   254                              <1> 
   255                              <1> 
   256                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   257                              <1> ; Dual [DMA] IDE devices
   258                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   259                              <1> DIDE		equ	IO_BASE + 20H	; range 0x20..0x3F
   260                              <1> 
   261                              <1> DIDE0		equ	DIDE		; first interface (master & slave)
   262                              <1> DIDE1		equ	DIDE+10h	; second interface (master & slave)
   263                              <1> 
   264                              <1> 
   265                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   266                              <1> ; DISK I/O v3 device codes (PPIDE only)
   267                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   268                              <1> DISKIO		equ	IO_BASE + 20h	; range 0x20..0x3F
   269                              <1> 
   270                              <1> DISKIO_PPIDE	equ	DISKIO		; 82c55
   271                              <1> DISKIO_FDC	equ	DISKIO + 10h	; FDC 9266
   272                              <1> DISKIO_DOR	equ	DISKIO + 18h	; OPERATION REGISTER	
   273                              <1> 
   274                              <1> 
   275                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   276                              <1> ; MF/PIC interfaces
   277                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   278                              <1> MFPIC		equ	IO_BASE + 40h	; range 0x40..0x4F
   279                              <1> 
   280                              <1> ;MFPIC_202	equ	MFPIC		; NS32202 is not usable on SBC-188
   281                              <1> MFPIC_PPIDE	equ	MFPIC + 4	; PPIDE disk interface
   282                              <1> MFPIC_UART	equ	MFPIC + 8	; TL16Cx50 SIO chip
   283                              <1> 
   284                              <1> 
   285                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   286                              <1> ; Cassette I/O
   287                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   288                              <1> cuart_base	EQU 	IO_BASE+80H	; BASE IO ADDRESS OF CASSETTE UART
   289                              <1> cuart_rbr	equ     cuart_base	;Rcvr Buffer / read only
   290                              <1> cuart_thr	equ     cuart_base	;Transmit Holding / write only
   291                              <1> cuart_ier	equ     cuart_base+1	;Interrupt Enable
   292                              <1> cuart_iir	equ     cuart_base+2	;Interrupt Ident / read only
   293                              <1> cuart_fcr	equ     cuart_base+2	;FIFO Control / write only
   294                              <1> cuart_lcr	equ     cuart_base+3	;Line Control
   295                              <1> cuart_mcr	equ     cuart_base+4	;Modem Control
   296                              <1> cuart_lsr	equ     cuart_base+5	;Line Status
   297                              <1> cuart_msr	equ     cuart_base+6	;Modem Status
   298                              <1> cuart_sr	equ	cuart_base+7	;Scratch
   299                              <1> 
   300                              <1> cuart_dll	equ     cuart_base	;Divisor Latch LS Byte
   301                              <1> cuart_dlm	equ	cuart_base+1	;Divisor Latch MS Byte
   302                              <1> 
   303                              <1> 
   304                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   305                              <1> ;
   306                              <1> ;       4MEM control registers
   307                              <1> ;
   308                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   309                              <1> EMM_addr        equ     1               ; high 6 bits of 20-bit address
   310                              <1> EMM_page        equ     0               ; 4MEM page in [0..254]
   311                              <1> 
   312                              <1> EMM_BASE        equ     IO_BASE + 000h          ; first EMM (4MEM) board
   313                              <1> EMM_unmapped    equ     255             ; unmapped 4MEM page
   314                              <1> 
   315                              <1> EMM0            equ     EMM_BASE        ; first  EMM board
   316                              <1> EMM1            equ     EMM0 + 2        ; second EMM board
   317                              <1> EMM2            equ     EMM1 + 2        ; third  EMM board
   318                              <1> EMM3            equ     EMM2 + 2        ; fourth EMM board
   319                              <1> 
   320                              <1> 
   321                              <1> 
   322                              <1> 
   323                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   324                              <1> ;
   325                              <1> ;	ColorVDU devices
   326                              <1> ;
   327                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   328                              <1> ;
   329                              <1> ;	major select on the Z80 bus
   330                              <1> ;
   331                              <1> devCVDU_8bit	equ	0xE0		; this may change to 0x10
   332                              <1> 
   333                              <1> devCVDUbase 	equ	IO_BASE + devCVDU_8bit
   334                              <1> 
   335                              <1> M8563status	equ	devCVDUbase + 4		; 4 == bitrev(2)
   336                              <1> M8563register	equ	devCVDUbase + 4
   337                              <1> M8563data	equ	devCVDUbase + 12	; 12 == bitrev(3)
   338                              <1> 
   339                              <1> %if CVDU_8563
   340                              <1> I8242status	equ	devCVDUbase + 10	; 10 == bitrev(5)
   341                              <1> I8242command	equ	devCVDUbase + 10
   342                              <1> I8242data	equ	devCVDUbase + 2		; 2 == bitrev(4)
   343                              <1> %endif
   344                              <1> 
   345                              <1> 
   346                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   347                              <1> ;
   348                              <1> ;	VGA3 devices
   349                              <1> ;
   350                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   351                              <1> ;
   352                              <1> ;	major select on the Z80 bus
   353                              <1> ;
   354                              <1> devVGA3_8bit    equ     0xE0                    ; same as CVDU
   355                              <1> 
   356                              <1> devVGA3base       equ     IO_BASE + devVGA3_8bit
   357                              <1> 
   358                              <1> %if VGA3_6445
   359                              <1> I8242status	equ	devVGA3base + 1
   360                              <1> I8242command	equ	devVGA3base + 1
   361                              <1> I8242data	equ	devVGA3base + 0
   362                              <1> %endif
   363                              <1> HD6445addr	equ	devVGA3base + 2		; to address the HD6445 registers
   364                              <1> HD6445reg	equ	devVGA3base + 3		; to r/w a register on the CRTC
   365                              <1> 
   366                              <1> vga3cfg		equ	devVGA3base + 4
   367                              <1> ; the following are probably not used on the SBC-188, except for testing/checking
   368                              <1> vga3adhi	equ	devVGA3base + 5
   369                              <1> vga3adlo	equ	devVGA3base + 6
   370                              <1> vga3data	equ	devVGA3base + 7
   371                              <1> 
   372                              <1> 
   373                              <1> 
   374                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   375                              <1> ;
   376                              <1> ;       2S1P registers
   377                              <1> ;
   378                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   379                              <1> dev_2S1P_loc		equ	0xC0	; same as 4UART !!!
   380                              <1> 
   381                              <1> dev_2S1P_base		equ	IO_BASE + dev_2S1P_loc	
   382                              <1> 
   383                              <1> dev_2S1P_A		equ	dev_2S1P_base		; serial port
   384                              <1> dev_2S1P_B		equ	dev_2S1P_base + 8h	; serial port
   385                              <1> 
   386                              <1> dev_2S1P_C		equ	dev_2S1P_base + 10h	; parallel port
   387                              <1> 
   388                              <1> 
   389                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   390                              <1> ;
   391                              <1> ;       4UART registers
   392                              <1> ;
   393                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   394                              <1> dev_4UART_loc		equ	0xC0	; same as 2S1P !!!
   395                              <1> ;				0xA0	; possible alternate
   396                              <1> dev_4UART_alt_offset	equ	0xA0 - dev_4UART_loc
   397                              <1> 
   398                              <1> dev_4UART_base		equ	IO_BASE + dev_4UART_loc	
   399                              <1> 
   400                              <1> dev_4UART_A		equ	dev_4UART_base
   401                              <1> dev_4UART_B		equ	dev_4UART_base + 8h
   402                              <1> dev_4UART_C		equ	dev_4UART_base + 10h
   403                              <1> dev_4UART_D		equ	dev_4UART_base + 18h
   404                              <1> 
   405                              <1> dev_4UART_config	equ	dev_4UART_B + 7		; overlays scratch register
   406                              <1> 
   407                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   408                              <1> ; debug port -- JRC only
   409                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   410                              <1> portD		equ	IO_BASE + 0FFh		; 0x04FF
   411                              <1> ;portD		equ	portB		     ; older 8255 output on PPI
   412                              <1> 
   413                              <1> ; end CPUREGS.ASM
   414                              <1> 
    27                                  %include        "equates.asm"
    28                              <1> ;========================================================================
    29                              <1> ; EQUATES.ASM -- Lots of Defintions for Relocatable BIOS
    30                              <1> ;========================================================================
    31                              <1> ;   for the N8VEM SBC-188 v.00.4 and 00.5
    32                              <1> ;
    33                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    34                              <1> ;
    35                              <1> ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
    36                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    37                              <1> ;
    38                              <1> ; This program is free software: you can redistribute it and/or modify
    39                              <1> ; it under the terms of the GNU General Public License as published by
    40                              <1> ; the Free Software Foundation, either version 3 of the License, or
    41                              <1> ; (at your option) any later version.
    42                              <1> ;
    43                              <1> ; This program is distributed in the hope that it will be useful,
    44                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    45                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    46                              <1> ; GNU General Public License for more details.
    47                              <1> ;
    48                              <1> ; You should have received a copy of the GNU General Public License
    49                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    50                              <1> ;
    51                              <1> ;========================================================================
    52                              <1> 
    53                              <1>         global  FPEM_segment
    54                              <1> 
    55                              <1> 
    56                              <1> %include "segdef.asm"
    57                              <2> ;========================================================================
    58                              <2> ; SEGDEF.ASM -- Lots of Defintions for Relocatable BIOS
    59                              <2> ;========================================================================
    60                              <2> ;   for the N8VEM SBC-188 v.00.4 and 00.5
    61                              <2> ;
    62                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    63                              <2> ;
    64                              <2> ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
    65                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    66                              <2> ;
    67                              <2> ; This program is free software: you can redistribute it and/or modify
    68                              <2> ; it under the terms of the GNU General Public License as published by
    69                              <2> ; the Free Software Foundation, either version 3 of the License, or
    70                              <2> ; (at your option) any later version.
    71                              <2> ;
    72                              <2> ; This program is distributed in the hope that it will be useful,
    73                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    74                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    75                              <2> ; GNU General Public License for more details.
    76                              <2> ;
    77                              <2> ; You should have received a copy of the GNU General Public License
    78                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    79                              <2> ;
    80                              <2> ;========================================================================
    81                              <2> 
    82                              <2> %ifndef __SEGDEF_
    83                              <2> %define __SEGDEF_
    84                              <2> 
    85                              <2> 	SEGMENT  _TEXT ALIGN=2 PUBLIC CLASS=CODE
    86                              <2>         SEGMENT  CONST ALIGN=2 PUBLIC CLASS=DATA
    87                              <2>         SEGMENT  CONST2 ALIGN=2 PUBLIC CLASS=DATA
    88                              <2> 	SEGMENT  _DATA ALIGN=16 PUBLIC CLASS=DATA
    89                              <2> 	SEGMENT  _BSS  ALIGN=2 PUBLIC CLASS=BSS
    90                              <2> ;;;        SEGMENT  _BASIC ALIGN=16 PUBLIC CLASS=BASIC
    91                              <2> 
    92                              <2> 	GROUP	DGROUP CONST CONST2 _DATA _BSS
    93                              <2> 
    94                              <2> %endif
    95                              <2> 
    57                              <1> %include "ascii.asm"
    58                              <2> ; ascii.asm
    59                              <2> ;
    60                              <2> CTRL            equ     1Fh     ; masks a character to CTRL-x
    61                              <2> 
    62                              <2> NUL     equ     00h
    63                              <2> BEL     equ     (CTRL & 'G')
    64                              <2> BS      equ     08h		; ^H
    65                              <2> HT      equ     09h		; ^I
    66                              <2> LF	equ	0Ah		; ^J
    67                              <2> NL      equ     LF
    68                              <2> VT	equ	0Bh		; ^K
    69                              <2> FWD	equ	0Ch		; ^L
    70                              <2> CR	equ	0Dh
    71                              <2> XON     equ     (CTRL & 'Q')
    72                              <2> XOFF    equ     (CTRL & 'S')
    73                              <2> DC1     equ     XON
    74                              <2> DC3     equ     XOFF
    75                              <2> ESC     equ	1Bh
    76                              <2> 
    77                              <2> 
    58                              <1> 
    59                              <1> 
    60                              <1> ; POST error codes. Presently one byte but can expand to word.
    61                              <1> ER_BIOS equ	01h		; Bad ROM bios checksum, patch last byte
    62                              <1> ER_RAM	equ	02h		; Bad RAM in main memory, replace
    63                              <1> ER_CRT	equ	04h		; Bad RAM in video card, replace
    64                              <1> ER_FDC	equ	08h		; Bad FDC
    65                              <1> ER_UNK1	equ	10h		; {unassigned}
    66                              <1> ER_MEM	equ	20h		; Bad RAM in vector area, replace
    67                              <1> ER_ROM	equ	40h		; Bad ROM in expansion area, bad checksum
    68                              <1> ER_UNK2	equ	80h		; {unassigned}
    69                              <1> 
    70                              <1> 
    71                              <1> 
    72                              <1> ;; ************************ BIOS Data Segment ******************************
    73                              <1> ;; BIOS data segment - not all will  be used
    74                              <1> ;                struc   BIOS_DATA_AREA  ; at 0040:0000
    75                              <1> %include "bda.inc"
    76                              <2> ;/*======================================================================
    77                              <2> ; bda.inc -- BIOS data area definitions
    78                              <2> ;========================================================================
    79                              <2> ;   for the N8VEM SBC-188
    80                              <2> ;
    81                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    82                              <2> ;
    83                              <2> ; Copyright (C) 2013 John R. Coffman.  All rights reserved.
    84                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    85                              <2> ;
    86                              <2> ; This program is free software: you can redistribute it and/or modify
    87                              <2> ; it under the terms of the GNU General Public License as published by
    88                              <2> ; the Free Software Foundation, either version 3 of the License, or
    89                              <2> ; (at your option) any later version.
    90                              <2> ;
    91                              <2> ; This program is distributed in the hope that it will be useful,
    92                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    93                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    94                              <2> ; GNU General Public License for more details.
    95                              <2> ;
    96                              <2> ; You should have received a copy of the GNU General Public License
    97                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    98                              <2> ;
    99                              <2> ;========================================================================
   100                              <2> 
   101                              <2> 			;*/ extern				/*
   102                              <2> 	ABSOLUTE  0	;*/ struct BDA {			/*
   103 00000000 ????????????????    <2> serial_ports    resw    4	;*/	word	serial_ports[4];	/*
   104 00000008 ????????????????    <2> parallel_ports  resw    4	;*/	word	parallel_ports[4];	/*
   105 00000010 ????                <2> equipment_flag  resw    1	;*/	EQFL	equipment_flag;		/*
   106                              <2> ;	dw	?		; 40:10 	; Equipment present word
   107                              <2> ;  						;  = (1 iff floppies) *     1.
   108                              <2> ;                                               ;  + (1 iff 187     ) *     2.
   109                              <2> ;  						;  + (#+1 64K sys ram) *    4.
   110                              <2> ;  						;  + (init crt mode ) *    16.
   111                              <2> ;  						;  + (# of floppies ) *    64.
   112                              <2> ;  						;  + (# serial ports) *   512.
   113                              <2> ;  						;  + (1 iff toy port) *  4096.
   114                              <2> ;                                               ;  + (1 iff modem   ) *  8192.
   115                              <2> ;  						;  + (# parallel LPT) * 16384.
   116 00000012 ??                  <2> mfg_test_flags  resb    1	;*/	byte	mfg_test_flags;	/* 40:12 unused by us
   117 00000013 ????                <2> memory_size     resw    1	;*/	word	memory_size;	/* 40:13 kilobytes
   118                              <2> uart_kbd_ctrl_R	equ	$	;*/				/*** JRC: count of ctrl-R's for reboot
   119 00000015 ??                  <2> IPL_errors      resb    1	;*/	byte	IPL_errors;	/* 40:15 IPL errors<-table/scratchpad
   120 00000016 ??                  <2> sbc188_rev       resb    1	;*/	byte	sbc188_rev;	/* was 'unused_01' before BIOS047
   121                              <2> ;;---------------[Keyboard data area]------------;
   122 00000017 ????                <2> keyboard_flags_0 resw   1	;*/	word	keyboard_flags_0;  /* 40:17 Shift/Alt/etc. keyboard flags
   123                              <2> keyboard_flags_1 equ	$-1	;     2nd byte	keyboard_flags_1;  
   124 00000019 ??                  <2> keypad_char	resb	1	;*/	byte	keypad_char;	/* 40:19 Alt-KEYPAD char. goes here
   125 0000001A ????                <2> kbd_buffer_head resw    1	;*/	word	kbd_buffer_head;   /* 40:1A --> keyboard buffer head
   126 0000001C ????                <2> kbd_buffer_tail resw    1	;*/	word	kbd_buffer_tail;   /* 40:1C --> keyboard buffer tail
   127 0000001E <res 20h>           <2> kbd_buffer      resw    16	;*/	word	kbd_buffer[16];	/* 40:1E Keyboard Buffer (Scan,Value)
   128                              <2> kbd_buffer_last	equ	$	;*/				/*
   129                              <2> ;;---------------[Diskette data area]------------;
   130 0000003E ??                  <2> fdc_drv_calib   resb    1	;*/	byte	fdc_drive_calib;   /* 40:3E
   131 0000003F ??                  <2> fdc_motor_LDOR  resb    1	;*/	byte	fdc_motor_LDOR;	   /* 40:3F Motor, DMA, select control
   132 00000040 ??                  <2> fdc_motor_ticks resb    1	;*/	byte	fdc_motor_ticks;   /* 40:40 ticks til motor off
   133 00000041 ??                  <2> fdc_status      resb    1	;*/	byte	fdc_status;	   /* 40:41
   134                              <2> ;				Floppy return code stat byte
   135                              <2> ;				;  1 = bad ic 765 command req.
   136                              <2> ;				;  2 = address mark not found
   137                              <2> ;				;  3 = write to protected disk
   138                              <2> ;				;  4 = sector not found
   139                              <2> ;				;  8 = data late (DMA overrun)
   140                              <2> ;				;  9 = DMA failed 64K page end
   141                              <2> ;				; 16 = bad CRC on floppy read
   142                              <2> ;				; 32 = bad NEC 765 controller
   143                              <2> ;				; 64 = seek operation failed
   144                              <2> ;				;128 = disk drive timed out
   145 00000042 ??????????????      <2> fdc_ctrl_status resb    7	;*/	byte	fdc_ctrl_status[7];  /* 40:42 Status bytes from NEC 765
   146                              <2> ;;---------------[Video display area]------------;
   147 00000049 ??                  <2> video_mode      resb    1	;*/	byte	video_mode;	/* 40:49
   148                              <2> ;			 	; Current CRT mode  (software)
   149                              <2> ;				;  0 = 40 x 25 text (no color)
   150                              <2> ;				;  1 = 40 x 25 text (16 color)
   151                              <2> ;				;  2 = 80 x 25 text (no color)
   152                              <2> ;				;  3 = 80 x 25 text (16 color)
   153                              <2> ;				;  4 = 320 x 200 grafix 4 color
   154                              <2> ;				;  5 = 320 x 200 grafix 0 color
   155                              <2> ;				;  6 = 640 x 200 grafix 0 color
   156                              <2> ;				;  7 = 80 x 25 text (mono card)
   157 0000004A ????                <2> video_columns   resw    1	;*/	word video_columns;	/* 40:4A Columns on CRT screen
   158 0000004C ????                <2> video_regen_bytes  resw 1	;*/	word video_regen_bytes;	/* 40:4C Bytes in the regen region
   159 0000004E ????                <2> video_regen_offset resw 1	;*/	word video_regen_offset;/* 40:4E Byte offset in regen region
   160 00000050 <res 10h>           <2> video_cursor_pos  resw  8	;*/	word video_cursor_pos[8];  /* 40:50 Cursor pos for up to 8 pages
   161 00000060 ????                <2> video_cursor_mode resw  1	;*/	word video_cursor_mode;	/* 40:60 Current cursor mode setting
   162 00000062 ??                  <2> video_page      resb    1	;*/	byte video_page;	/* 40:62 Current page on display
   163 00000063 ????                <2> video_base_seg  resw    1	;*/	word video_base_seg;	/* 40:63 Base address (B000h or B800h)
   164 00000065 ??                  <2> video_hw_mode   resb    1	;*/	byte video_hw_mode;	/* 40:65 ic 6845 mode reg. (hardware)
   165 00000066 ??                  <2> video_cga_palette resb  1	;*/	byte video_cga_palette;	/* 40:66 Current CGA palette
   166                              <2> ;;---------------[Used to setup ROM]-------------;
   167 00000067 ????????            <2> eprom_address   resd    1	;*/	dword eprom_address;	/* 40:67 Eprom base Offset,Segment
   168 0000006B ??                  <2> spurious_irq    resb    1	;*/	byte spurious_irq;	/* 40:6B Last spurious interrupt IRQ
   169                              <2> ;;---------------[Timer data area]---------------;
   170 0000006C ????????            <2> timer_ticks     resd    1	;*/	dword timer_ticks;	/* 40:6C Ticks since midnight (lo,hi)
   171 00000070 ??                  <2> timer_new_day   resb    1	;*/	byte timer_new_day;	/* 40:70 Non-zero if new day
   172                              <2> ;;---------------[System data area]--------------;
   173 00000071 ??                  <2> break_flag      resb    1	;*/	byte break_flag;	/* 40:71 Sign bit set iff break
   174 00000072 ????                <2> warm_boot       resw    1	;*/	word warm_boot;		/* 40:72 Warm boot iff==1234h
   175                              <2> ;;---------------[Hard disk scratchpad]----------;
   176 00000074 ????????            <2> hdd_scratch     resd    1	;*/	word hdd_scratch[2];	/* 40:74
   177                              <2> ;;---------------[Timout areas/PRT/LPT]----------;
   178 00000078 ????????            <2> lpt_timeout     resb    4	;*/	byte lpt_timeout[4];	/* 40:78 Ticks for LPT 1-4 timeouts
   179 0000007C ????????            <2> com_timeout     resb    4	;*/	byte com_timeout[4];	/* 40:7C Ticks for COM 1-4 timeouts
   180                              <2> ;;---obsolete----[Keyboard buf start/end]---jrc--;
   181 00000080 ????                <2> kbd_buffer_start resw   1	;*/	word kbd_buffer_start;	/* 40:80 KBD buffer head (PC/AT)
   182 00000082 ????                <2> kbd_buffer_end  resw    1	;*/	word kbd_buffer_end;	/* 40:82 KBD buffer tail (PC/AT)
   183                              <2> ;;---------------[EGA stuff]---------------------;
   184 00000084 ??????????????      <2> EGA_stuff	resb	7	;*/	byte EGA_stuff[7];	/* 40:84 Unspecified EGA data
   185                              <2> ;;---------------[Floppy/Fixed Media Info]-------------;
   186 0000008B ??                  <2> fdc_last_rate	resb	1	;*/	byte fdc_last_rate;	/* 40:8B Last floppy step rate/data rate?
   187 0000008C ????????            <2> fx_misc_unused	resb	4	;*/	byte fx_misc_unused[4];	/* 40:8C Fixed disk miscellaneous ???
   188 00000090 ????                <2> fdc_disk_state	resb	2	;*/	byte fdc_disk_state[2];	/* 40:90 Floppy disk state
   189 00000092 ????                <2> fdc_op_start	resb	2	;*/	byte fdc_op_start[2];	/* 40:92 Floppy operation start state machine
   190 00000094 ????                <2> fdc_cylinder	resb	2	;*/	byte fdc_cylinder[2];	/* 40:94 Floppy present cylinder
   191                              <2> ;;---------------[Additional KBD flags]----------------;
   192 00000096 ??                  <2> kbd_flag_3	resb	1	;*/	byte kbd_flag_3;	/* 40:96 kbd ???
   193 00000097 ??                  <2> kbd_flag_2	resb	1	;*/	byte kbd_flag_2;	/* 40:97 kbd ???
   194                              <2> ;;---------------[RTC/timer1 data]---------------------;
   195 00000098 ????????            <2> user_semaphore	resw	2	;*/	byte *user_semaphore;	/* 40:98 User semaphore in (bit 7)
   196 0000009C ????????            <2> rtc_count	resd	1	;*/	dword rtc_count;	/* 40:9C RTC tick counter
   197 000000A0 ??                  <2> rtc_wait_active	resb	1	;*/	byte rtc_wait_active;	/* 40:A0 Busy=01, Posted=80h, 
   198                              <2> ;;---------------[Cassette I/O stuff]------------------;
   199 000000A1 ??                  <2> last_val	resb	1	;*/	byte last_val;		/* 40:A1 Last byte read value
   200 000000A2 ????                <2> crc_reg		resw	1	;*/	word crc_reg;		/* 40:A2 CRC accumulation area
   201                              <2> ;									Post Acknowleged=00;
   202 000000A4 ??                  <2> EGA_data	resb	1	;*/	byte EGA_data;		/* 40:A4 Various usage
   203 000000A5 ????                <2> SDstatus	resb	2	;*/	byte SDstatus[2];	/* 40:A5 Status byte from command
   204 000000A7 ????                <2> SDcardtype	resb	2	;*/	byte SDcardtype[2];	/* 40:A7 SDcard type SDSC=2, HC=3, ...
   205                              <2> ;
   206 000000A9 ????????            <2> fixed_disk_tab	resb	4	;*/	byte fixed_disk_tab[4];	/* dispatch table to fixed disk drivers
   207 000000AD ??                  <2> wait12_count	resb	1	;*/	byte wait12_count;	/* 40:AD 12usec CX count
   208 000000AE ??                  <2> lock_count	resb	1	;*/	byte lock_count;	/* 40:AE lock level counter
   209 000000AF ??                  <2> EMS_start       resb    1	;*/	byte EMS_start;		/* start EMS allocation from here
   210                              <2> fx80		equ	$	;*/	struct EDD_disk fx80;	/* fixed disk parameter area 0
   211 000000B0 ????                <2> fx_log_cylinders resw   1	;	word fx_log_cylinders;	 logical number of cylinders
   212 000000B2 ??                  <2> fx_log_heads    resb    1	;	byte fx_log_heads;	 logical number of heads
   213 000000B3 ??                  <2> fx_signature	resb	1	;	byte fx_signature;	 A0h signature = translated geom
   214 000000B4 ??                  <2> fx_phys_sectors	resb    1       ;	byte fx_phys_sectors;	 physical number of sectors per track
   215 000000B5 ????                <2> fx_LBA_high     resw    1       ;	word fx_LBA_high;	 high word of LBA28 number of sectors
   216 000000B7 ??                  <2> fx_reserved	resb	1	;	byte fx_reserved;	 reserved for future use
   217 000000B8 ??                  <2> fx_drive_control resb   1       ;	byte fx_drive_control;	 flag bits for IDE head register
   218 000000B9 ????                <2> fx_phys_cylinders resw	1	;	word fx_phys_cylinders;	 physical number of cylinders
   219 000000BB ??                  <2> fx_phys_heads	resb	1	;	byte fx_phys_heads;	 physical number of heads
   220 000000BC ????                <2> fx_LBA_low	resw	1	;	word fx_LBA_low;	 low word of LBA28 number of sectors
   221 000000BE ??                  <2> fx_log_sectors	resb	1	;	byte fx_log_sectors;	 logical number of sectors per track
   222 000000BF ??                  <2> fx_checksum	resb	1	;	byte fx_checksum;	 checksum, dunno how to compute
   223 000000C0 <res 10h>           <2> fx81            resb    16	;*/	struct EDD_disk fx81;	/* fixed disk parameter area 1
   224 000000D0 <res 10h>           <2> fx82            resb    16	;*/	struct EDD_disk fx82;	/* fixed disk parameter area 2
   225 000000E0 <res 10h>           <2> fx83            resb    16	;*/	struct EDD_disk fx83;	/* fixed disk parameter area 3
   226                              <2> ;
   227                              <2> ;
   228                              <2> 
   229 000000F0 ????                <2> FPEM_segment    resw    1       ;*/	word FPEM_segment;	/* FPEM data segment
   230                              <2> 
   231 000000F2 ????                <2> EBDA_paragraph  resw    1       ;*/	word EBDA_paragraph;	/* lowest EBDA paragraph
   232                              <2> 
   233 000000F4 ????                <2> dma0_cw         resw    1       ;*/	word dma0_cw;		/* end of dma control word
   234 000000F6 ????                <2> dma1_cw         resw    1       ;*/	word dma1_cw;		/*   ditto
   235                              <2> 
   236 000000F8 ????                <2> fdc_type	resb	2	;*/	byte fdc_type[2];	/* disk type in low nibble, alternate in hi nib 
   237                              <2> 
   238 000000FA ????????            <2> debug_static_ptr  resw	2	;*/	void *debug_static_ptr;	/* pointer to debug static area
   239                              <2> 
   240 000000FE ??                  <2> n_fixed_disks   resb    1       ;*/	byte n_fixed_disks;	/* number of fixed disks
   241                              <2> 
   242 000000FF ??                  <2> cpu_xtal        resb    1       ;*/	byte cpu_xtal;		/* CPU crystal frequency in Mhz 
   243                              <2> ;								   CPU clock is half of this
   244                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   245                              <2> ;
   246                              <2> ;  System configuration stuff below
   247                              <2> ;	c.f., CONFIG.ASM (ANSI.CFG, CVDU.CFG, etc.), User configuration stuff
   248                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   249                              <2> %if 0				;*/
   250                              <2> #define FIXED_DISK_MAX 4		/*
   251                              <2> %else
   252                              <2> %define FIXED_DISK_MAX 4
   253                              <2> %endif
   254                              <2> %if 0				;*/
   255                              <2> #define PPIDE_driver 1		/*
   256                              <2> %else
   257                              <2> %define PPIDE_driver 1
   258                              <2> %endif
   259                              <2> %if 0				;*/
   260                              <2> #define DIDE_driver 0		/*
   261                              <2> %else
   262                              <2> %define DIDE_driver 0
   263                              <2> %endif
   264                              <2> %if 0				;*/
   265                              <2> #define DISKIO_driver 1		/*
   266                              <2> %else
   267                              <2> %define DISKIO_driver 1
   268                              <2> %endif
   269                              <2> %if 0				;*/
   270                              <2> #define MFPIC_driver 1		/*
   271                              <2> %else
   272                              <2> %define MFPIC_driver 1
   273                              <2> %endif
   274                              <2> %if 0				;*/
   275                              <2> #define DSD_driver 1		/*
   276                              <2> %else
   277                              <2> %define DSD_driver 1
   278                              <2> %endif
   279                              <2> %if 0				;*/
   280                              <2> #define V3IDE8_driver (SBC188==3)		/*
   281                              <2> %else
   282                              <2> %define V3IDE8_driver (SBC188==3)
   283                              <2> %endif
   284                              <2> 				;*/
    76                              <1> 
    77                              <1> ;  this must be the same in EQUATES.H */
    78                              <1> %if SOFT_DEBUG
    79                              <1> %define NBREAK  8
    80                              <1> %endif
    81                              <1> 
    82                              <1> 
    83                              <1> %if 0
    84                              <1>         segment _TEXT
    85                              <1> ;; *************************************************************************
    86                              <1> 
    87                              <1> 
    88                              <1> 
    89                              <1> 
    90                              <1> ;; ************************ DOS Data Segment *******************************
    91                              <1> ;dosdir	SEGMENT at 50h				; Boot disk directory from IPL
    92                              <1> ;xerox	label	byte				;  0 if Print Screen idle
    93                              <1> ;						;  1 if PrtSc xeroxing screen
    94                              <1> ;						;255 if PrtSc error in xerox
    95                              <1> ;						;  ...non-grafix PrtSc in bios
    96                              <1> ;	db	200h dup(?)			; PC-DOS bootstrap procedure
    97                              <1> ;						;  ...IBMBIO.COM buffers the
    98                              <1> ;						;  ...directory of the boot
    99                              <1> ;						;  ...device here at IPL time
   100                              <1> ;						;  ...when locating the guts
   101                              <1> ;						;  ...of the operating system
   102                              <1> ;						;  ...filename "IBMDOS.COM"
   103                              <1> ;dosdir	ends
   104                              <1> ;; *************************************************************************
   105                              <1> ;; ************************ DOS IPL Segment ********************************
   106                              <1> ;dosseg	SEGMENT at 70h				; "Kernel" of PC-DOS op sys
   107                              <1> ;;IBMBIO.COM file loaded by boot block. Device Drivers/Bootstrap. CONTIGUOUS<---
   108                              <1> ;;IBMDOS.COM operating system nucleus immediately follows IBMBIO.COM and       !
   109                              <1> ;;     doesn`t have to be contiguous.  The IBMDOS operating system nucleus     !
   110                              <1> ;;     binary image is loaded by transient code in IBMBIO binary image	      !
   111                              <1> ;dosseg	ends					;			      !
   112                              <1> ;iplseg	SEGMENT at 0h				; Segment for boot block      !
   113                              <1> ;;The following boot block is loaded with 512 bytes on the first sector of     !
   114                              <1> ;;the bootable device by code resident in the ROM-resident bios.  Control is   !
   115                              <1> ;;then transferred to the first word 0000:7C00 of the disk-resident bootstrap  !
   116                              <1> ;	ORG	07C00h				;  ..offset for boot block    !
   117                              <1> ;boot	db	200h dup(?)			;  ..start disk resident boot--
   118                              <1> ;iplseg	ends
   119                              <1> 
   120                              <1> %endif
    28                                  
    29                                          extern  cpu_table_init
    30                                  
    31                                          global  BIOS_call_1Ch
    32                                          global  timer0_interrupt, timer1_interrupt, timer2_interrupt
    33                                          extern  fdc_timer_hook
    34                                          global  BIOS_call_1Ah   ; BIOS call
    35                                          global  @timer_init
    36                                          global  _cpu_speed
    37                                          extern  rtc_get_loc, rtc_set_loc
    38                                  
    39                                  %if NEED_TIMER_FIX
    40                                  ; swap the timers in the intiialization table
    41                                  timer0          equ     TIM1
    42                                  timer1          equ     TIM0
    43                                  %else
    44                                  ; timers are their true selves in the initialization table
    45                                  timer0          equ     TIM0
    46                                  timer1          equ     TIM1
    47                                  %endif
    48                                  
    49                                  %if 1
    50                                  ;/* definitions below are from "ds1302.h" */
    51                                  
    52                                  ;/* definitions of the CMOS RAM locations */
    53                                  %define RAM_trickle		0
    54                                  %define RAM_century		1
    55                                  %define RAM_floppy      2
    56                                  %define RAM_floppy0     2
    57                                  %define RAM_floppy1     3
    58                                  %define RAM_bits        4
    59                                  %define RAM_bits_DST    01h     ; DST flag
    60                                  
    61                                  %define RAM_checksum		30
    62                                  %define RAM_length		31
    63                                  
    64                                  ;#define rtc_WP(on) rtc_set_loc(7|CLOCK,(on?0x80:0))
    65                                  %endif
    66                                  
    67                                  
    68                                  
    69                                  
    70                                  
    71                                          SEGMENT _TEXT
    72                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    73                                  ; _cpu_speed
    74                                  ;
    75                                  ;       Determine the CPU clock rate using the UART oscillator
    76                                  ;       as the time standard.
    77                                  ;
    78                                  ;       Return the CPU speed in AX
    79                                  ;
    80                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    81                                  _cpu_speed:
    82 00000000 E8(0000)                        call    cpu_table_init
    83 00000003 [1500]                           dw       speed_setup           ; start the two timers
    84                                  
    85 00000005 BA5EFF                          mov     dx,timer1+TCON
    86                                  .1:
    87 00000008 ED                              in      ax,dx                   ; read status of timer1
    88 00000009 A820                            test    al,tc_MC                ; max count reached ?
    89 0000000B 74FB                            jz      .1
    90                                  
    91 0000000D BA60FF                          mov     dx,TIM2+TCNT          ; read the count
    92 00000010 90                              nop
    93 00000011 90                              nop
    94 00000012 90                              nop
    95 00000013 ED                              in      ax,dx
    96 00000014 C3                              ret
    97                                  
    98                                  speed_setup:
    99                                          db_lo   timer1+TCON
    93 00000015 5E                  <1>  db (%1)&255
   100 00000016 0040                            dw      tc_nINH                 ; disable
   101                                  
   102                                          db_lo   TIM2+TCON
    93 00000018 66                  <1>  db (%1)&255
   103 00000019 0040                            dw      tc_nINH                 ; disable
   104                                  
   105                                          db_lo   TIM2+CMPA             ; max. count
    93 0000001B 62                  <1>  db (%1)&255
   106 0000001C FFFF                            dw      0FFFFh
   107                                  
   108                                          db_lo   timer1+CMPA             ; max. count
    93 0000001E 5A                  <1>  db (%1)&255
   109 0000001F 0048                            dw      UART_OSC / 100          ; 10 ms interval
   110                                  
   111                                          db_lo   TIM2+TCNT             ; timer count = 0
    93 00000021 60                  <1>  db (%1)&255
   112 00000022 0000                            dw      0
   113                                  
   114                                          db_lo   timer1+TCNT             ; timer_count = 0
    93 00000024 58                  <1>  db (%1)&255
   115 00000025 0000                            dw      0
   116                                  
   117                                          db_lo   timer1+TCON             ; start timer 1
    93 00000027 5E                  <1>  db (%1)&255
   118 00000028 04C0                            dw      tc_EN+tc_nINH+tc_EXT    ; no Interrupts
   119                                  
   120                                          db_lo   TIM2+TCON             ; start timer 2
    93 0000002A 66                  <1>  db (%1)&255
   121 0000002B 00C0                            dw      tc_EN+tc_nINH
   122                                  
   123 0000002D 00                              db      0               ; end of the table
   124                                  
   125                                  
   126                                  
   127                                  
   128                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   129                                  ; @timer_init
   130                                  ;
   131                                  ;       Start the 18.2 Hz clock ticks by initializing
   132                                  ;       timers 0 & 2    
   133                                  ;                               [1 & 2 on prototype boards]
   134                                  ;   Call with Xtal frequency in AX
   135                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   136                                  
   137                                  @timer_init:
   138 0000002E 56                              push    si
   139 0000002F 57                              push    di
   140                                  
   141 00000030 50                              push    ax              ; protect AX
   142                                  
   143 00000031 E8(0000)                        call    cpu_table_init
   144 00000034 [5900]                           dw      timer_table
   145                                  
   146 00000036 58                              pop     ax
   147 00000037 BFA335                          mov     di,13731
   148                                          
   149 0000003A A801                            test    al,1            ; test for odd frequency
   150 0000003C 7504                            jnz     .1
   151                                  ; even frequency
   152 0000003E D1E8                            shr     ax,1            ; halve the Xtal frequency
   153 00000040 EB02                            jmp     .2
   154                                  .1:     ; odd 
   155 00000042 D1EF                            shr     di,1            ; halve the divisor
   156                                  .2:
   157 00000044 BA62FF                          mov     dx,TIM2+CMPA    ; set the timer 2 max count A
   158 00000047 EF                              out     dx,ax
   159 00000048 BA52FF                          mov     dx,timer0+CMPA  ; set the timer 0 max count A
   160 0000004B 89F8                            mov     ax,di
   161 0000004D EF                              out     dx,ax
   162                                  
   163 0000004E BA32FF                          mov     dx,PIC_TCR      ; timer control register
   164 00000051 ED                              in      ax,dx
   165 00000052 83E0F7                          and     ax,~08h         ; clear the mask bit
   166 00000055 EF                              out     dx,ax
   167                                  
   168 00000056 5F                              pop     di
   169 00000057 5E                              pop     si
   170 00000058 C3                              ret
   171                                  
   172                                  timer_table:
   173                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   174                                  ;
   175                                  ;  Set up Timer 2 to provide the 250 kHz clock to Timer 0
   176                                  ;
   177                                  ;  By dividing CPU_CLK/4, the internal input to the timer, by the
   178                                  ;  CPU clock rate, the 1/4 Mhz internal clock to the other
   179                                  ;  timers is achieved.
   180                                  
   181                                          db_lo   TIM2+TCNT       ; zero the count register
    93 00000059 60                  <1>  db (%1)&255
   182 0000005A 0000                            dw      0
   183                                  
   184                                          db_lo   TIM2+TCON       ; wired: ALT=0, EXT=0, P=0, RTG=0
    93 0000005C 66                  <1>  db (%1)&255
   185 0000005D 01C0                            dw      tc_EN+tc_nINH+tc_CONT   ; EN=1, /INH=1, INT=0, CONT=1
   186                                  
   187                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   188                                  ;
   189                                  ;  Set up Timer 0 to provide the 54.925 ms (18.2 Hz) PC timer tick
   190                                  ;
   191                                  
   192                                          db_lo   timer0+TCNT       ; Timer 0 count register
    93 0000005F 50                  <1>  db (%1)&255
   193 00000060 0000                            dw      0
   194                                  
   195                                          db_lo   timer0+CMPB       ; count B register
    93 00000062 54                  <1>  db (%1)&255
   196 00000063 0000                            dw      0
   197                                  
   198                                  ;;        db_lo   timer0+CMPA       ; count A register
   199                                  ;;        dw      13731             ; divisor:  250000/13731 -> 18.206..
   200                                  
   201                                          db_lo   timer0+TCON       ; control register
    93 00000065 56                  <1>  db (%1)&255
   202 00000066 09E0                            dw      tc_EN+tc_nINH+tc_INT+tc_P+tc_CONT
   203                                                                  ; EN=1, /INH=1, INT=1, 
   204                                                                  ; RTG=0, P=1, EXT=0, ALT=0, CONT=1
   205                                  
   206                                  
   207                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   208                                  ;
   209                                  ;  Set up Timer 1 as disabled at 1024Hz
   210                                  ;
   211                                  
   212                                          db_lo   timer1+CMPA     ; max count A
    93 00000068 5A                  <1>  db (%1)&255
   213 00000069 0807                            dw      UART_OSC/1024   ; 1024Hz RTC counter for waits
   214                                  
   215                                          db_lo   timer1+TCNT     ; count
    93 0000006B 58                  <1>  db (%1)&255
   216 0000006C 0000                            dw      0
   217                                  
   218                                          db_lo   timer1+TCON       ; control register
    93 0000006E 5E                  <1>  db (%1)&255
   219 0000006F 0D60                            dw      tc_nINH+tc_P+tc_CONT+tc_EXT+tc_INT
   220                                                                  ; EN=0, /INH=1, INT=1, 
   221                                                                  ; RTG=0, P=1, EXT=1, ALT=0, CONT=1
   222                                  
   223 00000071 00                              db      0               ; end of the table
   224                                  
   225                                  
   226                                  timer2_interrupt:       ; int 19 = 13h
   227 00000072 CF                              iret
   228                                  
   229                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   230                                  ;  timer0_interrupt             (timer1, if NEED_TIMER_FIX)
   231                                  ;
   232                                  ;       This is the 18.2 Hz timer tick
   233                                  ;
   234                                  ;
   235                                  ;ONE_DAY         equ     1573040         ; timer ticks in a day (IBM PC)
   236                                  ONE_DAY         equ     1573080         ; timer ticks in a day (compromise)
   237                                  ;ONE_DAY        equ     1573082         ; timer ticks in a day (our clock)
   238                                  ;                                       ; ours is a little slow
   239                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   240 00000073 D8001800                one_day:        dd      ONE_DAY
   241                                  
   242                                  %if NEED_TIMER_FIX
   243                                  timer0_interrupt:
   244                                  %else
   245                                  timer1_interrupt:       ; int 18 = 12h 	Redirected from BIOS_call_12h
   246                                  %endif
   247 00000077 CD70                    	int	70h	; IRQ8 -- 1024Hz RTC timer (rtc_interrupt)
   248 00000079 CF                      	iret
   249                                  
   250                                  
   251                                  
   252                                  %if NEED_TIMER_FIX
   253                                  timer1_interrupt:
   254                                  %else
   255                                  timer0_interrupt:	; true timer 0 18.2Hz interrupt
   256                                  %endif
   257                                  ; service the timer tick interrupt
   258 0000007A 1E5250                          pushm   ax,dx,ds
   259                                  
   260 0000007D 6A40                            push    bios_data_seg
   261 0000007F 1F90                            popm    ds              ; address the BIOS data area
   262                                  
   263                                  ;%if (ONE_DAY < 0FFFFFFh) && ( ONE_DAY & 255 )
   264                                  %if 1
   265                                                  
   266 00000081 E8(0000)                        call    fdc_timer_hook
   267                                  
   268                                  ; the strategy below is that the most frequently travelled path
   269                                  ; is the fewest branches and the fewest number of instructions
   270 00000084 FE066C00                        inc     byte [timer_ticks]
   271 00000088 7415                            jz      .2
   272 0000008A 803E6C00D8                      cmp     byte [timer_ticks], ONE_DAY & 0FFh
   273 0000008F 7414                            je      .3
   274                                  .9:
   275 00000091 CD1C                    	int	1Ch			; User timer tick interrupt
   276                                  
   277                                  %if  CVDU_USE_MSDOS_KLUDGE
   278                                  	extern	cvdu_kbd_int	; external reference
   279                                  	xor	ax,ax
   280                                  	mov	ds,ax		; patch the keyboard interrupt vector
   281                                  				; on every timer tick!!!
   282                                  	mov	word [0Ch*4],cvdu_kbd_int
   283                                  	mov	word [0Ch*4+2],cs
   284                                  %endif
   285                                  
   286                                  %if CVDU_USE_KBD_HOOK
   287                                  	extern	cvdu_kbd_hook
   288                                  	call	cvdu_kbd_hook
   289                                  %endif
   290                                  
   291                                  ; signal EOI (End of Interrupt)
   292 00000093 BA22FF                          mov     dx,PIC_EOI              ; EOI register
   293 00000096 B80080                          mov     ax,EOI_NSPEC            ; non-specific
   294 00000099 EF                              out     dx,ax                   ; signal it
   295                                  
   296 0000009A 585A1F90                        popm    ax,dx,ds
   297 0000009E CF                      	iret
   298                                  
   299                                  ; the less frequent execution paths are below
   300                                  .2:     ;  low byte == 0
   301 0000009F FF066D00                        inc     word [timer_ticks+1]
   302 000000A3 EBEC                            jmp     .9
   303                                  
   304                                  .3:     ; AX = low word ONE_DAY
   305 000000A5 813E6D000018                    cmp     word [timer_ticks+1], ONE_DAY >> 8
   306 000000AB 75E4                            jne     .9
   307                                  
   308                                  ; a day has passed
   309 000000AD C7066C000000                    mov     word [timer_ticks],0
   310 000000B3 C7066E000000                    mov     word [timer_ticks+2],0  ; zero the high word
   311 000000B9 C606700001                      mov     byte [timer_new_day],1   ; set flag
   312 000000BE EBD1                            jmp     .9
   313                                  
   314                                  
   315                                  
   316                                  %else
   317                                          %error "Timer interrupt service."
   318                                  %endif
   319                                  
   320                                  
   321                                  
   322                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   323                                  ;  BIOS_call_1Ah        software interrupt
   324                                  ;
   325                                  ;       Functions in AH:
   326                                  ;               00      get tick count
   327                                  ;               01      set tick count
   328                                  ;               02      get time (from CMOS clock)
   329                                  ;               03      set time (to CMOS clock)
   330                                  ;               04      get date (from CMOS clock)
   331                                  ;               05      set data (to CMOS clock)
   332                                  ;               06      set alarm (we don't implement this one)
   333                                  ;               07      reset alarm
   334                                  ; we don't implement the following:
   335                                  ;               0Ah     get day count [PS/2]
   336                                  ;               0Bh     set day count [PS/2]
   337                                  ;               80h     set sound source [PC only]
   338                                  ;               
   339                                  ;
   340                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   341                                  offset_BP       equ     0
   342                                  offset_BX       equ     offset_BP+2
   343                                  offset_AX       equ     offset_BX+2
   344                                  offset_DS       equ     offset_AX+2
   345                                  offset_IP       equ     offset_DS+2
   346                                  offset_CS       equ     offset_IP+2
   347                                  offset_FLAGS    equ     offset_CS+2
   348                                  
   349                                  BIOS_call_1Ah:                  ; int 1Ah  call
   350 000000C0 1E                              pushm   ds
   351 000000C1 50                              push    ax
   352 000000C2 53                              push    bx
   353                                  
   354 000000C3 55                              push    bp              ; set to address stack
   355 000000C4 89E5                            mov     bp,sp
   356                                  
   357 000000C6 6A40                            push    bios_data_seg
   358 000000C8 1F90                            popm    ds              ; establish addressability
   359                                  
   360 000000CA 88E3                            mov     bl,ah           ; set to index into dispatch table
   361 000000CC 80FC08                          cmp     ah,max/2
   362 000000CF 7319                            jae     undefined
   363 000000D1 30FF                            xor     bh,bh
   364 000000D3 D1E3                            shl     bx,1            ; index words
   365                                  
   366 000000D5 2EFFA7[DA00]                cs  jmp     near [dispatch+bx]
   367                                  
   368                                  
   369                                  
   370                                  
   371                                  dispatch:
   372 000000DA [3B01]                          dw      fn0
   373 000000DC [4E01]                          dw      fn1
   374 000000DE [5801]                          dw      fn2
   375 000000E0 [9201]                          dw      fn3
   376 000000E2 [D501]                          dw      fn4
   377 000000E4 [0202]                          dw      fn5
   378 000000E6 [EA00]                          dw      fn6
   379 000000E8 [EA00]                          dw      fn7
   380                                  max     equ     $-dispatch
   381                                  
   382                                  fn6:
   383                                  fn7:
   384                                  undefined:
   385 000000EA C64605FF                        mov     byte [bp+offset_AX+1],0FFh      ; error code?
   386                                  set_carry:
   387 000000EE 804E0C01                        or      byte [bp+offset_FLAGS],1        ; set the carry
   388 000000F2 EB04                            jmp     popall
   389                                  good_exit:
   390 000000F4 80660CFE                        and     byte [bp+offset_FLAGS],~1       ; clear the carry
   391 000000F8 5D                      popall: pop     bp              
   392 000000F9 5B                              pop     bx              ; register restores
   393 000000FA 58                              pop     ax
   394 000000FB 1F90                            popm    ds
   395                                  BIOS_call_1Ch:
   396 000000FD CF                              iret
   397                                  
   398                                  ; update CMOS 
   399                                  ;       AL = ram address (0..29)
   400                                  ;       DL = new contents of address
   401                                  ;
   402                                  ; the RAM location is updated with the new contents
   403                                  ; and the checksum (location 30) is maintained at zero
   404                                  ;
   405                                  updateCMOS:
   406 000000FE 5253                            pushm   bx,dx
   407                                  
   408 00000100 B480                            mov     ah,80h
   409 00000102 50                              push    ax
   410 00000103 E8(0000)                        call    rtc_get_loc
   411 00000106 93                              xchg    ax,bx
   412 00000107 28D3                            sub     bl,dl           ; difference between contents
   413 00000109 58                              pop     ax
   414 0000010A 7412                            jz      .5              ; jump if no change
   415 0000010C E8(0000)                        call    rtc_set_loc     ; set DL, the changed value
   416 0000010F B81E80                          mov     ax,8000h+30     ; get checksum location
   417 00000112 50                              push    ax              ; save address
   418 00000113 E8(0000)                        call    rtc_get_loc
   419 00000116 00D8                            add     al,bl           ; update checksum
   420 00000118 88C2                            mov     dl,al
   421 0000011A 58                              pop     ax
   422 0000011B E8(0000)                        call    rtc_set_loc
   423                                  .5:
   424 0000011E 5B5A                            popm    bx,dx
   425 00000120 C3                              ret
   426                                  
   427                                  ; Write Enable the CMOS chip
   428                                  ;
   429                                  write_enable:
   430 00000121 5250                            pushm   ax,dx
   431 00000123 B80700                          mov     ax,7            ; 
   432 00000126 B200                            mov     dl,0
   433 00000128 E8(0000)                        call    rtc_set_loc
   434 0000012B 585A                            popm    ax,dx
   435 0000012D C3                              ret
   436                                  
   437                                  ; Write Protect the CMOS chip
   438                                  ;
   439                                  write_protect:
   440 0000012E 5250                            pushm   ax,dx
   441 00000130 B80700                          mov     ax,7            ; 
   442 00000133 B280                            mov     dl,80h
   443 00000135 E8(0000)                        call    rtc_set_loc
   444 00000138 585A                            popm    ax,dx
   445 0000013A C3                              ret
   446                                  
   447                                  
   448                                  ;
   449                                  ; Get Tick Count
   450                                  ;       AL = rolled-over flag
   451                                  ;       CX:DX = tick counter
   452                                  ;
   453                                  fn0:
   454 0000013B 31C0                            xor     ax,ax
   455 0000013D 86067000                        xchg    al,[timer_new_day]
   456 00000141 894604                          mov     [bp+offset_AX],ax
   457 00000144 8B166C00                        mov     dx,[timer_ticks]
   458 00000148 8B0E6E00                        mov     cx,[timer_ticks+2]
   459 0000014C EBA6                            jmp     good_exit
   460                                  
   461                                  ;
   462                                  ; Set Tick Count
   463                                  ;   returns:
   464                                  ;       CX:DX = tick counter
   465                                  ;
   466                                  fn1:
   467 0000014E 89166C00                        mov     [timer_ticks],dx
   468 00000152 890E6E00                        mov     [timer_ticks+2],cx
   469 00000156 EB9C                            jmp     good_exit
   470                                  
   471                                  
   472                                  
   473                                  ;
   474                                  ; Get Time from CMOS clock
   475                                  ;   returns:
   476                                  ;       CH = hours in BCD
   477                                  ;       CL = minutes in BCD
   478                                  ;       DH = seconds in BCD
   479                                  ;       DL = DST code (00=standard time, 01=daylight time)
   480                                  ;
   481                                  ;       Carry Clear if clock is running
   482                                  ;
   483                                  ;       Carry Set if clock is stopped
   484                                  ;
   485                                  fn2:
   486 00000158 B80480                          mov     ax,8004h        ; RAM_bits
   487 0000015B E8(0000)                        call    rtc_get_loc
   488 0000015E 88C2                            mov     dl,al
   489 00000160 80E201                          and     dl,1            ; RAM_bits_DST flag
   490                                  
   491                                  .2:
   492 00000163 B80000                          mov     ax,0
   493 00000166 E8(0000)                        call    rtc_get_loc
   494 00000169 88C6                            mov     dh,al           ; seconds
   495                                  
   496 0000016B B80200                          mov     ax,2            ; hours (AH=0)
   497 0000016E E8(0000)                        call    rtc_get_loc
   498 00000171 88C5                            mov     ch,al
   499                                  
   500 00000173 B80100                          mov     ax,1
   501 00000176 E8(0000)                        call    rtc_get_loc
   502 00000179 88C1                            mov     cl,al           ; minutes
   503                                  
   504 0000017B B80000                          mov     ax,0            ; seconds again
   505 0000017E E8(0000)                        call    rtc_get_loc
   506 00000181 38C6                            cmp     dh,al
   507 00000183 75DE                            jne     .2
   508                                  
   509 00000185 80E67F                          and     dh,7Fh          ; clear the ClockHalt flag
   510                                  
   511 00000188 A880                            test    al,80h          ; test the ClockHalt flag
   512 0000018A 7503E965FF                      jz      good_exit
   513 0000018F E95CFF                          jmp     set_carry
   514                                  
   515                                  
   516                                  
   517                                  
   518                                  ;
   519                                  ; Set Time into the CMOS clock
   520                                  ;   enter with:
   521                                  ;       CH = hours in BCD
   522                                  ;       CL = minutes in BCD
   523                                  ;       DH = seconds in BCD
   524                                  ;       DL = DST flag (0=std time, 1=daylight time)
   525                                  ;
   526                                  fn3:
   527 00000192 5251                            pushm   cx,dx
   528 00000194 E88AFF                          call    write_enable
   529                                  
   530 00000197 88D3                            mov     bl,dl           ; BL = DST flag
   531 00000199 B280                            mov     dl,80h          ; Clock Halt flag
   532 0000019B B80000                          mov     ax,0
   533 0000019E E8(0000)                        call    rtc_set_loc     ; stop the clock
   534 000001A1 B80100                          mov     ax,1
   535 000001A4 88CA                            mov     dl,cl           ; minutes to DL
   536 000001A6 E8(0000)                        call    rtc_set_loc
   537 000001A9 B80200                          mov     ax,2
   538 000001AC 88EA                            mov     dl,ch           ; hours to DL
   539 000001AE E8(0000)                        call    rtc_set_loc
   540 000001B1 B80000                          mov     ax,0
   541 000001B4 88F2                            mov     dl,dh           ; start the clock
   542 000001B6 E8(0000)                        call    rtc_set_loc
   543                                  
   544                                         
   545 000001B9 B80480                          mov     ax,8000h | RAM_bits        ; RAM_bits location (4)
   546 000001BC E8(0000)                        call    rtc_get_loc
   547 000001BF 24FE                            and     al,0FFh^RAM_bits_DST         ; RAM_bits_DST zeroed
   548 000001C1 88DA                            mov     dl,bl           ; DST code to DL
   549 000001C3 80E201                          and     dl,RAM_bits_DST ; mask to 1 bit
   550 000001C6 08C2                            or      dl,al           ; preserve the other bits
   551                                  
   552 000001C8 B004                            mov     al,RAM_bits     ; DST flag is updated
   553                                                                  ;   and the other flags are preserved
   554 000001CA E831FF                          call    updateCMOS      ; update loc. 4 & checksum
   555                                  
   556 000001CD E85EFF                          call    write_protect
   557 000001D0 595A                            popm    cx,dx
   558                                  good_exit2:
   559 000001D2 E91FFF                          jmp     good_exit
   560                                  
   561                                  
   562                                  
   563                                  ;
   564                                  ; Get Date
   565                                  ;   return with:
   566                                  ;       CH = century in BCD (19h or 20h)
   567                                  ;       CL = year in BCD
   568                                  ;       DH = month in BCD
   569                                  ;       DL = day in BCD
   570                                  ;
   571                                  ;       Carry clear if clock is running, set if clock is stopped
   572                                  ;
   573                                  fn4:
   574 000001D5 B80180                          mov     ax,8001h        ; century byte
   575 000001D8 E8(0000)                        call    rtc_get_loc
   576 000001DB 88C5                            mov     ch,al
   577                                  
   578 000001DD B80600                          mov     ax,6            ; year
   579 000001E0 E8(0000)                        call    rtc_get_loc
   580 000001E3 88C1                            mov     cl,al
   581                                  
   582 000001E5 B80400                          mov     ax,4            ; month
   583 000001E8 E8(0000)                        call    rtc_get_loc
   584 000001EB 88C6                            mov     dh,al
   585                                  
   586 000001ED B80300                          mov     ax,3            ; day (date)
   587 000001F0 E8(0000)                        call    rtc_get_loc
   588 000001F3 88C2                            mov     dl,al
   589                                  
   590 000001F5 B80000                          mov     ax,0
   591 000001F8 E8(0000)                        call    rtc_get_loc
   592 000001FB A880                            test    al,80h
   593 000001FD 74D3                            jz      good_exit2
   594 000001FF E9ECFE                          jmp     set_carry
   595                                  
   596                                  
   597                                  
   598                                  
   599                                  ;
   600                                  ; Set Date in the CMOS clock chip
   601                                  ;   enter with:
   602                                  ;       CH = century in BCD
   603                                  ;       CL = year in BCD
   604                                  ;       DH = month in BCD
   605                                  ;       DL = day in BCD
   606                                  ;
   607                                  fn5:
   608 00000202 5251                            pushm   cx,dx
   609 00000204 E81AFF                          call    write_enable
   610                                  
   611 00000207 B80300                          mov     ax,3            ; day
   612 0000020A E8(0000)                        call    rtc_set_loc
   613                                  
   614 0000020D 88F2                            mov     dl,dh
   615 0000020F B80400                          mov     ax,4            ; month
   616 00000212 E8(0000)                        call    rtc_set_loc
   617                                  
   618 00000215 88CA                            mov     dl,cl
   619 00000217 B80600                          mov     ax,6            ; year
   620 0000021A E8(0000)                        call    rtc_set_loc
   621                                  
   622 0000021D 88EA                            mov     dl,ch           ; century
   623 0000021F B001                            mov     al,1
   624 00000221 E8DAFE                          call    updateCMOS      ; fix checksum, too
   625                                  
   626 00000224 E807FF                          call    write_protect
   627 00000227 595A                            popm    cx,dx
   628 00000229 E9C8FE                          jmp     good_exit
