     1                                  ;========================================================================
     2                                  ; emm4mem.asm
     3                                  ;
     4                                  ;  LIM EMS 3.2 driver for the N8VEM 4MEM board used with the SBC-188
     5                                  ;
     6                                  ; This program is free software: you can redistribute it and/or modify
     7                                  ; it under the terms of the GNU General Public License as published by
     8                                  ; the Free Software Foundation, either version 3 of the License, or
     9                                  ; (at your option) any later version.
    10                                  ;
    11                                  ; This program is distributed in the hope that it will be useful,
    12                                  ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    13                                  ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    14                                  ; GNU General Public License for more details.
    15                                  ;
    16                                  ; You should have received a copy of the GNU General Public License
    17                                  ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    18                                  ;
    19                                  ;========================================================================
    20                                  ;
    21                                  %define MAJOR_VERSION 2
    22                                  %define MINOR_VERSION 0
    23                                  %define VERSION_SUFFIX ""
    24                                  %define DATE "30-Jan-2013"
    25                                  ;
    26                                  ;
    27                                  %ifndef SOFT_DEBUG
    28                                  %define SOFT_DEBUG 0
    29                                  %endif
    30                                  %ifndef TRACE
    31                                  %define TRACE 0
    32                                  %endif
    33                                  %include "config.asm"
    34                              <1> ;/*
    35                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    36                              <1> ; ANSI.CFG
    37                              <1> ;   Copied to CONFIG.ASM for general release.
    38                              <1> ;
    39                              <1> ;       Modify the parameters below to reflect your system
    40                              <1> ;
    41                              <1> ;
    42                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    43                              <1> ;
    44                              <1> ;   Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    45                              <1> ;   Provided for hobbyist use on the N8VEM SBC-188 board.
    46                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    47                              <1> ;
    48                              <1> ; Define the serial terminal that the Video BIOS must emulate
    49                              <1> ; Set one of the following to 1
    50                              <1> ; If you have no idea what to choose, set TTY to 1
    51                              <1> TTY     equ     0       ; hardcopy -- cannot position the cursor
    52                              <1> DUMB    equ     0       ; dumb CRT -- ^H, ^J, ^K, ^L can move the cursor
    53                              <1> ANSI    equ     1       ; very smart, like a VT-100
    54                              <1> WYSE    equ     0       ; very smart Wyse series (30, 50, ...)
    55                              <1> ; others may get added in the future
    56                              <1> ;  ONE OF THE ABOVE must BE SET TO 1!!!!!
    57                              <1> ;
    58                              <1> ; Does the hardware configuration contain the Color Video Display Unit?
    59                              <1> ; Both the 8563 and the 8242 are used.  The default is CVDU=0
    60                              <1> CVDU	equ	0	; system does not have the CVDU
    61                              <1> ;
    62                              <1> ; Does the hardware configuration contain the VGA3 a/n Video card?
    63                              <1> ; The 8563 will be disabled, but the 8242 code is shared with the CVDU
    64                              <1> ; The default is VGA3=0
    65                              <1> VGA3    equ     0       ; system does not have the VGA3
    66                              <1> %if 0
    67                              <1> 	*/
    68                              <1> #define VGA3 0
    69                              <1> /*
    70                              <1> %endif
    71                              <1> ;
    72                              <1> ; Boot up keyboard mode:  20h for NumLock on
    73                              <1> ;CVDU_KEYBOARD_STATUS	equ	0	; NumLock OFF
    74                              <1> CVDU_KEYBOARD_STATUS	equ	20h	; NumLock ON
    75                              <1> 
    76                              <1> ; Define the UART startup bit rate - 1200-19200 are most common
    77                              <1> ;UART_RATE	equ	0		; 1200
    78                              <1> ;UART_RATE	equ	1		; 2400
    79                              <1> ;UART_RATE	equ	2		; 4800
    80                              <1> UART_RATE	equ	3		; 9600
    81                              <1> ;UART_RATE	equ	4		; 19200
    82                              <1> ;UART_RATE	equ	5		; 38400
    83                              <1> ;UART_RATE	equ	6		; 57600
    84                              <1> ;UART_RATE	equ	7		; 115200
    85                              <1> 
    86                              <1> ; Does the serial terminal use the DSR/DTR protocol for flow control?
    87                              <1> ;UART_DSR_PROTOCOL	equ		1	; Yes!
    88                              <1> UART_DSR_PROTOCOL       equ             WYSE    ; Wyse always uses it
    89                              <1> 						; but not ANSI
    90                              <1> ; Define the size of the ROM image on the system in Kilobytes
    91                              <1> ; It may be smaller than the actual EPROM in use.
    92                              <1> ; The following sizes are supported:  32, 64, 128, and 256
    93                              <1> %ifndef ROM
    94                              <1> ROM             equ     32              ; 64 is the default
    95                              <1> %endif
    96                              <1> 
    97                              <1> ; Define the number of Wait States at which the ROM operates
    98                              <1> ROM_WS          equ     1               ; 0..3  (1 is the default)
    99                              <1> 
   100                              <1> ; Define the size in Kilobytes of DOS RAM (low SRAM plus EMM allocate RAM)
   101                              <1> ; This is a desired size and will only be present if a 4MEM board is added
   102                              <1> RAM_DOS         equ     640
   103                              <1> 
   104                              <1> ; Define the size of the low SRAM on the system in Kilobytes
   105                              <1> ; the default is 512 kilobytes
   106                              <1> RAM             equ     512             ; (512 is the default)
   107                              <1> 
   108                              <1> ; Define the number of Wait States at which the RAM operates
   109                              <1> RAM_WS          equ     0               ; 0..3  (0 is the default)
   110                              <1> 
   111                              <1> ; Define the number of Wait States for Local Peripheral devices (600-7FF)
   112                              <1> LCL_IO_WS       equ     1               ; 0..3  (1 is the default)
   113                              <1> 
   114                              <1> ; Define the number of Wait States for ECB BUS peripheral devices (4xx)
   115                              <1> BUS_IO_WS       equ     3               ; 0..3  (3 is the default)
   116                              <1> 
   117                              <1> ; Define the time zone in which we build the Relocatable BIOS
   118                              <1> %ifndef TIMEZONE
   119                              <1> %define TIMEZONE "CST"
   120                              <1> %endif
   121                              <1> 
   122                              <1> ; Has the REDBUG debugger been loaded?
   123                              <1> %ifndef SOFT_DEBUG
   124                              <1> %define SOFT_DEBUG 0
   125                              <1> %endif
   126                              <1> 
   127                              <1> ; Should the BIOS include "Tiny BASIC" in the image?
   128                              <1> %ifndef TBASIC
   129                              <1> TBASIC          equ     1		; default is 1
   130                              <1> %endif
   131                              <1> 
   132                              <1> ; Should the BIOS include the Floating Point Emulator?  The 80188 does
   133                              <1> ; not allow a floating point co-processor, so this is probably a good idea.
   134                              <1> %ifndef FPEM
   135                              <1> FPEM            equ     1               ; default is 1
   136                              <1> %endif
   137                              <1> 
   138                              <1> ; Define the maximum number of EMM (4MEM) boards supported
   139                              <1> EMM_BOARDS      equ     0
   140                              <1> 
   141                              <1> ; Should the Floating Point Emulator use temporary storage in the EBDA
   142                              <1> ; or at locations 0280h..3FFh in low memory?
   143                              <1> %if SOFT_DEBUG
   144                              <1> FPEM_USE_EBDA   equ     FPEM            ; default is 0
   145                              <1> %else
   146                              <1> FPEM_USE_EBDA   equ     0; FPEM            ; default is 0
   147                              <1> %endif
   148                              <1> 
   149                              <1> ; Define the size of the EPROM that is to be installed on the system
   150                              <1> ; It may be larger than the actual ROM image to be generated.
   151                              <1> %ifndef CHIP
   152                              <1> CHIP            equ     64
   153                              <1> %endif
   154                              <1> 
   155                              <1> ; Does the SBC-188 00.4 board have the LS138/LS08 piggyback fix
   156                              <1> ; Set to 1 for the SBC-188 v1.0 and later production boards
   157                              <1> ;FDC_PIGGYBACK_FIX       equ     0       ; Fix not installed
   158                              <1> FDC_PIGGYBACK_FIX       equ     1       ; fix  IS  installed
   159                              <1> 
   160                              <1> ; On SBC-188 rev 00.4 board, there is a published hardware fix (2010-09-18).
   161                              <1> ; If the wiring update is installed, or you have a later board, then
   162                              <1> ; set this to 0.  If you are using the software workaround, then set this
   163                              <1> ; to 1.  The rev 1.0 board has this fix already.
   164                              <1> NEED_TIMER_FIX  equ     0               ; have revised hardware
   165                              <1> ;NEED_TIMER_FIX  equ     1               ; use workaround
   166                              <1> 
   167                              <1> ; Define the UART oscillator speed
   168                              <1> UART_OSC        equ     1843200         ; 1.8432 Mhz is specified
   169                              <1> 
   170                              <1> 
   171                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   172                              <1> ; end of the User configuration
   173                              <1> ;       Do Not modify anything below this point
   174                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   175                              <1> 
   176                              <1> CVDU_8563	equ	CVDU		; separate inits
   177                              <1> CVDU_8242	equ	CVDU|VGA3 	; separate inits
   178                              <1> VGA3_6445       equ     VGA3            ; separate inits
   179                              <1> ; Suppress all UART output in color video Mode 3
   180                              <1> UART_MODE3_SUPPRESS	equ	CVDU_8563
   181                              <1> CVDU_USE_MSDOS_KLUDGE	equ	0; CVDU_8242	; bad, bad MSDOS
   182                              <1> CVDU_USE_KBD_HOOK		equ	CVDU_8242
   183                              <1> 
   184                              <1> ; Define existence of any uart chip
   185                              <1> UART		equ	TTY+DUMB+ANSI+WYSE
   186                              <1> startuplength   equ     512                     ; may be up to 1024
   187                              <1> startseg        equ     0FFFFh - (ROM*64) + 1
   188                              <1> highrom         equ     (ROM*400h)&0FFFFh
   189                              <1> startupseg      equ     0FFFFh - (startuplength>>4) + 1
   190                              <1> bios_data_seg   equ     040h            ; segment of BIOS data area
   191                              <1> 
   192                              <1> 
   193                              <1> %define ARG(n) [bp+2+(n)*2]
   194                              <1> 
   195                              <1> %macro  check   1.nolist
   196                              <1>  %if (%1)
   197                              <1>    %error Check Failure: %1
   198                              <1>  %endif
   199                              <1> %endm
   200                              <1> %macro  range   3.nolist
   201                              <1>  %if (%1)<(%2)
   202                              <1>    %error Out of Range: %1
   203                              <1>  %elif (%1)>(%3)
   204                              <1>    %error Out of Range: %1
   205                              <1>  %endif
   206                              <1> %endm
   207                              <1> _terminal equ UART+CVDU
   208                              <1>  check   RAM_DOS&15
   209                              <1>  check   RAM&(RAM-1)
   210                              <1>  check   ROM&(ROM-1)
   211                              <1>  range   RAM,32,512
   212                              <1>  range   ROM,32,256
   213                              <1>  range   RAM_WS,0,3
   214                              <1>  range   ROM_WS,0,3
   215                              <1>  range   RAM_DOS,RAM,(1024-ROM)
   216                              <1>  range   LCL_IO_WS,0,3
   217                              <1>  range   BUS_IO_WS,0,3
   218                              <1>  range   UART_OSC,500000,16000000
   219                              <1>  range   UART_RATE,0,7
   220                              <1>  range	 UART,0,1
   221                              <1>  range	 _terminal,1,2
   222                              <1> 
   223                              <1> %ifndef SOFT_DEBUG
   224                              <1> %define SOFT_DEBUG 0
   225                              <1> %endif
   226                              <1> 
   227                              <1> %ifndef TRACE
   228                              <1> %define TRACE 0
   229                              <1> %endif
   230                              <1> 
   231                              <1> %ifdef MAKE_OBJECT_FILE
   232                              <1>         segment _DATA WORD PUBLIC CLASS=DATA
   233                              <1>         export _ROMsize
   234                              <1>         export _CHIPsize
   235                              <1> _ROMsize        dw      ROM
   236                              <1> _CHIPsize       dw      CHIP
   237                              <1> %endif
   238                              <1> ; end of the Hardware configuration file
   239                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   240                              <1> ;*/
    34                                  %include "cpuregs.asm"
    35                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    36                              <1> ; CPUREGS.ASM
    37                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    38                              <1> ;
    39                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    40                              <1> ;
    41                              <1> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    42                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    43                              <1> ;
    44                              <1> ; This program is free software: you can redistribute it and/or modify
    45                              <1> ; it under the terms of the GNU General Public License as published by
    46                              <1> ; the Free Software Foundation, either version 3 of the License, or
    47                              <1> ; (at your option) any later version.
    48                              <1> ;
    49                              <1> ; This program is distributed in the hope that it will be useful,
    50                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    51                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    52                              <1> ; GNU General Public License for more details.
    53                              <1> ;
    54                              <1> ; You should have received a copy of the GNU General Public License
    55                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    56                              <1> ;
    57                              <1> ; Updated for the Duodyne 80c188 SBC
    58                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    59                              <1> %include	"macros.inc"
    60                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    61                              <2> ; MACROS.INC  
    62                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    63                              <2> ;
    64                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    65                              <2> ;
    66                              <2> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    67                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    68                              <2> ;
    69                              <2> ; This program is free software: you can redistribute it and/or modify
    70                              <2> ; it under the terms of the GNU General Public License as published by
    71                              <2> ; the Free Software Foundation, either version 3 of the License, or
    72                              <2> ; (at your option) any later version.
    73                              <2> ;
    74                              <2> ; This program is distributed in the hope that it will be useful,
    75                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    76                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    77                              <2> ; GNU General Public License for more details.
    78                              <2> ;
    79                              <2> ; You should have received a copy of the GNU General Public License
    80                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    81                              <2> ;
    82                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    83                              <2> 
    84                              <2> ; general macros for the SBC188 BIOS ASSEMBLY
    85                              <2> ;
    86                              <2> ;
    87                              <2> %ifndef __MACROS_DEFINED_
    88                              <2> %define __MACROS_DEFINED_ 1
    89                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    90                              <2> ;
    91                              <2> ; some useful macros:
    92                              <2> ;
    93                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    94                              <2> ;
    95                              <2> 	cpu	186
    96                              <2> 
    97                              <2> %imacro setloc  1.nolist
    98                              <2>  times   (%1-($-$$)) db 0FFh
    99                              <2> %endm
   100                              <2> 
   101                              <2> %imacro db_lo   1
   102                              <2>  db (%1)&255
   103                              <2> %endm
   104                              <2> 
   105                              <2> %imacro cnop    0.nolist
   106                              <2> %if SOFT_DEBUG
   107                              <2>         nop
   108                              <2> %endif
   109                              <2> %endm
   110                              <2> 
   111                              <2> %imacro popm 1-*.nolist
   112                              <2> %rep %0
   113                              <2> %ifidni %1,ALL
   114                              <2>  popa
   115                              <2> %elifidni %1,F
   116                              <2>  popf
   117                              <2> %else
   118                              <2>  pop %1
   119                              <2> %ifidni %1,DS
   120                              <2>  cnop
   121                              <2> %elifidni %1,ES
   122                              <2>  cnop
   123                              <2> %endif
   124                              <2> %endif
   125                              <2> %rotate 1
   126                              <2> %endrep
   127                              <2> %endm
   128                              <2> 
   129                              <2> %imacro pushm 1-*.nolist
   130                              <2> %rep %0
   131                              <2> %rotate -1
   132                              <2> %ifidni %1,ALL
   133                              <2>  pusha
   134                              <2> %elifidni %1,F
   135                              <2>  pushf
   136                              <2> %else
   137                              <2>  push %1
   138                              <2> %endif
   139                              <2> %endrep
   140                              <2> %endm
   141                              <2> 
   142                              <2> ;
   143                              <2> ; added from the 386EX project
   144                              <2> ;
   145                              <2> 
   146                              <2> ; call arguments
   147                              <2> %define ARG(n) [bp+2+(n)*2]
   148                              <2> 
   149                              <2> ;
   150                              <2> ; format of the BYTE initialization table:  address, byte
   151                              <2> ;
   152                              <2> %imacro  binit 2
   153                              <2>         dw      %1
   154                              <2>         db      %2
   155                              <2> %endmacro
   156                              <2> ; end with DW -1
   157                              <2> 
   158                              <2> ;
   159                              <2> ; format of the WORD initialization table:  address, word
   160                              <2> ;
   161                              <2> %imacro  winit 2
   162                              <2>         dw      %1
   163                              <2>         dw      %2
   164                              <2> %endmacro
   165                              <2> ; end with DW -1
   166                              <2> 
   167                              <2> 
   168                              <2> ; get the BIOS Data Area segment pointer to a [segment] register
   169                              <2> %imacro get_bda	1.nolist
   170                              <2> 	push	0x0040
   171                              <2> 	pop	%1
   172                              <2> 	cnop
   173                              <2> %endm
   174                              <2> 
   175                              <2> 
   176                              <2> %endif
    60                              <1> 
    61                              <1> 	cpu     186
    62                              <1> ;
    63                              <1> ;
    64                              <1> ; IBM model byte -- must be less than a 286
    65                              <1> ;
    66                              <1> ;MODEL_BYTE		equ	0FEh	; PC-XT
    67                              <1> ;SUBMODEL_BYTE		equ	0FFh	; not used
    68                              <1> 
    69                              <1> MODEL_BYTE		equ	0FEh	; PC-XT
    70                              <1> SUBMODEL_BYTE		equ	00h	;  "
    71                              <1> 
    72                              <1> 
    73                              <1> ; 80188 peripheral control register block address
    74                              <1> CPU_CSCR	        equ	0FF00h
    75                              <1> 
    76                              <1> ; Compatible Mode registers
    77                              <1> 
    78                              <1> cpu_relocation          equ     CPU_CSCR+0FEh
    79                              <1> 
    80                              <1> ; The memory and peripheral chip select register offsets from 0FF00h
    81                              <1> 
    82                              <1> cpu_umcs                equ     CPU_CSCR+0A0h          ; Upper memory select
    83                              <1> cpu_lmcs                equ     CPU_CSCR+0A2h          ; Lower memory select
    84                              <1> cpu_pacs                equ     CPU_CSCR+0A4h          ; Peripheral select
    85                              <1> cpu_mmcs                equ     CPU_CSCR+0A6h          ; Middle memory base
    86                              <1> cpu_mpcs                equ     CPU_CSCR+0A8h          ; Mid mem. & peripherals
    87                              <1> 
    88                              <1> ; Enhanced Mode registers
    89                              <1> 
    90                              <1> cpu_mdram               equ     CPU_CSCR+0E0h          ; memory partition reg.
    91                              <1> cpu_cdram               equ     CPU_CSCR+0E2h          ; clock prescaler
    92                              <1> cpu_edram               equ     CPU_CSCR+0E4h          ; Enable refresh reg.
    93                              <1> cpu_pdcon               equ     CPU_CSCR+0F0h          ; Power-Save control
    94                              <1> 
    95                              <1> 
    96                              <1> ; On-board internal peripheral equates
    97                              <1> ; Programmable Interrupt Controller
    98                              <1> PIC	        equ	CPU_CSCR+020H
    99                              <1> PIC_EOI	        equ	PIC+2           ; End Of Interrupt
   100                              <1> PIC_POLLR	equ	PIC+4
   101                              <1> PIC_POLLSR	equ	PIC+6
   102                              <1> PIC_IMASK	equ	PIC+8
   103                              <1> PIC_PMREG	equ	PIC+0AH
   104                              <1> PIC_SRVR	equ	PIC+0CH
   105                              <1> PIC_IRQR	equ	PIC+0EH
   106                              <1> PIC_IRQSR	equ	PIC+10H
   107                              <1> PIC_TCR	        equ	PIC+12H
   108                              <1> PIC_DMA0CR	equ	PIC+14H
   109                              <1> PIC_DMA1CR	equ	PIC+16H
   110                              <1> PIC_I0CON	equ	PIC+18H
   111                              <1> PIC_I1CON	equ	PIC+1AH
   112                              <1> PIC_I2CON	equ	PIC+1CH
   113                              <1> PIC_I3CON	equ	PIC+1EH
   114                              <1> 
   115                              <1> EOI_NSPEC       equ     8000h           ; Non-Specific EOI
   116                              <1> 
   117                              <1> ; Interrupt masks (Master Mode)
   118                              <1> ;
   119                              <1> mask_timer_all          equ     0001h
   120                              <1> mask_dma0               equ     0004h
   121                              <1> mask_dma1               equ     0008h
   122                              <1> mask_int0               equ     0010h
   123                              <1> mask_int1               equ     0020h
   124                              <1> mask_int2               equ     0040h
   125                              <1> mask_int3               equ     0080h
   126                              <1> 
   127                              <1> 
   128                              <1> 
   129                              <1> ; Timers
   130                              <1> TIM0	        equ	CPU_CSCR+050H
   131                              <1> TIM1	        equ	CPU_CSCR+058H
   132                              <1> TIM2	        equ	CPU_CSCR+060H
   133                              <1> 
   134                              <1> TCNT	        equ	0	; count register
   135                              <1> CMPA	        equ	2	; max count A
   136                              <1> CMPB	        equ	4	; max count B (not present on TIM2)
   137                              <1> TCON	        equ	6	; mode/control word
   138                              <1> 
   139                              <1> ; Timer control bits:
   140                              <1> tc_EN           equ     8000h   ; Enable bit
   141                              <1> tc_nINH         equ     4000h   ; not Inhibit Enable
   142                              <1> tc_INT          equ     2000h   ; Interrupt Enable
   143                              <1> tc_RIU          equ     1000h   ; Register A/B (0/1) in Use
   144                              <1> tc_MC           equ     0020h   ; Maximum Count reached
   145                              <1> tc_RTG          equ     0010h   ; Retrigger (internal source)
   146                              <1> tc_P            equ     0008h   ; Prescale internal clock (timers 0 & 1 only)
   147                              <1> tc_EXT          equ     0004h   ; External clock
   148                              <1> tc_ALT          equ     0002h   ; Alternate between A & B max count registers
   149                              <1> tc_CONT         equ     0001h   ; Continuous: continue after max count
   150                              <1> 
   151                              <1> 
   152                              <1> 
   153                              <1> 
   154                              <1> ; DMA
   155                              <1> DMA0	        equ	CPU_CSCR+0C0H
   156                              <1> DMA1	        equ	CPU_CSCR+0D0H
   157                              <1> DMASPL	        equ	0	; source pointer low
   158                              <1> DMASPU	        equ	2	; source pointer high
   159                              <1> DMADPL	        equ	4	; destination pointer low
   160                              <1> DMADPU	        equ	6	; destination pointer high
   161                              <1> DMATC	        equ	8	; terminal count
   162                              <1> DMACW	        equ	0AH	; control word
   163                              <1> 
   164                              <1> 
   165                              <1> 
   166                              <1> 
   167                              <1> 
   168                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   169                              <1> ;
   170                              <1> ;       SBC-188 external devices
   171                              <1> ;
   172                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   173                              <1> 
   174                              <1> IO_BASE			equ	0400h
   175                              <1> 
   176                              <1> 
   177                              <1> 
   178                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   179                              <1> ; The UART registers (Duodyne SBC 80c188 Console port)
   180                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   181                              <1> 
   182                              <1> uart_base               equ     IO_BASE+0280h
   183                              <1> uart_rbr                equ     uart_base       ;Rcvr Buffer / read only
   184                              <1> uart_thr                equ     uart_base       ;Transmit Holding / write only
   185                              <1> uart_ier                equ     uart_base+1     ;Interrupt Enable
   186                              <1> uart_iir                equ     uart_base+2     ;Interrupt Ident / read only
   187                              <1> uart_fcr                equ     uart_base+2     ;FIFO Control / write only
   188                              <1> uart_lcr                equ     uart_base+3     ;Line Control
   189                              <1> uart_mcr                equ     uart_base+4     ;Modem Control
   190                              <1> uart_lsr                equ     uart_base+5     ;Line Status
   191                              <1> uart_msr                equ     uart_base+6     ;Modem Status
   192                              <1> uart_sr			equ	uart_base+7	;Scratch
   193                              <1> 
   194                              <1> uart_dll                equ     uart_base       ;Divisor Latch LS Byte
   195                              <1> uart_dlm                equ     uart_base+1     ;Divisor Latch MS Byte
   196                              <1> 
   197                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   198                              <1> ; CONTROL LS259 PORT  (DuoDyne 80C188)
   199                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   200                              <1> CTRL259		equ	IO_BASE+0238H
   201                              <1> ; LEDS are at addresses 0..3
   202                              <1> ; other control ports on 4..7
   203                              <1> LED0		equ	CTRL259+0
   204                              <1> LED1		equ	LED0+1
   205                              <1> LED2		equ	LED0+2
   206                              <1> LED3		equ	LED0+3
   207                              <1> T1OSC18		equ	CTRL259+4	; ON=1.8432mhz, OFF="1" (for use of TIMER2)
   208                              <1> ;unused		equ	CTRL259+5
   209                              <1> ;unused		equ	CTRL259+6
   210                              <1> ;unused		equ	CTRL259+7
   211                              <1> 
   212                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   213                              <1> ; Front Panel Connector  (DuoDyne 80C188)
   214                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   215                              <1> FRONT_PANEL_LED	equ	IO_BASE+0230H
   216                              <1> 
   217                              <1> 
   218                              <1> 
   219                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   220                              <1> ; Floppy controller (Duodyne Disk IO)
   221                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   222                              <1> FDC	        equ	IO_BASE+0200H
   223                              <1> FDC_MSR         equ     FDC
   224                              <1> FDC_DATA        equ     FDC_MSR+1
   225                              <1> FDC_DACK        equ	FDC+10H
   226                              <1> FDC_LDOR	equ	FDC+20H
   227                              <1> FDC_LDCR	equ	FDC+30H
   228                              <1> FDC_TC	        equ	FDC+40H
   229                              <1> FDC_RES	        equ	FDC+40H
   230                              <1> FDC_DACK_TC     equ     FDC_DACK | FDC_TC
   231                              <1> 
   232                              <1> 
   233                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   234                              <1> ;DS1302 RTC (Duodyne Ram/ROM Card)
   235                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   236                              <1> RTC	equ	IO_BASE+0094H
   237                              <1> 
   238                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   239                              <1> ; PIO 82C55 I/O  (Duodyne Disk IO)
   240                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   241                              <1> PPI	        equ	IO_BASE+0088H
   242                              <1> 
   243                              <1> PIO_A	        equ	PPI+0	; (OUTPUT)
   244                              <1> PIO_B	        equ	PPI+1	; (INPUT)
   245                              <1> PIO_C	        equ	PPI+2	; (CENTRONICS control low nibble)
   246                              <1> PIO_CTRL	equ	PPI+3	; CONTROL BYTE PIO 82C55
   247                              <1> 
   248                              <1> portA           equ     PPI+0   ;
   249                              <1> portB           equ     PPI+1   ;
   250                              <1> portC           equ     PPI+2   ;
   251                              <1> 
   252                              <1> ; end CPUREGS.ASM
    35                                  
    36                                  FRAME0          equ     (0F000h - (ROM<<6))          ; default Frame segment
    37                                  NUM_HANDLES     equ     16      ; number of Handles
    38                                  HANDLE_BASE     equ     3456h   ; base handle #
    39                                  NUM_MAP_BLKS    equ     32      ; number of memory manager blocks
    40                                  
    41                                  
    42                                  ;
    43                                  ;
    44                                  ; The request block structure
    45                                                  struc   rq_block
    46 00000000 ??                      rq_length       resb    1       ; length of request block
    47 00000001 ??                      rq_unit         resb    1       ; unit number (block devices)
    48 00000002 ??                      rq_command      resb    1       ; command code
    49 00000003 ????                    rq_status       resw    1       ; return status
    50 00000005 ????????????????        rq_reserved05   resb    8       ; reserved for DOS
    51 0000000D ??                      rq_ret_units    resb    1       ; number of units (returned)
    52 0000000E ????????                rq_ret_freemem  resd    1       ; seg:offset of top of free memory
    53 00000012 ????????                rq_config_sys   resd    1       ; seg:offset of CONFIG.SYS
    54                                  rq_ret_BPB      equ     rq_config_sys
    55 00000016 ??                      rq_first_unit   resb    1       ; first unit number
    56 00000017 <res 9h>                rq_reserved17   resb    9       ; fill to 32 bytes
    57                                                  endstruc
    58                                  
    59                                  
    60                                  ; The EMM map structure
    61                                                  struc   emm_map
    62 00000000 ??                      map_count       resb    1       ; count of contiguous blocks
    63 00000001 ??                      map_start       resb    1       ; block number of first block
    64 00000002 ????                    map_link        resw    1       ; index of next block in chain (FFFF=end)
    65                                  map_board       equ     map_link+1      ; high 4 bits contain board #
    66                                  map_length      equ     $
    67                                                  endstruc
    68                                  
    69                                  
    70                                  
    71                                  DONE    equ     0100h           ; DONE bit
    72                                  CR      equ     0Dh
    73                                  LF      equ     0Ah
    74                                  NUL     equ     00h
    75                                  
    76                                  
    77                                  ; Standard int 13h stack frame layout is 
    78                                  ; created by:   PUSHM  ALL,DS,ES
    79                                  ;               MOV    BP,SP
    80                                  ;
    81                                  offset_DI       equ     0
    82                                  offset_SI       equ     offset_DI+2
    83                                  offset_BP       equ     offset_SI+2
    84                                  offset_SP       equ     offset_BP+2
    85                                  offset_BX       equ     offset_SP+2
    86                                  offset_DX       equ     offset_BX+2
    87                                  offset_CX       equ     offset_DX+2
    88                                  offset_AX       equ     offset_CX+2
    89                                  offset_DS       equ     offset_AX+2
    90                                  offset_ES       equ     offset_DS+2
    91                                  offset_IP       equ     offset_ES+2
    92                                  offset_CS       equ     offset_IP+2
    93                                  offset_FLAGS    equ     offset_CS+2
    94                                  
    95                                  ; The byte registers in the stack
    96                                  offset_AL       equ     offset_AX
    97                                  offset_AH       equ     offset_AX+1
    98                                  offset_BL       equ     offset_BX
    99                                  offset_BH       equ     offset_BX+1
   100                                  offset_CL       equ     offset_CX
   101                                  offset_CH       equ     offset_CX+1
   102                                  offset_DL       equ     offset_DX
   103                                  offset_DH       equ     offset_DX+1
   104                                  
   105                                  
   106                                  ; EMS int 67h error codes
   107                                  ;
   108                                  FN_GOOD         equ     0
   109                                  
   110                                  FN_INTERNAL_ERR equ     80h     ; internal software error
   111                                  FN_HARDWARE_ERR equ     81h     ; EMS hardware error
   112                                  FN_INVALID_HANDLE  equ  83h     ; invalid handle
   113                                  FN_UNDEFINED    equ     84h     ; undefined function
   114                                  FN_NO_HANDLE    equ     85h     ; no more handles available
   115                                  FN_SAVE_RESTORE equ     86h     ; error in save or restore of mapping context
   116                                  FN_NO_PHYS_PAGES   equ  87h     ; requested more physical pages than available; none allocated
   117                                  FN_NO_LOG_PAGES equ     88h     ; requested more logical pages than available; none allocated
   118                                  FN_ZERO_REQUEST equ     89h     ; zero pages requested
   119                                  FN_LOG_PAGE_ERR equ     8Ah     ; logical page not assigned to this handle
   120                                  FN_PHYS_PAGE_ERR   equ  8Bh     ; physical page number invalid
   121                                  FN_SAVE_AREA_FULL  equ  8Ch     ; mapping hardware state save area full
   122                                  FN_SAVE_FAILED  equ     8Dh     ; save context failed because context already associated with
   123                                                                  ;  the current handle
   124                                  FN_RESTORE      equ     8Eh     ; restore failed; save area has no context for the handle
   125                                  FN_SUBFN_UNDEF  equ     8Fh     ; sub-function undefined
   126                                  
   127                                  
   128                                  
   129                                  
   130                                  
   131                                  ; beginning of Driver
   132                                  
   133                                  ; The driver Header:
   134 00000000 FFFFFFFF                        dd      -1
   135 00000004 0080                            dw      8000h                   ; flag as character device
   136 00000006 [1204]                          dw      strategy
   137 00000008 [1D04]                          dw      interrupt
   138 0000000A 454D4D5858585830                db      "EMMXXXX0"
   139                                  
   140                                  
   141                                  dispatch:
   142 00000012 [5400]                          dw      fn40    ; Get Manager Status
   143 00000014 [5F00]                          dw      fn41    ; Get Page Frame Segment
   144 00000016 [6800]                          dw      fn42    ; Get Number of Pages
   145 00000018 [7600]                          dw      fn43    ; Get Handle and Allocate Memory
   146 0000001A [2901]                          dw      fn44    ; Map Memory
   147 0000001C [C501]                          dw      fn45    ; Release Handle and Memory
   148 0000001E [1702]                          dw      fn46    ; Get EMM Version
   149 00000020 [1E02]                          dw      fn47    ; Save Mapping Context
   150 00000022 [3502]                          dw      fn48    ; Restore Mapping Context
   151 00000024 [5000]                          dw      fn49    ; reserved -- old get h/w array
   152 00000026 [5000]                          dw      fn4A    ; reserved -- old get log. to phys. array map
   153 00000028 [9102]                          dw      fn4B    ; Get Number of EMS Handles
   154 0000002A [5000]                          dw      fn4C    ; Get Pages Owned by Handle
   155 0000002C [5000]                          dw      fn4D    ; Get Pages for All Handles
   156 0000002E [AB02]                          dw      fn4E    ; Get/Set Page Map
   157                                  
   158                                  ndispatch       equ     ($-dispatch)/2
   159                                  
   160                                  
   161                                  
   162                                  bios_call_67h:
   163                                  ;       sti                     ; interrupts on/off        
   164                                  %if TRACE
   165                                          pushm   all,ds,es
   166                                          mov     al,'c'
   167                                          call    putchar
   168                                          mov     al,ah
   169                                          call    bout
   170                                          popm    all,ds,es
   171                                  %endif
   172 00000030 061E60                          pushm   all,ds,es
   173 00000033 89E5                            mov     bp,sp           ; standard BIOS stack frame
   174 00000035 FC                              cld
   175 00000036 0E                              pushm   cs
   176 00000037 1F                              popm    ds              ; address the Data Base from
   177                                  
   178 00000038 89C6                            mov     si,ax           ; save AX
   179 0000003A 80EC40                          sub     ah,40h          ; base function codes at zero
   180 0000003D 80FC0F                          cmp     ah,ndispatch    ; check for valid code
   181 00000040 730E                            jae     undefined
   182                                  
   183 00000042 88E0                            mov     al,ah           ; zero based index to AL
   184 00000044 98                              cbw                     ; zap high byte
   185 00000045 96                              xchg    si,ax           ; restore AX, SI is index
   186 00000046 01F6                            add     si,si           ; index*2 for word table
   187 00000048 FFA4[1200]                      jmp     [dispatch + si] ; dispatch to function
   188                                  
   189                                  
   190                                  
   191                                  internal_error:
   192 0000004C B480                            mov     ah,FN_INTERNAL_ERR      ; internal software error
   193 0000004E EB06                            jmp     error_exit
   194                                  undefined:
   195 00000050 B484                            mov     ah,FN_UNDEFINED         ; undefined function
   196 00000052 EB02                            jmp     error_exit
   197                                  good_exit:
   198 00000054 30E4                            xor     ah,ah
   199                                  error_exit:
   200 00000056 88660F                          mov     [bp+offset_AH],ah       ; return error code
   201                                  %if TRACE
   202                                          pushm   ax
   203                                          mov     al,ah
   204                                          call    bout
   205                                          mov     al,'r'
   206                                          call    putchar
   207                                          popm    ax
   208                                  %endif
   209 00000059 89EC                            mov     sp,bp                   ; restore SP
   210 0000005B 611F07                          popm    all,ds,es
   211 0000005E CF                              iret
   212                                  
   213                                  
   214                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   215                                  ; function 40h -- Get EMM Manager Status
   216                                  ;
   217                                  ;  Enter With:
   218                                  ;       AH = function code 40h
   219                                  ;
   220                                  ;  Exit With:
   221                                  ;       AH = 0          good return
   222                                  ;;
   223                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   224                                  fn40    equ     good_exit
   225                                  
   226                                  
   227                                  
   228                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   229                                  ; function 41h -- Get Page Frame Segment
   230                                  ;
   231                                  ;  Enter With:
   232                                  ;       AH = function code 41h
   233                                  ;
   234                                  ;  Exit With:
   235                                  ;       AH = 0          good return
   236                                  ;;
   237                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   238                                  fn41:
   239 0000005F 8B1E[D802]                      mov     bx,[frame]
   240 00000063 895E08                          mov     [bp+offset_BX],bx
   241 00000066 EBEC                            jmp     good_exit
   242                                  
   243                                  
   244                                  
   245                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   246                                  ; function 42h -- Get Number of Pages
   247                                  ;
   248                                  ;  Enter With:
   249                                  ;       AH = function code 42h
   250                                  ;
   251                                  ;  Exit With:
   252                                  ;       AH = 0          good return
   253                                  ;       BX = number of unallocated pages
   254                                  ;       DX = total number of pages in system
   255                                  ;
   256                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   257                                  fn42:
   258 00000068 A1[6403]                        mov     ax,[npages]
   259 0000006B 89460A                          mov     [bp+offset_DX],ax
   260 0000006E E8CD03                          call    count_avail
   261 00000071 894608                          mov     [bp+offset_BX],ax
   262 00000074 EBDE                            jmp     good_exit
   263                                  
   264                                  
   265                                  
   266                                  
   267                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   268                                  ; function 43h -- Get Handle and Allocate Memory
   269                                  ;
   270                                  ;  Enter With:
   271                                  ;       AH = function code 43h
   272                                  ;       BX = number of logical pages to allocate
   273                                  ;
   274                                  ;  Exit With:
   275                                  ;       AH = 0          good return
   276                                  ;       DX = handle     
   277                                  ;
   278                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   279                                  fn43:
   280 00000076 3B1E[6403]                      cmp     bx,[npages]     ; check against total pages
   281 0000007A B487                            mov     ah,FN_NO_PHYS_PAGES     ; 
   282 0000007C 77D8                            ja      error_exit      ; RQ more that physically present
   283                                  
   284 0000007E E8BD03                          call    count_avail     ; count pages available
   285 00000081 39D8                            cmp     ax,bx
   286 00000083 B488                            mov     ah,FN_NO_LOG_PAGES
   287 00000085 72CF                            jb      error_exit      ; RQ more that currently available
   288                                          
   289 00000087 09DB                            or      bx,bx
   290 00000089 B489                            mov     ah,FN_ZERO_REQUEST
   291 0000008B 74C9                            jz      error_exit      ; RQ zero pages ????
   292                                  
   293                                  ; find a handle
   294 0000008D B91000                          mov     cx,NUM_HANDLES
   295 00000090 31F6                            xor     si,si
   296                                  .1:
   297 00000092 83BC[6A03]FF            	cmp	word [handle_list + si], -1
   298 00000097 7409                    	je	.2			; available if == -1
   299                                  
   300 00000099 83C602                          add     si,size_handle
   301 0000009C E2F4                            loop    .1
   302                                  ; error, no handles are available
   303 0000009E B485                            mov     ah,FN_NO_HANDLE
   304 000000A0 EBB4                            jmp     error_exit
   305                                  
   306                                  .2: ; found an available handle; index*2 is in SI
   307 000000A2 89F7                            mov     di,si                   ; zap the save area
   308 000000A4 C1E702                          shl     di,2                    ; index*8 is in DI
   309 000000A7 8DBD[9203]                      lea     di,[handle_save_area + di]      ; prepare to zap the save area
   310 000000AB B8FFFF                          mov     ax,-1                   ; empty value for save area
   311 000000AE 1E                              pushm   ds
   312 000000AF 07                              popm    es              ; will use ES:DI for the save area pointer
   313 000000B0 AB                              stosw
   314 000000B1 AB                              stosw                   ; clear 4 words
   315 000000B2 AB                              stosw
   316 000000B3 AB                              stosw
   317                                  
   318                                  ;  index*2 is still in SI
   319 000000B4 89F0                            mov     ax,si                   ; index*2 in AX
   320 000000B6 D1E8                            shr     ax,1                    ; index*1 of handle
   321 000000B8 055634                          add     ax,HANDLE_BASE          ; make the funny Handle
   322 000000BB 89460A                          mov     [bp+offset_DX],ax       ; return handle
   323                                  
   324 000000BE FF0E[6803]                      dec     word [handle_count]     ; count the handle
   325                                  
   326                                      ; allocate any memory loop
   327                                  allocate_more:
   328 000000C2 09DB                            or      bx,bx
   329 000000C4 748E                            jz      good_exit
   330                                  
   331 000000C6 8B3E[DC02]                      mov     di,[map_avail]          ; get index of available memory
   332 000000CA 81E7FF0F                        and     di,0FFFh
   333 000000CE C1E702                          shl     di,2                    ; index*4
   334 000000D1 8A85[DE02]                      mov     al,[map_block_list + di + map_count]
   335 000000D5 30E4                            xor     ah,ah
   336 000000D7 39D8                            cmp     ax,bx                   ; in block :: request remaining
   337 000000D9 7204                            jb      .4
   338 000000DB 89D9                            mov     cx,bx
   339 000000DD EB02                            jmp     .41
   340 000000DF 89C1                    .4:     mov     cx,ax
   341                                  .41:            ;               ; CX is the smaller of the two
   342 000000E1 29CB                            sub     bx,cx		; BX is what remains to be allocated (or 0)
   343 000000E3 29C8                            sub     ax,cx           ; AX is remainder on avail list
   344 000000E5 8AAD[DF02]                      mov     ch,[map_block_list + di + map_start]
   345 000000E9 8B95[E002]                      mov     dx,[map_block_list + di + map_link]
   346 000000ED 741B                            jz      got_it_all
   347                                  ; avail list entry has some memory remaining
   348 000000EF 008D[DF02]                      add     [map_block_list + di + map_start],cl    ; increment start by count
   349 000000F3 8885[DE02]                      mov     [map_block_list + di + map_count],al    ; remaining count
   350                                  ; CH:CL is memory to put on the Handle's chain
   351 000000F7 8BBC[6A03]                      mov     di,[handle_list + si]
   352 000000FB E8A103                          call    add_to_list2     ; DH was set above, CX is good
   353 000000FE 83FFFF                          cmp     di,-1
   354 00000101 7404                            je      .5
   355 00000103 89BC[6A03]                      mov     [handle_list + si],di
   356                                  .5:
   357 00000107 E94AFF                          jmp     good_exit
   358                                  
   359                                  ; all of the memory in the block at the head of the avail list is needed
   360                                  got_it_all:
   361 0000010A 80E60F                          and     dh,0Fh
   362 0000010D 8916[DC02]                      mov     [map_avail],dx          ; new head of the avail list
   363                                  ; DI is index*4 of the allocated memory piece
   364 00000111 8B84[6A03]                      mov     ax,[handle_list + si]
   365 00000115 3385[E002]                      xor     ax,[map_block_list + di + map_link]
   366 00000119 25FF0F                          and     ax,0FFFh
   367 0000011C 3185[E002]                      xor     [map_block_list + di + map_link],ax ; link DI at head of chain
   368 00000120 C1EF02                          shr     di,2
   369 00000123 89BC[6A03]                      mov     [handle_list + si],di
   370 00000127 EB99                            jmp     allocate_more
   371                                  
   372                                  
   373                                  
   374                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   375                                  ; function 44h -- Map Memory
   376                                  ;
   377                                  ;  Enter With:
   378                                  ;       AH = function code 44h
   379                                  ;       AL = physical page [0..3]
   380                                  ;       BX = logical page number:  0...
   381                                  ;       DX = handle
   382                                  ;
   383                                  ;  Exit With:
   384                                  ;       AH = 0          good return
   385                                  ;
   386                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   387                                  fn44:
   388 00000129 B48B                            mov     ah,FN_PHYS_PAGE_ERR
   389 0000012B 3C04                            cmp     al,4
   390 0000012D 7203E924FF                      jae     error_exit
   391                                  
   392 00000132 E84500                          call    unmap           ; use AL as page to unmap
   393                                  
   394 00000135 B483                            mov     ah,FN_INVALID_HANDLE
   395 00000137 81EA5634                        sub     dx,HANDLE_BASE          ; unbias the handle
   396 0000013B 83FA10                          cmp     dx,NUM_HANDLES
   397 0000013E 7203E913FF                      jae     error_exit
   398                                  
   399 00000143 89D6                            mov     si,dx           ; SI is the unbiased handle index
   400 00000145 01F6                            add     si,si           ; 
   401 00000147 8BBC[6A03]                      mov     di,[handle_list + si]   ; get memory chain index
   402                                  
   403                                  .1:                     ; validate that the chain continues
   404 0000014B C1E704                          shl     di,4
   405 0000014E 7903E903FF                      js      error_exit
   406                                  
   407 00000153 B48A                            mov     ah,FN_LOG_PAGE_ERR    ; logical page not assigned to this handle
   408 00000155 C1EF02                          shr     di,2            ; DI is index*4 into the map_block_list
   409                                  
   410 00000158 8A8D[DE02]                      mov     cl,[map_block_list + di + map_count]
   411 0000015C 30ED                            xor     ch,ch
   412 0000015E 39CB                            cmp     bx,cx           ; compare count to length of chain
   413 00000160 7208                            jb      .4              ; less than, good map
   414                                  
   415 00000162 29CB                            sub     bx,cx           ; BX is remaining count
   416 00000164 8BBD[E002]                      mov     di,[map_block_list + di + map_link]     ; get link index
   417 00000168 EBE1                            jmp     .1
   418                                  
   419                                  .4:                     ; BL is displacement into page chain
   420 0000016A 8AB5[E102]                      mov     dh,[map_block_list + di + map_board]
   421 0000016E 029D[DF02]                      add     bl,[map_block_list + di + map_start]    ; form logical page #
   422 00000172 88DC                            mov     ah,bl
   423                                  
   424 00000174 E82600                          call    remap           ; DH is set; AL is phys page# 0..3
   425                                                                  ; AH is logical page  (HW page)
   426 00000177 E9DAFE                          jmp     good_exit
   427                                  
   428                                  
   429                                  ; Unmap the present page in physical page in AL
   430                                  ;
   431                                  unmap:
   432 0000017A 525350                          pushm   ax,bx,dx
   433 0000017D 8B16[D802]                      mov     dx,[frame]      ; form the block # in DL
   434 00000181 C1EA0A                          shr     dx,10
   435 00000184 00C2                            add     dl,al           ; DL is physical page
   436 00000186 89C3                            mov     bx,ax
   437 00000188 30FF                            xor     bh,bh           ; BX in index into the map
   438 0000018A 01DB                            add     bx,bx           ; index*2
   439 0000018C 8AB7[8B03]                      mov     dh,[map + bx + 1]   ; get the physical board
   440 00000190 B0FF                            mov     al,255          ; make it invalid
   441 00000192 8887[8A03]                      mov     [map + bx],al
   442 00000196 E8C602                          call    put
   443 00000199 585B5A                          popm    ax,bx,dx
   444 0000019C C3                              ret
   445                                  
   446                                  
   447                                  ; Set and record the map
   448                                  ;       AH = hardware page # 0..254
   449                                  ;       AL = physical slot # 0..3
   450                                  ;       DH = board number in high 4 bits
   451                                  ;
   452                                  remap:
   453 0000019D 525350                          pushm   ax,bx,dx
   454 000001A0 8B1E[D802]                      mov     bx,[frame]
   455 000001A4 C1EB0A                          shr     bx,10           ; get board address reg. value
   456 000001A7 88DA                            mov     dl,bl
   457 000001A9 00C2                            add     dl,al           ; offset physical 
   458 000001AB 80E6F0                          and     dh,0F0h         ; mask off high 4 bits
   459 000001AE 89C3                            mov     bx,ax
   460 000001B0 30FF                            xor     bh,bh           ; BX is index into map array
   461 000001B2 01DB                            add     bx,bx
   462 000001B4 88E0                            mov     al,ah           ;
   463 000001B6 86C2                            xchg    al,dl
   464 000001B8 8997[8A03]                      mov     [map + bx],dx   ; record DH (board#), DL page#(0..254)
   465 000001BC 86C2                            xchg    al,dl
   466 000001BE E89E02                          call    put             ; set the HW regs.
   467 000001C1 585B5A                          popm    ax,bx,dx
   468 000001C4 C3                              ret
   469                                  
   470                                  
   471                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   472                                  ; function 45h -- Release Handle and Memory
   473                                  ;
   474                                  ;  Enter With:
   475                                  ;       AH = function code 45h
   476                                  ;       DX = handle
   477                                  ;
   478                                  ;  Exit With:
   479                                  ;       AH = 0          good return
   480                                  ;
   481                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   482                                  fn45:
   483 000001C5 81EA5634                        sub     dx,HANDLE_BASE          ; unbias the handle
   484 000001C9 B483                            mov     ah,FN_INVALID_HANDLE
   485 000001CB 83FA10                          cmp     dx,NUM_HANDLES          ; validate handle
   486 000001CE 7203E983FE                      jae     error_exit
   487                                  
   488 000001D3 89D6                            mov     si,dx                   ; use SI as handle index
   489 000001D5 01F6                            add     si,si                   ; index*2
   490 000001D7 83BC[6A03]FF                    cmp     word [handle_list + si], -1
   491 000001DC 7503E975FE                      je      error_exit              ; unallocated handle
   492                                  
   493 000001E1 89F7                            mov     di,si                   ; save pointer to DI
   494 000001E3 C1E702                          shl     di,2                    ; index*8
   495 000001E6 8DBD[9203]                      lea     di,[handle_save_area + di]
   496 000001EA B8FFFF                          mov     ax,-1			;;; 01/12/2013 jrc
   497 000001ED 1E                      	pushm	ds			;;;
   498 000001EE 07                      	popm	es			;;; for the STOSW  ES:DI
   499 000001EF AB                              stosw
   500 000001F0 AB                              stosw                           ; clear the save area
   501 000001F1 AB                              stosw
   502 000001F2 AB                              stosw
   503                                  ;                               ; SI is still index*2
   504 000001F3 8784[6A03]                      xchg    [handle_list + si],ax   ; clear the handle
   505                                  ;                               ; AX is now the index to the mem_block_list
   506                                  free_the_memory:
   507 000001F7 89C3                            mov     bx,ax           ; use it from BX        index*2
   508 000001F9 C1E004                          shl     ax,4            ; get sign bit
   509 000001FC 7812                            js      .9              ; end of chain
   510                                  ;  the continuation of the chain is in AX
   511                                  
   512 000001FE E89603                  	call	free_node	; set up CH:CL, DH, with link in DX
   513                                  ; CX is the memory to free, DH has the board number
   514 00000201 89D0                    	mov	ax,dx		; save link (unmasked)
   515                                  
   516 00000203 8B3E[DC02]                      mov     di,[map_avail]
   517 00000207 E89502                  	call    add_to_list2
   518 0000020A 893E[DC02]              	mov	[map_avail],di
   519                                  
   520 0000020E EBE7                            jmp     free_the_memory         ; loop back with AX
   521                                  
   522                                  .9:
   523 00000210 FF06[6803]                      inc     word [handle_count]     ; count the handle
   524 00000214 E93DFE                          jmp     good_exit
   525                                  
   526                                  
   527                                  
   528                                  
   529                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   530                                  ; function 46h -- Get EMM Version
   531                                  ;
   532                                  ;  Enter With:
   533                                  ;       AH = function code 46h
   534                                  ;
   535                                  ;  Exit With:
   536                                  ;       AH = 0          good return
   537                                  ;       AL = EMM version number in BCD  (this is LIM EMS 3.2)
   538                                  ;
   539                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   540                                  fn46:
   541 00000217 C6460E32                        mov     byte [bp+offset_AL],32h      ; version 3.2
   542 0000021B E936FE                          jmp     good_exit
   543                                  
   544                                  
   545                                  
   546                                  
   547                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   548                                  ; function 47h -- Save Mapping Context
   549                                  ;
   550                                  ;  Enter With:
   551                                  ;       AH = function code 47h
   552                                  ;       DX = handle
   553                                  ;
   554                                  ;  Exit With:
   555                                  ;       AH = 0          good return
   556                                  ;
   557                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   558                                  fn47:
   559 0000021E E83C00                          call    check_handle
   560                                  
   561 00000221 40                              inc     ax                      ; must become zero
   562 00000222 B48D                            mov     ah,FN_SAVE_FAILED
   563 00000224 7403E92DFE                      jnz     error_exit              ; can't do the save
   564                                  
   565 00000229 1E                              pushm   ds
   566 0000022A 07                              popm    es
   567 0000022B BE[8A03]                        mov     si,map                  ; source pointer to SI
   568                                  ; DI points at the save area
   569 0000022E A5                              movsw
   570 0000022F A5                              movsw                           ; do the state save
   571 00000230 A5                              movsw
   572 00000231 A5                              movsw
   573                                  
   574 00000232 E91FFE                          jmp     good_exit
   575                                  
   576                                  
   577                                  
   578                                  
   579                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   580                                  ; function 48h -- Restore Mapping Context
   581                                  ;
   582                                  ;  Enter With:
   583                                  ;       AH = function code 48h
   584                                  ;       DX = handle
   585                                  ;
   586                                  ;  Exit With:
   587                                  ;       AH = 0          good return
   588                                  ;
   589                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   590                                  fn48:
   591 00000235 E82500                          call    check_handle
   592                                  
   593 00000238 40                              inc     ax                      ; must become zero
   594 00000239 B48E                            mov     ah,FN_RESTORE
   595 0000023B 7503E916FE                      jz      error_exit              ; can't do the save
   596                                  
   597 00000240 89FE                            mov     si,di                   ; restore save area pointer
   598 00000242 30C0                            xor     al,al
   599                                  .6:
   600 00000244 8B14                            mov     dx,[si]                 ; get context to restore
   601 00000246 C704FFFF                        mov     word [si],-1            ; zap the context
   602 0000024A 46                              inc     si
   603 0000024B 46                              inc     si
   604 0000024C 88D4                            mov     ah,dl                   ; physical page #
   605 0000024E E829FF                          call    unmap           ; uses only AL
   606 00000251 E849FF                          call    remap           ; uses AL,AH,DH
   607 00000254 FEC0                            inc     al
   608 00000256 3C04                            cmp     al,4            ; remap pages 0..3
   609 00000258 72EA                            jb      .6
   610                                  
   611 0000025A E9F7FD                          jmp     good_exit
   612                                  
   613                                  ;
   614                                  ;  Handle check for Save/Restore functions
   615                                  ;       Enter with biased handle in DX
   616                                  ;
   617                                  ;       Exit with And'ed save area contents in AX
   618                                  ;       Save pointer to Save Area is in DI
   619                                  ;
   620                                  check_handle:
   621 0000025D 81EA5634                        sub     dx,HANDLE_BASE          ; unbias the handle
   622 00000261 B483                            mov     ah,FN_INVALID_HANDLE
   623 00000263 83FA10                          cmp     dx,NUM_HANDLES          ; validate handle
   624 00000266 7203E9EBFD                      jae     error_exit
   625                                  
   626 0000026B 89D6                            mov     si,dx                   ; use SI as handle index
   627 0000026D 01F6                            add     si,si                   ; index*2
   628 0000026F BAFFFF                          mov     dx,-1
   629 00000272 3994[6A03]                      cmp     [handle_list + si],dx
   630 00000276 7503E9DBFD                      je      error_exit              ; unallocated handle
   631                                  
   632 0000027B C1E603                          shl     si,3                    ; index*8
   633 0000027E 8DB4[9203]                      lea     si,[handle_save_area + si]
   634 00000282 89F7                            mov     di,si                   ; save pointer to DI
   635                                  %rep 4
   636                                          lodsw                           ; get map word
   637                                          and     dx,ax                   
   638                                  %endrep
   636 00000284 AD                  <1>  lodsw
   637 00000285 21C2                <1>  and dx,ax
   636 00000287 AD                  <1>  lodsw
   637 00000288 21C2                <1>  and dx,ax
   636 0000028A AD                  <1>  lodsw
   637 0000028B 21C2                <1>  and dx,ax
   636 0000028D AD                  <1>  lodsw
   637 0000028E 21C2                <1>  and dx,ax
   639 00000290 C3                              ret
   640                                  
   641                                  
   642                                  
   643                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   644                                  ; function 49h -- Reserved
   645                                  ;
   646                                  ;  Enter With:
   647                                  ;       AH = function code 49h
   648                                  ;
   649                                  ;  Exit With:
   650                                  ;       AH = 84h        undefined function
   651                                  ;
   652                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   653                                  fn49    equ     undefined
   654                                  
   655                                  
   656                                  
   657                                  
   658                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   659                                  ; function 4Ah -- Reserved
   660                                  ;
   661                                  ;  Enter With:
   662                                  ;       AH = function code 4Ah
   663                                  ;
   664                                  ;  Exit With:
   665                                  ;       AH = 84h        undefined function
   666                                  ;
   667                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   668                                  fn4A    equ     undefined
   669                                  
   670                                  
   671                                  
   672                                  
   673                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   674                                  ; function 4Bh -- Get Number of Active EMS Handles
   675                                  ;
   676                                  ;  Enter With:
   677                                  ;       AH = function code 46h
   678                                  ;
   679                                  ;  Exit With:
   680                                  ;       AH = 0          good return
   681                                  ;       BX = number of active Handles (255 is max.)
   682                                  ;               (255 - BX must equal the number of available handles)
   683                                  ;
   684                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   685                                  fn4B:
   686 00000291 B91000                          mov     cx,NUM_HANDLES
   687 00000294 31DB                            xor     bx,bx
   688 00000296 BE[6A03]                        mov     si,handle_list
   689                                  .1:
   690 00000299 833CFF                          cmp     word [si+0],-1
   691 0000029C 7401                            je      .2
   692 0000029E 43                              inc     bx
   693 0000029F 8D7402                  .2:     lea     si,[si+size_handle]
   694 000002A2 E2F5                            loop    .1
   695                                  
   696 000002A4 81C3EF00                        add     bx,255-NUM_HANDLES      ; 3.2 allows 255, so fake the count
   697 000002A8 E9A9FD                          jmp     good_exit
   698                                  
   699                                  
   700                                  
   701                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   702                                  ; function 4Ch -- Get Pages Owned by Handle
   703                                  ;
   704                                  ;  Enter With:
   705                                  ;       AH = function code 4Ch
   706                                  ;       DX = handle
   707                                  ;
   708                                  ;  Exit With:
   709                                  ;       AH = 0          good return
   710                                  ;       BX = number of logical pages
   711                                  ;
   712                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   713                                  fn4C    equ     undefined
   714                                  
   715                                  
   716                                  
   717                                  
   718                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   719                                  ; function 4Dh -- Get Pages for All Handles
   720                                  ;
   721                                  ;  Enter With:
   722                                  ;       AH = function code 4Dh
   723                                  ;
   724                                  ;  Exit With:
   725                                  ;       AH = 0          good return
   726                                  ;;
   727                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   728                                  fn4D    equ     undefined
   729                                  
   730                                  
   731                                  
   732                                  
   733                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   734                                  ; function 4Eh -- Get or Set Page Map
   735                                  ;
   736                                  ;  Enter With:
   737                                  ;       AH = function code 4Eh
   738                                  ;       AL = subfunction code
   739                                  ;               00h = get registers into array
   740                                  ;               01h = set registers from array
   741                                  ;               02h = get and set operation
   742                                  ;               03h = return size of page mapping array
   743                                  ;       DS:SI = array pointer from which to set registers
   744                                  ;       ES:DI = pointer to array to receive register information
   745                                  ;
   746                                  ;  Exit With:
   747                                  ;       AH = 0          good return
   748                                  ;       AL = #bytes in page mapping array (subfunction 3)
   749                                  ;
   750                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   751                                  fn4E:
   752 000002AB 8B7602                          mov     si,[bp + offset_SI]     ; restore SI
   753 000002AE E99FFD                          jmp     undefined
   754                                  
   755                                  
   756                                  
   757                                  ; Get the memory pointer to an empty map block from the empty list
   758                                  ;    Return in DI
   759                                  get_empty:
   760 000002B1 50                              pushm   ax
   761 000002B2 8B3E[DA02]                      mov     di,[map_empty]
   762 000002B6 83FFFF                          cmp     di,-1
   763 000002B9 7503E98EFD                      je      internal_error          ; error if no empty map block
   764 000002BE C1E702                          shl     di,2                    ; index into array
   765                                  check map_length-4
   766 000002C1 81C7[DE02]                      add     di,map_block_list
   767 000002C5 8B4502                          mov     ax,[di+map_link]
   768 000002C8 C1E004                          shl     ax,4
   769 000002CB C1F804                          sar     ax,4                    ; 0FFFh becomes -1
   770 000002CE A3[DA02]                        mov     [map_empty],ax          ; new head of empty list
   771 000002D1 C74502FFFF                      mov     word [di+map_link],-1   ; empty block not part of any chain
   772 000002D6 58                              popm    ax
   773 000002D7 C3                              ret                             ; return DI as memory pointer
   774                                  
   775                                  %if 0
   776                                  get_empty_index:
   777                                          call    get_empty
   778                                          sub     di,map_block_list
   779                                          ret
   780                                  %endif
   781                                  
   782                                          align   2
   783                                  ; The frame segment of physical EMM page 0
   784 000002D8 00E8                    frame:  dw      FRAME0          ; this may be modified during initialization
   785                                                                  ; of the driver
   786                                  
   787 000002DA 0000                    map_empty:      dw      0       ; first free map block
   788 000002DC FFFF                    map_avail:      dw      -1      ; first block of available memory
   789                                  
   790                                  
   791                                  ; The list of EMM map blocks
   792                                  %assign xemm 0
   793                                  map_block_list:
   794                                  %rep    NUM_MAP_BLKS-1
   795                                          dw      0,xemm+1
   796                                  %assign xemm (xemm+1)
   797                                  %endrep
   795 000002DE 00000100            <1>  dw 0,xemm+1
   796                              <1> %assign xemm (xemm+1)
   795 000002E2 00000200            <1>  dw 0,xemm+1
   796                              <1> %assign xemm (xemm+1)
   795 000002E6 00000300            <1>  dw 0,xemm+1
   796                              <1> %assign xemm (xemm+1)
   795 000002EA 00000400            <1>  dw 0,xemm+1
   796                              <1> %assign xemm (xemm+1)
   795 000002EE 00000500            <1>  dw 0,xemm+1
   796                              <1> %assign xemm (xemm+1)
   795 000002F2 00000600            <1>  dw 0,xemm+1
   796                              <1> %assign xemm (xemm+1)
   795 000002F6 00000700            <1>  dw 0,xemm+1
   796                              <1> %assign xemm (xemm+1)
   795 000002FA 00000800            <1>  dw 0,xemm+1
   796                              <1> %assign xemm (xemm+1)
   795 000002FE 00000900            <1>  dw 0,xemm+1
   796                              <1> %assign xemm (xemm+1)
   795 00000302 00000A00            <1>  dw 0,xemm+1
   796                              <1> %assign xemm (xemm+1)
   795 00000306 00000B00            <1>  dw 0,xemm+1
   796                              <1> %assign xemm (xemm+1)
   795 0000030A 00000C00            <1>  dw 0,xemm+1
   796                              <1> %assign xemm (xemm+1)
   795 0000030E 00000D00            <1>  dw 0,xemm+1
   796                              <1> %assign xemm (xemm+1)
   795 00000312 00000E00            <1>  dw 0,xemm+1
   796                              <1> %assign xemm (xemm+1)
   795 00000316 00000F00            <1>  dw 0,xemm+1
   796                              <1> %assign xemm (xemm+1)
   795 0000031A 00001000            <1>  dw 0,xemm+1
   796                              <1> %assign xemm (xemm+1)
   795 0000031E 00001100            <1>  dw 0,xemm+1
   796                              <1> %assign xemm (xemm+1)
   795 00000322 00001200            <1>  dw 0,xemm+1
   796                              <1> %assign xemm (xemm+1)
   795 00000326 00001300            <1>  dw 0,xemm+1
   796                              <1> %assign xemm (xemm+1)
   795 0000032A 00001400            <1>  dw 0,xemm+1
   796                              <1> %assign xemm (xemm+1)
   795 0000032E 00001500            <1>  dw 0,xemm+1
   796                              <1> %assign xemm (xemm+1)
   795 00000332 00001600            <1>  dw 0,xemm+1
   796                              <1> %assign xemm (xemm+1)
   795 00000336 00001700            <1>  dw 0,xemm+1
   796                              <1> %assign xemm (xemm+1)
   795 0000033A 00001800            <1>  dw 0,xemm+1
   796                              <1> %assign xemm (xemm+1)
   795 0000033E 00001900            <1>  dw 0,xemm+1
   796                              <1> %assign xemm (xemm+1)
   795 00000342 00001A00            <1>  dw 0,xemm+1
   796                              <1> %assign xemm (xemm+1)
   795 00000346 00001B00            <1>  dw 0,xemm+1
   796                              <1> %assign xemm (xemm+1)
   795 0000034A 00001C00            <1>  dw 0,xemm+1
   796                              <1> %assign xemm (xemm+1)
   795 0000034E 00001D00            <1>  dw 0,xemm+1
   796                              <1> %assign xemm (xemm+1)
   795 00000352 00001E00            <1>  dw 0,xemm+1
   796                              <1> %assign xemm (xemm+1)
   795 00000356 00001F00            <1>  dw 0,xemm+1
   796                              <1> %assign xemm (xemm+1)
   798 0000035A 0000FFFF                        dw      0,-1
   799                                  
   800                                  ; The driver request block pointer
   801                                  request:
   802 0000035E 00000000                        dw      0,0
   803                                  
   804 00000362 0000                    nboards:  dw      EMM_BOARDS
   805 00000364 0000                    npages:   dw      0
   806                                  
   807                                  %assign xemm 0
   808                                  board_dev_list:
   809                                  %rep    EMM_BOARDS
   810                                          dw      EMM0+xemm+EMM_addr
   811                                  %assign xemm (xemm+EMM1-EMM0)
   812                                  %endrep
   813 00000366 FFFF                            dw      -1
   814                                  
   815 00000368 1000                    handle_count:   dw      NUM_HANDLES
   816                                  handle_list:
   817                                  %rep    NUM_HANDLES
   818                                          dw      -1
   819                                  %endrep
   818 0000036A FFFF                <1>  dw -1
   818 0000036C FFFF                <1>  dw -1
   818 0000036E FFFF                <1>  dw -1
   818 00000370 FFFF                <1>  dw -1
   818 00000372 FFFF                <1>  dw -1
   818 00000374 FFFF                <1>  dw -1
   818 00000376 FFFF                <1>  dw -1
   818 00000378 FFFF                <1>  dw -1
   818 0000037A FFFF                <1>  dw -1
   818 0000037C FFFF                <1>  dw -1
   818 0000037E FFFF                <1>  dw -1
   818 00000380 FFFF                <1>  dw -1
   818 00000382 FFFF                <1>  dw -1
   818 00000384 FFFF                <1>  dw -1
   818 00000386 FFFF                <1>  dw -1
   818 00000388 FFFF                <1>  dw -1
   820                                  size_handle     equ     2       ; for now
   821                                  
   822                                  
   823                                  map:    
   824 0000038A FF00                            dw      00FFh   ; hi 4 bits = board number @ frame0
   825 0000038C FF00                            dw      00FFh
   826 0000038E FF00                            dw      00FFh
   827 00000390 FF00                            dw      00FFh
   828                                  size_save_area  equ     $-map
   829                                  
   830                                  handle_save_area:
   831                                  %rep    NUM_HANDLES
   832                                          dw      -1, -1, -1, -1
   833                                  %endrep
   832 00000392 FFFFFFFFFFFFFFFF    <1>  dw -1, -1, -1, -1
   832 0000039A FFFFFFFFFFFFFFFF    <1>  dw -1, -1, -1, -1
   832 000003A2 FFFFFFFFFFFFFFFF    <1>  dw -1, -1, -1, -1
   832 000003AA FFFFFFFFFFFFFFFF    <1>  dw -1, -1, -1, -1
   832 000003B2 FFFFFFFFFFFFFFFF    <1>  dw -1, -1, -1, -1
   832 000003BA FFFFFFFFFFFFFFFF    <1>  dw -1, -1, -1, -1
   832 000003C2 FFFFFFFFFFFFFFFF    <1>  dw -1, -1, -1, -1
   832 000003CA FFFFFFFFFFFFFFFF    <1>  dw -1, -1, -1, -1
   832 000003D2 FFFFFFFFFFFFFFFF    <1>  dw -1, -1, -1, -1
   832 000003DA FFFFFFFFFFFFFFFF    <1>  dw -1, -1, -1, -1
   832 000003E2 FFFFFFFFFFFFFFFF    <1>  dw -1, -1, -1, -1
   832 000003EA FFFFFFFFFFFFFFFF    <1>  dw -1, -1, -1, -1
   832 000003F2 FFFFFFFFFFFFFFFF    <1>  dw -1, -1, -1, -1
   832 000003FA FFFFFFFFFFFFFFFF    <1>  dw -1, -1, -1, -1
   832 00000402 FFFFFFFFFFFFFFFF    <1>  dw -1, -1, -1, -1
   832 0000040A FFFFFFFFFFFFFFFF    <1>  dw -1, -1, -1, -1
   834                                  check $-handle_save_area - NUM_HANDLES*size_save_area
   835                                  
   836                                  strategy:
   837 00000412 2E891E[5E03]               cs   mov     [request],bx
   838 00000417 2E8C06[6003]               cs   mov     [request+2],es
   839 0000041C CB                              retf
   840                                  
   841                                  interrupt:
   842 0000041D 061E609C                        pushm   f,all,ds,es
   843 00000421 FC                              cld
   844 00000422 0E                              push    cs
   845 00000423 1F                              pop     ds
   846 00000424 C41E[5E03]                      les     bx,[request]            ; get request pointer
   847 00000428 26807F0200                  es  cmp     byte [bx+rq_command],0  ; support only "init" command
   848 0000042D 7503E9D101                      jz      initialization
   849                                  installation_error:
   850 00000432 B80C80                          mov     ax,800Ch                ; general error
   851                                  finish:
   852 00000435 26894703                    es  mov     [bx+rq_status],ax
   853 00000439 9D611F07                        popm    f,all,ds,es
   854 0000043D CB                              retf
   855                                  
   856                                  
   857                                  ; Return the number of available pages by counting the [map_avail] list
   858                                  ;       AX = pages available
   859                                  ;
   860                                  count_avail:
   861 0000043E 5153                            pushm   bx,cx
   862 00000440 31C0                            xor     ax,ax           ; clear the result
   863 00000442 31C9                            xor     cx,cx           ; zero CH
   864 00000444 8B1E[DC02]                      mov     bx,[map_avail]
   865                                  .1:
   866 00000448 C1E304                          shl     bx,4
   867 0000044B 780F                            js      .9
   868 0000044D C1EB02                          shr     bx,2
   869 00000450 8A8F[DE02]                      mov     cl,[map_block_list + bx + map_count]
   870 00000454 01C8                            add     ax,cx           ; add to the count
   871 00000456 8B9F[E002]                      mov     bx,[map_block_list + bx + map_link]
   872 0000045A EBEC                            jmp     .1
   873                                  .9:
   874 0000045C 5B59                            popm    bx,cx
   875 0000045E C3                              ret
   876                                  
   877                                  
   878                                  
   879                                  ; put
   880                                  ;       DH = board # in hi 4 bits
   881                                  ;       DL = addr [0..3F]
   882                                  ;       AL = page# [0..FE,FF]
   883                                  ;
   884                                  put:
   885 0000045F 56                              push    si              ; SI is where we generate the device code
   886 00000460 89D6                            mov     si,dx
   887 00000462 C1EE0C                          shr     si,12           ; SI is board #
   888 00000465 D1E6                            shl     si,1            ; index words
   889 00000467 8BB4[6603]                      mov     si,[board_dev_list+si]  ; assume DS==CS
   890 0000046B 83FEFF                          cmp     si,-1           ; bad device code
   891 0000046E 7503E9D9FB                      je      internal_error
   892 00000473 50                              push    ax              ; save page frame
   893 00000474 88D0                            mov     al,dl
   894 00000476 87D6                            xchg    dx,si
   895 00000478 EE                              out     dx,al           ; put out the address
   896 00000479 4A                              dec     dx
   897 0000047A 58                              pop     ax
   898 0000047B EE                              out     dx,al
   899 0000047C 89F2                            mov     dx,si
   900 0000047E 5E                              pop     si
   901 0000047F C3                              ret
   902                                  
   903                                  
   904                                  
   905                                  
   906                                  ; get
   907                                  ;       DH = board # in hi 4 bits
   908                                  ;       DL = addr [0..3F]
   909                                  ;   Returns:
   910                                  ;       AL = page# [0..FE,FF]
   911                                  ;
   912                                  get:
   913 00000480 56                              push    si              ; SI is where we generate the device code
   914 00000481 89D6                            mov     si,dx
   915 00000483 C1EE0C                          shr     si,12           ; SI is board #
   916 00000486 D1E6                            shl     si,1            ; index words
   917 00000488 8BB4[6603]                      mov     si,[board_dev_list+si]  ; assume DS==CS
   918 0000048C 83FEFF                          cmp     si,-1           ; bad device code
   919 0000048F 7503E9B8FB                      je      internal_error
   920 00000494 88D0                            mov     al,dl
   921 00000496 87D6                            xchg    dx,si
   922 00000498 EE                              out     dx,al           ; put out the address
   923 00000499 4A                              dec     dx
   924 0000049A EC                              in      al,dx
   925 0000049B 89F2                            mov     dx,si
   926 0000049D 5E                              pop     si
   927 0000049E C3                              ret
   928                                  
   929                                  
   930                                  %if 1
   931                                  ; Add a memory chunk (not part of a node) to a list
   932                                  ;   Input:
   933                                  ;	CH:CL	start ; count
   934                                  ;	DH	board number	(in the hi 4 bits)
   935                                  ;	DI	list to scan	(may be null; i.e., 0FFFh)
   936                                  ;   Returns:
   937                                  ;	DI	is new head of list
   938                                  ;
   939                                  ;	AX & BX are preserved
   940                                  ;
   941                                  add_to_list2:
   942 0000049F 5350                    	pushm	ax,bx
   943                                  
   944 000004A1 80E6F0                  	and	dh,0F0h			; mask to board # only
   945 000004A4 81E7FF0F                	and	di,0FFFh		; mask to index only
   946                                  
   947 000004A8 81FFFF0F                	cmp	di,0FFFh		; check for NULL list
   948 000004AC 7503E9B600              	je	.new_list
   949                                  	
   950 000004B1 C1E702                  	shl	di,2			; DI = index*4
   951 000004B4 8AA5[E102]              	mov	ah,[map_block_list + di + map_board]	; get board number
   952 000004B8 80E4F0                  	and	ah,0F0h			; make to only board number
   953 000004BB 38E6                    	cmp	dh,ah			; arg : board on list
   954 000004BD 721E                    	jb	.make_new		; below
   955 000004BF 7435                    	je	.may_combine		; equal board numbers
   956                                  ; above, we fit in list later
   957 000004C1 89FB                    	mov	bx,di			; save index*4 in BX
   958 000004C3 8BBD[E002]              	mov	di,[map_block_list + di + map_link]	; get rest of chain in DI
   959 000004C7 E8D5FF                  	call	add_to_list2		; recursively add to the list
   960 000004CA 33BF[E002]              	xor	di,[map_block_list + bx + map_link]	; store DI index only
   961 000004CE 81E7FF0F                	and	di,0FFFh		; **
   962 000004D2 31BF[E002]              	xor	[map_block_list + bx + map_link],di	; **
   963 000004D6 C1EB02                  	shr	bx,2			; make index*1
   964 000004D9 89DF                    	mov	di,bx			; return head of list unaltered
   965 000004DB EB16                    	jmp	.atl_exit		; **
   966                                  
   967                                  .make_new:
   968 000004DD E88E00                  	call	get_node
   969 000004E0 C1EF02                  	shr	di,2			; DI = index*1
   970 000004E3 C1E302                  	shl	bx,2			; BX = index*4
   971 000004E6 21BF[E002]              	and	[map_block_list + bx + map_link],di	; link is FFF, so AND stores link
   972 000004EA 08B7[E102]              	or	[map_block_list + bx + map_board],dh	; board is 0FFF, so OR stores board
   973 000004EE C1EB02                  	shr	bx,2			; BX = index*1
   974 000004F1 89DF                    	mov	di,bx
   975                                  .atl_exit:
   976 000004F3 585B                    	popm	ax,bx			; return
   977 000004F5 C3                      	ret				; new head of list returned
   978                                  
   979                                  ; board numbers are the same
   980                                  ;  CH:CL memory piece may combine with node in DI
   981                                  ;  DI is index*4 of possible combining point
   982                                  .may_combine:
   983 000004F6 8B85[DE02]              	mov	ax,[map_block_list + di + map_count]	; AH:AL is  start : count  of node
   984 000004FA 00E0                    	add	al,ah			; AH:AL is  start : end+1  of node
   985 000004FC 00E9                    	add	cl,ch			; CH:CL is  start : end+1  of chunk
   986 000004FE 38E1                    	cmp	cl,ah			; end chunk <> start node
   987 00000500 724F                    	jb	.before
   988 00000502 750D                    	jne	.mc2
   989                                  
   990                                  ; end chunk == start node	node grows at the head
   991 00000504 88EC                    	mov	ah,ch			; start node <-- start chunk
   992                                  ;.mc1:
   993 00000506 28E0                    	sub	al,ah			; AH:AL is  start : count of node
   994 00000508 8985[DE02]              	mov	[map_block_list + di + map_count],ax	; update the node
   995 0000050C C1EF02                  	shr	di,2			; DI is index*1
   996                                  ;;;	xor	cx,cx			; destroy CX, no mem to return
   997 0000050F EBE2                    	jmp	.atl_exit
   998                                  
   999                                  ; check for combining at the end
  1000 00000511 38E8                    .mc2:	cmp	al,ch			; end node <> start chunk
  1001 00000513 721E                    	jb	.after
  1002 00000515 7519                    	jne	.mc4
  1003                                  ; end node == start chunk
  1004 00000517 88C8                    	mov	al,cl			; end node <-- start chunk
  1005                                  ;;;;;	jmp	.mc1
  1006 00000519 28E0                    	sub	al,ah			; AH:AL is  start : count of node
  1007 0000051B 8985[DE02]              	mov	[map_block_list + di + map_count],ax	; update the node
  1008 0000051F 8B9D[E002]              	mov	bx,[map_block_list + di + map_link]	; get link
  1009 00000523 C1EF02                  	shr	di,2			; DI is index*1
  1010 00000526 87DF                    	xchg	bx,di			; BX is combined node, DI is end of list
  1011 00000528 E86C00                  	call	free_node		; free up BX; sets DH, CH:CL
  1012 0000052B E871FF                  	call	add_to_list2		; add to the DI list
  1013                                  				; and return the new DI
  1014 0000052E EBC3                    	jmp	.atl_exit
  1015                                  
  1016                                  ; chunk and node did not combine, nor were before or after determined
  1017 00000530 E919FB                  .mc4:	jmp	internal_error
  1018                                  
  1019                                  ; memory chunk fits in after the current node
  1020                                  .after:
  1021 00000533 28E9                    	sub	cl,ch			; CH:CL  start : count  restored
  1022 00000535 89FB                    	mov	bx,di			; node pointer to BX  index*4
  1023 00000537 8BBF[E002]              	mov	di,[map_block_list + bx + map_link]	; node link to DI  index*1
  1024 0000053B E861FF                  	call	add_to_list2
  1025 0000053E 33BF[E002]              	xor	di,[map_block_list + bx + map_link]	; store link index*1
  1026 00000542 81E7FF0F                	and	di,0FFFh				; **
  1027 00000546 31BF[E002]              	xor	[map_block_list + bx + map_link],di	; **
  1028 0000054A 89DF                    	mov	di,bx			; DI <-- BX   == index*4
  1029 0000054C C1EF02                  	shr	di,2			; make index*1
  1030 0000054F EBA2                    	jmp	.atl_exit
  1031                                  
  1032                                  ;memory chunk fits in before the current node
  1033                                  .before:
  1034 00000551 28E9                    	sub	cl,ch			; CH:CL  start : count  restored
  1035 00000553 E81800                  	call	get_node		; allocate and fill in node
  1036 00000556 C1EF02                  	shr	di,2			; make DI index*1
  1037 00000559 C1E302                  	shl	bx,2			; new node index*4
  1038 0000055C 21BF[E002]              	and	[map_block_list + bx + map_link],di	; link is 0FFF, so this stores it
  1039 00000560 C1EB02                  	shr	bx,2			; index*1
  1040 00000563 89DF                    	mov	di,bx			; return new node as head
  1041 00000565 EB8C                    	jmp	.atl_exit
  1042                                  
  1043                                  ; null list, create a list
  1044                                  .new_list:
  1045 00000567 E80400                  	call	get_node		; get a memory node (CH:CL, DH)
  1046 0000056A 89DF                    	mov	di,bx			; return new index in DI
  1047 0000056C EB85                    	jmp	.atl_exit
  1048                                  
  1049                                  
  1050                                  ; Get a memory node and fill it in from CH:CL, and DH
  1051                                  ;	return index in BX	(index * 1)
  1052                                  ;
  1053                                  ;	uses AX
  1054                                  ;
  1055                                  get_node:
  1056 0000056E 50                      	pushm	ax
  1057                                  
  1058 0000056F 8B1E[DA02]              	mov	bx,[map_empty]
  1059 00000573 83FBFF                  	cmp	bx,-1			; check for none available
  1060 00000576 7503E9D1FA              	je	internal_error
  1061                                  
  1062 0000057B C1E302                  	shl	bx,2			; make index * 4
  1063 0000057E 8B87[E002]              	mov	ax,[map_block_list + bx + map_link]
  1064 00000582 A3[DA02]                	mov	[map_empty],ax		; new head of list
  1065 00000585 898F[DE02]              	mov	[map_block_list + bx + map_count],cx	; save CH:CL in start : count
  1066 00000589 88F4                    	mov	ah,dh			; board # to AH
  1067 0000058B 0DFF0F                  	or	ax,0FFFh		; terminate as a single node
  1068 0000058E 8987[E002]              	mov	[map_block_list + bx + map_link],ax
  1069 00000592 C1EB02                  	shr	bx,2			; make BX an index
  1070                                  
  1071 00000595 58                      	popm	ax
  1072 00000596 C3                      	ret				; AX was destroyed
  1073                                  
  1074                                  
  1075                                  ; Free the memory node indexed by BX
  1076                                  ;   setting CH:CL and DX in the process
  1077                                  ;
  1078                                  free_node:
  1079 00000597 81E3FF0F                	and	bx,0FFFh		; mask index
  1080 0000059B C1E302                  	shl	bx,2			; make into  index*4
  1081 0000059E 31C9                    	xor	cx,cx
  1082 000005A0 878F[DE02]              	xchg	cx,[map_block_list + bx + map_count]
  1083 000005A4 8B16[DA02]              	mov	dx,[map_empty]		; get head of empty list
  1084 000005A8 C1E204                  	shl	dx,4
  1085 000005AB C1FA04                  	sar	dx,4		; mask, but keep -1
  1086 000005AE 8797[E002]              	xchg	dx,[map_block_list + bx + map_link]
  1087 000005B2 C1EB02                  	shr	bx,2
  1088 000005B5 891E[DA02]              	mov	[map_empty],bx
  1089 000005B9 C3                      	ret
  1090                                  
  1091                                  
  1092                                  %endif
  1093                                  
  1094                                          align   2                
  1095                                  ;;;***
  1096                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1097                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1098                                  ;  All memory below this point is released after initialization
  1099                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1100                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1101                                  %if TRACE==0
  1102                                  free_below_here:
  1103                                  %endif
  1104                                  ; Add to list
  1105                                  ;   Input:
  1106                                  ;       CH:CL = start page# : number of pages
  1107                                  ;       DH = board number in high 4 bits
  1108                                  ;
  1109                                  ;       DI = index of list to scan in low 12 bits (or -1)
  1110                                  ;
  1111                                  ;    Return:
  1112                                  ;       DI = -1 if no new head of list
  1113                                  ;       DI = index & 0FFFh of new head of list
  1114                                  ;
  1115                                  %if 0
  1116                                  add_to_list:
  1117                                          pushm   ax,bx,cx,dx,si
  1118                                          and     dh,0F0h         ; mask to 4 bits == board #
  1119                                          mov     si,-1           ; former list pointer
  1120                                          add     cl,ch           ; CL = page beyond end
  1121                                  
  1122                                  ;  DI is index in low 12 bits
  1123                                  atl_loop:
  1124                                          cmp     di,-1           ; 
  1125                                          je      new_entry
  1126                                  ; 
  1127                                          and     di,0FFFh
  1128                                          shl     di,2            ; index into array
  1129                                          mov     al,[map_block_list + di + map_board]
  1130                                          and     al,0F0h
  1131                                          cmp     al,dh
  1132                                          ja      new_entry
  1133                                  ;;;        je      atl_compare
  1134                                          jb      atl_next
  1135                                  atl_compare:
  1136                                          mov     ax,[map_block_list + di + map_count]
  1137                                          add     al,ah           ; AL is one beyond end
  1138                                          cmp     ah,cl           ; begin == end
  1139                                          jne     .1
  1140                                  ; tag it at the beginning
  1141                                          mov     ah,ch
  1142                                          jmp     .3
  1143                                  .1:     cmp     al,ch           ; end == begin
  1144                                          jne     atl_next
  1145                                  ; tag it onto the end
  1146                                          mov     al,cl
  1147                                  .3:     ; combining occurred
  1148                                          sub     al,ah           ; AL = new count
  1149                                  %if TRACE
  1150                                          call    wout
  1151                                          call    crlf
  1152                                  %endif
  1153                                          mov     [map_block_list + di + map_count],ax
  1154                                          mov     di,-1
  1155                                          jmp     atl_done
  1156                                  atl_next:
  1157                                          mov     si,di           ; SI = former index*4
  1158                                          mov     di,[map_block_list + di + map_link]
  1159                                          shl     di,4
  1160                                          sar     di,4
  1161                                          jmp     atl_loop
  1162                                  
  1163                                  
  1164                                          mov     ax,[map_block_list + di + map_count]
  1165                                          add     al,ah           ; AL = page beyond end
  1166                                  
  1167                                  ; insert a new entry between SI (lower*4) and DI (higher*4)
  1168                                  new_entry:
  1169                                          mov     bx,di           ; save in BX
  1170                                          call    get_empty
  1171                                          sub     cl,ch           ; CL = count
  1172                                          mov     [di+map_count],cx       ; save count & start
  1173                                          sar     bx,2            ; -1 -> -1  or  index*4 -> index
  1174                                          and     bh,0Fh          ; clear board #
  1175                                          or      bh,dh           ; include board number
  1176                                          mov     [di+map_link],bx
  1177                                          sub     di,map_block_list       ; make into index*4
  1178                                          shr     di,2            ; make index*1
  1179                                          cmp     si,-1
  1180                                          je      .3
  1181                                          xor     di,[map_block_list + si + map_link]
  1182                                          and     di,0FFFh
  1183                                          xor     [map_block_list + si + map_link],di
  1184                                          mov     di,-1           ; list is linked, and no new head
  1185                                  .3:
  1186                                  atl_done:
  1187                                          popm    ax,bx,cx,dx,si
  1188                                          ret
  1189                                  %endif
  1190                                  %if 1
  1191                                  dout:
  1192 000005BA 5250                            pushm   ax,dx
  1193 000005BC 31D2                            xor     dx,dx
  1194 000005BE F736[D105]                      div     word [dout_ten]
  1195 000005C2 09C0                            or      ax,ax
  1196 000005C4 7403                            jz      .1
  1197 000005C6 E8F1FF                          call    dout
  1198 000005C9 89D0                    .1:     mov     ax,dx
  1199 000005CB E81400                          call    nout
  1200 000005CE 585A                            popm    ax,dx
  1201 000005D0 C3                              ret
  1202 000005D1 0A00                    dout_ten:   dw      10
  1203                                  %endif
  1204                                  wout:
  1205 000005D3 86E0                            xchg    ah,al
  1206 000005D5 E80200                          call    bout
  1207 000005D8 86E0                            xchg    ah,al
  1208                                  bout:
  1209 000005DA 50                              push    ax
  1210 000005DB C1E804                          shr     ax,4
  1211 000005DE E80100                          call    nout
  1212 000005E1 58                              pop     ax
  1213                                  nout:
  1214 000005E2 50                              push    ax
  1215 000005E3 240F                            and     al,00Fh          ; mask 4bits
  1216 000005E5 27                              daa
  1217 000005E6 04F0                            add     al,0F0h
  1218 000005E8 1440                            adc     al,040h
  1219 000005EA E80200                          call    putchar
  1220 000005ED 58                              pop     ax
  1221 000005EE C3                              ret
  1222                                  
  1223                                  putchar:
  1224 000005EF 5250                            pushm   ax,dx
  1225 000005F1 88C2                            mov     dl,al
  1226 000005F3 B402                            mov     ah,2
  1227 000005F5 CD21                            int     21h
  1228 000005F7 585A                            popm    ax,dx
  1229 000005F9 C3                              ret
  1230                                  
  1231                                  crlf:
  1232 000005FA 68[E508]                        push    fmt_NL
  1233 000005FD E8E701                          call    fprint
  1234 00000600 44                              inc     sp
  1235 00000601 44                              inc     sp
  1236 00000602 C3                              ret
  1237                                  
  1238                                  %if 0
  1239                                  dot:
  1240                                          pushm   all
  1241                                          mov     al,'.'
  1242                                          call    putchar
  1243                                          popm    all
  1244                                          ret
  1245                                  %endif
  1246                                  
  1247                                  %if TRACE>0
  1248                                  free_below_here:
  1249                                  %endif
  1250                                  initialization:
  1251                                  %if 0
  1252                                          mov     dx,hello
  1253                                          mov     ah,9            ; DOS write string
  1254                                          int     21h
  1255                                  %else
  1256 00000603 6A00                            push    MINOR_VERSION
  1257 00000605 6A02                            push    MAJOR_VERSION
  1258 00000607 68[3108]                        push    fmt1
  1259 0000060A E8DA01                          call    fprint
  1260 0000060D 83C406                          add     sp,6
  1261                                  %endif
  1262                                  %if TRACE
  1263                                          pushm   ds
  1264                                      es  lds     si,[bx+rq_config_sys]
  1265                                  .1:
  1266                                          lodsb
  1267                                          cmp     al,20h          ; compare to SPACE
  1268                                          jb      .2
  1269                                          call    putchar
  1270                                          jmp     .1
  1271                                  .2:
  1272                                          popm    ds
  1273                                  
  1274                                  %if 0
  1275                                          mov     dx,double_space
  1276                                          mov     ah,9            ; DOS write string
  1277                                          int     21h
  1278                                  %else
  1279                                  	push	double_space
  1280                                  	call	fprint
  1281                                  	pop	ax
  1282                                  %endif
  1283                                  %endif
  1284                                  
  1285                                  
  1286                                  
  1287                                  
  1288                                  get_frame_segment:
  1289                                  %if 0		; obsolete
  1290                                  ; compute the frame segment from the 18h (Tiny Basic) interrupt vector
  1291                                  	pushm	ds
  1292                                  	push	0
  1293                                  	pop	ds
  1294                                  	mov	ax,[18h*4+2]	; get BIOS segment
  1295                                  	sub	ax,1000h
  1296                                  	popm	ds	  	; assume DS==CS
  1297                                  %else
  1298 00000610 5253                    	pushm	bx,dx
  1299                                  
  1300 00000612 BAA6FF                  	mov	dx,cpu_mmcs	; find memory hole
  1301 00000615 ED                      	in	ax,dx		;
  1302 00000616 2500FE                  	and	ax,0FE00h
  1303 00000619 3D0070                  	cmp	ax,7000h	; was 8000h, but disabled EXT_MEM
  1304                                  				;  will map to 7000h area
  1305 0000061C 7216                    	jb	.5		; version 1 board if below
  1306                                  	; the Middle memory is part of the low 512K memory select
  1307                                  ; version 3 board
  1308 0000061E 89C3                    	mov	bx,ax		; save start of EXT_MEM in BX
  1309 00000620 BAA8FF                  	mov	dx,cpu_mpcs	; find size of EXT_MEM
  1310 00000623 ED                      	in	ax,dx		;
  1311 00000624 D1E0                    	shl	ax,1
  1312 00000626 2500FE                  	and	ax,0FE00h	;
  1313 00000629 93                      	xchg	bx,ax		;
  1314                                  
  1315 0000062A 80FF10                  	cmp	bh,10h		; compare to 64k
  1316 0000062D 730E                       	jae	.9		; 64K or more; use lowest 64k
  1317                                  ; must have 64K
  1318 0000062F 5B5A                    	popm	bx,dx
  1319 00000631 E9FEFD                  	jmp	installation_error	; (I hope ES is intact)
  1320                                  ;
  1321                                  ;
  1322                                  ; version 1 board
  1323                                  ; get segment 64K below the start of ROM
  1324                                  ;
  1325                                  .5:
  1326 00000634 BAA0FF                  	mov	dx,cpu_umcs	; get upper memory start address
  1327 00000637 ED                      	in	ax,dx		; from the upper memory select
  1328 00000638 30C0                    	xor	al,al		; get segment
  1329 0000063A 80EC10                  	sub	ah,10h	 	; deduct 64K
  1330                                  .9:
  1331 0000063D 5B5A                    	popm	bx,dx
  1332                                  %endif
  1333 0000063F A3[D802]                	mov	word [frame],ax
  1334                                  
  1335                                  
  1336                                  ; find the boards that are present
  1337                                  
  1338                                  prescence_test:
  1339 00000642 B600                            mov     dh,0
  1340 00000644 31F6                            xor     si,si
  1341 00000646 BF[6603]                        mov     di,board_dev_list
  1342                                  .3:
  1343                                  TEST_FRAME      equ     0A000h
  1344                                  TEST_PAGE1      equ     5Ch
  1345                                  TEST_PAGE2      equ     0F0h
  1346 00000649 833DFF                          cmp     word [di],-1
  1347 0000064C 747A                            je      .7
  1348                                  
  1349 0000064E B228                            mov     dl,TEST_FRAME>>10
  1350 00000650 E82DFE                          call    get
  1351 00000653 88C1                            mov     cl,al
  1352 00000655 B05C                            mov     al,TEST_PAGE1
  1353 00000657 E805FE                          call    put
  1354                                  
  1355 0000065A FEC2                            inc     dl
  1356 0000065C E821FE                          call    get
  1357 0000065F 88C5                            mov     ch,al
  1358 00000661 B0F0                            mov     al,TEST_PAGE2
  1359 00000663 E8F9FD                          call    put
  1360                                  
  1361 00000666 FECA                            dec     dl
  1362 00000668 E815FE                          call    get
  1363 0000066B 2C5C                            sub     al,TEST_PAGE1
  1364 0000066D 88C4                            mov     ah,al
  1365 0000066F 88C8                            mov     al,cl
  1366 00000671 E8EBFD                          call    put
  1367                                  
  1368 00000674 FEC2                            inc     dl
  1369 00000676 E807FE                          call    get
  1370 00000679 2CF0                            sub     al,TEST_PAGE2
  1371 0000067B 08C4                            or      ah,al
  1372 0000067D 88E8                            mov     al,ch
  1373 0000067F E8DDFD                          call    put
  1374                                  
  1375 00000682 08E4                            or      ah,ah
  1376 00000684 7535                            jnz     .4
  1377                                  
  1378                                  ; Found a board, add all of its pages to the available list
  1379 00000686 E8D300                          call    size_board
  1380 00000689 726D                            jc      init_error
  1381 0000068B 53                              push    bx
  1382 0000068C 89C3                            mov     bx,ax
  1383                                  
  1384 0000068E 81C3[DE02]                      add     bx,map_block_list       ; make into actual pointer
  1385                                  %if TRACE
  1386                                          call    crlf
  1387                                          mov     ax,[bx+map_count]
  1388                                          call    wout
  1389                                          call    crlf
  1390                                  %endif
  1391                                  
  1392 00000692 8A07                            mov     al,[bx+map_count]
  1393 00000694 30E4                            xor     ah,ah
  1394 00000696 50                              push    ax
  1395 00000697 8A4703                          mov     al,[bx+map_board]
  1396 0000069A C1E804                          shr     ax,4
  1397 0000069D 50                              push    ax
  1398 0000069E 68[B708]                        push    fmt2
  1399 000006A1 E84301                          call    fprint
  1400 000006A4 83C406                          add     sp,6
  1401                                  
  1402 000006A7 E85E00                          call    reduce_board            ; nop if not board 0
  1403                                  
  1404 000006AA 8A07                            mov     al,[bx+map_count]
  1405 000006AC 30E4                            xor     ah,ah
  1406 000006AE 50                              push    ax
  1407 000006AF 68[D908]                        push    fmt2a
  1408 000006B2 E83201                          call    fprint
  1409 000006B5 83C404                          add     sp,4
  1410                                  
  1411                                  %if TRACE
  1412                                          call    crlf
  1413                                          mov     ax,[bx+map_count]
  1414                                          call    wout
  1415                                          call    crlf
  1416                                  %endif
  1417                                  
  1418 000006B8 5B                              pop     bx
  1419 000006B9 EB05                            jmp     .5
  1420                                  
  1421                                  .4:   ; failure to match
  1422 000006BB 4E                              dec     si              ; undo the inc. below
  1423 000006BC C705FFFF                        mov     word [di],-1    ; wipe out the device code
  1424                                  .5: 
  1425 000006C0 46                              inc     si              ; count board prescence
  1426 000006C1 47                              inc     di              ; update pointer
  1427 000006C2 47                              inc     di
  1428 000006C3 80C610                          add     dh,10h          ; increment the board number
  1429 000006C6 EB81                            jmp     .3
  1430                                  .7:
  1431 000006C8 89F0                            mov     ax,si
  1432                                  %if TRACE
  1433                                          call    bout
  1434                                          call    crlf
  1435                                  %endif
  1436 000006CA 8936[6203]                      mov     [nboards],si
  1437 000006CE 09F6                            or      si,si
  1438 000006D0 7426                            jz      init_error
  1439                                  
  1440 000006D2 FF36[6803]                      push    word [handle_count]
  1441 000006D6 FF36[D802]                      push    word [frame]
  1442 000006DA 68[E808]                        push    fmt3
  1443 000006DD E80701                          call    fprint
  1444 000006E0 83C406                          add     sp,6
  1445                                  
  1446 000006E3 B80001                          mov     ax,DONE
  1447 000006E6 BA[BA05]                        mov     dx,free_below_here                      ; address of driver end
  1448                                  
  1449                                  ; DS will not be used beyond this point in the code
  1450                                  ; Use DS to set the int 67h vector
  1451 000006E9 6A00                            push    0
  1452 000006EB 1F                              popm    ds
  1453 000006EC C7069C01[3000]                  mov     word [67h*4],bios_call_67h
  1454 000006F2 8C0E9E01                        mov     word [67h*4 + 2],cs
  1455 000006F6 EB05                            jmp     save_it
  1456                                  
  1457                                  init_error:
  1458 000006F8 B80C80                          mov     ax,800Ch        ; general failure
  1459 000006FB 31D2                            xor     dx,dx           ; don't install the driver
  1460                                  save_it:
  1461 000006FD 2689570E                    es  mov     word [bx+rq_ret_freemem],dx             ; **
  1462 00000701 268C4F10                    es  mov     word [bx+rq_ret_freemem+2],cs           ; **
  1463 00000705 E92DFD                          jmp     finish          ; exit
  1464                                  ; note:  DS is not referenced any more at 'finish'
  1465                                  
  1466                                  
  1467                                  ; reduce the size of board 0
  1468                                  ;       DH = board number in high 4 bits
  1469                                  ;       BX = pointer to the map_block
  1470                                  ;
  1471                                  reduce_board:
  1472 00000708 F6C6F0                          test    dh,0F0h         ; is it board 0
  1473 0000070B 754E                            jnz     .99
  1474                                  
  1475 0000070D 515250                          pushm   ax,dx,cx
  1476 00000710 30D2                            xor     dl,dl           ; start at address 0
  1477                                  .1:
  1478 00000712 E86BFD                          call    get             ; get the mapping
  1479                                  %if TRACE
  1480                                          call    bout
  1481                                          cmp     dl,32-1
  1482                                          jne     .11
  1483                                          call    crlf
  1484                                  .11:
  1485                                  %endif
  1486 00000715 3CFF                            cmp     al,255
  1487 00000717 740A                            je      .4
  1488 00000719 3A4701                          cmp     al,[bx+map_start]       ; is it allocated
  1489 0000071C 7505                            jne     .4
  1490 0000071E FE4701                          inc     byte [bx+map_start]     ; remove block from available
  1491 00000721 FE0F                            dec     byte [bx+map_count]     ; it is allocated
  1492 00000723 FEC2                    .4:     inc     dl
  1493 00000725 80FA40                          cmp     dl,64           ; 64 memory map slots
  1494 00000728 72E8                            jb      .1
  1495                                  
  1496                                  %if TRACE
  1497                                          call    crlf
  1498                                  %endif
  1499                                  
  1500                                  %if 1
  1501 0000072A A1[D802]                        mov     ax,[frame]
  1502 0000072D C1E802                          shr     ax,10-8           ; get start in AH
  1503 00000730 88E2                            mov     dl,ah
  1504 00000732 80C203                          add     dl,3            ; last slot in frame
  1505                                  .6:
  1506 00000735 E848FD                          call    get             ; get mapping
  1507 00000738 3CFF                            cmp     al,255          ; is it unassigned
  1508 0000073A 7416                            je      .7
  1509 0000073C 88C5                            mov     ch,al           ; page#
  1510 0000073E B0FF                            mov     al,255
  1511 00000740 E81CFD                          call    put             ; make it unavailable
  1512 00000743 B101                            mov     cl,1            ; count
  1513                                  %if 0
  1514                                  	mov     di,[map_avail]  ; add to list of available pages
  1515                                          call    add_to_list
  1516                                          mov     al,ch
  1517                                          cmp     di,-1
  1518                                  %else
  1519 00000745 8B3E[DC02]              	mov     di,[map_avail]  ; add to list of available pages
  1520 00000749 88E8                            mov     al,ch	      	; save page # in AL
  1521 0000074B E851FD                          call    add_to_list2
  1522 0000074E 893E[DC02]              	mov     [map_avail],di  ; add to list of available pages
  1523                                  %endif
  1524                                  ;;;        jne     init_error
  1525 00000752 FECA                    .7:     dec     dl
  1526                                  
  1527                                  %if 0
  1528                                          xchg    ah,dl
  1529                                          call    wout
  1530                                          xchg    ah,dl
  1531                                          call    wout
  1532                                          call    crlf
  1533                                  %endif
  1534 00000754 38E2                            cmp     dl,ah           ; compare to beginning
  1535 00000756 73DD                            jae     .6
  1536                                  %endif
  1537                                  
  1538 00000758 585A59                          popm    ax,dx,cx
  1539                                  .99:
  1540 0000075B C3                              ret
  1541                                  
  1542                                  
  1543                                  ; figure the size of the board (known to be present)
  1544                                  ;       DH = board number in the high 4 bits
  1545                                  ;
  1546                                  ;       C = 0 means no error
  1547                                  ;       C = 1 means an error occurred
  1548                                  ;
  1549                                  ;       AX = index of the memory block (0 .. NUM_MAP_BLKS-1)
  1550                                  ;
  1551                                  size_board:
  1552 0000075C 5157                            pushm   di,cx
  1553 0000075E B0FF                            mov     al,255                  ; highest page number
  1554 00000760 B900FF                          mov     cx,0FF00h               ; 
  1555                                  .1:
  1556 00000763 FEC8                            dec     al
  1557 00000765 E82400                          call    page_present            ; is page present
  1558 00000768 73F9                            jnc     .1
  1559                                  ;;;        call    dot
  1560 0000076A FEC1                            inc     cl
  1561 0000076C FF06[6403]                      inc     word [npages]   ; count total pages
  1562 00000770 88C5                            mov     ch,al
  1563                                  
  1564 00000772 08C0                            or      al,al           ; set C=0
  1565 00000774 75ED                            jnz     .1              ; loop through all of them
  1566 00000776 F5                              cmc                     ; set C=1
  1567 00000777 F5                      .6:     cmc
  1568 00000778 19C0                            sbb     ax,ax           ; save the Carry
  1569 0000077A 8B3E[DC02]                      mov     di,[map_avail]
  1570                                  %if 0
  1571                                          push    ax
  1572                                          mov     ax,di
  1573                                          call    wout
  1574                                          pop     ax
  1575                                  %endif
  1576                                  %if 0
  1577                                          call    add_to_list
  1578                                  %if 0
  1579                                          push    ax
  1580                                          mov     ax,di
  1581                                          call    wout
  1582                                          pop     ax
  1583                                  %endif
  1584                                          cmp     di,-1
  1585                                          je      .8
  1586                                          mov     [map_avail],di  ;
  1587                                  .8:
  1588                                  %else
  1589 0000077E E81EFD                          call    add_to_list2
  1590 00000781 893E[DC02]                      mov     [map_avail],di  ;
  1591                                  %endif
  1592 00000785 D1E8                            shr     ax,1            ; restore the Carry
  1593 00000787 89F8                            mov     ax,di           ; compute the index
  1594 00000789 5F59                            popm    di,cx
  1595 0000078B C3                              ret
  1596                                  
  1597                                  ; Return Page Present flag (Carry==1)
  1598                                  ;       DH = board number in the high 4 bits
  1599                                  ;       AL = page number (0..FE)
  1600                                  ;
  1601                                  page_present:
  1602 0000078C 515250                          pushm   ax,dx,cx
  1603 0000078F 1E                              pushm   ds
  1604                                  %if 0
  1605                                          push    ax
  1606                                          mov     al,dh
  1607                                          call    bout
  1608                                          pop     ax
  1609                                          call    bout
  1610                                  %endif
  1611 00000790 88C4                            mov     ah,al                   ; save the page to be tested
  1612 00000792 B228                            mov     dl,TEST_FRAME>>10
  1613 00000794 E8E9FC                          call    get
  1614 00000797 86E0                            xchg    ah,al                   ; save present setting in AH
  1615 00000799 E8C3FC                          call    put                     ; set the map
  1616 0000079C 6800A0                          push    TEST_FRAME
  1617 0000079F 1F                              popm    ds
  1618                                  .1:
  1619 000007A0 8B0E0000                        mov     cx,word [0]     ; save contents
  1620 000007A4 C70600006CA5                    mov     word [0],0a56ch ; addressing is [DS:0]
  1621 000007AA 89DB                            mov     bx,bx
  1622 000007AC 89C0                            mov     ax,ax           ; waste time
  1623 000007AE 813E00006CA5                    cmp     word [0],0a56ch ; see if it is the same
  1624 000007B4 7521                            jne     .8
  1625 000007B6 890E0000                        mov     word [0],cx     ; restore
  1626 000007BA 8B0EFC03                        mov     cx,word [1020]
  1627 000007BE C706FC03325A                    mov     word [1020],05a32h  ; address [DS:1020]
  1628 000007C4 89C0                            mov     ax,ax
  1629 000007C6 89DB                            mov     bx,bx
  1630 000007C8 813EFC03325A                    cmp     word [1020],05a32h
  1631 000007CE 7507                            jne     .8
  1632 000007D0 890EFC03                        mov     word [1020],cx  ; restore
  1633                                  ;  if words are equal, the carry is clear because there was no borrow
  1634 000007D4 F8                              clc
  1635 000007D5 EB01                            jmp     .9
  1636                                  
  1637                                  ; Memory test succeeded at the address
  1638                                  .8:
  1639 000007D7 F9                              stc             ; flag not present (C=1; will be complemented C=0)
  1640                                  .9:
  1641 000007D8 F5                              cmc             ; zero Carry on equal (memory present) made C=1
  1642 000007D9 1F                              popm    ds
  1643 000007DA 19C9                            sbb     cx,cx
  1644 000007DC 86E0                            xchg    ah,al
  1645 000007DE E87EFC                          call    put
  1646 000007E1 D1E9                            shr     cx,1
  1647 000007E3 585A59                          popm    ax,dx,cx
  1648 000007E6 C3                              ret
  1649                                  
  1650                                  ;  Formatted string print
  1651                                  ;       C-calling convention
  1652                                  ;               fprint(fmt, ...)
  1653                                  ;       String is NUL terminated
  1654                                  ;       Escape character is '$'
  1655                                  ;               Escapes are:    $d      decimal value
  1656                                  ;                               $X      hex word
  1657                                  ;                               $x      hex byte
  1658                                  ;                               none others at this time
  1659                                  fprint:
  1660 000007E7 55                              push    bp
  1661 000007E8 89E5                            mov     bp,sp
  1662 000007EA 565350                          pushm   ax,bx,si
  1663                                  
  1664 000007ED 8B7604                          mov     si,[bp+4]       ; get format string pointer
  1665 000007F0 8D5E06                          lea     bx,[bp+6]       ; get argument pointer pointer
  1666                                  .1:
  1667 000007F3 AC                              lodsb                   ; get byte
  1668 000007F4 08C0                            or      al,al           ; test for end of string
  1669 000007F6 7434                            jz      .9
  1670 000007F8 3C24                            cmp     al,'$'          ; test for escape
  1671 000007FA 752B                            jne     .7
  1672                                  
  1673 000007FC AC                              lodsb                   ; get format character
  1674 000007FD 3C64                            cmp     al,'d'          ; decimal value
  1675 000007FF 750A                            jne     .2
  1676                                  ; print a decimal value
  1677 00000801 368B07                      ss  mov     ax,word [bx]
  1678 00000804 43                              inc     bx
  1679 00000805 43                              inc     bx
  1680 00000806 E8B1FD                          call    dout            ; decimal value
  1681 00000809 EBE8                            jmp     .1
  1682                                  .2:
  1683 0000080B 3C58                            cmp     al,'X'          ; hexadecimal word?
  1684 0000080D 750A                            jne     .3
  1685 0000080F 368B07                      ss  mov     ax,word [bx]
  1686 00000812 43                              inc     bx
  1687 00000813 43                              inc     bx
  1688 00000814 E8BCFD                          call    wout            ; hex word printed
  1689 00000817 EBDA                            jmp     .1
  1690                                  .3:
  1691 00000819 3C78                            cmp     al,'x'          ; hexadecimal byte?
  1692 0000081B 750A                            jne     .4
  1693 0000081D 368B07                      ss  mov     ax,word [bx]
  1694 00000820 43                              inc     bx
  1695 00000821 43                              inc     bx
  1696 00000822 E8B5FD                          call    bout            ; hex byte printed
  1697 00000825 EBCC                            jmp     .1
  1698                                  .4:
  1699                                  .7:
  1700 00000827 E8C5FD                          call    putchar         ; not special, put out the character
  1701 0000082A EBC7                            jmp     .1
  1702                                  .9:
  1703 0000082C 585B5E                          popm    ax,bx,si
  1704 0000082F C9                              leave
  1705 00000830 C3                              ret
  1706                                  
  1707 00000831 0D0A                    fmt1:   db      CR,LF
  1708 00000833 344D65676162797465-             db      "4Megabyte Expanded Memory (4MEM / LIM EMS 3.2) manager for the SBC-188"
  1708 0000083C 20457870616E646564-
  1708 00000845 204D656D6F72792028-
  1708 0000084E 344D454D202F204C49-
  1708 00000857 4D20454D5320332E32-
  1708 00000860 29206D616E61676572-
  1708 00000869 20666F722074686520-
  1708 00000872 5342432D313838     
  1709 00000879 0D0A                            db      CR,LF
  1710 0000087B 202020202020202020-             db      "             driver version $d.$d", VERSION_SUFFIX
  1710 00000884 202020206472697665-
  1710 0000088D 722076657273696F6E-
  1710 00000896 2024642E2464       
  1711                                  %ifdef __DATE__
  1712                                  %ifdef __TIME__
  1713 0000089C 2028323032342D3130-             db      " (",__DATE__," ",__TIME__,")"
  1713 000008A5 2D32382030323A3539-
  1713 000008AE 3A333229           
  1714                                  %endif
  1715                                  %else
  1716                                          db      "  (",DATE,")"
  1717                                  %endif
  1718                                  double_space:
  1719 000008B2 0D0A                            db      CR,LF
  1720 000008B4 0D0A00                          db      CR,LF,NUL
  1721                                  
  1722 000008B7 344D454D20626F6172-     fmt2:   db      "4MEM board[$d]   $d pages total, ",NUL
  1722 000008C0 645B24645D20202024-
  1722 000008C9 642070616765732074-
  1722 000008D2 6F74616C2C2000     
  1723 000008D9 246420617661696C61-     fmt2a:  db      "$d available"
  1723 000008E2 626C65             
  1724 000008E5 0D0A00                  fmt_NL: db      CR,LF,NUL
  1725                                  
  1726 000008E8 4672616D6520617420-     fmt3:   db      "Frame at $X with $d handles"
  1726 000008F1 245820776974682024-
  1726 000008FA 642068616E646C6573 
  1727 00000903 0D0A00                          db      CR,LF,NUL
  1728                                  
  1729                                  
  1730                                  
