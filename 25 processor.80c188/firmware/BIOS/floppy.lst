     1                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     2                                  ; floppy.asm -- WD37C65B floppy disk controller driver
     3                                  ;		Version 2.0 -- Apr 2013, JRC
     4                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     5                                  ;
     6                                  ;   This version is for assembly by  NASM 0.98.39 or later
     7                                  ;
     8                                  ; Copyright (C) 2010-2013 John R. Coffman.  All rights reserved.
     9                                  ; Provided for hobbyist use on the N8VEM SBC-188 board.
    10                                  ;
    11                                  ; This program is free software: you can redistribute it and/or modify
    12                                  ; it under the terms of the GNU General Public License as published by
    13                                  ; the Free Software Foundation, either version 3 of the License, or
    14                                  ; (at your option) any later version.
    15                                  ;
    16                                  ; This program is distributed in the hope that it will be useful,
    17                                  ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    18                                  ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    19                                  ; GNU General Public License for more details.
    20                                  ;
    21                                  ; You should have received a copy of the GNU General Public License
    22                                  ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    23                                  ;
    24                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    25                                  %include        "config.asm"
    26                              <1> ;/*
    27                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    28                              <1> ; ANSI.CFG
    29                              <1> ;   Copied to CONFIG.ASM for general release.
    30                              <1> ;
    31                              <1> ;       Modify the parameters below to reflect your system
    32                              <1> ;
    33                              <1> ;
    34                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    35                              <1> ;
    36                              <1> ;   Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    37                              <1> ;   Provided for hobbyist use on the N8VEM SBC-188 board.
    38                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    39                              <1> ;
    40                              <1> ; Define the serial terminal that the Video BIOS must emulate
    41                              <1> ; Set one of the following to 1
    42                              <1> ; If you have no idea what to choose, set TTY to 1
    43                              <1> TTY     equ     0       ; hardcopy -- cannot position the cursor
    44                              <1> DUMB    equ     0       ; dumb CRT -- ^H, ^J, ^K, ^L can move the cursor
    45                              <1> ANSI    equ     1       ; very smart, like a VT-100
    46                              <1> WYSE    equ     0       ; very smart Wyse series (30, 50, ...)
    47                              <1> ; others may get added in the future
    48                              <1> ;  ONE OF THE ABOVE must BE SET TO 1!!!!!
    49                              <1> ;
    50                              <1> ; Does the hardware configuration contain the Color Video Display Unit?
    51                              <1> ; Both the 8563 and the 8242 are used.  The default is CVDU=0
    52                              <1> CVDU	equ	0	; system does not have the CVDU
    53                              <1> ;
    54                              <1> ; Does the hardware configuration contain the VGA3 a/n Video card?
    55                              <1> ; The 8563 will be disabled, but the 8242 code is shared with the CVDU
    56                              <1> ; The default is VGA3=0
    57                              <1> VGA3    equ     0       ; system does not have the VGA3
    58                              <1> %if 0
    59                              <1> 	*/
    60                              <1> #define VGA3 0
    61                              <1> /*
    62                              <1> %endif
    63                              <1> ;
    64                              <1> ; Boot up keyboard mode:  20h for NumLock on
    65                              <1> ;CVDU_KEYBOARD_STATUS	equ	0	; NumLock OFF
    66                              <1> CVDU_KEYBOARD_STATUS	equ	20h	; NumLock ON
    67                              <1> 
    68                              <1> ; Define the UART startup bit rate - 1200-19200 are most common
    69                              <1> ;UART_RATE	equ	0		; 1200
    70                              <1> ;UART_RATE	equ	1		; 2400
    71                              <1> ;UART_RATE	equ	2		; 4800
    72                              <1> UART_RATE	equ	3		; 9600
    73                              <1> ;UART_RATE	equ	4		; 19200
    74                              <1> ;UART_RATE	equ	5		; 38400
    75                              <1> ;UART_RATE	equ	6		; 57600
    76                              <1> ;UART_RATE	equ	7		; 115200
    77                              <1> 
    78                              <1> ; Does the serial terminal use the DSR/DTR protocol for flow control?
    79                              <1> ;UART_DSR_PROTOCOL	equ		1	; Yes!
    80                              <1> UART_DSR_PROTOCOL       equ             WYSE    ; Wyse always uses it
    81                              <1> 						; but not ANSI
    82                              <1> ; Define the size of the ROM image on the system in Kilobytes
    83                              <1> ; It may be smaller than the actual EPROM in use.
    84                              <1> ; The following sizes are supported:  32, 64, 128, and 256
    85                              <1> %ifndef ROM
    86                              <1> ROM             equ     64              ; 64 is the default
    87                              <1> %endif
    88                              <1> 
    89                              <1> ; Define the number of Wait States at which the ROM operates
    90                              <1> ROM_WS          equ     1               ; 0..3  (1 is the default)
    91                              <1> 
    92                              <1> ; Define the size in Kilobytes of DOS RAM (low SRAM plus EMM allocate RAM)
    93                              <1> ; This is a desired size and will only be present if a 4MEM board is added
    94                              <1> RAM_DOS         equ     640
    95                              <1> 
    96                              <1> ; Define the size of the low SRAM on the system in Kilobytes
    97                              <1> ; the default is 512 kilobytes
    98                              <1> RAM             equ     512             ; (512 is the default)
    99                              <1> 
   100                              <1> ; Define the number of Wait States at which the RAM operates
   101                              <1> RAM_WS          equ     0               ; 0..3  (0 is the default)
   102                              <1> 
   103                              <1> ; Define the number of Wait States for Local Peripheral devices (600-7FF)
   104                              <1> LCL_IO_WS       equ     1               ; 0..3  (1 is the default)
   105                              <1> 
   106                              <1> ; Define the number of Wait States for ECB BUS peripheral devices (4xx)
   107                              <1> BUS_IO_WS       equ     3               ; 0..3  (3 is the default)
   108                              <1> 
   109                              <1> ; Define the time zone in which we build the Relocatable BIOS
   110                              <1> %ifndef TIMEZONE
   111                              <1> %define TIMEZONE "CDT"
   112                              <1> %endif
   113                              <1> 
   114                              <1> ; Has the REDBUG debugger been loaded?
   115                              <1> %ifndef SOFT_DEBUG
   116                              <1> %define SOFT_DEBUG 1
   117                              <1> %endif
   118                              <1> 
   119                              <1> ; Should the BIOS include "Tiny BASIC" in the image?
   120                              <1> %ifndef TBASIC
   121                              <1> TBASIC          equ     1		; default is 1
   122                              <1> %endif
   123                              <1> 
   124                              <1> ; Should the BIOS include the Floating Point Emulator?  The 80188 does
   125                              <1> ; not allow a floating point co-processor, so this is probably a good idea.
   126                              <1> %ifndef FPEM
   127                              <1> FPEM            equ     1               ; default is 1
   128                              <1> %endif
   129                              <1> 
   130                              <1> ; Define the maximum number of EMM (4MEM) boards supported
   131                              <1> EMM_BOARDS      equ     0
   132                              <1> 
   133                              <1> ; Should the Floating Point Emulator use temporary storage in the EBDA
   134                              <1> ; or at locations 0280h..3FFh in low memory?
   135                              <1> %if SOFT_DEBUG
   136                              <1> FPEM_USE_EBDA   equ     FPEM            ; default is 0
   137                              <1> %else
   138                              <1> FPEM_USE_EBDA   equ     0; FPEM            ; default is 0
   139                              <1> %endif
   140                              <1> 
   141                              <1> ; Define the size of the EPROM that is to be installed on the system
   142                              <1> ; It may be larger than the actual ROM image to be generated.
   143                              <1> %ifndef CHIP
   144                              <1> CHIP            equ     64
   145                              <1> %endif
   146                              <1> 
   147                              <1> ; Does the SBC-188 00.4 board have the LS138/LS08 piggyback fix
   148                              <1> ; Set to 1 for the SBC-188 v1.0 and later production boards
   149                              <1> ;FDC_PIGGYBACK_FIX       equ     0       ; Fix not installed
   150                              <1> FDC_PIGGYBACK_FIX       equ     1       ; fix  IS  installed
   151                              <1> 
   152                              <1> ; On SBC-188 rev 00.4 board, there is a published hardware fix (2010-09-18).
   153                              <1> ; If the wiring update is installed, or you have a later board, then
   154                              <1> ; set this to 0.  If you are using the software workaround, then set this
   155                              <1> ; to 1.  The rev 1.0 board has this fix already.
   156                              <1> NEED_TIMER_FIX  equ     0               ; have revised hardware
   157                              <1> ;NEED_TIMER_FIX  equ     1               ; use workaround
   158                              <1> 
   159                              <1> ; Define the UART oscillator speed
   160                              <1> UART_OSC        equ     1843200         ; 1.8432 Mhz is specified
   161                              <1> 
   162                              <1> 
   163                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   164                              <1> ; end of the User configuration
   165                              <1> ;       Do Not modify anything below this point
   166                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   167                              <1> 
   168                              <1> CVDU_8563	equ	CVDU		; separate inits
   169                              <1> CVDU_8242	equ	CVDU|VGA3 	; separate inits
   170                              <1> VGA3_6445       equ     VGA3            ; separate inits
   171                              <1> ; Suppress all UART output in color video Mode 3
   172                              <1> UART_MODE3_SUPPRESS	equ	CVDU_8563
   173                              <1> CVDU_USE_MSDOS_KLUDGE	equ	0; CVDU_8242	; bad, bad MSDOS
   174                              <1> CVDU_USE_KBD_HOOK		equ	CVDU_8242
   175                              <1> 
   176                              <1> ; Define existence of any uart chip
   177                              <1> UART		equ	TTY+DUMB+ANSI+WYSE
   178                              <1> startuplength   equ     512                     ; may be up to 1024
   179                              <1> startseg        equ     0FFFFh - (ROM*64) + 1
   180                              <1> highrom         equ     (ROM*400h)&0FFFFh
   181                              <1> startupseg      equ     0FFFFh - (startuplength>>4) + 1
   182                              <1> bios_data_seg   equ     040h            ; segment of BIOS data area
   183                              <1> 
   184                              <1> 
   185                              <1> %define ARG(n) [bp+2+(n)*2]
   186                              <1> 
   187                              <1> %macro  check   1.nolist
   188                              <1>  %if (%1)
   189                              <1>    %error Check Failure: %1
   190                              <1>  %endif
   191                              <1> %endm
   192                              <1> %macro  range   3.nolist
   193                              <1>  %if (%1)<(%2)
   194                              <1>    %error Out of Range: %1
   195                              <1>  %elif (%1)>(%3)
   196                              <1>    %error Out of Range: %1
   197                              <1>  %endif
   198                              <1> %endm
   199                              <1> _terminal equ UART+CVDU
   200                              <1>  check   RAM_DOS&15
   201                              <1>  check   RAM&(RAM-1)
   202                              <1>  check   ROM&(ROM-1)
   203                              <1>  range   RAM,32,512
   204                              <1>  range   ROM,32,256
   205                              <1>  range   RAM_WS,0,3
   206                              <1>  range   ROM_WS,0,3
   207                              <1>  range   RAM_DOS,RAM,(1024-ROM)
   208                              <1>  range   LCL_IO_WS,0,3
   209                              <1>  range   BUS_IO_WS,0,3
   210                              <1>  range   UART_OSC,500000,16000000
   211                              <1>  range   UART_RATE,0,7
   212                              <1>  range	 UART,0,1
   213                              <1>  range	 _terminal,1,2
   214                              <1> 
   215                              <1> %ifndef SOFT_DEBUG
   216                              <1> %define SOFT_DEBUG 0
   217                              <1> %endif
   218                              <1> 
   219                              <1> %ifndef TRACE
   220                              <1> %define TRACE 0
   221                              <1> %endif
   222                              <1> 
   223                              <1> %ifdef MAKE_OBJECT_FILE
   224                              <1>         segment _DATA WORD PUBLIC CLASS=DATA
   225                              <1>         export _ROMsize
   226                              <1>         export _CHIPsize
   227                              <1> _ROMsize        dw      ROM
   228                              <1> _CHIPsize       dw      CHIP
   229                              <1> %endif
   230                              <1> ; end of the Hardware configuration file
   231                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   232                              <1> ;*/
    26                                  %include        "cpuregs.asm"
    27                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    28                              <1> ; CPUREGS.ASM
    29                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    30                              <1> ;
    31                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    32                              <1> ;
    33                              <1> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    34                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    35                              <1> ;
    36                              <1> ; This program is free software: you can redistribute it and/or modify
    37                              <1> ; it under the terms of the GNU General Public License as published by
    38                              <1> ; the Free Software Foundation, either version 3 of the License, or
    39                              <1> ; (at your option) any later version.
    40                              <1> ;
    41                              <1> ; This program is distributed in the hope that it will be useful,
    42                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    43                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    44                              <1> ; GNU General Public License for more details.
    45                              <1> ;
    46                              <1> ; You should have received a copy of the GNU General Public License
    47                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    48                              <1> ;
    49                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    50                              <1> %include	"macros.inc"
    51                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    52                              <2> ; MACROS.INC  
    53                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    54                              <2> ;
    55                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    56                              <2> ;
    57                              <2> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    58                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    59                              <2> ;
    60                              <2> ; This program is free software: you can redistribute it and/or modify
    61                              <2> ; it under the terms of the GNU General Public License as published by
    62                              <2> ; the Free Software Foundation, either version 3 of the License, or
    63                              <2> ; (at your option) any later version.
    64                              <2> ;
    65                              <2> ; This program is distributed in the hope that it will be useful,
    66                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    67                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    68                              <2> ; GNU General Public License for more details.
    69                              <2> ;
    70                              <2> ; You should have received a copy of the GNU General Public License
    71                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    72                              <2> ;
    73                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    74                              <2> 
    75                              <2> ; general macros for the SBC188 BIOS ASSEMBLY
    76                              <2> ;
    77                              <2> ;
    78                              <2> %ifndef __MACROS_DEFINED_
    79                              <2> %define __MACROS_DEFINED_ 1
    80                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    81                              <2> ;
    82                              <2> ; some useful macros:
    83                              <2> ;
    84                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    85                              <2> ;
    86                              <2> 	cpu	186
    87                              <2> 
    88                              <2> %imacro setloc  1.nolist
    89                              <2>  times   (%1-($-$$)) db 0FFh
    90                              <2> %endm
    91                              <2> 
    92                              <2> %imacro db_lo   1
    93                              <2>  db (%1)&255
    94                              <2> %endm
    95                              <2> 
    96                              <2> %imacro cnop    0.nolist
    97                              <2> %if SOFT_DEBUG
    98                              <2>         nop
    99                              <2> %endif
   100                              <2> %endm
   101                              <2> 
   102                              <2> %imacro popm 1-*.nolist
   103                              <2> %rep %0
   104                              <2> %ifidni %1,ALL
   105                              <2>  popa
   106                              <2> %elifidni %1,F
   107                              <2>  popf
   108                              <2> %else
   109                              <2>  pop %1
   110                              <2> %ifidni %1,DS
   111                              <2>  cnop
   112                              <2> %elifidni %1,ES
   113                              <2>  cnop
   114                              <2> %endif
   115                              <2> %endif
   116                              <2> %rotate 1
   117                              <2> %endrep
   118                              <2> %endm
   119                              <2> 
   120                              <2> %imacro pushm 1-*.nolist
   121                              <2> %rep %0
   122                              <2> %rotate -1
   123                              <2> %ifidni %1,ALL
   124                              <2>  pusha
   125                              <2> %elifidni %1,F
   126                              <2>  pushf
   127                              <2> %else
   128                              <2>  push %1
   129                              <2> %endif
   130                              <2> %endrep
   131                              <2> %endm
   132                              <2> 
   133                              <2> ;
   134                              <2> ; added from the 386EX project
   135                              <2> ;
   136                              <2> 
   137                              <2> ; call arguments
   138                              <2> %define ARG(n) [bp+2+(n)*2]
   139                              <2> 
   140                              <2> ;
   141                              <2> ; format of the BYTE initialization table:  address, byte
   142                              <2> ;
   143                              <2> %imacro  binit 2
   144                              <2>         dw      %1
   145                              <2>         db      %2
   146                              <2> %endmacro
   147                              <2> ; end with DW -1
   148                              <2> 
   149                              <2> ;
   150                              <2> ; format of the WORD initialization table:  address, word
   151                              <2> ;
   152                              <2> %imacro  winit 2
   153                              <2>         dw      %1
   154                              <2>         dw      %2
   155                              <2> %endmacro
   156                              <2> ; end with DW -1
   157                              <2> 
   158                              <2> 
   159                              <2> ; get the BIOS Data Area segment pointer to a [segment] register
   160                              <2> %imacro get_bda	1.nolist
   161                              <2> 	push	0x0040
   162                              <2> 	pop	%1
   163                              <2> 	cnop
   164                              <2> %endm
   165                              <2> 
   166                              <2> 
   167                              <2> %endif
    51                              <1> 
    52                              <1> 	cpu     186
    53                              <1> ;
    54                              <1> ;
    55                              <1> ; IBM model byte -- must be less than a 286
    56                              <1> ;
    57                              <1> ;MODEL_BYTE		equ	0FEh	; PC-XT
    58                              <1> ;SUBMODEL_BYTE		equ	0FFh	; not used
    59                              <1> 
    60                              <1> MODEL_BYTE		equ	0FEh	; PC-XT
    61                              <1> SUBMODEL_BYTE		equ	00h	;  "
    62                              <1> 
    63                              <1> 
    64                              <1> ; 80188 peripheral control register block address
    65                              <1> CPU_CSCR	        equ	0FF00h
    66                              <1> 
    67                              <1> ; Compatible Mode registers
    68                              <1> 
    69                              <1> cpu_relocation          equ     CPU_CSCR+0FEh
    70                              <1> 
    71                              <1> ; The memory and peripheral chip select register offsets from 0FF00h
    72                              <1> 
    73                              <1> cpu_umcs                equ     CPU_CSCR+0A0h          ; Upper memory select
    74                              <1> cpu_lmcs                equ     CPU_CSCR+0A2h          ; Lower memory select
    75                              <1> cpu_pacs                equ     CPU_CSCR+0A4h          ; Peripheral select
    76                              <1> cpu_mmcs                equ     CPU_CSCR+0A6h          ; Middle memory base
    77                              <1> cpu_mpcs                equ     CPU_CSCR+0A8h          ; Mid mem. & peripherals
    78                              <1> 
    79                              <1> ; Enhanced Mode registers
    80                              <1> 
    81                              <1> cpu_mdram               equ     CPU_CSCR+0E0h          ; memory partition reg.
    82                              <1> cpu_cdram               equ     CPU_CSCR+0E2h          ; clock prescaler
    83                              <1> cpu_edram               equ     CPU_CSCR+0E4h          ; Enable refresh reg.
    84                              <1> cpu_pdcon               equ     CPU_CSCR+0F0h          ; Power-Save control
    85                              <1> 
    86                              <1> 
    87                              <1> ; On-board internal peripheral equates
    88                              <1> ; Programmable Interrupt Controller
    89                              <1> PIC	        equ	CPU_CSCR+020H
    90                              <1> PIC_EOI	        equ	PIC+2           ; End Of Interrupt
    91                              <1> PIC_POLLR	equ	PIC+4
    92                              <1> PIC_POLLSR	equ	PIC+6
    93                              <1> PIC_IMASK	equ	PIC+8
    94                              <1> PIC_PMREG	equ	PIC+0AH
    95                              <1> PIC_SRVR	equ	PIC+0CH
    96                              <1> PIC_IRQR	equ	PIC+0EH
    97                              <1> PIC_IRQSR	equ	PIC+10H
    98                              <1> PIC_TCR	        equ	PIC+12H
    99                              <1> PIC_DMA0CR	equ	PIC+14H
   100                              <1> PIC_DMA1CR	equ	PIC+16H
   101                              <1> PIC_I0CON	equ	PIC+18H
   102                              <1> PIC_I1CON	equ	PIC+1AH
   103                              <1> PIC_I2CON	equ	PIC+1CH
   104                              <1> PIC_I3CON	equ	PIC+1EH
   105                              <1> 
   106                              <1> EOI_NSPEC       equ     8000h           ; Non-Specific EOI
   107                              <1> 
   108                              <1> ; Interrupt masks (Master Mode)
   109                              <1> ;
   110                              <1> mask_timer_all          equ     0001h
   111                              <1> mask_dma0               equ     0004h
   112                              <1> mask_dma1               equ     0008h
   113                              <1> mask_int0               equ     0010h
   114                              <1> mask_int1               equ     0020h
   115                              <1> mask_int2               equ     0040h
   116                              <1> mask_int3               equ     0080h
   117                              <1> 
   118                              <1> 
   119                              <1> 
   120                              <1> ; Timers
   121                              <1> TIM0	        equ	CPU_CSCR+050H
   122                              <1> TIM1	        equ	CPU_CSCR+058H
   123                              <1> TIM2	        equ	CPU_CSCR+060H
   124                              <1> 
   125                              <1> TCNT	        equ	0	; count register
   126                              <1> CMPA	        equ	2	; max count A
   127                              <1> CMPB	        equ	4	; max count B (not present on TIM2)
   128                              <1> TCON	        equ	6	; mode/control word
   129                              <1> 
   130                              <1> ; Timer control bits:
   131                              <1> tc_EN           equ     8000h   ; Enable bit
   132                              <1> tc_nINH         equ     4000h   ; not Inhibit Enable
   133                              <1> tc_INT          equ     2000h   ; Interrupt Enable
   134                              <1> tc_RIU          equ     1000h   ; Register A/B (0/1) in Use
   135                              <1> tc_MC           equ     0020h   ; Maximum Count reached
   136                              <1> tc_RTG          equ     0010h   ; Retrigger (internal source)
   137                              <1> tc_P            equ     0008h   ; Prescale internal clock (timers 0 & 1 only)
   138                              <1> tc_EXT          equ     0004h   ; External clock
   139                              <1> tc_ALT          equ     0002h   ; Alternate between A & B max count registers
   140                              <1> tc_CONT         equ     0001h   ; Continuous: continue after max count
   141                              <1> 
   142                              <1> 
   143                              <1> 
   144                              <1> 
   145                              <1> ; DMA
   146                              <1> DMA0	        equ	CPU_CSCR+0C0H
   147                              <1> DMA1	        equ	CPU_CSCR+0D0H
   148                              <1> DMASPL	        equ	0	; source pointer low
   149                              <1> DMASPU	        equ	2	; source pointer high
   150                              <1> DMADPL	        equ	4	; destination pointer low
   151                              <1> DMADPU	        equ	6	; destination pointer high
   152                              <1> DMATC	        equ	8	; terminal count
   153                              <1> DMACW	        equ	0AH	; control word
   154                              <1> 
   155                              <1> 
   156                              <1> 
   157                              <1> 
   158                              <1> 
   159                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   160                              <1> ;
   161                              <1> ;       SBC-188 external devices
   162                              <1> ;
   163                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   164                              <1> 
   165                              <1> IO_BASE			equ	0400h
   166                              <1> 
   167                              <1> 
   168                              <1> 
   169                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   170                              <1> ; The UART registers
   171                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   172                              <1> 
   173                              <1> uart_base               equ     IO_BASE+0280h
   174                              <1> uart_rbr                equ     uart_base       ;Rcvr Buffer / read only
   175                              <1> uart_thr                equ     uart_base       ;Transmit Holding / write only
   176                              <1> uart_ier                equ     uart_base+1     ;Interrupt Enable
   177                              <1> uart_iir                equ     uart_base+2     ;Interrupt Ident / read only
   178                              <1> uart_fcr                equ     uart_base+2     ;FIFO Control / write only
   179                              <1> uart_lcr                equ     uart_base+3     ;Line Control
   180                              <1> uart_mcr                equ     uart_base+4     ;Modem Control
   181                              <1> uart_lsr                equ     uart_base+5     ;Line Status
   182                              <1> uart_msr                equ     uart_base+6     ;Modem Status
   183                              <1> uart_sr			equ	uart_base+7	;Scratch
   184                              <1> 
   185                              <1> uart_dll                equ     uart_base       ;Divisor Latch LS Byte
   186                              <1> uart_dlm                equ     uart_base+1     ;Divisor Latch MS Byte
   187                              <1> 
   188                              <1> 
   189                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   190                              <1> ; Floppy controller
   191                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   192                              <1> FDC	        equ	IO_BASE+0200H
   193                              <1> FDC_MSR         equ     FDC
   194                              <1> FDC_DATA        equ     FDC_MSR+1
   195                              <1> FDC_DACK        equ	FDC+10H
   196                              <1> FDC_LDOR	equ	FDC+20H
   197                              <1> FDC_LDCR	equ	FDC+30H
   198                              <1> FDC_TC	        equ	FDC+40H
   199                              <1> FDC_DACK_TC     equ     FDC_DACK | FDC_TC
   200                              <1> 
   201                              <1> 
   202                              <1> %if SBC188==1
   203                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   204                              <1> ;DS1302 RTC
   205                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   206                              <1> RTC	equ	IO_BASE+0300H
   207                              <1> %endif
   208                              <1> 
   209                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   210                              <1> ; PIO 82C55 I/O 
   211                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   212                              <1> ; for the SBCv1/v2 with PPIDE adapter board
   213                              <1> ; and for the SBCv3 with PPIDE connector
   214                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   215                              <1> PPI	        equ	IO_BASE+0260H
   216                              <1> 
   217                              <1> PIO_A	        equ	PPI+0	; (OUTPUT)
   218                              <1> PIO_B	        equ	PPI+1	; (INPUT)
   219                              <1> PIO_C	        equ	PPI+2	; (CENTRONICS control low nibble)  
   220                              <1> PIO_CTRL	equ	PPI+3	; CONTROL BYTE PIO 82C55
   221                              <1> 
   222                              <1> portA           equ     PPI+0   ;
   223                              <1> portB           equ     PPI+1   ;
   224                              <1> portC           equ     PPI+2   ;
   225                              <1> 
   226                              <1> 
   227                              <1> 
   228                              <1> ;;;%if SBC188==3   startup.asm is universal
   229                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   230                              <1> ; CONTROL LS259 PORT ON SBC188 V3
   231                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   232                              <1> CTRL259		equ	IO_BASE+0270H
   233                              <1> ; LEDS are at addresses 0..3
   234                              <1> ; other control ports on 4..7
   235                              <1> LED0		equ	CTRL259+0
   236                              <1> LED1		equ	LED0+1
   237                              <1> LED2		equ	LED0+2
   238                              <1> LED3		equ	LED0+3
   239                              <1> T1OSC18		equ	CTRL259+4	; ON=1.8432mhz, OFF="1" (for use of TIMER2)
   240                              <1> ;unused		equ	CTRL259+5
   241                              <1> FDC_RES		equ	CTRL259+6	; RESET IS ACTIVE HIGH
   242                              <1> IDE8_RES	equ	CTRL259+7	; fast IDE RESET IS ACTIVE LOW
   243                              <1> 
   244                              <1> 
   245                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   246                              <1> ; FIDE8 8-bit IDE on the 80C188 bus
   247                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   248                              <1> FIDE_BASE       equ     IO_BASE+2C0h
   249                              <1> 
   250                              <1> IDE8_CS0        equ     FIDE_BASE
   251                              <1> IDE8_CS1        equ     FIDE_BASE+0x10
   252                              <1> 
   253                              <1> ;;;%endif   startup.asm is universal
   254                              <1> 
   255                              <1> 
   256                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   257                              <1> ; Dual [DMA] IDE devices
   258                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   259                              <1> DIDE		equ	IO_BASE + 20H	; range 0x20..0x3F
   260                              <1> 
   261                              <1> DIDE0		equ	DIDE		; first interface (master & slave)
   262                              <1> DIDE1		equ	DIDE+10h	; second interface (master & slave)
   263                              <1> 
   264                              <1> 
   265                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   266                              <1> ; DISK I/O v3 device codes (PPIDE only)
   267                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   268                              <1> DISKIO		equ	IO_BASE + 20h	; range 0x20..0x3F
   269                              <1> 
   270                              <1> DISKIO_PPIDE	equ	DISKIO		; 82c55
   271                              <1> DISKIO_FDC	equ	DISKIO + 10h	; FDC 9266
   272                              <1> DISKIO_DOR	equ	DISKIO + 18h	; OPERATION REGISTER	
   273                              <1> 
   274                              <1> 
   275                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   276                              <1> ; MF/PIC interfaces
   277                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   278                              <1> MFPIC		equ	IO_BASE + 40h	; range 0x40..0x4F
   279                              <1> 
   280                              <1> ;MFPIC_202	equ	MFPIC		; NS32202 is not usable on SBC-188
   281                              <1> MFPIC_PPIDE	equ	MFPIC + 4	; PPIDE disk interface
   282                              <1> MFPIC_UART	equ	MFPIC + 8	; TL16Cx50 SIO chip
   283                              <1> 
   284                              <1> 
   285                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   286                              <1> ; Cassette I/O
   287                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   288                              <1> cuart_base	EQU 	IO_BASE+80H	; BASE IO ADDRESS OF CASSETTE UART
   289                              <1> cuart_rbr	equ     cuart_base	;Rcvr Buffer / read only
   290                              <1> cuart_thr	equ     cuart_base	;Transmit Holding / write only
   291                              <1> cuart_ier	equ     cuart_base+1	;Interrupt Enable
   292                              <1> cuart_iir	equ     cuart_base+2	;Interrupt Ident / read only
   293                              <1> cuart_fcr	equ     cuart_base+2	;FIFO Control / write only
   294                              <1> cuart_lcr	equ     cuart_base+3	;Line Control
   295                              <1> cuart_mcr	equ     cuart_base+4	;Modem Control
   296                              <1> cuart_lsr	equ     cuart_base+5	;Line Status
   297                              <1> cuart_msr	equ     cuart_base+6	;Modem Status
   298                              <1> cuart_sr	equ	cuart_base+7	;Scratch
   299                              <1> 
   300                              <1> cuart_dll	equ     cuart_base	;Divisor Latch LS Byte
   301                              <1> cuart_dlm	equ	cuart_base+1	;Divisor Latch MS Byte
   302                              <1> 
   303                              <1> 
   304                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   305                              <1> ;
   306                              <1> ;       4MEM control registers
   307                              <1> ;
   308                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   309                              <1> EMM_addr        equ     1               ; high 6 bits of 20-bit address
   310                              <1> EMM_page        equ     0               ; 4MEM page in [0..254]
   311                              <1> 
   312                              <1> EMM_BASE        equ     IO_BASE + 000h          ; first EMM (4MEM) board
   313                              <1> EMM_unmapped    equ     255             ; unmapped 4MEM page
   314                              <1> 
   315                              <1> EMM0            equ     EMM_BASE        ; first  EMM board
   316                              <1> EMM1            equ     EMM0 + 2        ; second EMM board
   317                              <1> EMM2            equ     EMM1 + 2        ; third  EMM board
   318                              <1> EMM3            equ     EMM2 + 2        ; fourth EMM board
   319                              <1> 
   320                              <1> 
   321                              <1> 
   322                              <1> 
   323                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   324                              <1> ;
   325                              <1> ;	ColorVDU devices
   326                              <1> ;
   327                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   328                              <1> ;
   329                              <1> ;	major select on the Z80 bus
   330                              <1> ;
   331                              <1> devCVDU_8bit	equ	0xE0		; this may change to 0x10
   332                              <1> 
   333                              <1> devCVDUbase 	equ	IO_BASE + devCVDU_8bit
   334                              <1> 
   335                              <1> M8563status	equ	devCVDUbase + 4		; 4 == bitrev(2)
   336                              <1> M8563register	equ	devCVDUbase + 4
   337                              <1> M8563data	equ	devCVDUbase + 12	; 12 == bitrev(3)
   338                              <1> 
   339                              <1> %if CVDU_8563
   340                              <1> I8242status	equ	devCVDUbase + 10	; 10 == bitrev(5)
   341                              <1> I8242command	equ	devCVDUbase + 10
   342                              <1> I8242data	equ	devCVDUbase + 2		; 2 == bitrev(4)
   343                              <1> %endif
   344                              <1> 
   345                              <1> 
   346                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   347                              <1> ;
   348                              <1> ;	VGA3 devices
   349                              <1> ;
   350                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   351                              <1> ;
   352                              <1> ;	major select on the Z80 bus
   353                              <1> ;
   354                              <1> devVGA3_8bit    equ     0xE0                    ; same as CVDU
   355                              <1> 
   356                              <1> devVGA3base       equ     IO_BASE + devVGA3_8bit
   357                              <1> 
   358                              <1> %if VGA3_6445
   359                              <1> I8242status	equ	devVGA3base + 1
   360                              <1> I8242command	equ	devVGA3base + 1
   361                              <1> I8242data	equ	devVGA3base + 0
   362                              <1> %endif
   363                              <1> HD6445addr	equ	devVGA3base + 2		; to address the HD6445 registers
   364                              <1> HD6445reg	equ	devVGA3base + 3		; to r/w a register on the CRTC
   365                              <1> 
   366                              <1> vga3cfg		equ	devVGA3base + 4
   367                              <1> ; the following are probably not used on the SBC-188, except for testing/checking
   368                              <1> vga3adhi	equ	devVGA3base + 5
   369                              <1> vga3adlo	equ	devVGA3base + 6
   370                              <1> vga3data	equ	devVGA3base + 7
   371                              <1> 
   372                              <1> 
   373                              <1> 
   374                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   375                              <1> ;
   376                              <1> ;       2S1P registers
   377                              <1> ;
   378                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   379                              <1> dev_2S1P_loc		equ	0xC0	; same as 4UART !!!
   380                              <1> 
   381                              <1> dev_2S1P_base		equ	IO_BASE + dev_2S1P_loc	
   382                              <1> 
   383                              <1> dev_2S1P_A		equ	dev_2S1P_base		; serial port
   384                              <1> dev_2S1P_B		equ	dev_2S1P_base + 8h	; serial port
   385                              <1> 
   386                              <1> dev_2S1P_C		equ	dev_2S1P_base + 10h	; parallel port
   387                              <1> 
   388                              <1> 
   389                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   390                              <1> ;
   391                              <1> ;       4UART registers
   392                              <1> ;
   393                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   394                              <1> dev_4UART_loc		equ	0xC0	; same as 2S1P !!!
   395                              <1> ;				0xA0	; possible alternate
   396                              <1> dev_4UART_alt_offset	equ	0xA0 - dev_4UART_loc
   397                              <1> 
   398                              <1> dev_4UART_base		equ	IO_BASE + dev_4UART_loc	
   399                              <1> 
   400                              <1> dev_4UART_A		equ	dev_4UART_base
   401                              <1> dev_4UART_B		equ	dev_4UART_base + 8h
   402                              <1> dev_4UART_C		equ	dev_4UART_base + 10h
   403                              <1> dev_4UART_D		equ	dev_4UART_base + 18h
   404                              <1> 
   405                              <1> dev_4UART_config	equ	dev_4UART_B + 7		; overlays scratch register
   406                              <1> 
   407                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   408                              <1> ; debug port -- JRC only
   409                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   410                              <1> portD		equ	IO_BASE + 0FFh		; 0x04FF
   411                              <1> ;portD		equ	portB		     ; older 8255 output on PPI
   412                              <1> 
   413                              <1> ; end CPUREGS.ASM
   414                              <1> 
    27                                  %include        "equates.asm"
    28                              <1> ;========================================================================
    29                              <1> ; EQUATES.ASM -- Lots of Defintions for Relocatable BIOS
    30                              <1> ;========================================================================
    31                              <1> ;   for the N8VEM SBC-188 v.00.4 and 00.5
    32                              <1> ;
    33                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    34                              <1> ;
    35                              <1> ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
    36                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    37                              <1> ;
    38                              <1> ; This program is free software: you can redistribute it and/or modify
    39                              <1> ; it under the terms of the GNU General Public License as published by
    40                              <1> ; the Free Software Foundation, either version 3 of the License, or
    41                              <1> ; (at your option) any later version.
    42                              <1> ;
    43                              <1> ; This program is distributed in the hope that it will be useful,
    44                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    45                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    46                              <1> ; GNU General Public License for more details.
    47                              <1> ;
    48                              <1> ; You should have received a copy of the GNU General Public License
    49                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    50                              <1> ;
    51                              <1> ;========================================================================
    52                              <1> 
    53                              <1>         global  FPEM_segment
    54                              <1> 
    55                              <1> 
    56                              <1> %include "segdef.asm"
    57                              <2> ;========================================================================
    58                              <2> ; SEGDEF.ASM -- Lots of Defintions for Relocatable BIOS
    59                              <2> ;========================================================================
    60                              <2> ;   for the N8VEM SBC-188 v.00.4 and 00.5
    61                              <2> ;
    62                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    63                              <2> ;
    64                              <2> ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
    65                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    66                              <2> ;
    67                              <2> ; This program is free software: you can redistribute it and/or modify
    68                              <2> ; it under the terms of the GNU General Public License as published by
    69                              <2> ; the Free Software Foundation, either version 3 of the License, or
    70                              <2> ; (at your option) any later version.
    71                              <2> ;
    72                              <2> ; This program is distributed in the hope that it will be useful,
    73                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    74                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    75                              <2> ; GNU General Public License for more details.
    76                              <2> ;
    77                              <2> ; You should have received a copy of the GNU General Public License
    78                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    79                              <2> ;
    80                              <2> ;========================================================================
    81                              <2> 
    82                              <2> %ifndef __SEGDEF_
    83                              <2> %define __SEGDEF_
    84                              <2> 
    85                              <2> 	SEGMENT  _TEXT ALIGN=2 PUBLIC CLASS=CODE
    86                              <2>         SEGMENT  CONST ALIGN=2 PUBLIC CLASS=DATA
    87                              <2>         SEGMENT  CONST2 ALIGN=2 PUBLIC CLASS=DATA
    88                              <2> 	SEGMENT  _DATA ALIGN=16 PUBLIC CLASS=DATA
    89                              <2> 	SEGMENT  _BSS  ALIGN=2 PUBLIC CLASS=BSS
    90                              <2> ;;;        SEGMENT  _BASIC ALIGN=16 PUBLIC CLASS=BASIC
    91                              <2> 
    92                              <2> 	GROUP	DGROUP CONST CONST2 _DATA _BSS
    93                              <2> 
    94                              <2> %endif
    95                              <2> 
    57                              <1> %include "ascii.asm"
    58                              <2> ; ascii.asm
    59                              <2> ;
    60                              <2> CTRL            equ     1Fh     ; masks a character to CTRL-x
    61                              <2> 
    62                              <2> NUL     equ     00h
    63                              <2> BEL     equ     (CTRL & 'G')
    64                              <2> BS      equ     08h		; ^H
    65                              <2> HT      equ     09h		; ^I
    66                              <2> LF	equ	0Ah		; ^J
    67                              <2> NL      equ     LF
    68                              <2> VT	equ	0Bh		; ^K
    69                              <2> FWD	equ	0Ch		; ^L
    70                              <2> CR	equ	0Dh
    71                              <2> XON     equ     (CTRL & 'Q')
    72                              <2> XOFF    equ     (CTRL & 'S')
    73                              <2> DC1     equ     XON
    74                              <2> DC3     equ     XOFF
    75                              <2> ESC     equ	1Bh
    76                              <2> 
    77                              <2> 
    58                              <1> 
    59                              <1> 
    60                              <1> ; POST error codes. Presently one byte but can expand to word.
    61                              <1> ER_BIOS equ	01h		; Bad ROM bios checksum, patch last byte
    62                              <1> ER_RAM	equ	02h		; Bad RAM in main memory, replace
    63                              <1> ER_CRT	equ	04h		; Bad RAM in video card, replace
    64                              <1> ER_FDC	equ	08h		; Bad FDC
    65                              <1> ER_UNK1	equ	10h		; {unassigned}
    66                              <1> ER_MEM	equ	20h		; Bad RAM in vector area, replace
    67                              <1> ER_ROM	equ	40h		; Bad ROM in expansion area, bad checksum
    68                              <1> ER_UNK2	equ	80h		; {unassigned}
    69                              <1> 
    70                              <1> 
    71                              <1> 
    72                              <1> ;; ************************ BIOS Data Segment ******************************
    73                              <1> ;; BIOS data segment - not all will  be used
    74                              <1> ;                struc   BIOS_DATA_AREA  ; at 0040:0000
    75                              <1> %include "bda.inc"
    76                              <2> ;/*======================================================================
    77                              <2> ; bda.inc -- BIOS data area definitions
    78                              <2> ;========================================================================
    79                              <2> ;   for the N8VEM SBC-188
    80                              <2> ;
    81                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    82                              <2> ;
    83                              <2> ; Copyright (C) 2013 John R. Coffman.  All rights reserved.
    84                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    85                              <2> ;
    86                              <2> ; This program is free software: you can redistribute it and/or modify
    87                              <2> ; it under the terms of the GNU General Public License as published by
    88                              <2> ; the Free Software Foundation, either version 3 of the License, or
    89                              <2> ; (at your option) any later version.
    90                              <2> ;
    91                              <2> ; This program is distributed in the hope that it will be useful,
    92                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    93                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    94                              <2> ; GNU General Public License for more details.
    95                              <2> ;
    96                              <2> ; You should have received a copy of the GNU General Public License
    97                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    98                              <2> ;
    99                              <2> ;========================================================================
   100                              <2> 
   101                              <2> 			;*/ extern				/*
   102                              <2> 	ABSOLUTE  0	;*/ struct BDA {			/*
   103 00000000 ????????????????    <2> serial_ports    resw    4	;*/	word	serial_ports[4];	/*
   104 00000008 ????????????????    <2> parallel_ports  resw    4	;*/	word	parallel_ports[4];	/*
   105 00000010 ????                <2> equipment_flag  resw    1	;*/	EQFL	equipment_flag;		/*
   106                              <2> ;	dw	?		; 40:10 	; Equipment present word
   107                              <2> ;  						;  = (1 iff floppies) *     1.
   108                              <2> ;                                               ;  + (1 iff 187     ) *     2.
   109                              <2> ;  						;  + (#+1 64K sys ram) *    4.
   110                              <2> ;  						;  + (init crt mode ) *    16.
   111                              <2> ;  						;  + (# of floppies ) *    64.
   112                              <2> ;  						;  + (# serial ports) *   512.
   113                              <2> ;  						;  + (1 iff toy port) *  4096.
   114                              <2> ;                                               ;  + (1 iff modem   ) *  8192.
   115                              <2> ;  						;  + (# parallel LPT) * 16384.
   116 00000012 ??                  <2> mfg_test_flags  resb    1	;*/	byte	mfg_test_flags;	/* 40:12 unused by us
   117 00000013 ????                <2> memory_size     resw    1	;*/	word	memory_size;	/* 40:13 kilobytes
   118                              <2> uart_kbd_ctrl_R	equ	$	;*/				/*** JRC: count of ctrl-R's for reboot
   119 00000015 ??                  <2> IPL_errors      resb    1	;*/	byte	IPL_errors;	/* 40:15 IPL errors<-table/scratchpad
   120 00000016 ??                  <2> sbc188_rev       resb    1	;*/	byte	sbc188_rev;	/* was 'unused_01' before BIOS047
   121                              <2> ;;---------------[Keyboard data area]------------;
   122 00000017 ????                <2> keyboard_flags_0 resw   1	;*/	word	keyboard_flags_0;  /* 40:17 Shift/Alt/etc. keyboard flags
   123                              <2> keyboard_flags_1 equ	$-1	;     2nd byte	keyboard_flags_1;  
   124 00000019 ??                  <2> keypad_char	resb	1	;*/	byte	keypad_char;	/* 40:19 Alt-KEYPAD char. goes here
   125 0000001A ????                <2> kbd_buffer_head resw    1	;*/	word	kbd_buffer_head;   /* 40:1A --> keyboard buffer head
   126 0000001C ????                <2> kbd_buffer_tail resw    1	;*/	word	kbd_buffer_tail;   /* 40:1C --> keyboard buffer tail
   127 0000001E <res 20h>           <2> kbd_buffer      resw    16	;*/	word	kbd_buffer[16];	/* 40:1E Keyboard Buffer (Scan,Value)
   128                              <2> kbd_buffer_last	equ	$	;*/				/*
   129                              <2> ;;---------------[Diskette data area]------------;
   130 0000003E ??                  <2> fdc_drv_calib   resb    1	;*/	byte	fdc_drive_calib;   /* 40:3E
   131 0000003F ??                  <2> fdc_motor_LDOR  resb    1	;*/	byte	fdc_motor_LDOR;	   /* 40:3F Motor, DMA, select control
   132 00000040 ??                  <2> fdc_motor_ticks resb    1	;*/	byte	fdc_motor_ticks;   /* 40:40 ticks til motor off
   133 00000041 ??                  <2> fdc_status      resb    1	;*/	byte	fdc_status;	   /* 40:41
   134                              <2> ;				Floppy return code stat byte
   135                              <2> ;				;  1 = bad ic 765 command req.
   136                              <2> ;				;  2 = address mark not found
   137                              <2> ;				;  3 = write to protected disk
   138                              <2> ;				;  4 = sector not found
   139                              <2> ;				;  8 = data late (DMA overrun)
   140                              <2> ;				;  9 = DMA failed 64K page end
   141                              <2> ;				; 16 = bad CRC on floppy read
   142                              <2> ;				; 32 = bad NEC 765 controller
   143                              <2> ;				; 64 = seek operation failed
   144                              <2> ;				;128 = disk drive timed out
   145 00000042 ??????????????      <2> fdc_ctrl_status resb    7	;*/	byte	fdc_ctrl_status[7];  /* 40:42 Status bytes from NEC 765
   146                              <2> ;;---------------[Video display area]------------;
   147 00000049 ??                  <2> video_mode      resb    1	;*/	byte	video_mode;	/* 40:49
   148                              <2> ;			 	; Current CRT mode  (software)
   149                              <2> ;				;  0 = 40 x 25 text (no color)
   150                              <2> ;				;  1 = 40 x 25 text (16 color)
   151                              <2> ;				;  2 = 80 x 25 text (no color)
   152                              <2> ;				;  3 = 80 x 25 text (16 color)
   153                              <2> ;				;  4 = 320 x 200 grafix 4 color
   154                              <2> ;				;  5 = 320 x 200 grafix 0 color
   155                              <2> ;				;  6 = 640 x 200 grafix 0 color
   156                              <2> ;				;  7 = 80 x 25 text (mono card)
   157 0000004A ????                <2> video_columns   resw    1	;*/	word video_columns;	/* 40:4A Columns on CRT screen
   158 0000004C ????                <2> video_regen_bytes  resw 1	;*/	word video_regen_bytes;	/* 40:4C Bytes in the regen region
   159 0000004E ????                <2> video_regen_offset resw 1	;*/	word video_regen_offset;/* 40:4E Byte offset in regen region
   160 00000050 <res 10h>           <2> video_cursor_pos  resw  8	;*/	word video_cursor_pos[8];  /* 40:50 Cursor pos for up to 8 pages
   161 00000060 ????                <2> video_cursor_mode resw  1	;*/	word video_cursor_mode;	/* 40:60 Current cursor mode setting
   162 00000062 ??                  <2> video_page      resb    1	;*/	byte video_page;	/* 40:62 Current page on display
   163 00000063 ????                <2> video_base_seg  resw    1	;*/	word video_base_seg;	/* 40:63 Base address (B000h or B800h)
   164 00000065 ??                  <2> video_hw_mode   resb    1	;*/	byte video_hw_mode;	/* 40:65 ic 6845 mode reg. (hardware)
   165 00000066 ??                  <2> video_cga_palette resb  1	;*/	byte video_cga_palette;	/* 40:66 Current CGA palette
   166                              <2> ;;---------------[Used to setup ROM]-------------;
   167 00000067 ????????            <2> eprom_address   resd    1	;*/	dword eprom_address;	/* 40:67 Eprom base Offset,Segment
   168 0000006B ??                  <2> spurious_irq    resb    1	;*/	byte spurious_irq;	/* 40:6B Last spurious interrupt IRQ
   169                              <2> ;;---------------[Timer data area]---------------;
   170 0000006C ????????            <2> timer_ticks     resd    1	;*/	dword timer_ticks;	/* 40:6C Ticks since midnight (lo,hi)
   171 00000070 ??                  <2> timer_new_day   resb    1	;*/	byte timer_new_day;	/* 40:70 Non-zero if new day
   172                              <2> ;;---------------[System data area]--------------;
   173 00000071 ??                  <2> break_flag      resb    1	;*/	byte break_flag;	/* 40:71 Sign bit set iff break
   174 00000072 ????                <2> warm_boot       resw    1	;*/	word warm_boot;		/* 40:72 Warm boot iff==1234h
   175                              <2> ;;---------------[Hard disk scratchpad]----------;
   176 00000074 ????????            <2> hdd_scratch     resd    1	;*/	word hdd_scratch[2];	/* 40:74
   177                              <2> ;;---------------[Timout areas/PRT/LPT]----------;
   178 00000078 ????????            <2> lpt_timeout     resb    4	;*/	byte lpt_timeout[4];	/* 40:78 Ticks for LPT 1-4 timeouts
   179 0000007C ????????            <2> com_timeout     resb    4	;*/	byte com_timeout[4];	/* 40:7C Ticks for COM 1-4 timeouts
   180                              <2> ;;---obsolete----[Keyboard buf start/end]---jrc--;
   181 00000080 ????                <2> kbd_buffer_start resw   1	;*/	word kbd_buffer_start;	/* 40:80 KBD buffer head (PC/AT)
   182 00000082 ????                <2> kbd_buffer_end  resw    1	;*/	word kbd_buffer_end;	/* 40:82 KBD buffer tail (PC/AT)
   183                              <2> ;;---------------[EGA stuff]---------------------;
   184 00000084 ??????????????      <2> EGA_stuff	resb	7	;*/	byte EGA_stuff[7];	/* 40:84 Unspecified EGA data
   185                              <2> ;;---------------[Floppy/Fixed Media Info]-------------;
   186 0000008B ??                  <2> fdc_last_rate	resb	1	;*/	byte fdc_last_rate;	/* 40:8B Last floppy step rate/data rate?
   187 0000008C ????????            <2> fx_misc_unused	resb	4	;*/	byte fx_misc_unused[4];	/* 40:8C Fixed disk miscellaneous ???
   188 00000090 ????                <2> fdc_disk_state	resb	2	;*/	byte fdc_disk_state[2];	/* 40:90 Floppy disk state
   189 00000092 ????                <2> fdc_op_start	resb	2	;*/	byte fdc_op_start[2];	/* 40:92 Floppy operation start state machine
   190 00000094 ????                <2> fdc_cylinder	resb	2	;*/	byte fdc_cylinder[2];	/* 40:94 Floppy present cylinder
   191                              <2> ;;---------------[Additional KBD flags]----------------;
   192 00000096 ??                  <2> kbd_flag_3	resb	1	;*/	byte kbd_flag_3;	/* 40:96 kbd ???
   193 00000097 ??                  <2> kbd_flag_2	resb	1	;*/	byte kbd_flag_2;	/* 40:97 kbd ???
   194                              <2> ;;---------------[RTC/timer1 data]---------------------;
   195 00000098 ????????            <2> user_semaphore	resw	2	;*/	byte *user_semaphore;	/* 40:98 User semaphore in (bit 7)
   196 0000009C ????????            <2> rtc_count	resd	1	;*/	dword rtc_count;	/* 40:9C RTC tick counter
   197 000000A0 ??                  <2> rtc_wait_active	resb	1	;*/	byte rtc_wait_active;	/* 40:A0 Busy=01, Posted=80h, 
   198                              <2> ;;---------------[Cassette I/O stuff]------------------;
   199 000000A1 ??                  <2> last_val	resb	1	;*/	byte last_val;		/* 40:A1 Last byte read value
   200 000000A2 ????                <2> crc_reg		resw	1	;*/	word crc_reg;		/* 40:A2 CRC accumulation area
   201                              <2> ;									Post Acknowleged=00;
   202 000000A4 ??                  <2> EGA_data	resb	1	;*/	byte EGA_data;		/* 40:A4 Various usage
   203 000000A5 ????                <2> SDstatus	resb	2	;*/	byte SDstatus[2];	/* 40:A5 Status byte from command
   204 000000A7 ????                <2> SDcardtype	resb	2	;*/	byte SDcardtype[2];	/* 40:A7 SDcard type SDSC=2, HC=3, ...
   205                              <2> ;
   206 000000A9 ????????            <2> fixed_disk_tab	resb	4	;*/	byte fixed_disk_tab[4];	/* dispatch table to fixed disk drivers
   207 000000AD ??                  <2> wait12_count	resb	1	;*/	byte wait12_count;	/* 40:AD 12usec CX count
   208 000000AE ??                  <2> lock_count	resb	1	;*/	byte lock_count;	/* 40:AE lock level counter
   209 000000AF ??                  <2> EMS_start       resb    1	;*/	byte EMS_start;		/* start EMS allocation from here
   210                              <2> fx80		equ	$	;*/	struct EDD_disk fx80;	/* fixed disk parameter area 0
   211 000000B0 ????                <2> fx_log_cylinders resw   1	;	word fx_log_cylinders;	 logical number of cylinders
   212 000000B2 ??                  <2> fx_log_heads    resb    1	;	byte fx_log_heads;	 logical number of heads
   213 000000B3 ??                  <2> fx_signature	resb	1	;	byte fx_signature;	 A0h signature = translated geom
   214 000000B4 ??                  <2> fx_phys_sectors	resb    1       ;	byte fx_phys_sectors;	 physical number of sectors per track
   215 000000B5 ????                <2> fx_LBA_high     resw    1       ;	word fx_LBA_high;	 high word of LBA28 number of sectors
   216 000000B7 ??                  <2> fx_reserved	resb	1	;	byte fx_reserved;	 reserved for future use
   217 000000B8 ??                  <2> fx_drive_control resb   1       ;	byte fx_drive_control;	 flag bits for IDE head register
   218 000000B9 ????                <2> fx_phys_cylinders resw	1	;	word fx_phys_cylinders;	 physical number of cylinders
   219 000000BB ??                  <2> fx_phys_heads	resb	1	;	byte fx_phys_heads;	 physical number of heads
   220 000000BC ????                <2> fx_LBA_low	resw	1	;	word fx_LBA_low;	 low word of LBA28 number of sectors
   221 000000BE ??                  <2> fx_log_sectors	resb	1	;	byte fx_log_sectors;	 logical number of sectors per track
   222 000000BF ??                  <2> fx_checksum	resb	1	;	byte fx_checksum;	 checksum, dunno how to compute
   223 000000C0 <res 10h>           <2> fx81            resb    16	;*/	struct EDD_disk fx81;	/* fixed disk parameter area 1
   224 000000D0 <res 10h>           <2> fx82            resb    16	;*/	struct EDD_disk fx82;	/* fixed disk parameter area 2
   225 000000E0 <res 10h>           <2> fx83            resb    16	;*/	struct EDD_disk fx83;	/* fixed disk parameter area 3
   226                              <2> ;
   227                              <2> ;
   228                              <2> 
   229 000000F0 ????                <2> FPEM_segment    resw    1       ;*/	word FPEM_segment;	/* FPEM data segment
   230                              <2> 
   231 000000F2 ????                <2> EBDA_paragraph  resw    1       ;*/	word EBDA_paragraph;	/* lowest EBDA paragraph
   232                              <2> 
   233 000000F4 ????                <2> dma0_cw         resw    1       ;*/	word dma0_cw;		/* end of dma control word
   234 000000F6 ????                <2> dma1_cw         resw    1       ;*/	word dma1_cw;		/*   ditto
   235                              <2> 
   236 000000F8 ????                <2> fdc_type	resb	2	;*/	byte fdc_type[2];	/* disk type in low nibble, alternate in hi nib 
   237                              <2> 
   238 000000FA ????????            <2> debug_static_ptr  resw	2	;*/	void *debug_static_ptr;	/* pointer to debug static area
   239                              <2> 
   240 000000FE ??                  <2> n_fixed_disks   resb    1       ;*/	byte n_fixed_disks;	/* number of fixed disks
   241                              <2> 
   242 000000FF ??                  <2> cpu_xtal        resb    1       ;*/	byte cpu_xtal;		/* CPU crystal frequency in Mhz 
   243                              <2> ;								   CPU clock is half of this
   244                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   245                              <2> ;
   246                              <2> ;  System configuration stuff below
   247                              <2> ;	c.f., CONFIG.ASM (ANSI.CFG, CVDU.CFG, etc.), User configuration stuff
   248                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   249                              <2> %if 0				;*/
   250                              <2> #define FIXED_DISK_MAX 4		/*
   251                              <2> %else
   252                              <2> %define FIXED_DISK_MAX 4
   253                              <2> %endif
   254                              <2> %if 0				;*/
   255                              <2> #define PPIDE_driver 1		/*
   256                              <2> %else
   257                              <2> %define PPIDE_driver 1
   258                              <2> %endif
   259                              <2> %if 0				;*/
   260                              <2> #define DIDE_driver 0		/*
   261                              <2> %else
   262                              <2> %define DIDE_driver 0
   263                              <2> %endif
   264                              <2> %if 0				;*/
   265                              <2> #define DISKIO_driver 1		/*
   266                              <2> %else
   267                              <2> %define DISKIO_driver 1
   268                              <2> %endif
   269                              <2> %if 0				;*/
   270                              <2> #define MFPIC_driver 1		/*
   271                              <2> %else
   272                              <2> %define MFPIC_driver 1
   273                              <2> %endif
   274                              <2> %if 0				;*/
   275                              <2> #define DSD_driver 1		/*
   276                              <2> %else
   277                              <2> %define DSD_driver 1
   278                              <2> %endif
   279                              <2> %if 0				;*/
   280                              <2> #define V3IDE8_driver (SBC188==3)		/*
   281                              <2> %else
   282                              <2> %define V3IDE8_driver (SBC188==3)
   283                              <2> %endif
   284                              <2> 				;*/
    76                              <1> 
    77                              <1> ;  this must be the same in EQUATES.H */
    78                              <1> %if SOFT_DEBUG
    79                              <1> %define NBREAK  8
    80                              <1> %endif
    81                              <1> 
    82                              <1> 
    83                              <1> %if 0
    84                              <1>         segment _TEXT
    85                              <1> ;; *************************************************************************
    86                              <1> 
    87                              <1> 
    88                              <1> 
    89                              <1> 
    90                              <1> ;; ************************ DOS Data Segment *******************************
    91                              <1> ;dosdir	SEGMENT at 50h				; Boot disk directory from IPL
    92                              <1> ;xerox	label	byte				;  0 if Print Screen idle
    93                              <1> ;						;  1 if PrtSc xeroxing screen
    94                              <1> ;						;255 if PrtSc error in xerox
    95                              <1> ;						;  ...non-grafix PrtSc in bios
    96                              <1> ;	db	200h dup(?)			; PC-DOS bootstrap procedure
    97                              <1> ;						;  ...IBMBIO.COM buffers the
    98                              <1> ;						;  ...directory of the boot
    99                              <1> ;						;  ...device here at IPL time
   100                              <1> ;						;  ...when locating the guts
   101                              <1> ;						;  ...of the operating system
   102                              <1> ;						;  ...filename "IBMDOS.COM"
   103                              <1> ;dosdir	ends
   104                              <1> ;; *************************************************************************
   105                              <1> ;; ************************ DOS IPL Segment ********************************
   106                              <1> ;dosseg	SEGMENT at 70h				; "Kernel" of PC-DOS op sys
   107                              <1> ;;IBMBIO.COM file loaded by boot block. Device Drivers/Bootstrap. CONTIGUOUS<---
   108                              <1> ;;IBMDOS.COM operating system nucleus immediately follows IBMBIO.COM and       !
   109                              <1> ;;     doesn`t have to be contiguous.  The IBMDOS operating system nucleus     !
   110                              <1> ;;     binary image is loaded by transient code in IBMBIO binary image	      !
   111                              <1> ;dosseg	ends					;			      !
   112                              <1> ;iplseg	SEGMENT at 0h				; Segment for boot block      !
   113                              <1> ;;The following boot block is loaded with 512 bytes on the first sector of     !
   114                              <1> ;;the bootable device by code resident in the ROM-resident bios.  Control is   !
   115                              <1> ;;then transferred to the first word 0000:7C00 of the disk-resident bootstrap  !
   116                              <1> ;	ORG	07C00h				;  ..offset for boot block    !
   117                              <1> ;boot	db	200h dup(?)			;  ..start disk resident boot--
   118                              <1> ;iplseg	ends
   119                              <1> 
   120                              <1> %endif
    28                                  
    29                                  %define DUMP 0
    30                                  
    31                                  ; sterilize SOFT_DEBUG for now
    32                                  %if SOFT_DEBUG > 1
    33                                  %undef SOFT_DEBUG
    34                                  %define SOFT_DEBUG 1
    35                                  %endif
    36                                  
    37                                  	global  BIOS_call_13h
    38                                  ;;	global  Floppy_BIOS_call_13h_entry
    39                                  	global  wait12
    40                                  	global	@enable, @disable
    41                                  %if SOFT_DEBUG
    42                                  	extern	_cprintf
    43                                  	global  undefined
    44                                  	global	fn00,fn02,fn03,fn04
    45                                  	global  get_msr
    46                                  	global	check_DL
    47                                  	global	get_disk_type
    48                                  	global	get_media
    49                                  	global	set_media_pointer
    50                                  	global	rwv_common
    51                                  	global	Seek, recalibrate, Specify
    52                                  	global	rwv_common.marker
    53                                  	global	end_rwv
    54                                  	global	xfer_read_sector, xfer_write_sector, xfer_verify_sector
    55                                  	global	xfer_format_track
    56                                   	global	Check_RW_Status
    57                                  %endif
    58                                  
    59                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    60                                  ; Error, Okay, Complete status conditions
    61                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    62                                  
    63                                  %define	Error		stc
    64                                  ;  test with:
    65                                  ;	JC xxx	(jump on error)
    66                                  ;	JNC xxx	(jump on no error)
    67                                  
    68                                  %define	Okay		xor ah,ah
    69                                  ;  test with:
    70                                  ;	JZ xxx	(jump okay)
    71                                  ;	JNZ xxx (jump not okay)
    72                                  
    73                                  %define Complete	or ah,3
    74                                  ;  test with:
    75                                  ;	JA xxx	(jump complete AND no error)
    76                                  ;	JNZ xxx	(jump complete)
    77                                  ;	JZ xxx	(jump not complete)
    78                                  
    79                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    80                                  
    81                                  
    82                                  ; at most we use 2 floppies
    83                                  %define FLOPPY_MAX	2
    84                                  
    85                                  ; there is some disagreement about whether ES:DI gets set
    86                                  ; for Floppy calls to "int 13h, function 8"
    87                                  FN08_SET_ES_DI   equ     1
    88                                  ;FN08_SET_ES_DI   equ     0
    89                                  
    90                                  ; Define the three modes of operation of the WD37C65B floppy controller
    91                                  %define BASE    0FFh
    92                                  %define SPECIAL 80h
    93                                  %define PC_AT   00h
    94                                  
    95                                  ; DMA watch threshhold
    96                                  %define THRESHHOLD  12
    97                                  
    98                                  ; Do we use DMA or Programmed I/O
    99                                  %define USE_DMA 1       ; We want this to be 1
   100                                  %define USE_DMA_INTs	1	; Use DMA interrupts
   101                                  
   102                                  ; Define the mode in which the WD37C65B is operated
   103                                  %define MODE    PC_AT   ; This MUST NOT be changed
   104                                  
   105                                  ; specify bits in the Operations Register
   106                                  %define DSEL1    00h
   107                                  %define DSEL2    01h
   108                                  %define DSEL_MASK (DSEL1|DSEL2)
   109                                  %define NO_RESET 04h
   110                                  %define RESET    00h
   111                                  %define DMAEN    08h
   112                                  %define MOEN1    10h
   113                                  %define MOEN2    20h
   114                                  %define MOEN_MASK (MOEN1|MOEN2)
   115                                  
   116                                  %define TurnOn	8			; used by all DSEL's
   117                                  
   118                                  ; the Motor turn-on delay in milliseconds
   119                                  %define MOTOR_DELAY     (TurnOn*125)
   120                                  
   121                                  ; define the disk density clock rate selects
   122                                  %define FDC_HD  00h
   123                                  %define FDC_DD  02h
   124                                  
   125                                  ; The individual floppy disk status bits
   126                                  %define FDC_DRIVE_PRESENT  1
   127                                  %define FDC_DRIVE_READY    2
   128                                  
   129                                  
   130                                  ; define the MSR bits:
   131                                  RQM     equ     80h             ; request for master
   132                                  DIO     equ     40h             ; data IN=1, out=0
   133                                  EXM     equ     20h             ; Execution phase in non-DMA mode
   134                                  				;  this should NEVER be set
   135                                  BUSY    equ     10h             ; Controller Busy
   136                                  FD3     equ     08h             ; DS3 is seeking
   137                                  FD2     equ     04h             ; DS2 is seeking
   138                                  FD1     equ     02h             ; DS1 is seeking
   139                                  FD0     equ     01h             ; DS0 is seeking
   140                                  
   141                                  ; MSR I/O status (in/out from CPU)
   142                                  MSR_IN	equ	RQM | DIO
   143                                  MSR_OUT	equ	RQM
   144                                  MSR_MASK equ	RQM | DIO
   145                                  
   146                                  ;  This is the list of controller commands that we use
   147                                  
   148                                  CMD_RECALIBRATE         equ     7       ; 1 param byte (unit #)
   149                                  					; No result bytes
   150                                  CMD_SENSE_INT_STATUS    equ     8       ; No paramter bytes
   151                                  					; 2 result bytes
   152                                  CMD_SENSE_DRIVE_STATUS  equ     4       ; 1 param byte
   153                                  					; 1 result byte
   154                                  CMD_SPECIFY             equ     3       ; 2 parameter bytes
   155                                  					; No result bytes
   156                                  CMD_SEEK                equ     15      ; 2 parameter bytes
   157                                  					; No result bytes
   158                                  CMD_READ_ID             equ     10      ; param in cmd; 1 param byte
   159                                  					; 7 result bytes
   160                                  CMD_READ_DATA           equ     6       ; params in cmd; 8 param bytes
   161                                  					; 7 result bytes
   162                                  CMD_WRITE_DATA          equ     5       ; params in cmd; 8 param bytes
   163                                  					; 7 result bytes
   164                                  CMD_READ_A_TRACK        equ     2       ; params in cmd; 8 param bytes
   165                                  					; 7 result bytes
   166                                  CMD_FORMAT_A_TRACK      equ     13      ; params in cmd; 5 param bytes
   167                                  					; 7 result bytes
   168                                  CMD_SCAN_EQUAL          equ     11h     ; params in cmd; 8 param bytes
   169                                  					; 7 result bytes
   170                                  CMD_SCAN_LOW_OR_EQUAL   equ     19h     ; params in cmd; 8 param bytes
   171                                  					; 7 result bytes
   172                                  CMD_SCAN_HIGH_OR_EQUAL  equ     1Dh     ; params in cmd; 8 param bytes
   173                                  					; 7 result bytes
   174                                  
   175                                  
   176                                  ; define the extra bits in some command codes
   177                                  
   178                                  CMD_MT          equ     80h             ; Multi-track operation
   179                                  CMD_MF          equ     40h             ; MFM recording mode
   180                                  CMD_SK          equ     20h             ; skip deleted data mark
   181                                  
   182                                  
   183                                  
   184                                  ; define the ST3 status bits
   185                                  
   186                                  ST3_WP          equ     40h             ; NOT Write Protected
   187                                  ST3_TR00        equ     10h             ; Track 0 signal
   188                                  ST3_WP2         equ     08h             ; duplicate of ST3_WP; ST3_2S for 8" floppies
   189                                  ST3_HS          equ     04h             ; head 0 or 1
   190                                  ST3_US          equ     03h             ; Unit mask (0..3)
   191                                  
   192                                  
   193                                  ; define the ST2 status bits
   194                                  
   195                                  ST2_CM          equ     40h             ; Control Mark (deleted data mark)
   196                                  ST2_DD          equ     20h             ; Data Error (data field)
   197                                  ST2_WC          equ     10h             ; Wrong Cylinder
   198                                  ST2_SH          equ     08h             ; Scan Hit (not used here)
   199                                  ST2_SN          equ     04h             ; Scan Not Satisfied (not used here)
   200                                  ST2_BC          equ     02h             ; Bad Cylinder
   201                                  ST2_MD          equ     01h             ; Missing address mark
   202                                  
   203                                  ST2_ANY         equ     ST2_CM+ST2_DD+ST2_WC+ST2_BC+ST2_MD
   204                                  
   205                                  
   206                                  ; define the ST1 status bits
   207                                  
   208                                  ST1_EN          equ     80h             ; End of cylinder
   209                                  ST1_DE          equ     20h             ; Data error (CRC err in address or data field)
   210                                  ST1_OR          equ     10h             ; Overrun (we will always see this flag)
   211                                  ST1_ND          equ     04h             ; No Data
   212                                  ST1_NW          equ     02h             ; Not writeable (WP is set)
   213                                  ST1_MA          equ     01h             ; Missing address mark
   214                                  
   215                                  %if FDC_PIGGYBACK_FIX
   216                                  ST1_ANY         equ     ST1_EN+ST1_DE+ST1_OR+ST1_ND+ST1_NW+ST1_MA
   217                                  %else
   218                                  ;ST1_ANY         equ     ST1_EN+ST1_DE+ST1_ND+ST1_NW+ST1_MA
   219                                  ST1_ANY         equ            ST1_DE+ST1_ND+ST1_NW+ST1_MA
   220                                  %endif
   221                                  
   222                                  ; define the ST0 status bits
   223                                  
   224                                  ST0_IC          equ     0C0h            ; Interrupt code mask
   225                                  					; 00 = normal termination
   226                                  					; 01 = abnormal termination
   227                                  					; 10 = invalid command
   228                                  					; 11 = abnormal termination -- change in ready status
   229                                  
   230                                  ST0_SE          equ     20h             ; Seek end
   231                                  ST0_EC          equ     10h             ; Equipment check
   232                                  ST0_NR          equ     08h             ; Not Ready (always 0 on WD37C65B)
   233                                  ST0_HS          equ     04h             ; Head Select
   234                                  ;ST0_US          equ     03h             ; Unit select mask
   235                                  ST0_US          equ     01h             ; Unit select mask
   236                                  
   237                                  ST0_ANY         equ     ST0_EC+ST0_NR   ; Any ST0 error
   238                                  
   239                                  
   240                                  
   241                                  ; The FDC interrupt control register
   242                                  fdc_int_control         equ     PIC_I3CON
   243                                  
   244                                  
   245                                  ; Standard int 13h stack frame layout is 
   246                                  ; created by:   PUSHM  ALL,DS,ES
   247                                  ;               MOV    BP,SP
   248                                  ;
   249                                  offset_DI       equ     0
   250                                  offset_SI       equ     offset_DI+2
   251                                  offset_BP       equ     offset_SI+2
   252                                  offset_SP       equ     offset_BP+2
   253                                  offset_BX       equ     offset_SP+2
   254                                  offset_DX       equ     offset_BX+2
   255                                  offset_CX       equ     offset_DX+2
   256                                  offset_AX       equ     offset_CX+2
   257                                  offset_DS       equ     offset_AX+2
   258                                  offset_ES       equ     offset_DS+2
   259                                  offset_IP       equ     offset_ES+2
   260                                  offset_CS       equ     offset_IP+2
   261                                  offset_FLAGS    equ     offset_CS+2
   262                                  
   263                                  ; The byte registers in the stack
   264                                  offset_AL       equ     offset_AX
   265                                  offset_AH       equ     offset_AX+1
   266                                  offset_BL       equ     offset_BX
   267                                  offset_BH       equ     offset_BX+1
   268                                  offset_CL       equ     offset_CX
   269                                  offset_CH       equ     offset_CX+1
   270                                  offset_DL       equ     offset_DX
   271                                  offset_DH       equ     offset_DX+1
   272                                  
   273                                  
   274                                  ; FDC error codes (returned in AH)
   275                                  ;
   276                                  ERR_no_error            equ     0       ; no error (return Carry clear)
   277                                  ;   everything below returns with the Carry set to indicate an error
   278                                  ERR_invalid_command     equ     1
   279                                  ERR_address_mark_not_found      equ     2
   280                                  ERR_write_protect       equ     3
   281                                  ERR_sector_not_found    equ     4
   282                                  ERR_disk_removed        equ     6
   283                                  ERR_dma_overrun         equ     8
   284                                  ERR_dma_crossed_64k     equ     9
   285                                  
   286                                  
   287                                  ERR_media_type_not_found        equ     12	; 0Ch
   288                                  ERR_uncorrectable_CRC_error     equ     10h
   289                                  ERR_controller_failure  equ     20h
   290                                  ERR_seek_failed         equ     40h
   291                                  ERR_disk_timeout        equ     80h
   292                                  
   293                                  ERR_81			equ	81h	; fdc_ready_for_cmd, not rdy for input
   294                                  ERR_82			equ	82h	; fdc_ready_for_result, not rdy for output
   295                                  ERR_83			equ	83h	; input_result_from_fdc, after input, still busy
   296                                  ERR_84			equ	84h	; fdc_wait_seek_done, abnormal ST0_IC code
   297                                  ERR_85			equ	85h	; xfer_read_sector timeout
   298                                  ERR_86			equ	86h	; cylinder requested is invalid for drive
   299                                  ERR_87			equ	87h	; not on track 0 after recalibrate
   300                                  ERR_88			equ	88h	; wait for operation complete to be posted
   301                                  ERR_89			equ	89h	; fdc_ready_for_cmd, unexpectedly BUSY
   302                                  ERR_8A			equ	8Ah	; second "seek failed" error (ignore during Format)
   303                                  
   304                                  ERR_unknown		equ	8Fh	;   ADDED--JRC (may need to change)
   305                                  
   306                                  
   307                                  	SEGMENT	_TEXT
   308                                  %if SOFT_DEBUG > 1
   309                                  	extern  lites
   310                                  %endif
   311                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   312                                  ;  BIOS call entry for Floppy Disk driver
   313                                  ;       int  13h
   314                                  ;
   315                                  ; The Fixed Disk driver will move the vector from 13h to 40h
   316                                  ; At the moment there is no Fixed Disk Driver
   317                                  ;
   318                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   319                                  	global  BIOS_call_13h
   320                                  BIOS_call_13h:          ; Floppy driver entry
   321 00000000 FB                      	sti                     ; Enable interrupts
   322 00000001 061E60                  	pushm   all,ds,es       ; Standard register save
   323 00000004 89E5                    	mov     bp,sp           ; establish stack addressing
   324                                  
   325 00000006 FC                      	cld			; may NOT assume direction flag is clear
   326 00000007 6A40                    	push    bios_data_seg
   327 00000009 1F90                    	popm	ds              ; establish addressability for all functions
   328 0000000B C606AE0000              	mov	byte [lock_count],0	; clear the lock counter
   329                                  
   330                                  %if SOFT_DEBUG & DUMP
   331                                  	pushm	ax,cx,dx,es
   332                                  
   333                                  	push	bx
   334                                  	push	es
   335                                  	xor	bh,bh
   336                                  	mov	bl,dl
   337                                  	push	bx
   338                                  	mov	bl,cl
   339                                  	push	bx
   340                                  	mov	bl,dh
   341                                  	push	bx
   342                                  	mov	bl,ch
   343                                  	push	bx
   344                                  	mov	bx,ax
   345                                  	push	bx
   346                                  	push	cs
   347                                  	push	rwvc
   348                                  	call	_cprintf
   349                                  	add	sp,18
   350                                  
   351                                  	popm	ax,cx,dx,es
   352                                  	xor	bh,bh
   353                                  %endif
   354 00000010 88E3                    	mov     bl,ah           ; set to index into dispatch table
   355 00000012 80FC19                  	cmp     ah,max/2
   356 00000015 7202                    	jb	.1
   357 00000017 B314                    	mov	bl,14h		; fn not defined for Floppy diskette
   358 00000019 30FF                    .1:	xor     bh,bh
   359 0000001B D1E3                    	shl     bx,1            ; index words
   360 0000001D 2EFF97[3700]                cs  call    near [dispatch+bx]
   361                                  
   362                                  ; returns come here with AH set
   363                                  
   364 00000022 08E4                    	or	ah,ah		; is return code 0? sets carry=0, too
   365 00000024 7401                    	jz	exit_pops
   366                                  error_exit:
   367 00000026 F9                      	stc
   368                                  exit_pops:
   369 00000027 88660F                  	mov	[bp+offset_AH],ah	; store for return
   370 0000002A 89EC                    	mov     sp,bp		; remove any allocated variables
   371                                  %if SOFT_DEBUG & DUMP
   372                                  	pushm	f	;  ,ax,bx,cx,dx,es
   373                                  	mov	al,ah		; save AH in AL
   374                                  	lahf			; get flags
   375                                  	xor	bh,bh		; Zap BH
   376                                  	mov	bl,[fdc_op_start+1]
   377                                  	push	bx
   378                                  	mov	bl,[fdc_op_start]
   379                                  	push	bx
   380                                  	mov	bl,ah
   381                                  	and	bx,1		; mask Carry
   382                                  	push	bx
   383                                  	mov	bl,al		; former AH
   384                                  	push	bx
   385                                  	push	cs		; far pointer to ...
   386                                  	push	fnret		;   format
   387                                  	call	_cprintf
   388                                  	add	sp,12
   389                                  	popm	f	; ,ax,bx,cx,dx,es
   390                                  %endif
   391 0000002C 611F900790              	popm    all,ds,es
   392 00000031 CA0200                  	retf	2			; return the carry
   393                                  
   394                                  
   395                                  
   396                                  ;fn00           ; Reset Disk System
   397                                  fn01:           ; Get Disk System Status
   398                                  ;fn02           ; Read Sector
   399                                  ;fn03           ; Write Sector
   400                                  ;fn04           ; Verify Sector
   401                                  ;fn05:           ; Format Track
   402                                  fn06:           ; Format Bad Track (fixed disk) [PC]
   403                                  fn07:           ; Format Drive (fixed disk)     [PC]
   404                                  ;fn08           ; Get Drive Parameters
   405                                  fn09:
   406                                  fn0A:
   407                                  fn0B:
   408                                  fn0C:
   409                                  fn0D:
   410                                  fn0E:
   411                                  fn0F:
   412                                  fn10:
   413                                  fn11:
   414                                  fn12:
   415                                  fn13:
   416                                  fn14:		; *** fixed disk only ***
   417                                  ;fn15:		; Get Disk Type                 [AT]
   418                                  ;fn16:           ; Get Disk Change Status (floppy)
   419                                  fn17:           ; Set Disk Type (floppy)
   420                                  ;fn18:           ; Set Media Type for Format (floppy)
   421                                  undefined:
   422 00000034 B401                    	mov     ah,ERR_invalid_command	; equ 1
   423 00000036 C3                      	ret
   424                                  
   425                                  
   426                                  dispatch:
   427 00000037 [8A02]                  	dw      fn00    ; Reset Disk System
   428 00000039 [3400]                  	dw      fn01    ; 
   429 0000003B [3403]                  	dw      fn02
   430 0000003D [3E03]                  	dw      fn03
   431 0000003F [4803]                  	dw      fn04
   432 00000041 [C803]                  	dw      fn05
   433 00000043 [3400]                  	dw      fn06
   434 00000045 [3400]                  	dw      fn07
   435 00000047 [F202]                  	dw      fn08
   436 00000049 [3400]                  	dw      fn09
   437 0000004B [3400]                  	dw      fn0A
   438 0000004D [3400]                  	dw      fn0B
   439 0000004F [3400]                  	dw      fn0C
   440 00000051 [3400]                  	dw      fn0D
   441 00000053 [3400]                  	dw      fn0E
   442 00000055 [3400]                  	dw      fn0F
   443 00000057 [3400]                  	dw      fn10
   444 00000059 [3400]                  	dw      fn11
   445 0000005B [3400]                  	dw      fn12
   446 0000005D [3400]                  	dw      fn13
   447 0000005F [3400]                  	dw      fn14
   448 00000061 [6504]                  	dw      fn15
   449 00000063 [7B04]                  	dw      fn16
   450 00000065 [3400]                  	dw      fn17
   451 00000067 [9304]                  	dw      fn18
   452                                  max     equ     $-dispatch
   453                                  
   454                                  
   455                                  ;
   456                                  ;   Floppy Drive Types  (fn08)
   457                                  ;
   458                                  ;                               We support:
   459                                  ;       1 = 5.25" 360K 40track     yes
   460                                  ;       2 = 5.25" 1.2M 80track     yes
   461                                  ;       3 = 3.5"  720K 80track     yes
   462                                  ;       4 = 3.5" 1.44M 80track     yes
   463                                  ;       6 = 3.5" 2.88M 80track      no  (WD37C65CJM & 32Mhz osc)
   464                                  ;	7 = 3.5" 1.28M 1024sect	    no  (Japan)
   465                                  ;
   466                                  ;   Floppy Combos
   467                                  ;       5 = 5.25" 360K 40track in Drive Type 2   	no
   468                                  ;	8 = 5.25" 512k 77track/128sector in Drv 2	(future) CP/M
   469                                  ;	9 = 3.5" 256k 77track/128sector in Drv 3	(future) CP/M
   470                                  ;      10 = 3.5" 512k 77track/128sector in Drv 4	(future) CP/M
   471                                  ;;
   472                                  
   473                                  D_table:
   474 00000069 0000                    	dw      0
   475 0000006B [7F00]                  	dw      DTAB1	; 360K	(MFM)
   476 0000006D [8C00]                  	dw      DTAB2	; 1.2M
   477 0000006F [9900]                  	dw      DTAB3	; 720K
   478 00000071 [A600]                  	dw      DTAB4	; 1.44M
   479 00000073 0000                    	dw      0; DTAB5
   480 00000075 0000                    	dw      0; DTAB6
   481 00000077 [CD00]                  	dw      DTAB7	; 1024 byte sectors (Japan)
   482 00000079 [DA00]                  	dw      DTAB8	; CP/M 26/77 in 1.2M drive	(128 byte FM sectors)
   483 0000007B [E700]                  	dw      DTAB9	; CP/M 13/77 in 720K drive
   484 0000007D [F400]                  	dw      DTAB10	; CP/M 26/77 in 1.44M drive
   485                                  L_table         equ     ($ - D_table)/2
   486                                  
   487                                  
   488                                  ;   Disk Information
   489                                  ;               specify  off   N  R  gp   DTL   gp3  fill  unk  on cyl clk
   490                                  ;;; The DOS MFM floppies
   491                                  ; 360K 5.25" DD floppy
   492 0000007F DF022502092AFF50F6-     DTAB1:  db      0DFh, 2, 25h,  2, 9, 2Ah, 0FFh, 50h, 0F6h, 0Fh, 8, 39, 80h
   492 00000088 0F082780           
   493                                  
   494                                  ; 1.2M 5.25" HD floppy
   495 0000008C DF0225020F1BFF54F6-     DTAB2:  db      0DFh, 2, 25h,  2, 15, 1Bh, 0FFh, 54h, 0F6h, 0Fh, 8, 79, 00h
   495 00000095 0F084F00           
   496                                  
   497                                  ; 720K 3.5" or 5.25" DD floppy
   498 00000099 DF022502092AFF50F6-     DTAB3:  db      0DFh, 2, 25h,  2, 9, 2Ah, 0FFh, 50h, 0F6h, 0Fh, 8, 79, 80h
   498 000000A2 0F084F80           
   499                                  
   500                                  ; 1.44M 3.5" HD floppy
   501 000000A6 AF022502121BFF6CF6-     DTAB4:  db      0AFh, 2, 25h,  2, 18, 1Bh, 0FFh, 6Ch, 0F6h, 0Fh, 8, 79, 00h
   501 000000AF 0F084F00           
   502                                  
   503                                  ; 360K 5.25" DD floppy in 1.2M HD drive
   504 000000B3 DF022502092AFF50F6-     DTAB5:	db	0DFh, 2, 25h,  2, 9, 2Ah, 0FFh, 50h, 0F6h, 0Fh, 8, 39, 40h
   504 000000BC 0F082740           
   505                                  
   506                                  ; 2.88M 3.5" XD floppy
   507 000000C0 AF022502241BFF50F6-     DTAB6:	db      0AFh, 2, 25h,  2, 36, 1Bh, 0FFh, 50h, 0F6h, 0Fh, 8, 79, 0C0h
   507 000000C9 0F084FC0           
   508                                  
   509                                  ; 1.28M 3.5" HD floppy with 1K sectors (Japan)
   510 000000CD AF0225030835FF74F6-     DTAB7:	db	0AFh, 2, 25h,  3,  8, 35h, 0FFh, 74h, 0F6h, 0Fh, 8, 79, 00h
   510 000000D6 0F084F00           
   511                                  
   512                                  ;               specify  off   N  R  gp   DTL   gp3  fill  unk  on cyl clk
   513                                  ;;; The CP/M FM floppies
   514                                  ; 500K 5.25" CP/M (FM) floppy in 1.2M drive
   515 000000DA DF0225001A098023E5-     DTAB8:  db      0DFh, 2, 25h,  0, 26,  9, 80h, 35, 0E5h, 0Fh, 8, 76, 00h
   515 000000E3 0F084C00           
   516                                  ;;;				       7h      1Bh
   517                                  
   518                                  ; 250K 3.5" CP/M (FM) floppy in 720K drive
   519 000000E7 DF0225000D138046E5-     DTAB9:  db      0DFh, 2, 25h,  0, 13, 19, 80h, 70, 0E5h, 0Fh, 8, 76, 80h
   519 000000F0 0F084C80           
   520                                  
   521                                  ; 500K 3.5" CP/M (FM) floppy in 1.44M drive
   522 000000F4 AF0225001A15804BE5-     DTAB10: db      0AFh, 2, 25h,  0, 26, 21, 80h, 75, 0E5h, 0Fh, 8, 76, 00h
   522 000000FD 0F084C00           
   523                                  
   524                                  
   525                                  ; DTAB table offsets
   526                                  DTAB_specify    	equ     0
   527                                  DTAB_specify2   	equ     DTAB_specify+1
   528                                  DTAB_turnoff_ticks	equ     DTAB_specify2+1
   529                                  DTAB_N_param    	equ     DTAB_turnoff_ticks+1
   530                                  DTAB_EOT_nsect  	equ     DTAB_N_param+1
   531                                  DTAB_rw_gap     	equ     DTAB_EOT_nsect+1
   532                                  DTAB_data_len   	equ     DTAB_rw_gap+1
   533                                  DTAB_fmt_gap3   	equ     DTAB_data_len+1
   534                                  DTAB_fmt_fill   	equ     DTAB_fmt_gap3+1
   535                                  DTAB_unknown    equ     DTAB_fmt_fill+1
   536                                  DTAB_startup		equ     DTAB_unknown+1	; in 1/8 seconds
   537                                  DTAB_max_cylinder	equ     DTAB_startup+1
   538                                  DTAB_control    equ     DTAB_max_cylinder+1
   539                                  
   540                                  
   541                                  
   542                                  ;
   543                                  ; Returns:
   544                                  ;	AL = contents of FDC_MSR  (Main Status Register)
   545                                  ;
   546                                  get_msr:
   547 00000101 52                      	push	dx
   548 00000102 BA0006                  	mov     dx,FDC_MSR
   549 00000105 EC                      	in      al,dx
   550                                  %if SOFT_DEBUG > 1
   551                                  	push    ax
   552                                  	call    lites
   553                                  %endif
   554 00000106 5A                      	pop	dx
   555 00000107 C3                      	ret
   556                                  
   557                                  ; delay for about 12 microseconds for MSR to be set
   558                                  	extern  microsecond
   559                                  	global  wait12
   560                                  wait12:
   561 00000108 51                      	push    cx
   562                                  %if 1
   563                                  ;	mov	cx,12		; 12 microseconds
   564 00000109 30ED                    	xor	ch,ch
   565 0000010B 8A0EFF00                	mov	cl,[cpu_xtal]	; 2x clock (32usec on 16Mhz CPU)
   566 0000010F D0E9                    	shr	cl,1
   567 00000111 83E905                  	sub	cx,5		; fudge factor for overhead
   568                                  %else
   569                                  	xor	ch,ch
   570                                  	mov	cl,[wait12_count]
   571                                  %endif
   572 00000114 E8(0000)                	call    microsecond
   573 00000117 59                      	pop     cx
   574 00000118 C3                      	ret
   575                                  
   576                                  
   577                                  wait1000:
   578 00000119 51                      	push	cx
   579 0000011A B9E803                  	mov	cx,1000		; 1 ms delay
   580 0000011D E8(0000)                	call	microsecond
   581 00000120 59                      	pop	cx
   582 00000121 C3                      	ret
   583                                  
   584                                  ;
   585                                  ;  Convention used below
   586                                  ;     Flags:           Meaning:
   587                                  ;       C=1             error
   588                                  ;       C=0, AH=0       okay
   589                                  ;       C=0, AH=3+      complete
   590                                  ;
   591                                  	global  fdc_ready_for_command
   592                                  fdc_ready_for_command:
   593 00000122 51                      	push	cx
   594                                  
   595                                  .0:
   596 00000123 B9E803                  	mov	cx,1000
   597 00000126 E8DFFF                  .1:	call	wait12
   598 00000129 E8D5FF                  	call    get_msr
   599 0000012C A880                    	test    al,RQM 		; C=0
   600 0000012E E1F6                    	loopz	.1
   601                                  ; try to compensate for MSDOS anomaly with a BUSY test
   602 00000130 7508                    	jnz	.req
   603 00000132 A810                    	test	al,BUSY		; How does MSDOS manage this???
   604 00000134 74ED                    	jz      .0
   605 00000136 B489                    	mov	ah,ERR_89
   606 00000138 EB06                    	jmp	.err
   607                                  
   608                                  .req:
   609 0000013A A840                    	test    al,DIO          ; C=0,	clear the carry
   610 0000013C 7405                    	jz     .2               ; ready for input?
   611 0000013E B481                    	mov	ah,ERR_81	; not ready for input
   612 00000140 F9                      .err:	Error			; C=1, signal error
   613 00000141 EB02                    	jmp	.99
   614                                  
   615 00000143 30E4                    .2:	Okay			; AH=0, C=0
   616 00000145 59                      .99:	pop	cx
   617 00000146 C3                      	ret
   618                                  ; returns Error or Okay
   619                                  
   620                                  
   621                                  	global  fdc_ready_for_result
   622                                  fdc_ready_for_result:
   623 00000147 E8BEFF                  	call    wait12
   624 0000014A E8B4FF                  	call    get_msr
   625 0000014D A810                    	test    al,BUSY         ; controller busy?
   626 0000014F 7505                    	jnz	.0 		; jump if busy
   627 00000151 80CC03                  	Complete		; not busy, return Complete
   628 00000154 EB15                    	jmp	.99
   629                                  .0:
   630 00000156 E8AFFF                  	call	wait12
   631 00000159 E8A5FF                  .1:	call    get_msr
   632 0000015C A880                    	test    al,RQM          ; wait for RQM
   633 0000015E 74F9                    	jz      .1
   634                                  
   635 00000160 A840                    	test    al,DIO		; set C=0, Z-flag
   636 00000162 7505                    	jnz     .5		; DIO==1 means output
   637 00000164 B482                    	mov	ah,ERR_82
   638 00000166 F9                      	Error
   639 00000167 EB02                    	jmp	.99
   640                                  
   641 00000169 30E4                    .5:	Okay
   642 0000016B C3                      .99:	ret
   643                                  ; returns Error, Okay, or Complete
   644                                  
   645                                  
   646                                  
   647                                  ; byte to output is in AL
   648                                  ; AH=0 and Carry=0 if all Okay
   649                                  ; Carry=1, AH=code if FDC not ready
   650                                  	global  output_byte_to_fdc
   651                                  output_byte_to_fdc:
   652 0000016C 52                      	pushm	dx
   653                                  
   654 0000016D 88C2                    	mov	dl,al
   655 0000016F E8B0FF                  	call    fdc_ready_for_command
   656 00000172 88D0                    	mov	al,dl
   657 00000174 7206                    	jc      .8              ; propagate error
   658                                  
   659 00000176 BA0106                  	mov     dx,FDC_DATA
   660 00000179 EE                      	out     dx,al
   661 0000017A 30E4                    	Okay			; C=0, AH=okay
   662                                  .8:     
   663 0000017C 5A                      	popm	dx
   664 0000017D C3                      	ret                     ; C=0, AH=okay
   665                                  ; returns Error or Okay
   666                                  
   667                                  
   668                                  	global  input_byte_from_fdc
   669                                  input_byte_from_fdc:
   670 0000017E 52                      	push	dx
   671 0000017F E8C5FF                  	call    fdc_ready_for_result
   672 00000182 7208                    	jc      .9              ; propagate error
   673 00000184 7506                    	jnz	.9		; if (Complete) return Complete;
   674                                  
   675 00000186 BA0106                  	mov     dx,FDC_DATA
   676 00000189 EC                      	in      al,dx
   677 0000018A 30E4                    	Okay			; return Okay
   678                                  .9:     
   679 0000018C 5A                      	pop	dx
   680 0000018D C3                      	ret                     ;
   681                                  ; returns Error, Okay, or Complete
   682                                  
   683                                  
   684                                  ;  CX = length of command
   685                                  ;  DX:SI = pointer to command (not DS:SI, we'll set this up)
   686                                  ;  
   687                                  	global  output_cmd_to_fdc
   688                                  output_cmd_to_fdc:
   689 0000018E 0656                    	pushm   si,es
   690 00000190 8EC2                    	mov     es,dx           ; DS:SI is now the source
   691 00000192 90                      	cnop
   692                                  
   693                                  %if SOFT_DEBUG & DUMP
   694                                    es	mov	al,[si]			; record two bytes of command
   695                                    	mov	[fdc_op_start],al
   696                                    es	mov	al,[si+1]		; first & second
   697                                    	mov	[fdc_op_start+1],al
   698                                  %endif
   699                                  
   700 00000193 E84306                  	call	@disable
   701                                  .1:
   702 00000196 26AC                      es	lodsb			; note segment override
   703 00000198 E8D1FF                  	call    output_byte_to_fdc  ; returns error or okay
   704 0000019B 7206                    	jc      .7              ; propagate any error
   705 0000019D E2F7                    	loop    .1
   706                                  
   707 0000019F 30E4                    	Okay			; return ok
   708 000001A1 EB01                    	jmp	.9
   709                                  
   710 000001A3 F9                      .7:	Error			; propagate error
   711                                  
   712 000001A4 E84306                  .9:	call	@enable
   713 000001A7 5E0790                  	popm	si,es
   714 000001AA C3                      	ret
   715                                  ; returns Error or Okay
   716                                  
   717                                  
   718                                  
   719                                  ; assumes DS points at BIOS Data Area
   720                                  ; preserves DI
   721                                  	global  input_result_from_fdc
   722                                  input_result_from_fdc:
   723 000001AB 5157                    	pushm   di,cx
   724 000001AD E82906                  	call	@disable	; lock the operation
   725                                  
   726 000001B0 BF4200                  	mov     di,fdc_ctrl_status      ; in BIOS Data Area
   727 000001B3 B90800                  	mov     cx,8            ; 7 bytes input, then 'complete'
   728                                  
   729 000001B6 E8C5FF                  .0:     call    input_byte_from_fdc
   730 000001B9 7217                    	jc      .9              ; propagate error
   731 000001BB 7511                    	jnz     .8              ; if complete, return okay
   732                                  
   733 000001BD 8805                    	mov     byte [di],al    ; store the result
   734 000001BF 47                      	inc     di
   735 000001C0 E2F4                    	loop    .0
   736                                  
   737 000001C2 E843FF                  	call	wait12		;
   738 000001C5 E839FF                  	call	get_msr		; check for busy
   739 000001C8 A810                    	test	al,BUSY
   740                                  
   741 000001CA B483                    	mov	ah,ERR_83
   742 000001CC 7504                    	jnz	.95		; return error if busy
   743                                  
   744                                  .8:
   745 000001CE 30E4                    	Okay			; return okay
   746 000001D0 EB01                    	jmp	.99		; single return point
   747                                  
   748                                  .9:
   749 000001D2 F9                      .95:	Error			; return error;
   750                                  
   751 000001D3 E81406                  .99:	call	@enable		; unlock the operation
   752 000001D6 5F59                    	popm	di,cx
   753 000001D8 C3                      	ret
   754                                  ; returns Error, Okay, or Complete
   755                                  
   756                                  
   757                                  %define INT_ENABLE 1
   758                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   759                                  ; 
   760                                  ;  Floppy Disk Controller
   761                                  ;               Interrupt Handler
   762                                  ;
   763                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   764                                  	global  fdc_interrupt_level
   765                                  fdc_interrupt_level:
   766                                  %if INT_ENABLE
   767 000001D9 FB                      	sti
   768                                  %endif
   769 000001DA 1E60                    	pushm   all,ds
   770 000001DC FC                      	cld                     ; just be sure
   771                                  	
   772 000001DD 6A40                    	push    bios_data_seg
   773 000001DF 1F90                    	popm    ds
   774                                  %if INT_ENABLE==0
   775                                  	inc	byte [lock_count]	; so we don't re-enable
   776                                  %endif
   777 000001E1 E81DFF                  	call    get_msr
   778 000001E4 A810                    	test    al,BUSY         ; test for controller busy
   779 000001E6 740A                    	jz      .4
   780                                  ; BUSY is set
   781 000001E8 E8C0FF                  	call    input_result_from_fdc
   782 000001EB 18C0                    	sbb     al,al           ; carry to AL
   783 000001ED A24100                  	mov     byte [fdc_status],al    ; FF=error, 0=okay 
   784 000001F0 EB2C                    	jmp     .9              ; we got the results
   785                                  
   786                                  
   787                                  ; FDC not busy:
   788                                  
   789                                  .4:
   790                                  ;;        xor     bh,bh           ; BH = false
   791 000001F2 B008                    .5:     mov     al,CMD_SENSE_INT_STATUS
   792 000001F4 E875FF                  	call    output_byte_to_fdc
   793 000001F7 7225                    	jc      .9              ; quit if error
   794 000001F9 E8AFFF                  	call    input_result_from_fdc
   795 000001FC 7220                    	jc      .9
   796                                  
   797 000001FE A04200                  	mov	al,[fdc_ctrl_status]	; get ST0
   798 00000201 3480                    	xor	al,80h			; IC= 10xxxxxxb (invalid)
   799 00000203 24C0                    	and	al,ST0_IC		; isolate IC
   800 00000205 7417                    	je	.9			; invalid command
   801                                  
   802 00000207 A14200                  	mov	ax,[fdc_ctrl_status]	; get ST0 + PCN (present cylinder)
   803 0000020A A820                    	test	al,ST0_SE		; test Seek End condition
   804 0000020C 74E4                    	jz	.5
   805                                  
   806 0000020E 89C7                    	mov	di,ax			;
   807 00000210 83E701                  	and	di,ST0_US		; isolate unit number
   808 00000213 88A59400                	mov	[fdc_cylinder+di],ah	; set PCN from controller
   809 00000217 800E3E0004              	or	byte [fdc_drv_calib],04h     ;POST Seek End seen
   810 0000021C EBD4                    	jmp     .5
   811                                  
   812                                  
   813                                  .9:
   814 0000021E 800E3E0001              	or	byte [fdc_drv_calib],01h     ;POST end of FDC interrupt
   815                                  %if INT_ENABLE==0
   816                                  	dec	byte [lock_count]	; restore the lock count
   817                                  %endif
   818                                  ; signal EOI (End of Interrupt)
   819 00000223 BA22FF                  	mov     dx,PIC_EOI              ; EOI register
   820 00000226 B80080                  	mov     ax,EOI_NSPEC            ; non-specific
   821 00000229 EF                      	out     dx,ax                   ; signal it
   822                                  	
   823 0000022A 611F90                  	popm    all,ds
   824 0000022D CF                      	iret
   825                                  
   826                                  
   827                                  
   828                                  	global  fdc_timer_hook
   829                                  ; called from Timer Tick code with DS->BIOS data area
   830                                  ; Destroys AX and DX
   831                                  	global  fdc_timer_hook
   832                                  fdc_timer_hook:
   833 0000022E 803E400000              	cmp     byte [fdc_motor_ticks],0
   834 00000233 740E                    	je      .9
   835 00000235 FE0E4000                	dec     byte [fdc_motor_ticks]
   836 00000239 7508                    	jnz     .9
   837                                  ; timer expired, stop the motors
   838 0000023B 80263F00CF              	and     byte [fdc_motor_LDOR],~(MOEN1+MOEN2)
   839 00000240 E80100                  	call    out_LDOR_mem
   840 00000243 C3                      .9:     ret
   841                                  
   842                                  
   843                                  
   844                                  ; FDC Operations Register operations
   845                                  ; put out the LDOR write-only register
   846                                  ;  Assumes DS is BIOS data segment
   847                                  ; Destroys AX and DX
   848                                  out_LDOR_mem:
   849 00000244 A03F00                  	mov     al,[fdc_motor_LDOR]
   850 00000247 BA2006                  	mov     dx,FDC_LDOR
   851 0000024A EE                      	out     dx,al
   852 0000024B C3                      	ret
   853                                  
   854                                  
   855                                  ; wait until all seeking is done
   856                                  ; assumes DS is set to BIOS data area
   857                                  ;
   858                                  	global  fdc_wait_seek_done
   859                                  fdc_wait_seek_done:
   860                                  .1:     
   861 0000024C E8B9FE                  	call    wait12
   862 0000024F E8AFFE                  	call    get_msr
   863 00000252 A80F                    	test    al,0Fh          ; test all the seek bits
   864 00000254 740C                    	jz      .8
   865 00000256 803E400000              	cmp     byte [fdc_motor_ticks],0
   866 0000025B 75EF                    	jnz     .1
   867 0000025D B480                    	mov	ah,ERR_disk_timeout
   868 0000025F F9                      .7:     Error			; signal error
   869 00000260 EB22                    	jmp	.9
   870                                  
   871                                  .8:     ; seek is done, check ST0 bits
   872 00000262 F6063E0004              	test	byte [fdc_drv_calib],04h	; Seek End seen?
   873 00000267 7512                    	jnz	.okay
   874                                  
   875 00000269 F6064200C0              	test    byte [fdc_ctrl_status],ST0_IC   ; interrupt code
   876 0000026E B484                    	mov	ah,ERR_84
   877 00000270 75ED                    	jnz     .7
   878 00000272 F606420020              	test    byte [fdc_ctrl_status],ST0_SE   ; Seek End
   879 00000277 B440                    	mov	ah,ERR_seek_failed
   880 00000279 74E4                    	jz      .7
   881                                  .okay:
   882                                  
   883                                  %if 0
   884                                  ; add settle time -- may not really be needed
   885                                  	mov	al,[fdc_motor_ticks]
   886                                  	add	al,450/54
   887                                  	xchg	al,[fdc_motor_ticks]
   888                                  .settle:
   889                                  	cmp	[fdc_motor_ticks],al
   890                                  	ja	.settle
   891                                  %else
   892                                  ; add time for more revolutions if a seek occurs
   893 0000027B 2E8A4702                  cs	mov	al,[DTAB_turnoff_ticks+bx]
   894 0000027F A24000                    	mov	[fdc_motor_ticks],al
   895                                  %endif
   896                                  
   897 00000282 30E4                    	Okay					; IC==00 and SE=1
   898 00000284 C3                      .9	ret
   899                                  
   900                                  ;
   901                                  ;  power on init
   902                                  ;
   903                                  	global  @floppy_init
   904                                  @floppy_init:
   905 00000285 B400                    	mov     ah,0            ; fn00
   906 00000287 CD13                    	int     13h
   907 00000289 C3                      	ret
   908                                  
   909                                  
   910                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   911                                  ;  Function 00h         Reset the Disk System
   912                                  ;       Used both at power on and after a serious error
   913                                  ;
   914                                  ;  Enter with:
   915                                  ;       AH = 00h
   916                                  ;       DL = drive 0 or 1
   917                                  ;
   918                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   919                                  fn00:
   920 0000028A B81700                  	mov     ax,0017h        ; LTM=1, MSK=0, PRI=7    (07h for LTM=0)
   921 0000028D BA3EFF                  	mov     dx,fdc_int_control
   922 00000290 EF                      	out     dx,ax           ; enable interrupt controller
   923 00000291 C606AD0020              	mov	byte [wait12_count],32	; this is about the max.
   924                                  
   925 00000296 E86FFE                  	call    wait12          ; wait 12 microseconds
   926 00000299 E865FE                  	call    get_msr         ; set BASE mode
   927 0000029C E869FE                  	call    wait12          ; wait 12 microseconds
   928                                  
   929 0000029F C6063F0008              	mov     byte [fdc_motor_LDOR],(MODE + RESET + DMAEN)         ; set PC_AT mode
   930 000002A4 E89DFF                  	call    out_LDOR_mem
   931 000002A7 E85EFE                  	call    wait12
   932                                  
   933                                  %if 1
   934                                  ;;; This read may not be necessary, unless Special Mode is set
   935 000002AA BA3006                  	mov     dx,FDC_LDCR
   936 000002AD EC                      	in      al,dx           ; read a write-only register to latch Mode
   937                                  ;;;;;
   938                                  %endif
   939 000002AE E868FE                  	call	wait1000
   940                                  
   941 000002B1 800E3F000C              	or	byte [fdc_motor_LDOR],(MODE + NO_RESET + DMAEN)      ; remove the RESET
   942 000002B6 E88BFF                  	call    out_LDOR_mem
   943 000002B9 E84CFE                  	call	wait12
   944                                  
   945                                  %if 0
   946                                  	mov     dx,FDC_LDCR
   947                                  	mov     al,FDC_HD               ; set for HD disks
   948                                  	out     dx,al
   949                                  %endif
   950                                  
   951 000002BC BACAFF                  	mov	dx,DMA0+DMACW
   952                                  %if 1
   953 000002BF B80400                  	mov	ax,4			; set change bit
   954                                  %else
   955                                  	in	ax,dx
   956                                  	and	ax,~2			; clear the stop bit
   957                                  	or	ax,4			; set the change bit
   958                                  %endif
   959 000002C2 EF                      	out	dx,ax
   960                                  
   961 000002C3 BA34FF                  	mov     dx,PIC_DMA0CR
   962 000002C6 B80700                  	mov     ax,0007h        ; MSK=0, PRI=7
   963 000002C9 EF                      	out     dx,ax           ; enable DMA0 interrupts
   964                                  
   965 000002CA 31C0                    	xor	ax,ax
   966 000002CC A24000                  	mov	[fdc_motor_ticks],al	; Zero the timer tick counter
   967 000002CF A28B00                  	mov	[fdc_last_rate],al	; force a specify command
   968                                  
   969 000002D2 8EC0                    	mov	es,ax
   970 000002D4 90                      	cnop
   971 000002D5 26A37800                  es	mov	[1Eh*4],ax
   972 000002D9 26A37A00                  es	mov	[1Eh*4+2],ax		; Zap the parameter pointer
   973                                  
   974 000002DD C7069400FFFF            	mov	word [fdc_cylinder],-1	; Specify & Recalibration needed
   975                                  ;***	mov	[fdc_cylinder+1],-1	; done by above instruction
   976                                  
   977                                  ; now allow time for the polling interrupts
   978 000002E3 B90100                  	mov	cx, 102400>>16		; 0.1 seconds
   979 000002E6 31D2                    	xor	dx,dx			; CX:DX is delay in usec
   980 000002E8 B486                    	mov	ah,86h			; delay in microseconds
   981 000002EA CD15                    	int	15h
   982                                  
   983 000002EC E8BCFE                  	call	input_result_from_fdc
   984                                  
   985 000002EF 30E4                    	Okay			; signal good execution
   986 000002F1 C3                      	ret			; end of FN00
   987                                  
   988                                  
   989                                  
   990                                  
   991                                  
   992                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   993                                  ;  Function 08h         Get Drive Parameters
   994                                  ;
   995                                  ;  Enter with:
   996                                  ;       AH = 08h
   997                                  ;       DL = drive 0 or 1
   998                                  ;
   999                                  ;  Return with:
  1000                                  ;       Carry clear if no error
  1001                                  ;       BL = drive type (2 or 4 for us)
  1002                                  ;       CH = max cylinder number
  1003                                  ;       CL = max sector number
  1004                                  ;       DH = max head number
  1005                                  ;       DL = number of drives
  1006                                  ;       ES:DI = address of disk parameter table
  1007                                  ;
  1008                                  ;       Carry set on error
  1009                                  ;       AH = error code
  1010                                  ;
  1011                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1012                                  fn08:           ; Get Drive Parameters
  1013 000002F2 A01000                  	mov	al,[equipment_flag]
  1014 000002F5 B401                    	mov	ah,1
  1015 000002F7 20C4                    	and	ah,al			; any floppies at all?
  1016 000002F9 7407                    	jz	.2
  1017 000002FB C0C002                  	rol	al,2			; at least one
  1018 000002FE 2403                    	and	al,3
  1019 00000300 00C4                    	add	ah,al			; 1..4
  1020                                  .2:
  1021 00000302 88660A                  	mov	[offset_DL+bp],ah		; return # of drives
  1022 00000305 E8E601                  	call	check_DL
  1023 00000308 7221                    	jc	.err_no_drive
  1024 0000030A E8F801                  	call	get_disk_type
  1025 0000030D 884608                  	mov	[offset_BL+bp],al		; return BL = disk type
  1026 00000310 E80102                  	call	get_media
  1027 00000313 2E8A670B                  cs	mov	ah,[DTAB_max_cylinder+bx]
  1028 00000317 2E8A4704                  cs	mov	al,[DTAB_EOT_nsect+bx]
  1029 0000031B 89460C                    	mov	[offset_CX+bp],ax		; return CYL | SECT in CX
  1030 0000031E C6460B01                	mov	byte [offset_DH+bp],1		; head max. always 1
  1031 00000322 8C4E12                  	mov	[offset_ES+bp],cs		; return ES  param table
  1032 00000325 895E00                  	mov	[offset_DI+bp],bx		; return DI  param table
  1033                                  
  1034 00000328 30E4                    	xor	ah,ah				; no error
  1035 0000032A C3                      	ret
  1036                                  
  1037                                  .err_no_drive:
  1038 0000032B B401                    	mov	ah,ERR_invalid_command		; error if no floppies
  1039 0000032D C3                      	ret					; DL is still zero !!!
  1040                                  
  1041                                  
  1042                                  
  1043                                  
  1044                                  
  1045                                  
  1046                                  %if 0
  1047                                  ; validate the READ/WRITE CHS,SC parameters
  1048                                  ;       Enter with DI pointing at the type table
  1049                                  ;
  1050                                  ;  Carry clear if okay
  1051                                  ;  Carry set if invalid
  1052                                  ;       AX & all other registers are preserved
  1053                                  validate_call:
  1054                                  	push    ax
  1055                                  
  1056                                     cs   cmp     ch,[DTAB_max_cyl+di]
  1057                                  	jnbe    .7
  1058                                     cs   mov     ah,[DI_heads+di]
  1059                                  	sub     ah,dh
  1060                                  	jbe     .7
  1061                                     cs   mov     al,[DTAB_EOT_nsect+di]
  1062                                  	dec     cl      ; base sectors at 0
  1063                                  	cmp     cl,al
  1064                                  	jnc     .6      ; JNC = JNB = JAE
  1065                                  	mul     ah
  1066                                  ; AX is 1 or 2 * sectors
  1067                                  	sub     al,cl
  1068                                  ; AL is the maximum number of sectors we can transfer
  1069                                  	cmp     al,[offset_AX+bp]       ; compare to sector count
  1070                                  .6:     inc     cl      ; back to sectors from 1
  1071                                  	jnc     .8      ; JAE = JNB = JNC
  1072                                  .7:     stc
  1073                                  .8:     pop     ax      ;
  1074                                  	ret
  1075                                  %endif
  1076                                  
  1077                                  
  1078                                  
  1079                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1080                                  ;  Function 02h         Read Sectors
  1081                                  ;  Function 03h         Write Sectors
  1082                                  ;  Function 04h         Verify Sectors
  1083                                  ;
  1084                                  ;  Enter with:
  1085                                  ;       AH = 02h (read)
  1086                                  ;       AH = 03h (write)
  1087                                  ;       AH = 04h (verify)
  1088                                  ;       AL = number of sectors to transfer
  1089                                  ;       CH = cylinder number
  1090                                  ;       CL = sector number
  1091                                  ;       DH = head number
  1092                                  ;       DL = drive 0 or 1
  1093                                  ;       ES:BX = buffer to read into or write from
  1094                                  ;
  1095                                  ;  Return with:
  1096                                  ;       Carry clear if no error
  1097                                  ;       AH = 0
  1098                                  ;       AL = number of sectors transferred
  1099                                  ;
  1100                                  ;       Carry set on error
  1101                                  ;       AH = error code
  1102                                  ;
  1103                                  ;       All other registers are preserved.
  1104                                  ;
  1105                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1106                                  ;
  1107                                  ;  Stack variables
  1108                                  ;
  1109                                  rwv_return	equ	-2	; offset from BP
  1110                                  rwv_dma		equ	rwv_return - 2
  1111                                  rwv_xfer	equ	rwv_dma - 2
  1112                                  rwv_cmd		equ	rwv_xfer - 9
  1113                                  rwv_AL		equ	rwv_cmd - 1
  1114                                  rwv_stack	equ	- rwv_AL
  1115                                  
  1116                                  ;FDC_DMA_READ	equ (101b<<13)+(011b<<10)+(11b<<8)+(01b<<6)+(00b<<4)+0110b
  1117                                  FDC_DMA_READ	equ (101b<<13)+(000b<<10)+(11b<<8)+(01b<<6)+(10b<<4)+0110b
  1118                                  
  1119                                  ;FDC_DMA_WRITE	equ (011b<<13)+(101b<<10)+(11b<<8)+(10b<<6)+(00b<<4)+0110b
  1120                                  FDC_DMA_WRITE	equ (000b<<13)+(101b<<10)+(11b<<8)+(10b<<6)+(10b<<4)+0110b
  1121                                  
  1122                                  ;FDC_DMA_READ	equ (101b<<13)+(000b<<10)+(11b<<8)+(01b<<6)+(10b<<4)+0110b
  1123                                  FDC_DMA_SCAN	equ (100b<<13)+(000b<<10)+(11b<<8)+(01b<<6)+(10b<<4)+0110b
  1124                                  
  1125                                  FDC_DMA_FORMAT	equ	FDC_DMA_WRITE
  1126                                  
  1127                                  
  1128                                  %if SOFT_DEBUG
  1129 0000032E 66A3                    	dw	FDC_DMA_READ
  1130 00000330 A617                    	dw	FDC_DMA_WRITE
  1131 00000332 6683                    	dw	FDC_DMA_SCAN
  1132                                  %endif
  1133                                  
  1134                                  fn02:	; READ
  1135 00000334 B4E6                    	mov	ah,(CMD_READ_DATA | CMD_MT | CMD_MF | CMD_SK)
  1136 00000336 BF66A3                  	mov	di,FDC_DMA_READ
  1137 00000339 BB[F805]                	mov	bx,xfer_read_sector
  1138 0000033C EB12                    	jmp	rwv_common
  1139                                  
  1140                                  %define EXTRA 0
  1141                                  fn03:	; WRITE
  1142                                  %if EXTRA
  1143                                  	cmp	al,1
  1144                                  	jbe	.10
  1145                                  
  1146                                  	mov	bx,[offset_BX+bp]	; restore BX
  1147                                  	mov	[offset_AH+bp],al	; use return code as counter
  1148                                  
  1149                                  .1:	mov	ax,0301h		; write 1 sector
  1150                                  	int	13h
  1151                                  	jc	.5
  1152                                  
  1153                                  	inc	cl			; increment sector number
  1154                                  	add	bx,200h			; increment transfer address
  1155                                  	dec	byte [offset_AH+bp]
  1156                                  	jnz	.1
  1157                                  
  1158                                  	Okay				; all went Okay
  1159                                  	ret
  1160                                  
  1161                                  ; process error return
  1162                                  ;  AH = error code
  1163                                  .5:	mov	al,[offset_AL+bp]	; sectors requested
  1164                                  	sub	al,[offset_AH+bp]	; sectors remaining
  1165                                  	mov	[offset_AL+bp],al	; set sectors transferred
  1166                                  	Error
  1167                                  	ret
  1168                                  
  1169                                  .10:
  1170                                  %endif
  1171 0000033E B4C5                    	mov	ah,(CMD_WRITE_DATA | CMD_MT | CMD_MF)
  1172 00000340 BFA617                  	mov	di,FDC_DMA_WRITE
  1173 00000343 BB[7306]                	mov	bx,xfer_write_sector
  1174 00000346 EB08                    	jmp	rwv_common
  1175                                  
  1176                                  fn04:	; VERIFY
  1177 00000348 B4E6                    	mov	ah,(CMD_READ_DATA | CMD_MT | CMD_MF | CMD_SK)
  1178 0000034A BF6683                  	mov	di,FDC_DMA_SCAN
  1179 0000034D BB[A806]                	mov	bx,xfer_verify_sector
  1180                                  ;;;	jmp	rwv_common
  1181                                  
  1182                                  ;  Common code to READ, WRITE, and VERIFY
  1183                                  rwv_common:
  1184 00000350 57                      	push	di			; dma control register
  1185 00000351 53                      	push	bx			; transfer function
  1186 00000352 83EC08                  	sub	sp,rwv_stack - 8	; 4 words in stack by pushes or Call
  1187 00000355 50                      	push	ax			; including this push
  1188                                  
  1189 00000356 E89501                  	call	check_DL		; sets DI
  1190 00000359 B401                    	mov	ah,ERR_invalid_command
  1191 0000035B 7267                    	jc	.exit
  1192 0000035D E8A501                  	call	get_disk_type
  1193 00000360 E8B101                  	call	get_media		; get media pointer to CS:BX
  1194 00000363 E8BA01                  	call	set_media_pointer	; set up Int 1Eh
  1195 00000366 E82A02                  	call	motor_on		; use DI to start motor
  1196                                  
  1197 00000369 E8C003                  	call	Seek			; use CH to seek to track
  1198                                  					; recalibrate is possible
  1199 0000036C 7256                    	jc	.exit			; AH is error code
  1200                                  
  1201 0000036E E87002                  	call	make_head_unit		; AL is next byte
  1202                                  
  1203 00000371 571E06                  	pushm	es,ds,di
  1204 00000374 8D7EF2                  	lea	di,[rwv_cmd+1+bp]		; SS override not needed
  1205 00000377 8D7703                  	lea	si,[DTAB_N_param+bx]
  1206 0000037A 160E                    	pushm	cs,ss
  1207 0000037C 1F900790                	popm	ds,es
  1208 00000380 AA                      	stosb				; store head unit in cmd stream
  1209 00000381 88E8                    	mov	al,ch			; cylinder
  1210 00000383 AA                      	stosb
  1211 00000384 88F0                    	mov	al,dh			; head
  1212 00000386 AA                      	stosb
  1213 00000387 88C8                    	mov	al,cl			; sector (R)
  1214 00000389 AA                      	stosb
  1215 0000038A AC                      	lodsb				; get N
  1216 0000038B 88C1                    	mov	cl,al
  1217 0000038D AA                      	stosb				; store N
  1218 0000038E A4                      	movsb				; EOT
  1219 0000038F A4                      	movsb				; GPL
  1220 00000390 A4                      	movsb				; DTL = FF
  1221 00000391 8D76F1                  	lea	si,[rwv_cmd+bp]		; get command start
  1222 00000394 07901F905F              	popm	es,ds,di
  1223                                  
  1224 00000399 B88000                  	mov	ax,128			; minimum sector size
  1225 0000039C F666F0                  	mul	byte [rwv_AL+bp]	; times number of sectors to transfer
  1226 0000039F D3E0                    	shl	ax,cl			; shift by N_param
  1227 000003A1 89C1                    	mov	cx,ax			; CX is byte count of transfer
  1228                                  
  1229 000003A3 53                      	pushm	bx			; save DTAB pointer
  1230                                  
  1231 000003A4 8B4608                  	mov	ax,[offset_BX+bp]	; get Xfer address offset
  1232 000003A7 8CC3                    	mov	bx,es			; segment to AX
  1233 000003A9 89DA                    	mov	dx,bx			; and to DX
  1234 000003AB C1EB0C                  	shr	bx,12			; high 4 bits of address
  1235 000003AE C1E204                  	shl	dx,4			; high part of offset from segment
  1236 000003B1 01D0                    	add	ax,dx			; form low 16 bits of 20-bit address
  1237 000003B3 83D300                  	adc	bx,0			; and carry into the high bits
  1238                                  
  1239 000003B6 8CD2                    	mov	dx,ss			; DX:SI points at command start
  1240                                  
  1241                                  .marker:
  1242                                  ;	BX:AX	transfer 20-bit address in memory
  1243                                  ;	CX	transfer byte count
  1244                                  ;	DX:SI	pointer to 9-byte FDC command
  1245                                  ;
  1246 000003B8 80263E0000              	and	byte [fdc_drv_calib],00h	;POST no interrupts received
  1247                                  
  1248 000003BD FF56FA                  	call	near [rwv_xfer+bp]		;call specific transfer function
  1249                                  
  1250 000003C0 5B                      	popm	bx				; restor DTAB pointer (CS:BX)
  1251                                  ;;;	jc	.exit			; AH is set to error code
  1252                                  
  1253 000003C1 E8CC03                  	call	Check_RW_Status		; get final return code
  1254                                  
  1255                                  .exit:
  1256 000003C4 8D66FE                  	lea	sp,[rwv_return+bp]
  1257 000003C7 C3                      	ret
  1258                                  
  1259                                  %if SOFT_DEBUG
  1260                                  end_rwv		equ	$
  1261                                  %endif
  1262                                  
  1263                                  
  1264                                  
  1265                                  ; Format stack layout
  1266                                  fmt_return	equ	-2			; return from fn05 call
  1267                                  fmt_dma		equ	fmt_return - 2
  1268                                  fmt_cmd		equ	fmt_dma - 6
  1269                                  fmt_stack	equ	-fmt_cmd		; stack size
  1270                                  
  1271                                  %if fmt_dma != rwv_dma
  1272                                  %error "fmt_dma != rwv_dma"
  1273                                  %endif
  1274                                  
  1275                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1276                                  ;  Function 05h         Format a Track
  1277                                  ;
  1278                                  ;  Precede with call to Function 18h (or 17h) to set the disk type
  1279                                  ;
  1280                                  ;  Enter with:
  1281                                  ;       AH = 05h
  1282                                  ;       CH = cylinder number
  1283                                  ;       DH = head number
  1284                                  ;       DL = drive 0 or 1
  1285                                  ;       ES:BX = segment/offset of address field list (C/H/R/N)
  1286                                  ;
  1287                                  ;  Return with:
  1288                                  ;       Carry clear if no error
  1289                                  ;       AH = 0
  1290                                  ;
  1291                                  ;       Carry set on error
  1292                                  ;       AH = error code
  1293                                  ;
  1294                                  ;       All other registers are preserved.
  1295                                  ;
  1296                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1297                                  fn05:
  1298 000003C8 83EC0A                  	sub	sp,fmt_stack		; allocate stack space
  1299 000003CB C746FCA617              	mov	word [fmt_dma+bp],FDC_DMA_FORMAT
  1300                                  
  1301 000003D0 E81B01                  	call	check_DL		; sets DI
  1302 000003D3 B401                    	mov	ah,ERR_invalid_command
  1303 000003D5 7272                    	jc	.exit
  1304                                  
  1305 000003D7 06                      	pushm	es		; save ES
  1306 000003D8 6A00                    	push	0
  1307 000003DA 0790                    	popm	es
  1308 000003DC 8CCB                    	mov	bx,cs		; get CS segment
  1309 000003DE 263B1E7A00                es	cmp	bx,[1Eh*4+2]	; check segment is CS
  1310 000003E3 7564                    	jne	.exit		; (will restore stack)
  1311                                  
  1312 000003E5 268B1E7800                es	mov	bx,[1Eh*4]	; get CS:BX as disk param table pointer
  1313 000003EA 0790                    	popm	es     		; restore Stack
  1314                                  
  1315 000003EC E8A401                  	call	motor_on		; use DI to start motor
  1316                                  
  1317 000003EF E83A03                  	call	Seek			; use CH to seek to track
  1318                                  					; recalibrate is possible
  1319 000003F2 7255                    	jc	.exit			; AH is error code
  1320                                  
  1321 000003F4 E8EA01                  	call	make_head_unit		; AL is next byte
  1322 000003F7 88C4                    	mov	ah,al			; save head/unit in AH
  1323                                  
  1324 000003F9 571E06                  	pushm	es,ds,di
  1325                                  
  1326 000003FC 160E                    	pushm	cs,ss
  1327 000003FE 1F900790                	popm	ds,es
  1328 00000402 8D7EF6                  	lea	di,[bp+fmt_cmd]
  1329 00000405 8D7703                  	lea	si,[bx+DTAB_N_param]
  1330                                  
  1331 00000408 B00D                    	mov	al,CMD_FORMAT_A_TRACK
  1332 0000040A 803C00                  	cmp	byte [si],0		; is N==0
  1333 0000040D 7402                    	je	.2
  1334 0000040F 0C40                    	or	al,CMD_MF		; MFM recording
  1335                                  .2:
  1336 00000411 AB                      	stosw				; AH=head/unit, AL=format cmd
  1337 00000412 A4                      	movsb				; set N
  1338 00000413 AC                      	lodsb				; get SC
  1339 00000414 88C1                    	mov	cl,al			; save SC in AL
  1340 00000416 AA                      	stosb				; set SC
  1341 00000417 83C602                  	add	si,2			; advance to GPL3
  1342 0000041A A5                      	movsw				; set GPL3 and Fill
  1343                                  
  1344 0000041B 8D76F6                  	lea	si,[bp+fmt_cmd]
  1345 0000041E 07901F905F              	popm	es,ds,di    		; restore regs
  1346                                  
  1347 00000423 30ED                    	xor	ch,ch			; CX = sector count
  1348 00000425 C1E102                  	shl	cx,2			; CX = byte count of param table
  1349                                  
  1350 00000428 53                      	pushm	bx			; save DTAB pointer
  1351                                  
  1352 00000429 8B4608                  	mov	ax,[offset_BX+bp]	; get Xfer address offset
  1353 0000042C 8CC3                    	mov	bx,es			; segment to AX
  1354 0000042E 89DA                    	mov	dx,bx			; and to DX
  1355 00000430 C1EB0C                  	shr	bx,12			; high 4 bits of address
  1356 00000433 C1E204                  	shl	dx,4			; high part of offset from segment
  1357 00000436 01D0                    	add	ax,dx			; form low 16 bits of 20-bit address
  1358 00000438 83D300                  	adc	bx,0			; and carry into the high bits
  1359                                  
  1360 0000043B 8CD2                    	mov	dx,ss			; DX:SI points at command start
  1361                                  
  1362                                  ;.marker:
  1363                                  ;	BX:AX	transfer 20-bit address in memory
  1364                                  ;	CX	transfer byte count
  1365                                  ;	DX:SI	pointer to 9-byte FDC command
  1366                                  ;
  1367 0000043D 80263E0000              	and	byte [fdc_drv_calib],00h	;POST no interrupts received
  1368                                  
  1369 00000442 E82E02                  	call	xfer_format_track	; format the track
  1370                                  
  1371 00000445 5B                      	popm	bx				; restor DTAB pointer (CS:BX)
  1372                                  ;;;	jc	.exit			; AH is set to error code
  1373                                  
  1374 00000446 E84703                  	call	Check_RW_Status		; get final return code
  1375                                  
  1376                                  
  1377                                  .exit:
  1378 00000449 8D66FE                  	lea	sp,[rwv_return+bp]	; restore stack location
  1379 0000044C C3                      	ret
  1380                                  
  1381                                  
  1382                                  
  1383                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1384                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1385                                  	global  dma0_interrupt
  1386                                  dma0_interrupt:
  1387 0000044D 1E5250                  	pushm   ax,dx,ds
  1388                                  	
  1389 00000450 6A40                    	push    bios_data_seg
  1390 00000452 1F90                    	popm    ds
  1391                                  
  1392                                  %if SOFT_DEBUG
  1393 00000454 800E3E0002              	or	byte [fdc_drv_calib],02h		;POST dma interrupt
  1394                                  %endif
  1395                                  
  1396                                  %if 0
  1397                                  	mov     dx,FDC_TC               ; Terminal Count
  1398                                  	in      al,dx                   ; pulse the line
  1399                                  %endif
  1400                                  
  1401                                  %if 0
  1402                                  	mov     dx,DMA0+DMACW           ; DMA0 control word
  1403                                  	in      ax,dx
  1404                                  	mov     [dma0_cw],ax            ; post the resulting CW
  1405                                  %endif
  1406                                  
  1407                                  ; signal EOI (End of Interrupt)
  1408 00000459 BA22FF                  	mov     dx,PIC_EOI              ; EOI register
  1409 0000045C B80080                  	mov     ax,EOI_NSPEC            ; non-specific
  1410 0000045F EF                      	out     dx,ax                   ; signal it
  1411                                  
  1412 00000460 585A1F90                	popm    ax,dx,ds
  1413 00000464 CF                      	iret
  1414                                  
  1415                                  
  1416                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1417                                  ;  Function 15h         Get Disk Type 
  1418                                  ;
  1419                                  ;  Enter with:
  1420                                  ;       AH = 15h
  1421                                  ;       DL = drive 0 or 1
  1422                                  ;
  1423                                  ;  Return with:
  1424                                  ;       Carry clear if no error
  1425                                  ;       AH = drive type code
  1426                                  ;               0 = no drive present
  1427                                  ;               1 = floppy without change line support
  1428                                  ;               2 = floppy with change line support
  1429                                  ;               3 = fixed disk
  1430                                  ;
  1431                                  ;       Carry set on error
  1432                                  ;       AH = error code
  1433                                  ;
  1434                                  ;       All other registers are preserved.
  1435                                  ;
  1436                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1437                                  fn15:
  1438 00000465 30E4                    	xor	ah,ah			; No drive present
  1439 00000467 E88400                  	call	check_DL
  1440 0000046A 7309                    	jnc	.ok
  1441 0000046C 83FFFF                  	cmp	di,-1
  1442 0000046F 7503E9C0FB              	je	undefined		; DL is really bad
  1443 00000474 C3                      	ret				; AH=0, no drive present
  1444                                  					; carry will be cleared
  1445                                  .ok:
  1446 00000475 FEC4                    	inc	ah			; drive ok, no change line support
  1447 00000477 F8                      	clc
  1448 00000478 E9ACFB                  	jmp	exit_pops		;
  1449                                  
  1450                                  
  1451                                  
  1452                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1453                                  ;  Function 16h         Get Disk Change Status
  1454                                  ;
  1455                                  ;  Enter with:
  1456                                  ;       AH = 16h
  1457                                  ;       DL = drive 0 or 1
  1458                                  ;
  1459                                  ;  Return with:
  1460                                  ;       Carry clear
  1461                                  ;       AH = 0  disk not changed
  1462                                  ;
  1463                                  ;       Carry set
  1464                                  ;       AH = 6  disk has been changed
  1465                                  ;            0  error
  1466                                  ;
  1467                                  ;       All other registers are preserved.
  1468                                  ;
  1469                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1470                                  fn16:
  1471 0000047B E87000                  	call	check_DL
  1472 0000047E 7303E9B1FB              	jc	undefined
  1473                                  
  1474 00000483 89F8                    	mov	ax,di			; AL = 0, 1	AH = 0
  1475                                  ; AH is now 0
  1476 00000485 FEC0                    	inc	al			; AL = 1, 2
  1477 00000487 C0C004                  	rol	al,4			; AL = MOEN1 or MOEN2
  1478 0000048A 84063F00                	test	[fdc_motor_LDOR],al	; test if motor running
  1479 0000048E 7502                    	jnz     .on
  1480                                  
  1481 00000490 B406                    	mov     ah,ERR_disk_removed	; signal disk changed
  1482                                  .on:
  1483 00000492 C3                      	ret			; AH=6, Carry will be set
  1484                                  	
  1485                                  
  1486                                  
  1487                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1488                                  ;  Function 17h		Set Disk Type for Format	(PC-AT)
  1489                                  ;
  1490                                  ;  Enter with:
  1491                                  ;	AH = 17h
  1492                                  ;	AL =	00h     not used
  1493                                  ;		01h     160, 180, 320, or 360Kb diskette in 360kb drive
  1494                                  ;		02h     360Kb diskette in 1.2Mb drive
  1495                                  ;		03h     1.2Mb diskette in 1.2Mb drive
  1496                                  ;		04h     720Kb diskette in 720Kb drive
  1497                                  ;	DL = drive number
  1498                                  ;
  1499                                  ;  Return with:
  1500                                  ;	AH = 0		success
  1501                                  ;	Carry clear
  1502                                  ;
  1503                                  ;	Carry set	error
  1504                                  ;	AH = error code
  1505                                  ;
  1506                                  ;  note 1) This function is probably enhanced for the PS/2 series to detect
  1507                                  ;	   1.44 in 1.44 and 720k in 1.44.
  1508                                  ;	2) This function is not supported for floppy disks on the PC or XT.
  1509                                  ;	3) If the change line is active for the specified drive, it is reset.
  1510                                  ;	4) The BIOS sets the data rate for the specified drive and media type.
  1511                                  ;	   The rate is 250k/sec for double-density media and 500k/sec for high
  1512                                  ;	   density media. The proper hardware is required.
  1513                                  ;	5) This function is used by DOS <= 3.1
  1514                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1515                                  ;fn17:
  1516                                  ;;;	ret
  1517                                  
  1518                                  
  1519                                  
  1520                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1521                                  ;  Function 18h		Set Media Type For Format  (diskette)   (AT, XT2, XT/286, PS/2)
  1522                                  ;
  1523                                  ;  Enter with:
  1524                                  ;	AH = 18h
  1525                                  ;	CH = max. cylinder number (80 or 40  minus  1)
  1526                                  ;	CL = number of sectors (9, 15, 18)
  1527                                  ;	DL = drive number
  1528                                  ;
  1529                                  ;  Return with:
  1530                                  ;	Carry clear -- no errors
  1531                                  ;	AH =	00h      if requested combination supported
  1532                                  ;	ES:DI	pointer to 13-byte parameter table
  1533                                  ;
  1534                                  ;	Carry set -- error
  1535                                  ;	AH =	01h      if function not available
  1536                                  ;		0Ch      if not suppported or drive type unknown
  1537                                  ;		80h      if there is no media in the drive
  1538                                  ;
  1539                                  ;  note 1) A floppy disk must be present in the drive.
  1540                                  ;	2) This function should be called prior to formatting a disk with Int 13h
  1541                                  ;	   Fn 05h so the BIOS can set the correct data rate for the media.
  1542                                  ;	3) If the change line is active for the specified drive, it is reset.
  1543                                  ;	4) This function is used by DOS >= 3.2
  1544                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1545                                  fn18:
  1546 00000493 E85800                  	call	check_DL		; check validity of drive no.
  1547 00000496 7303E999FB              	jc	undefined
  1548                                  
  1549 0000049B E86700                  	call	get_disk_type		; get disk type to AL
  1550 0000049E 3C0B                    	cmp	al,L_table
  1551 000004A0 7327                    	jnb	.alt
  1552 000004A2 88C3                    	mov	bl,al
  1553 000004A4 30FF                    	xor	bh,bh
  1554 000004A6 D1E3                    	shl	bx,1
  1555 000004A8 2E8B9F[6900]              cs	mov	bx,[D_table+bx]		; get offset of DTAB entry
  1556 000004AD 85DB                    	test	bx,bx
  1557 000004AF 743A                    	jz	.errC
  1558 000004B1 2E384F04                  cs	cmp	[DTAB_EOT_nsect+bx],cl	; check number of sectors
  1559 000004B5 7512                      	jne	.alt			; try alternate
  1560 000004B7 2E386F0B                  cs	cmp	[DTAB_max_cylinder+bx],ch  ; check number of cylinders
  1561 000004BB 750C                      	jne	.alt
  1562                                  .found:
  1563 000004BD E86000                         	call	set_media_pointer
  1564 000004C0 895E00                  	mov	[offset_DI+bp],bx
  1565 000004C3 8C4E12                  	mov	[offset_ES+bp],cs	; return in ES:DI
  1566 000004C6 30E4                    	xor	ah,ah
  1567 000004C8 C3                      	ret
  1568                                  
  1569                                  .alt:
  1570 000004C9 E84000                  	call	get_disk_alt_type	; get disk type to AL
  1571 000004CC 3C0B                    	cmp	al,L_table
  1572 000004CE 731B                    	jnb	.errC
  1573 000004D0 88C3                    	mov	bl,al
  1574 000004D2 30FF                    	xor	bh,bh
  1575 000004D4 D1E3                    	shl	bx,1
  1576 000004D6 2E8B9F[6900]              cs	mov	bx,[D_table+bx]		; get offset of DTAB entry
  1577 000004DB 85DB                    	test	bx,bx
  1578 000004DD 740C                    	jz	.errC
  1579 000004DF 2E384F04                  cs	cmp	[DTAB_EOT_nsect+bx],cl	; check number of sectors
  1580 000004E3 7506                      	jne	.errC			; no match?
  1581 000004E5 2E386F0B                  cs	cmp	[DTAB_max_cylinder+bx],ch  ; check number of cylinders
  1582 000004E9 74D2                    	je	.found
  1583                                  
  1584 000004EB B40C                    .errC:	mov	ah,ERR_media_type_not_found
  1585 000004ED C3                      	ret
  1586                                  
  1587                                  
  1588                                  
  1589                                  
  1590                                  
  1591                                  check   cpu_xtal-0FFh
  1592                                  
  1593                                  
  1594                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1595                                  ;  check_DL -- check for valid disk #
  1596                                  ;
  1597                                  ;  Return:
  1598                                  ;	DI = 0 or 1 if DL is valid floppy
  1599                                  ;	Carry clear
  1600                                  ;
  1601                                  ;	DI not valid if DL is invalid
  1602                                  ;	Carry set
  1603                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1604                                  check_DL:
  1605 000004EE BFFFFF                  	mov	di,-1				; invalid DI
  1606 000004F1 80FA02                  	cmp	dl,FLOPPY_MAX
  1607 000004F4 730D                    	jnb	.err
  1608 000004F6 89D7                    	mov	di,dx
  1609 000004F8 83E701                  	and	di,FLOPPY_MAX-1			; clear the carry
  1610 000004FB F685F8000F              	test	byte [fdc_type+di],0Fh		; drive present?
  1611 00000500 7401                    	jz	.err
  1612 00000502 C3                      	ret					; carry is clear
  1613                                  
  1614 00000503 F9                      .err:	stc
  1615 00000504 C3                      	ret
  1616                                  
  1617                                  
  1618                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1619                                  ;  get_disk_type
  1620                                  ;
  1621                                  ;  Enter with:
  1622                                  ;	DI = drive no.
  1623                                  ;
  1624                                  ;  Return with:
  1625                                  ;	AL = drive type (0..4)
  1626                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1627                                  get_disk_type:
  1628 00000505 8A85F800                	mov	al,[fdc_type+di]	; get type byte
  1629 00000509 240F                    	and	al,0Fh			; mask low nibble
  1630 0000050B C3                      	ret
  1631                                  
  1632                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1633                                  ;  get_disk_alt_type
  1634                                  ;
  1635                                  ;  Enter with:
  1636                                  ;	DI = drive no.
  1637                                  ;
  1638                                  ;  Return with:
  1639                                  ;	AL = drive type (0..4)
  1640                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1641                                  get_disk_alt_type:
  1642 0000050C 8A85F800                	mov	al,[fdc_type+di]	; get type byte
  1643 00000510 C0E804                  	shr	al,4
  1644 00000513 C3                      	ret
  1645                                  
  1646                                  
  1647                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1648                                  ;  get_media
  1649                                  ;
  1650                                  ;  Call with:
  1651                                  ;	AL = disk type
  1652                                  ;
  1653                                  ;  Return with:
  1654                                  ;	CS:BX		pointer to 13-byte disk media table
  1655                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1656                                  get_media:
  1657 00000514 88C3                    	mov	bl,al
  1658 00000516 30FF                    	xor	bh,bh
  1659 00000518 D1E3                    	shl	bx,1
  1660 0000051A 2E8B9F[6900]              cs	mov	bx,[D_table+bx]		; get offset of DTAB entry
  1661 0000051F C3                        	ret
  1662                                  
  1663                                  
  1664                                  
  1665                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1666                                  ;  set_media_pointer
  1667                                  ;
  1668                                  ;  Call with:
  1669                                  ;	CS:BX	pointer to 13-byte disk media table
  1670                                  ;	DS	BIOS data area pointer
  1671                                  ;
  1672                                  ;  Return with:
  1673                                  ;	CS:BX		pointer to 13-byte disk media table
  1674                                  ;	Int 1Eh 	floppy media pointer set
  1675                                  ;
  1676                                  ;	Carry Set = new media pointer (needed Specify command)
  1677                                  ;	Carry Clear = same media pointer (Specify not needed)
  1678                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1679                                  set_media_pointer:
  1680 00000520 0651                    	pushm	cx,es			; save for later
  1681 00000522 6A00                    	push	0			; address interrupt vectors
  1682 00000524 07                      	pop	es			; **
  1683 00000525 8CC9                    	mov	cx,cs
  1684 00000527 26391E7800                es	cmp	word [1Eh*4],bx
  1685 0000052C 7508                    	jne	.diff
  1686 0000052E 26390E7A00                es	cmp	word [1Eh*4+2],cx	; segment
  1687 00000533 F8                      	clc
  1688 00000534 7411                    	jz	.same
  1689                                  .diff:
  1690 00000536 26891E7800                es	mov	word [1Eh*4],bx		; offset
  1691 0000053B 26890E7A00                es	mov	word [1Eh*4+2],cx	; segment
  1692 00000540 8EC1                    	mov	es,cx
  1693 00000542 90                      	cnop
  1694 00000543 E80500                  	call	Specify			; ES:BX is table pointer
  1695 00000546 F9                      	stc
  1696                                  .same:
  1697 00000547 590790                  	popm	cx,es			; restore DS
  1698 0000054A C3                      	ret
  1699                                  
  1700                                  
  1701                                  
  1702                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1703                                  ;  Specify		issue specify command to FDC
  1704                                  ;
  1705                                  ;  Call with:
  1706                                  ;	ES:BX		pointer to 13-byte disk table
  1707                                  ;	DS		BIOS data area pointer
  1708                                  ;
  1709                                  ;  Return with:
  1710                                  ;	Nothing
  1711                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1712                                  Specify:
  1713 0000054B 56525350                	pushm	ax,bx,dx,si
  1714 0000054F 83EC04                  	sub	sp,4			; allocate 4 bytes for command
  1715 00000552 89E6                    	mov	si,sp
  1716                                  
  1717 00000554 268A470C                  es	mov	al,[DTAB_control+bx]	; clock bits
  1718 00000558 C0C002                    	rol	al,2
  1719 0000055B BA3006                  	mov	dx,FDC_LDCR		; Control Register
  1720 0000055E EE                      	out	dx,al
  1721                                  
  1722 0000055F B20C                    	mov	dl,12			; 12 usec delay  = T time
  1723 00000561 08C0                    	or	al,al			; test for hi (00) or lo (80) data rate
  1724 00000563 7502                    	jnz	.3
  1725 00000565 D0EA                    	shr	dl,1			; crystal has factor of 2 already
  1726                                  .3:
  1727 00000567 A0FF00                  	mov	al,[cpu_xtal]		; 2x clock frequency
  1728 0000056A F6E2                    	mul	dl			; AX = 2xClock * T or 2xclock * T/2 (80 or 00)
  1729 0000056C 83E82C                  	sub	ax,44			; overhead CPU clocks
  1730 0000056F B214                    	mov	dl,20			; loop clock count
  1731 00000571 F6F2                    	div	dl
  1732 00000573 FEC0                    	inc	al			; for good measure
  1733 00000575 A2AD00                  	mov	[wait12_count],al	; save count
  1734                                  
  1735 00000578 36C60403                  ss	mov	byte [si],CMD_SPECIFY
  1736 0000057C 268B07                    es	mov	ax,[DTAB_specify+bx]	; get two specify bytes
  1737 0000057F 36894401                  ss	mov	word [si+1],ax
  1738 00000583 8CD2                      	mov	dx,ss
  1739 00000585 B90300                  	mov	cx,3			; length of command = 3
  1740 00000588 E803FC                  	call	output_cmd_to_fdc
  1741 0000058B 83C404                  	add	sp,4
  1742 0000058E 585B5A5E                	popm	ax,bx,dx,si
  1743 00000592 C3                      	ret
  1744                                  
  1745                                  
  1746                                  
  1747                                  
  1748                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1749                                  ;  motor_on			Start the drive motor & wait
  1750                                  ;
  1751                                  ;  Call with:
  1752                                  ;	DI = drive to start (0, 1)
  1753                                  ;	CS:BX = drive parameter table pointer
  1754                                  ;
  1755                                  ;  Return with:
  1756                                  ;	motor is running and startup delay has been taken
  1757                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1758                                  	global	motor_on
  1759                                  motor_on:
  1760 00000593 525150                  	pushm	ax,cx,dx
  1761 00000596 89F8                    	mov	ax,di			; drive # to AL
  1762 00000598 0401                    	add	al,MOEN1>>4		; form MOENx >> 4
  1763 0000059A C0E004                  	shl	al,4			; form MOENx bitmask
  1764 0000059D 88C4                    	mov	ah,al			; MOENx -> AH
  1765 0000059F 01F8                    	add	ax,di			; MOENx + DSELx -> AL
  1766                                  
  1767 000005A1 B1B6                    	mov	cl,182				;10 seconds
  1768 000005A3 880E4000                  	mov	byte [fdc_motor_ticks],cl	; set long timer = 10 seconds
  1769                                  
  1770 000005A7 84263F00                	test	byte [fdc_motor_LDOR],ah	; motor already on?
  1771 000005AB 88C5                    	mov	ch,al
  1772 000005AD 750F                    	jnz	.its_on
  1773                                  
  1774                                  ; motor is not running
  1775 000005AF 2E8B470A                  cs	mov	ax,[DTAB_startup+bx]	; get startup delay in 1/8 seconds
  1776 000005B3 98                        	cbw
  1777 000005B4 6BC07D                    	imul	ax,125			; * 125 ms
  1778 000005B7 B236                    	mov	dl,54
  1779 000005B9 F6F2                    	div	dl			; divided by 54ms/tick
  1780 000005BB 40                      	inc	ax			; one more tick for good measure
  1781 000005BC 28C1                    	sub	cl,al			; CL is tick to wait for
  1782                                  
  1783                                  ; if motor was already running, then CL has not been changed
  1784                                  ; Do the select
  1785                                  .its_on:
  1786 000005BE 322E3F00                	xor	ch,[fdc_motor_LDOR]	; set selected bits
  1787 000005C2 80E531                  	and	ch,(MOEN_MASK | DSEL_MASK)
  1788 000005C5 302E3F00                	xor	[fdc_motor_LDOR],ch
  1789 000005C9 E878FC                  	call	out_LDOR_mem		; Motor Starts here, or continues
  1790 000005CC EB01                    	jmp	.wait
  1791                                  
  1792 000005CE F4                      	hlt
  1793 000005CF 380E4000                .wait:	cmp	[fdc_motor_ticks],cl	; has tick counter expired?
  1794 000005D3 77F9                    	ja	.wait-1
  1795                                  
  1796                                  ; reduce timer to turn-off delay time
  1797 000005D5 2E8A4F02                  cs	mov	cl,[DTAB_turnoff_ticks+bx]	; 2 seconds
  1798 000005D9 880E4000                  	mov	[fdc_motor_ticks],cl
  1799                                  
  1800 000005DD 58595A                  	popm	ax,cx,dx
  1801 000005E0 C3                      	ret
  1802                                  
  1803                                  
  1804                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1805                                  ;  make_head_unit
  1806                                  ;
  1807                                  ;  Enter with:
  1808                                  ;	DH = head number
  1809                                  ;	DI = unit number
  1810                                  ;
  1811                                  ;  Return with:
  1812                                  ;	AL = 0000 0huu
  1813                                  ;	Carry clear
  1814                                  ;
  1815                                  ;	Carry is set on error
  1816                                  ;
  1817                                  ;  Assumes "motor_on" has done the real unit select in the LDOR (operations register)
  1818                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1819                                  make_head_unit:
  1820 000005E1 88F0                    	mov	al,dh			; head number to AL
  1821 000005E3 A8FE                    	test	al, ~1			; check for head 0 or 1
  1822 000005E5 F9                      	stc				; set to signal error
  1823 000005E6 7507                    	jnz	.err
  1824 000005E8 2401                    	and	al,1			; defensive programming
  1825 000005EA C0E002                  	shl	al,2			; shift H to position
  1826 000005ED 09F8                    	or	ax,di			; clear the carry
  1827 000005EF C3                      .err:	ret
  1828                                  
  1829                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1830                                  ;  dma_outd		output a double word to a DMA double word register
  1831                                  ;
  1832                                  ;  Call with:
  1833                                  ;	BX:AX	double word to put out
  1834                                  ;	DX	low port address in the DMA controller
  1835                                  
  1836                                  ;  Exit with:
  1837                                  ;	DX incremented by 4
  1838                                  ;
  1839                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1840                                  dma_outd:
  1841 000005F0 EF                      	out	dx,ax
  1842 000005F1 42                      	inc	dx
  1843 000005F2 42                      	inc	dx
  1844 000005F3 93                      	xchg	ax,bx
  1845 000005F4 EF                      	out	dx,ax
  1846 000005F5 42                      	inc	dx
  1847 000005F6 42                      	inc	dx
  1848 000005F7 C3                      	ret
  1849                                  
  1850                                  
  1851                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1852                                  ;  xfer_read_sector
  1853                                  ;
  1854                                  ;  Call with:
  1855                                  ;	BX:AX	transfer address in memory
  1856                                  ;	CX	transfer byte count
  1857                                  ;	DX:SI	pointer to 9-byte FDC command
  1858                                  ;
  1859                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1860                                  xfer_read_sector:
  1861 000005F8 52                      	push	dx
  1862                                  
  1863                                  ;;;	and	byte [fdc_drv_calib],00h	;POST no interrupts
  1864                                  						; operation is not complete
  1865                                  
  1866                                  ;   BX:AX is the transfer destination address
  1867 000005F9 BAC4FF                  	mov	dx,DMA0+DMADPL		; set low destination
  1868 000005FC E8F1FF                  	call	dma_outd
  1869                                  
  1870 000005FF 89C8                    	mov	ax,cx			; total byte count
  1871 00000601 EF                      	out	dx,ax			; set terminal count
  1872                                  
  1873 00000602 31DB                    	xor	bx,bx
  1874 00000604 B81006                  	mov	ax,FDC_DACK
  1875                                  ;   BX:AX is the transfer source port
  1876 00000607 BAC0FF                  	mov	dx,DMA0+DMASPL		; set low source pointer
  1877 0000060A E8E3FF                  	call	dma_outd
  1878                                  
  1879 0000060D 8B46FC                  	mov	ax,[rwv_dma+bp]		; get Control register
  1880 00000610 BACAFF                  	mov	dx,DMA0+DMACW
  1881 00000613 EF                      	out	dx,ax			; starts the DMA
  1882                                  
  1883 00000614 5A                      	pop	dx		; reset DX:SI command pointer
  1884                                  
  1885 00000615 B90900                  	mov	cx,9			; 9-byte FDC command
  1886 00000618 E873FB                  	call	output_cmd_to_fdc
  1887                                  
  1888                                  
  1889 0000061B BBC0FF                  	mov	bx,DMA0+DMASPL
  1890 0000061E B95006                  	mov	cx,FDC_DACK_TC
  1891                                  
  1892                                  xfer_common_wait:
  1893 00000621 BAC8FF                  	mov	dx,DMA0+DMATC
  1894                                  .loop1:
  1895 00000624 803E400000              	cmp	byte [fdc_motor_ticks],0
  1896                                  ;;;	cmp	byte [fdc_motor_ticks],20h	; 2Fh - 0Fh in DTABx entries
  1897 00000629 7625                    	jbe	.timeout
  1898                                  
  1899 0000062B E8DAFA                  	call	wait12
  1900 0000062E ED                      	in	ax,dx
  1901 0000062F 83F80C                  	cmp	ax,THRESHHOLD
  1902 00000632 73F0                    	jae	.loop1
  1903                                  
  1904 00000634 E8A201                  	call	@disable
  1905                                  .loop2:
  1906 00000637 90                      	nop
  1907 00000638 90                      	nop
  1908 00000639 ED                      	in	ax,dx
  1909 0000063A 83F801                  	cmp	ax,1
  1910 0000063D 77F8                    	ja	.loop2
  1911                                  
  1912 0000063F 89DA                    	mov	dx,bx	; Source low
  1913 00000641 89C8                    	mov	ax,cx	; FDC_DACK_TC
  1914 00000643 EF                      	out	dx,ax
  1915                                  
  1916 00000644 E8A301                  	call	@enable
  1917                                  
  1918                                  ;;;	mov	ax,100b			; stop the channel
  1919                                  ;;;	mov	dx,DMA0+DMACW			; DMA control word
  1920                                  ;;;	out	dx,ax
  1921                                  
  1922 00000647 E81100                  	call	wait_operation_complete
  1923 0000064A 720E                    	jc	.99
  1924                                  
  1925                                  ;;;	mov	ax,100b			; stop the channel
  1926                                  ;;;	mov	dx,DMA0+DMACW			; DMA control word
  1927                                  ;;;	out	dx,ax
  1928                                  
  1929 0000064C 30E4                    	Okay
  1930 0000064E EB0A                    	jmp	.99
  1931                                  
  1932                                  .timeout:
  1933                                  ;;;	call	@enable
  1934                                  ; add the following:
  1935 00000650 B80400                  	mov	ax,100b			; stop the channel
  1936 00000653 BACAFF                  	mov	dx,DMA0+DMACW			; DMA control word
  1937 00000656 EF                      	out	dx,ax
  1938                                  
  1939 00000657 B485                    	mov	ah,ERR_85
  1940 00000659 F9                      	Error
  1941 0000065A C3                      .99:	ret
  1942                                  
  1943                                  
  1944                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1945                                  ;  wait_operation_complete		; wait for disk operation
  1946                                  ;					; to post a "complete" status
  1947                                  ;  Call with:
  1948                                  ;	DS = BIOS data area segment
  1949                                  ;
  1950                                  ;  Return with:
  1951                                  ;	CY = 0		success
  1952                                  ;	CY = 1		timed out, AH=error code
  1953                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1954                                  wait_operation_complete:
  1955 0000065B F6063E0001              .1:	test	byte [fdc_drv_calib],01h	; FDC interrupt posted "complete"?
  1956 00000660 7509                    	jnz	.okay
  1957 00000662 803E400000              	cmp	byte [fdc_motor_ticks],0
  1958 00000667 75F2                    	jne	.1
  1959 00000669 EB04                    	jmp	.timeout
  1960                                  
  1961 0000066B 30E4                    .okay:	Okay
  1962 0000066D EB03                    	jmp	.99
  1963                                  
  1964                                  .timeout:
  1965 0000066F B488                    	mov	ah,ERR_88		; mark timeout
  1966 00000671 F9                      	Error
  1967 00000672 C3                      .99:	ret
  1968                                  
  1969                                  
  1970                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1971                                  ;  xfer_write_sector
  1972                                  ;  xfer_format_track	(only command count is different)
  1973                                  ;
  1974                                  ;  Call with:
  1975                                  ;	BX:AX	transfer address in memory
  1976                                  ;	CX	transfer byte count
  1977                                  ;	DX:SI	pointer to 9-byte FDC command
  1978                                  ;
  1979                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1980                                  xfer_format_track:
  1981                                  xfer_write_sector:
  1982 00000673 52                      	push	dx
  1983                                  
  1984                                  ;   BX:AX is the transfer source address
  1985 00000674 BAC0FF                  	mov	dx,DMA0+DMASPL		; set low source address
  1986 00000677 E876FF                  	call	dma_outd
  1987                                  
  1988 0000067A 31DB                    	xor	bx,bx
  1989 0000067C B81006                  	mov	ax,FDC_DACK
  1990                                  
  1991                                  ;   BX:AX is the transfer destination port
  1992 0000067F BAC4FF                  	mov	dx,DMA0+DMADPL		; set low destination port
  1993 00000682 E86BFF                  	call	dma_outd
  1994                                  
  1995 00000685 89C8                    	mov	ax,cx			; total byte count
  1996 00000687 EF                      	out	dx,ax			; set terminal count
  1997                                  
  1998 00000688 8B46FC                  	mov	ax,[rwv_dma+bp]		; get Control register
  1999 0000068B BACAFF                  	mov	dx,DMA0+DMACW
  2000 0000068E EF                      	out	dx,ax			; starts the DMA
  2001                                  
  2002 0000068F 5A                      	pop	dx		; reset DX:SI command pointer
  2003                                  
  2004 00000690 B90900                  	mov	cx,9			; 9-byte FDC command
  2005 00000693 36F60408                  ss	test	byte [si], 01000b	; test for FORMAT command
  2006 00000697 7403                      	jz	.4
  2007 00000699 B90600                  	mov	cx,6			; it is FORMAT
  2008                                  .4:
  2009 0000069C E8EFFA                  	call	output_cmd_to_fdc
  2010                                  
  2011                                  
  2012 0000069F BBC4FF                  	mov	bx,DMA0+DMADPL		; Destination to be updated
  2013 000006A2 B95006                  	mov	cx,FDC_DACK_TC
  2014                                  
  2015 000006A5 E979FF                  	jmp	xfer_common_wait
  2016                                  
  2017                                  
  2018                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2019                                  ;  xfer_verify_sector
  2020                                  ;
  2021                                  ;  Call with:
  2022                                  ;	BX:AX	transfer address in memory
  2023                                  ;	CX	transfer byte count
  2024                                  ;	DX:SI	pointer to 9-byte FDC command
  2025                                  ;
  2026                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2027                                  xfer_verify_sector:
  2028 000006A8 52                      	push	dx
  2029                                  
  2030 000006A9 31DB                    	xor	bx,bx			; BX:AX is transfer address
  2031 000006AB B84204                  	mov	ax, (bios_data_seg<<4)+fdc_ctrl_status
  2032                                  
  2033                                  ;   BX:AX is the transfer destination address
  2034 000006AE BAC4FF                  	mov	dx,DMA0+DMADPL		; set low destination
  2035 000006B1 E83CFF                  	call	dma_outd
  2036                                  
  2037 000006B4 89C8                    	mov	ax,cx			; total byte count
  2038 000006B6 EF                      	out	dx,ax			; set terminal count
  2039                                  
  2040 000006B7 31DB                    	xor	bx,bx
  2041 000006B9 B81006                  	mov	ax,FDC_DACK
  2042                                  ;   BX:AX is the transfer source port
  2043 000006BC BAC0FF                  	mov	dx,DMA0+DMASPL		; set low source pointer
  2044 000006BF E82EFF                  	call	dma_outd
  2045                                  
  2046 000006C2 8B46FC                  	mov	ax,[rwv_dma+bp]		; get Control register
  2047 000006C5 BACAFF                  	mov	dx,DMA0+DMACW
  2048 000006C8 EF                      	out	dx,ax			; starts the DMA
  2049                                  
  2050 000006C9 5A                      	pop	dx		; reset DX:SI command pointer
  2051                                  
  2052 000006CA B90900                  	mov	cx,9			; 9-byte FDC command
  2053 000006CD E8BEFA                  	call	output_cmd_to_fdc
  2054                                  
  2055                                  
  2056 000006D0 BBC0FF                  	mov	bx,DMA0+DMASPL
  2057 000006D3 B95006                  	mov	cx,FDC_DACK_TC
  2058                                  
  2059 000006D6 E948FF                  	jmp	xfer_common_wait
  2060                                  
  2061                                  
  2062                                  
  2063                                  
  2064                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2065                                  ;  recalibrate
  2066                                  ;
  2067                                  ;  Enter with:
  2068                                  ;	DI = drive number
  2069                                  ;	CS:BX = parameter area pointer
  2070                                  ;	DS = BIOS data area pointer
  2071                                  ;
  2072                                  ;  Return with:
  2073                                  ;	Carry = 0 -- okay
  2074                                  ;
  2075                                  ;	Carry = 1 -- error
  2076                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2077                                  recalibrate:
  2078 000006D9 565251                  	pushm   cx,dx,si
  2079                                  
  2080                                  ;;;	call    motor_on
  2081                                  
  2082 000006DC 80263E0000              	and	byte [fdc_drv_calib],00h	;POST no interrupts
  2083                                  
  2084 000006E1 B001                    	mov	al,ST0_US	; mask to 2 drives
  2085 000006E3 21F8                    	and	ax,di		; unit number to AL
  2086 000006E5 86C4                    	xchg    al,ah		; AH is second byte of command
  2087 000006E7 B007                    	mov     al,CMD_RECALIBRATE
  2088 000006E9 50                      	push    ax		; push 2 byte command
  2089 000006EA 89E6                    	mov     si,sp           ; form command pointer
  2090 000006EC 8CD2                    	mov     dx,ss           ; DX:SI points at command
  2091 000006EE B90200                  	mov     cx,2		
  2092 000006F1 E89AFA                  	call    output_cmd_to_fdc	; output the command
  2093 000006F4 7231                    	jc      .7
  2094                                  
  2095 000006F6 E862FF                  	call	wait_operation_complete
  2096 000006F9 722C                    	jc	.7
  2097                                  
  2098 000006FB E84EFB                  	call    fdc_wait_seek_done
  2099 000006FE 7227                    	jc      .7
  2100                                  
  2101 00000700 58                      	pop     ax		; get unit # to AH
  2102 00000701 B004                    	mov     al,CMD_SENSE_DRIVE_STATUS
  2103 00000703 50                      	push    ax		; push 2 byte command again
  2104 00000704 B90200                  	mov     cx,2
  2105 00000707 89E6                    	mov     si,sp
  2106 00000709 8CD2                    	mov     dx,ss		; DX:SI points at the 2 byte command
  2107 0000070B E880FA                  	call    output_cmd_to_fdc
  2108 0000070E 7217                    	jc      .7
  2109                                  
  2110 00000710 E86BFA                  	call    input_byte_from_fdc	; get ST3
  2111 00000713 7212                    	jc      .7
  2112 00000715 88859000                	mov     [fdc_disk_state+di],al	; save ST3 for drive
  2113 00000719 B487                    	mov	ah,ERR_87		; not on track 0
  2114 0000071B A810                    	test    al,ST3_TR00
  2115 0000071D F9                      	Error				; signal error
  2116 0000071E 7407                    	jz      .7                      ; Not on Track 00, C=1 error
  2117                                  
  2118 00000720 C685940000              	mov	byte [fdc_cylinder+di],0	; set present cylinder
  2119                                  
  2120                                  %if SOFT_DEBUG > 1
  2121                                  	push    -1
  2122                                  	call    lites
  2123                                  %endif
  2124 00000725 30E4                    	Okay			;
  2125                                  	
  2126 00000727 5E                      .7:     pop     si		; Command is still in the stack
  2127 00000728 595A5E                  	popm    cx,dx,si	; restore
  2128 0000072B C3                      	ret
  2129                                  
  2130                                  
  2131                                  
  2132                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2133                                  ;  Seek			seek to proper cylinder
  2134                                  ;
  2135                                  ;  Call with:
  2136                                  ;	CH = cylinder to which to position heads
  2137                                  ;	CS:BX = disk parameter area
  2138                                  ;	DI = unit number
  2139                                  ;	DS = BIOS data area pointer
  2140                                  ;
  2141                                  ;  Return with:
  2142                                  ;	Carry = 0	success
  2143                                  ;
  2144                                  ;	Carry = 1	error
  2145                                  ;  
  2146                                  ;  Assumes "motor_on" has done the real unit select in the LDOR (operations register)
  2147                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2148                                  Seek:
  2149 0000072C 565251                  	pushm	cx,dx,si
  2150                                  
  2151                                  ; check for a recalibration needed
  2152 0000072F 8A859400                	mov	al,[fdc_cylinder+di]	; get present cylinder (0FFh forces recalibrate)
  2153 00000733 2E3A470B                 cs	cmp	al,[DTAB_max_cylinder+bx]	; compare to maximum
  2154 00000737 760E                    	jbe	.no_recal
  2155                                  
  2156 00000739 BE0200                  	mov	si,2			; two recalibrates max.
  2157                                  .rerecal:
  2158 0000073C E89AFF                  	call	recalibrate
  2159 0000073F 7306                    	jnc	.no_recal
  2160 00000741 4E                      	dec	si
  2161 00000742 F9                      	Error
  2162 00000743 7442                    	jz	.exit			; two have failed
  2163 00000745 EBF5                    	jmp	.rerecal		; try again
  2164                                  
  2165                                  .no_recal:
  2166 00000747 3AAD9400                	cmp	ch,[fdc_cylinder+di]	; sought : present cylinder
  2167 0000074B 7438                    	je	.okay
  2168                                  
  2169                                  ; we are not on the cylinder we want
  2170                                  
  2171 0000074D 2E3A6F0B                  cs	cmp	ch,[DTAB_max_cylinder+bx]  ; validate cylinder number
  2172 00000751 7738                    	ja	.invalid
  2173                                  
  2174                                  .valid:
  2175 00000753 80263E0000              	and	byte [fdc_drv_calib],00h	;POST no interrupts
  2176                                  
  2177 00000758 86CD                    	xchg	cl,ch			; cylinder to CL
  2178 0000075A 51                      	push	cx			; CL = sought cylinder
  2179 0000075B E883FE                  	call	make_head_unit
  2180 0000075E B40F                    	mov	ah,CMD_SEEK		; command byte
  2181 00000760 86C4                    	xchg	al,ah			; command byte must be first in stack
  2182 00000762 50                      	push	ax			; push 3 byte command
  2183 00000763 89E6                    	mov	si,sp
  2184 00000765 8CD2                    	mov	dx,ss			; DX:SI points at command
  2185 00000767 B90300                  	mov	cx,3			; 3 byte command
  2186 0000076A E821FA                  	call	output_cmd_to_fdc
  2187 0000076D 5E59                    	popm	si,cx			; fix stack; get CL=seek to cylinder
  2188 0000076F 86CD                    	xchg	cl,ch			; CH=seek to cylinder
  2189 00000771 7214                    	jc	.exit
  2190                                  
  2191 00000773 E8E5FE                  	call	wait_operation_complete
  2192 00000776 720F                    	jc	.exit
  2193                                  
  2194                                  ;;;	mov	[fdc_cylinder+di],ch	; set new cylinder number
  2195                                  
  2196 00000778 E8D1FA                  	call	fdc_wait_seek_done	; AH=error code if C=1
  2197 0000077B 720A                    	jc	.exit
  2198                                  
  2199                                  %if 0
  2200                                  ; probably have to skip the following during Format
  2201                                  	call	read_track_id		; just to be sure
  2202                                  	jc	.exit
  2203                                  %endif
  2204                                  
  2205 0000077D B440                    	mov	ah,ERR_seek_failed
  2206 0000077F 3AAD9400                	cmp	ch,[fdc_cylinder+di]	; PCN filled in
  2207 00000783 7508                    	jne	.err
  2208                                  ;;;	mov	ah,ERR_8A
  2209                                  ;;;	cmp	ch,[fdc_ctrl_status+3]	; read cylinder number
  2210                                  ;;;	jne	.err
  2211                                  
  2212                                  
  2213                                  .okay:
  2214 00000785 30E4                    	Okay
  2215                                  .exit:
  2216 00000787 595A5E                  	popm	cx,dx,si
  2217 0000078A C3                      	ret
  2218                                  
  2219                                  .invalid:
  2220                                  ; error -- the cylinder requested is invalid for this drive
  2221 0000078B B486                    	mov	ah,ERR_86
  2222 0000078D F9                      .err:	Error
  2223 0000078E EBF7                    	jmp	.exit		  	; jump WAY out
  2224                                  
  2225                                  
  2226                                  
  2227                                  
  2228                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2229                                  ;  Check_RW_Status		check ST0 & ST1 error bits
  2230                                  ;
  2231                                  ;  Call with:
  2232                                  ;	CY = 0,1	needs to be examined
  2233                                  ;
  2234                                  ;  Return with:
  2235                                  ;	CY = 0, AH = 0		no error detected
  2236                                  ;
  2237                                  ;	CY = 1, AH = final error code	error in status bits
  2238                                  ;
  2239                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2240                                   	global	Check_RW_Status
  2241                                  Check_RW_Status:
  2242 00000790 061E56525153            	pushm	bx,cx,dx,si,ds,es
  2243                                  
  2244                                  %if SOFT_DEBUG & DUMP
  2245                                  	xchg	al,ah			; error code to AL
  2246                                  	lahf				; flags to AH
  2247                                  	push	ax
  2248                                  
  2249                                  	xor	ah,ah			; zero hi-byte
  2250                                  	mov	cx,7
  2251                                  	mov	si,fdc_ctrl_status+6	; byte to start
  2252                                  .1	std
  2253                                  	lodsb
  2254                                    	push	ax			; push argument
  2255                                  	loop	.1
  2256                                  	cld
  2257                                  	push	cs
  2258                                  	push	fcrw
  2259                                  	call	_cprintf
  2260                                  	add	sp,18
  2261                                  
  2262                                  	pop	ax
  2263                                  	sahf				; restore flags
  2264                                  	xchg	al,ah			; restore error code to AH
  2265                                  %endif
  2266                                  
  2267                                  %if 1
  2268 00000796 7309                    	jnc	.no_err
  2269                                  
  2270 00000798 C6460E00                	mov	byte [offset_AL+bp],0	; say nothing transferred
  2271                                  
  2272                                  ; Carry is set, what happened?
  2273 0000079C 80FC81                  	cmp	ah,ERR_81		; first of our new error codes
  2274                                  	;;;
  2275 0000079F EB2E                    	jmp	.error		; for now
  2276                                  %endif
  2277                                  
  2278                                  
  2279                                  .no_err:
  2280 000007A1 8A264200                	mov	ah,[fdc_ctrl_status]	; get ST0 to AH
  2281 000007A5 88E0                    	mov	al,ah			; retain copy in AL
  2282 000007A7 80E4C0                  	and	ah,ST0_IC		; check interrupt code
  2283 000007AA 7424                    	jz	.exit	; Okay is set
  2284                                  	
  2285 000007AC B420                    	mov	ah,ERR_controller_failure
  2286 000007AE A810                    	test	al,ST0_EC
  2287 000007B0 751D                    	jnz	.error
  2288                                  
  2289 000007B2 A04300                  	mov	al,[fdc_ctrl_status+1]	; get ST1 to AL
  2290 000007B5 B402                    	mov	ah,ERR_address_mark_not_found
  2291 000007B7 A801                    	test	al,ST1_MA		; test Missing Address mark
  2292 000007B9 7514                    	jnz	.error
  2293                                  
  2294 000007BB FEC4                    	inc	ah			; Write Protect
  2295 000007BD A802                    	test	al,ST1_NW		;
  2296 000007BF 750E                    	jnz	.error
  2297                                  
  2298 000007C1 FEC4                    	inc	ah			; Sector not Found
  2299 000007C3 A804                    	test	al,ST1_ND		; No Data
  2300 000007C5 7508                    	jnz	.error
  2301                                  
  2302 000007C7 B410                    	mov	ah,ERR_uncorrectable_CRC_error
  2303 000007C9 A820                    	test	al,ST1_DE
  2304 000007CB 7502                    	jnz	.error
  2305                                  
  2306 000007CD B48F                    	mov	ah,ERR_unknown		; may be in ST2
  2307                                  
  2308 000007CF F9                      .error:	Error				; code is in AH
  2309                                  .exit:
  2310 000007D0 5B595A5E1F900790        	popm	bx,cx,dx,si,ds,es
  2311 000007D8 C3                      	ret
  2312                                  
  2313                                  
  2314                                  %if SOFT_DEBUG & DUMP
  2315                                  fcrw	db	NL,"ST0 %02x  ST1 %02x  ST2 %02x  C+ %02x  H+ %02x  S+ %02x  N %x", 0
  2316                                  rwvc	db	NL,"AX %04x  CHS %02x:%02x:%02x  DL %02x  ES:BX %04x:%04x", 0
  2317                                  fnret	db	NL,"AH %02x  CY %d  CMD %02x %02x",NL, 0
  2318                                  %endif
  2319                                  
  2320                                  
  2321                                  
  2322                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2323                                  ;  @enable / @disable		Interrupt enable/disable
  2324                                  ;
  2325                                  ;  On a @disable, increment the lock counter and CLI
  2326                                  ;  On an @enable, decrement the lock counter and if it goes to zero, STI
  2327                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2328                                  	global	@enable, @disable
  2329                                  @disable:
  2330 000007D9 1E50                    	pushm	ax,ds
  2331 000007DB 9F                      	lahf				; save user flags
  2332 000007DC 6A40                    	push	bios_data_seg		; universal addressing
  2333 000007DE 1F90                    	popm	ds
  2334 000007E0 FA                      	cli				; guarantee locked operation
  2335 000007E1 FE06AE00                	inc	byte [lock_count]
  2336 000007E5 9E                      	sahf				; restore user flags
  2337 000007E6 581F90                  	popm	ax,ds
  2338 000007E9 C3                      	ret
  2339                                  
  2340                                  @enable:
  2341 000007EA 1E50                    	pushm	ax,ds
  2342 000007EC 9F                      	lahf				; save user flags
  2343 000007ED 6A40                    	push	bios_data_seg
  2344 000007EF 1F90                    	popm	ds
  2345 000007F1 FE0EAE00                	dec	byte [lock_count]	; test the lock count
  2346 000007F5 7501                    	jnz	.5
  2347 000007F7 FB                      	sti				; lock count went to zero, re-enable
  2348                                  .5:
  2349 000007F8 9E                      	sahf				; restore user flags
  2350 000007F9 581F90                  	popm	ax,ds
  2351 000007FC C3                      	ret
  2352                                  
  2353                                  
  2354                                  
  2355                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2356                                  ;  read_track_id			; read address mark information
  2357                                  ;
  2358                                  ;  Call with:
  2359                                  ;	DS = BIOS data segment
  2360                                  ;	DI = unit number
  2361                                  ;	DH = head number
  2362                                  ;
  2363                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2364                                  read_track_id:
  2365 000007FD 525156                  	pushm	si,cx,dx
  2366                                  
  2367 00000800 C6063E0000              	mov	byte [fdc_drv_calib],0	; clear interrupt flags
  2368                                  
  2369 00000805 E8D9FD                  	call	make_head_unit		; head/un
  2370 00000808 88C4                    	mov	ah,al			; move to AH (second byte of command)
  2371 0000080A B04A                    	mov	al,CMD_READ_ID | CMD_MF
  2372 0000080C 50                      	push	ax			; push the 2-byte command
  2373 0000080D 89E6                    	mov	si,sp
  2374 0000080F 8CD2                    	mov	dx,ss			; DX:SI points at command
  2375 00000811 B90200                  	mov	cx,2			; 2 bytes to READ_ID
  2376 00000814 E877F9                  	call 	output_cmd_to_fdc	; issue the command
  2377 00000817 58                      	pop	ax			; discard word in stack
  2378                                  
  2379 00000818 E840FE                  	call	wait_operation_complete
  2380                                  
  2381 0000081B 5E595A                  	popm	si,cx,dx
  2382 0000081E C3                      	ret
  2383                                  
  2384                                  
  2385                                  
