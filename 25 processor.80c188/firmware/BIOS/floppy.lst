     1                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     2                                  ; floppy.asm -- WD37C65B floppy disk controller driver
     3                                  ;		Version 2.0 -- Apr 2013, JRC
     4                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     5                                  ;
     6                                  ;   This version is for assembly by  NASM 0.98.39 or later
     7                                  ;
     8                                  ; Copyright (C) 2010-2013 John R. Coffman.  All rights reserved.
     9                                  ; Provided for hobbyist use on the N8VEM SBC-188 board.
    10                                  ;
    11                                  ; This program is free software: you can redistribute it and/or modify
    12                                  ; it under the terms of the GNU General Public License as published by
    13                                  ; the Free Software Foundation, either version 3 of the License, or
    14                                  ; (at your option) any later version.
    15                                  ;
    16                                  ; This program is distributed in the hope that it will be useful,
    17                                  ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    18                                  ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    19                                  ; GNU General Public License for more details.
    20                                  ;
    21                                  ; You should have received a copy of the GNU General Public License
    22                                  ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    23                                  ;
    24                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    25                                  %include        "config.asm"
    26                              <1> ;/*
    27                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    28                              <1> ; ANSI.CFG
    29                              <1> ;   Copied to CONFIG.ASM for general release.
    30                              <1> ;
    31                              <1> ;       Modify the parameters below to reflect your system
    32                              <1> ;
    33                              <1> ;
    34                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    35                              <1> ;
    36                              <1> ;   Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    37                              <1> ;   Provided for hobbyist use on the N8VEM SBC-188 board.
    38                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    39                              <1> ;
    40                              <1> ; Define the serial terminal that the Video BIOS must emulate
    41                              <1> ; Set one of the following to 1
    42                              <1> ; If you have no idea what to choose, set TTY to 1
    43                              <1> TTY     equ     0       ; hardcopy -- cannot position the cursor
    44                              <1> DUMB    equ     0       ; dumb CRT -- ^H, ^J, ^K, ^L can move the cursor
    45                              <1> ANSI    equ     1       ; very smart, like a VT-100
    46                              <1> WYSE    equ     0       ; very smart Wyse series (30, 50, ...)
    47                              <1> ; others may get added in the future
    48                              <1> ;  ONE OF THE ABOVE must BE SET TO 1!!!!!
    49                              <1> ;
    50                              <1> ; Define the UART startup bit rate - 1200-19200 are most common
    51                              <1> ;UART_RATE	equ	0		; 1200
    52                              <1> ;UART_RATE	equ	1		; 2400
    53                              <1> ;UART_RATE	equ	2		; 4800
    54                              <1> UART_RATE	equ	3		; 9600
    55                              <1> ;UART_RATE	equ	4		; 19200
    56                              <1> ;UART_RATE	equ	5		; 38400
    57                              <1> ;UART_RATE	equ	6		; 57600
    58                              <1> ;UART_RATE	equ	7		; 115200
    59                              <1> 
    60                              <1> ; Does the serial terminal use the DSR/DTR protocol for flow control?
    61                              <1> ;UART_DSR_PROTOCOL	equ		1	; Yes!
    62                              <1> UART_DSR_PROTOCOL       equ             WYSE    ; Wyse always uses it
    63                              <1> 						; but not ANSI
    64                              <1> ; Define the size of the ROM image on the system in Kilobytes
    65                              <1> ; It may be smaller than the actual EPROM in use.
    66                              <1> ; The following sizes are supported:  32, 64, 128, and 256
    67                              <1> %ifndef ROM
    68                              <1> ROM             equ     32              ; 64 is the default
    69                              <1> %endif
    70                              <1> 
    71                              <1> ; Define the number of Wait States at which the ROM operates
    72                              <1> ROM_WS          equ     1               ; 0..3  (1 is the default)
    73                              <1> 
    74                              <1> ; Define the size in Kilobytes of DOS RAM (low SRAM plus EMM allocate RAM)
    75                              <1> ; This is a desired size and will only be present if a 4MEM board is added
    76                              <1> RAM_DOS         equ     640
    77                              <1> 
    78                              <1> ; Define the size of the low SRAM on the system in Kilobytes
    79                              <1> ; the default is 512 kilobytes
    80                              <1> RAM             equ     512             ; (512 is the default)
    81                              <1> 
    82                              <1> ; Define the number of Wait States at which the RAM operates
    83                              <1> RAM_WS          equ     0               ; 0..3  (0 is the default)
    84                              <1> 
    85                              <1> ; Define the number of Wait States for Local Peripheral devices (600-7FF)
    86                              <1> LCL_IO_WS       equ     1               ; 0..3  (1 is the default)
    87                              <1> 
    88                              <1> ; Define the number of Wait States for ECB BUS peripheral devices (4xx)
    89                              <1> BUS_IO_WS       equ     3               ; 0..3  (3 is the default)
    90                              <1> 
    91                              <1> ; Define the time zone in which we build the Relocatable BIOS
    92                              <1> %ifndef TIMEZONE
    93                              <1> %define TIMEZONE "CST"
    94                              <1> %endif
    95                              <1> 
    96                              <1> ; Has the REDBUG debugger been loaded?
    97                              <1> %ifndef SOFT_DEBUG
    98                              <1> %define SOFT_DEBUG 0
    99                              <1> %endif
   100                              <1> 
   101                              <1> ; Should the BIOS include "Tiny BASIC" in the image?
   102                              <1> %ifndef TBASIC
   103                              <1> TBASIC          equ     1		; default is 1
   104                              <1> %endif
   105                              <1> 
   106                              <1> ; Should the BIOS include the Floating Point Emulator?  The 80188 does
   107                              <1> ; not allow a floating point co-processor, so this is probably a good idea.
   108                              <1> %ifndef FPEM
   109                              <1> FPEM            equ     1               ; default is 1
   110                              <1> %endif
   111                              <1> 
   112                              <1> ; Define the maximum number of EMM (4MEM) boards supported
   113                              <1> EMM_BOARDS      equ     0
   114                              <1> 
   115                              <1> ; Should the Floating Point Emulator use temporary storage in the EBDA
   116                              <1> ; or at locations 0280h..3FFh in low memory?
   117                              <1> %if SOFT_DEBUG
   118                              <1> FPEM_USE_EBDA   equ     FPEM            ; default is 0
   119                              <1> %else
   120                              <1> FPEM_USE_EBDA   equ     0; FPEM            ; default is 0
   121                              <1> %endif
   122                              <1> 
   123                              <1> ; Define the size of the EPROM that is to be installed on the system
   124                              <1> ; It may be larger than the actual ROM image to be generated.
   125                              <1> %ifndef CHIP
   126                              <1> CHIP            equ     64
   127                              <1> %endif
   128                              <1> 
   129                              <1> ; Does the SBC-188 00.4 board have the LS138/LS08 piggyback fix
   130                              <1> ; Set to 1 for the SBC-188 v1.0 and later production boards
   131                              <1> ;FDC_PIGGYBACK_FIX       equ     0       ; Fix not installed
   132                              <1> FDC_PIGGYBACK_FIX       equ     1       ; fix  IS  installed
   133                              <1> 
   134                              <1> ; On SBC-188 rev 00.4 board, there is a published hardware fix (2010-09-18).
   135                              <1> ; If the wiring update is installed, or you have a later board, then
   136                              <1> ; set this to 0.  If you are using the software workaround, then set this
   137                              <1> ; to 1.  The rev 1.0 board has this fix already.
   138                              <1> NEED_TIMER_FIX  equ     0               ; have revised hardware
   139                              <1> ;NEED_TIMER_FIX  equ     1               ; use workaround
   140                              <1> 
   141                              <1> ; Define the UART oscillator speed
   142                              <1> UART_OSC        equ     1843200         ; 1.8432 Mhz is specified
   143                              <1> 
   144                              <1> 
   145                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   146                              <1> ; end of the User configuration
   147                              <1> ;       Do Not modify anything below this point
   148                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   149                              <1> 
   150                              <1> ; Define existence of any uart chip
   151                              <1> UART		equ	TTY+DUMB+ANSI+WYSE
   152                              <1> startuplength   equ     512                     ; may be up to 1024
   153                              <1> startseg        equ     0FFFFh - (ROM*64) + 1
   154                              <1> highrom         equ     (ROM*400h)&0FFFFh
   155                              <1> startupseg      equ     0FFFFh - (startuplength>>4) + 1
   156                              <1> bios_data_seg   equ     040h            ; segment of BIOS data area
   157                              <1> 
   158                              <1> 
   159                              <1> %define ARG(n) [bp+2+(n)*2]
   160                              <1> 
   161                              <1> %macro  check   1.nolist
   162                              <1>  %if (%1)
   163                              <1>    %error Check Failure: %1
   164                              <1>  %endif
   165                              <1> %endm
   166                              <1> %macro  range   3.nolist
   167                              <1>  %if (%1)<(%2)
   168                              <1>    %error Out of Range: %1
   169                              <1>  %elif (%1)>(%3)
   170                              <1>    %error Out of Range: %1
   171                              <1>  %endif
   172                              <1> %endm
   173                              <1> _terminal equ UART
   174                              <1>  check   RAM_DOS&15
   175                              <1>  check   RAM&(RAM-1)
   176                              <1>  check   ROM&(ROM-1)
   177                              <1>  range   RAM,32,512
   178                              <1>  range   ROM,32,256
   179                              <1>  range   RAM_WS,0,3
   180                              <1>  range   ROM_WS,0,3
   181                              <1>  range   RAM_DOS,RAM,(1024-ROM)
   182                              <1>  range   LCL_IO_WS,0,3
   183                              <1>  range   BUS_IO_WS,0,3
   184                              <1>  range   UART_OSC,500000,16000000
   185                              <1>  range   UART_RATE,0,7
   186                              <1>  range	 UART,0,1
   187                              <1>  range	 _terminal,1,2
   188                              <1> 
   189                              <1> %ifndef SOFT_DEBUG
   190                              <1> %define SOFT_DEBUG 0
   191                              <1> %endif
   192                              <1> 
   193                              <1> %ifndef TRACE
   194                              <1> %define TRACE 0
   195                              <1> %endif
   196                              <1> 
   197                              <1> %ifdef MAKE_OBJECT_FILE
   198                              <1>         segment _DATA WORD PUBLIC CLASS=DATA
   199                              <1>         export _ROMsize
   200                              <1>         export _CHIPsize
   201                              <1> _ROMsize        dw      ROM
   202                              <1> _CHIPsize       dw      CHIP
   203                              <1> %endif
   204                              <1> ; end of the Hardware configuration file
   205                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   206                              <1> ;*/
    26                                  %include        "cpuregs.asm"
    27                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    28                              <1> ; CPUREGS.ASM
    29                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    30                              <1> ;
    31                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    32                              <1> ;
    33                              <1> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    34                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    35                              <1> ;
    36                              <1> ; This program is free software: you can redistribute it and/or modify
    37                              <1> ; it under the terms of the GNU General Public License as published by
    38                              <1> ; the Free Software Foundation, either version 3 of the License, or
    39                              <1> ; (at your option) any later version.
    40                              <1> ;
    41                              <1> ; This program is distributed in the hope that it will be useful,
    42                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    43                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    44                              <1> ; GNU General Public License for more details.
    45                              <1> ;
    46                              <1> ; You should have received a copy of the GNU General Public License
    47                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    48                              <1> ;
    49                              <1> ; Updated for the Duodyne 80c188 SBC
    50                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    51                              <1> %include	"macros.inc"
    52                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    53                              <2> ; MACROS.INC  
    54                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    55                              <2> ;
    56                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    57                              <2> ;
    58                              <2> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    59                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    60                              <2> ;
    61                              <2> ; This program is free software: you can redistribute it and/or modify
    62                              <2> ; it under the terms of the GNU General Public License as published by
    63                              <2> ; the Free Software Foundation, either version 3 of the License, or
    64                              <2> ; (at your option) any later version.
    65                              <2> ;
    66                              <2> ; This program is distributed in the hope that it will be useful,
    67                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    68                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    69                              <2> ; GNU General Public License for more details.
    70                              <2> ;
    71                              <2> ; You should have received a copy of the GNU General Public License
    72                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    73                              <2> ;
    74                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    75                              <2> 
    76                              <2> ; general macros for the SBC188 BIOS ASSEMBLY
    77                              <2> ;
    78                              <2> ;
    79                              <2> %ifndef __MACROS_DEFINED_
    80                              <2> %define __MACROS_DEFINED_ 1
    81                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    82                              <2> ;
    83                              <2> ; some useful macros:
    84                              <2> ;
    85                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    86                              <2> ;
    87                              <2> 	cpu	186
    88                              <2> 
    89                              <2> %imacro setloc  1.nolist
    90                              <2>  times   (%1-($-$$)) db 0FFh
    91                              <2> %endm
    92                              <2> 
    93                              <2> %imacro db_lo   1
    94                              <2>  db (%1)&255
    95                              <2> %endm
    96                              <2> 
    97                              <2> %imacro cnop    0.nolist
    98                              <2> %if SOFT_DEBUG
    99                              <2>         nop
   100                              <2> %endif
   101                              <2> %endm
   102                              <2> 
   103                              <2> %imacro popm 1-*.nolist
   104                              <2> %rep %0
   105                              <2> %ifidni %1,ALL
   106                              <2>  popa
   107                              <2> %elifidni %1,F
   108                              <2>  popf
   109                              <2> %else
   110                              <2>  pop %1
   111                              <2> %ifidni %1,DS
   112                              <2>  cnop
   113                              <2> %elifidni %1,ES
   114                              <2>  cnop
   115                              <2> %endif
   116                              <2> %endif
   117                              <2> %rotate 1
   118                              <2> %endrep
   119                              <2> %endm
   120                              <2> 
   121                              <2> %imacro pushm 1-*.nolist
   122                              <2> %rep %0
   123                              <2> %rotate -1
   124                              <2> %ifidni %1,ALL
   125                              <2>  pusha
   126                              <2> %elifidni %1,F
   127                              <2>  pushf
   128                              <2> %else
   129                              <2>  push %1
   130                              <2> %endif
   131                              <2> %endrep
   132                              <2> %endm
   133                              <2> 
   134                              <2> ;
   135                              <2> ; added from the 386EX project
   136                              <2> ;
   137                              <2> 
   138                              <2> ; call arguments
   139                              <2> %define ARG(n) [bp+2+(n)*2]
   140                              <2> 
   141                              <2> ;
   142                              <2> ; format of the BYTE initialization table:  address, byte
   143                              <2> ;
   144                              <2> %imacro  binit 2
   145                              <2>         dw      %1
   146                              <2>         db      %2
   147                              <2> %endmacro
   148                              <2> ; end with DW -1
   149                              <2> 
   150                              <2> ;
   151                              <2> ; format of the WORD initialization table:  address, word
   152                              <2> ;
   153                              <2> %imacro  winit 2
   154                              <2>         dw      %1
   155                              <2>         dw      %2
   156                              <2> %endmacro
   157                              <2> ; end with DW -1
   158                              <2> 
   159                              <2> 
   160                              <2> ; get the BIOS Data Area segment pointer to a [segment] register
   161                              <2> %imacro get_bda	1.nolist
   162                              <2> 	push	0x0040
   163                              <2> 	pop	%1
   164                              <2> 	cnop
   165                              <2> %endm
   166                              <2> 
   167                              <2> 
   168                              <2> %endif
    52                              <1> 
    53                              <1> 	cpu     186
    54                              <1> ;
    55                              <1> ;
    56                              <1> ; IBM model byte -- must be less than a 286
    57                              <1> ;
    58                              <1> ;MODEL_BYTE		equ	0FEh	; PC-XT
    59                              <1> ;SUBMODEL_BYTE		equ	0FFh	; not used
    60                              <1> 
    61                              <1> MODEL_BYTE		equ	0FEh	; PC-XT
    62                              <1> SUBMODEL_BYTE		equ	00h	;  "
    63                              <1> 
    64                              <1> 
    65                              <1> ; 80188 peripheral control register block address
    66                              <1> CPU_CSCR	        equ	0FF00h
    67                              <1> 
    68                              <1> ; Compatible Mode registers
    69                              <1> 
    70                              <1> cpu_relocation          equ     CPU_CSCR+0FEh
    71                              <1> 
    72                              <1> ; The memory and peripheral chip select register offsets from 0FF00h
    73                              <1> 
    74                              <1> cpu_umcs                equ     CPU_CSCR+0A0h          ; Upper memory select
    75                              <1> cpu_lmcs                equ     CPU_CSCR+0A2h          ; Lower memory select
    76                              <1> cpu_pacs                equ     CPU_CSCR+0A4h          ; Peripheral select
    77                              <1> cpu_mmcs                equ     CPU_CSCR+0A6h          ; Middle memory base
    78                              <1> cpu_mpcs                equ     CPU_CSCR+0A8h          ; Mid mem. & peripherals
    79                              <1> 
    80                              <1> ; Enhanced Mode registers
    81                              <1> 
    82                              <1> cpu_mdram               equ     CPU_CSCR+0E0h          ; memory partition reg.
    83                              <1> cpu_cdram               equ     CPU_CSCR+0E2h          ; clock prescaler
    84                              <1> cpu_edram               equ     CPU_CSCR+0E4h          ; Enable refresh reg.
    85                              <1> cpu_pdcon               equ     CPU_CSCR+0F0h          ; Power-Save control
    86                              <1> 
    87                              <1> 
    88                              <1> ; On-board internal peripheral equates
    89                              <1> ; Programmable Interrupt Controller
    90                              <1> PIC	        equ	CPU_CSCR+020H
    91                              <1> PIC_EOI	        equ	PIC+2           ; End Of Interrupt
    92                              <1> PIC_POLLR	equ	PIC+4
    93                              <1> PIC_POLLSR	equ	PIC+6
    94                              <1> PIC_IMASK	equ	PIC+8
    95                              <1> PIC_PMREG	equ	PIC+0AH
    96                              <1> PIC_SRVR	equ	PIC+0CH
    97                              <1> PIC_IRQR	equ	PIC+0EH
    98                              <1> PIC_IRQSR	equ	PIC+10H
    99                              <1> PIC_TCR	        equ	PIC+12H
   100                              <1> PIC_DMA0CR	equ	PIC+14H
   101                              <1> PIC_DMA1CR	equ	PIC+16H
   102                              <1> PIC_I0CON	equ	PIC+18H
   103                              <1> PIC_I1CON	equ	PIC+1AH
   104                              <1> PIC_I2CON	equ	PIC+1CH
   105                              <1> PIC_I3CON	equ	PIC+1EH
   106                              <1> 
   107                              <1> EOI_NSPEC       equ     8000h           ; Non-Specific EOI
   108                              <1> 
   109                              <1> ; Interrupt masks (Master Mode)
   110                              <1> ;
   111                              <1> mask_timer_all          equ     0001h
   112                              <1> mask_dma0               equ     0004h
   113                              <1> mask_dma1               equ     0008h
   114                              <1> mask_int0               equ     0010h
   115                              <1> mask_int1               equ     0020h
   116                              <1> mask_int2               equ     0040h
   117                              <1> mask_int3               equ     0080h
   118                              <1> 
   119                              <1> 
   120                              <1> 
   121                              <1> ; Timers
   122                              <1> TIM0	        equ	CPU_CSCR+050H
   123                              <1> TIM1	        equ	CPU_CSCR+058H
   124                              <1> TIM2	        equ	CPU_CSCR+060H
   125                              <1> 
   126                              <1> TCNT	        equ	0	; count register
   127                              <1> CMPA	        equ	2	; max count A
   128                              <1> CMPB	        equ	4	; max count B (not present on TIM2)
   129                              <1> TCON	        equ	6	; mode/control word
   130                              <1> 
   131                              <1> ; Timer control bits:
   132                              <1> tc_EN           equ     8000h   ; Enable bit
   133                              <1> tc_nINH         equ     4000h   ; not Inhibit Enable
   134                              <1> tc_INT          equ     2000h   ; Interrupt Enable
   135                              <1> tc_RIU          equ     1000h   ; Register A/B (0/1) in Use
   136                              <1> tc_MC           equ     0020h   ; Maximum Count reached
   137                              <1> tc_RTG          equ     0010h   ; Retrigger (internal source)
   138                              <1> tc_P            equ     0008h   ; Prescale internal clock (timers 0 & 1 only)
   139                              <1> tc_EXT          equ     0004h   ; External clock
   140                              <1> tc_ALT          equ     0002h   ; Alternate between A & B max count registers
   141                              <1> tc_CONT         equ     0001h   ; Continuous: continue after max count
   142                              <1> 
   143                              <1> 
   144                              <1> 
   145                              <1> 
   146                              <1> ; DMA
   147                              <1> DMA0	        equ	CPU_CSCR+0C0H
   148                              <1> DMA1	        equ	CPU_CSCR+0D0H
   149                              <1> DMASPL	        equ	0	; source pointer low
   150                              <1> DMASPU	        equ	2	; source pointer high
   151                              <1> DMADPL	        equ	4	; destination pointer low
   152                              <1> DMADPU	        equ	6	; destination pointer high
   153                              <1> DMATC	        equ	8	; terminal count
   154                              <1> DMACW	        equ	0AH	; control word
   155                              <1> 
   156                              <1> 
   157                              <1> 
   158                              <1> 
   159                              <1> 
   160                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   161                              <1> ;
   162                              <1> ;       SBC-188 external devices
   163                              <1> ;
   164                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   165                              <1> 
   166                              <1> IO_BASE			equ	0400h
   167                              <1> 
   168                              <1> 
   169                              <1> 
   170                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   171                              <1> ; The UART registers (Duodyne SBC 80c188 Console port)
   172                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   173                              <1> 
   174                              <1> uart_base               equ     IO_BASE+0280h
   175                              <1> uart_rbr                equ     uart_base       ;Rcvr Buffer / read only
   176                              <1> uart_thr                equ     uart_base       ;Transmit Holding / write only
   177                              <1> uart_ier                equ     uart_base+1     ;Interrupt Enable
   178                              <1> uart_iir                equ     uart_base+2     ;Interrupt Ident / read only
   179                              <1> uart_fcr                equ     uart_base+2     ;FIFO Control / write only
   180                              <1> uart_lcr                equ     uart_base+3     ;Line Control
   181                              <1> uart_mcr                equ     uart_base+4     ;Modem Control
   182                              <1> uart_lsr                equ     uart_base+5     ;Line Status
   183                              <1> uart_msr                equ     uart_base+6     ;Modem Status
   184                              <1> uart_sr			equ	uart_base+7	;Scratch
   185                              <1> 
   186                              <1> uart_dll                equ     uart_base       ;Divisor Latch LS Byte
   187                              <1> uart_dlm                equ     uart_base+1     ;Divisor Latch MS Byte
   188                              <1> 
   189                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   190                              <1> ; CONTROL LS259 PORT  (DuoDyne 80C188)
   191                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   192                              <1> CTRL259		equ	IO_BASE+0238H
   193                              <1> ; LEDS are at addresses 0..3
   194                              <1> ; other control ports on 4..7
   195                              <1> LED0		equ	CTRL259+0
   196                              <1> LED1		equ	LED0+1
   197                              <1> LED2		equ	LED0+2
   198                              <1> LED3		equ	LED0+3
   199                              <1> T1OSC18		equ	CTRL259+4	; ON=1.8432mhz, OFF="1" (for use of TIMER2)
   200                              <1> ;unused		equ	CTRL259+5
   201                              <1> ;unused		equ	CTRL259+6
   202                              <1> ;unused		equ	CTRL259+7
   203                              <1> 
   204                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   205                              <1> ; Front Panel Connector  (DuoDyne 80C188)
   206                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   207                              <1> FRONT_PANEL_LED	equ	IO_BASE+0230H
   208                              <1> 
   209                              <1> 
   210                              <1> 
   211                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   212                              <1> ; Floppy controller (Duodyne Disk IO)
   213                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   214                              <1> FDC	        equ	IO_BASE+0200H
   215                              <1> FDC_MSR         equ     FDC
   216                              <1> FDC_DATA        equ     FDC_MSR+1
   217                              <1> FDC_DACK        equ	FDC+10H
   218                              <1> FDC_LDOR	equ	FDC+20H
   219                              <1> FDC_LDCR	equ	FDC+30H
   220                              <1> FDC_TC	        equ	FDC+40H
   221                              <1> FDC_RES	        equ	FDC+40H
   222                              <1> FDC_DACK_TC     equ     FDC_DACK | FDC_TC
   223                              <1> 
   224                              <1> 
   225                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   226                              <1> ;DS1302 RTC (Duodyne Ram/ROM Card)
   227                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   228                              <1> RTC	equ	IO_BASE+0094H
   229                              <1> 
   230                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   231                              <1> ; PIO 82C55 I/O  (Duodyne Disk IO)
   232                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   233                              <1> PPI	        equ	IO_BASE+0088H
   234                              <1> 
   235                              <1> PIO_A	        equ	PPI+0	; (OUTPUT)
   236                              <1> PIO_B	        equ	PPI+1	; (INPUT)
   237                              <1> PIO_C	        equ	PPI+2	; (CENTRONICS control low nibble)
   238                              <1> PIO_CTRL	equ	PPI+3	; CONTROL BYTE PIO 82C55
   239                              <1> 
   240                              <1> portA           equ     PPI+0   ;
   241                              <1> portB           equ     PPI+1   ;
   242                              <1> portC           equ     PPI+2   ;
   243                              <1> 
   244                              <1> ; end CPUREGS.ASM
    27                                  %include        "equates.asm"
    28                              <1> ;========================================================================
    29                              <1> ; EQUATES.ASM -- Lots of Defintions for Relocatable BIOS
    30                              <1> ;========================================================================
    31                              <1> ;   for the N8VEM SBC-188 v.00.4 and 00.5
    32                              <1> ;
    33                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    34                              <1> ;
    35                              <1> ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
    36                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    37                              <1> ;
    38                              <1> ; This program is free software: you can redistribute it and/or modify
    39                              <1> ; it under the terms of the GNU General Public License as published by
    40                              <1> ; the Free Software Foundation, either version 3 of the License, or
    41                              <1> ; (at your option) any later version.
    42                              <1> ;
    43                              <1> ; This program is distributed in the hope that it will be useful,
    44                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    45                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    46                              <1> ; GNU General Public License for more details.
    47                              <1> ;
    48                              <1> ; You should have received a copy of the GNU General Public License
    49                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    50                              <1> ;
    51                              <1> ;========================================================================
    52                              <1> 
    53                              <1>         global  FPEM_segment
    54                              <1> 
    55                              <1> 
    56                              <1> %include "segdef.asm"
    57                              <2> ;========================================================================
    58                              <2> ; SEGDEF.ASM -- Lots of Defintions for Relocatable BIOS
    59                              <2> ;========================================================================
    60                              <2> ;   for the N8VEM SBC-188 v.00.4 and 00.5
    61                              <2> ;
    62                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    63                              <2> ;
    64                              <2> ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
    65                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    66                              <2> ;
    67                              <2> ; This program is free software: you can redistribute it and/or modify
    68                              <2> ; it under the terms of the GNU General Public License as published by
    69                              <2> ; the Free Software Foundation, either version 3 of the License, or
    70                              <2> ; (at your option) any later version.
    71                              <2> ;
    72                              <2> ; This program is distributed in the hope that it will be useful,
    73                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    74                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    75                              <2> ; GNU General Public License for more details.
    76                              <2> ;
    77                              <2> ; You should have received a copy of the GNU General Public License
    78                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    79                              <2> ;
    80                              <2> ;========================================================================
    81                              <2> 
    82                              <2> %ifndef __SEGDEF_
    83                              <2> %define __SEGDEF_
    84                              <2> 
    85                              <2> 	SEGMENT  _TEXT ALIGN=2 PUBLIC CLASS=CODE
    86                              <2>         SEGMENT  CONST ALIGN=2 PUBLIC CLASS=DATA
    87                              <2>         SEGMENT  CONST2 ALIGN=2 PUBLIC CLASS=DATA
    88                              <2> 	SEGMENT  _DATA ALIGN=16 PUBLIC CLASS=DATA
    89                              <2> 	SEGMENT  _BSS  ALIGN=2 PUBLIC CLASS=BSS
    90                              <2> ;;;        SEGMENT  _BASIC ALIGN=16 PUBLIC CLASS=BASIC
    91                              <2> 
    92                              <2> 	GROUP	DGROUP CONST CONST2 _DATA _BSS
    93                              <2> 
    94                              <2> %endif
    95                              <2> 
    57                              <1> %include "ascii.asm"
    58                              <2> ; ascii.asm
    59                              <2> ;
    60                              <2> CTRL            equ     1Fh     ; masks a character to CTRL-x
    61                              <2> 
    62                              <2> NUL     equ     00h
    63                              <2> BEL     equ     (CTRL & 'G')
    64                              <2> BS      equ     08h		; ^H
    65                              <2> HT      equ     09h		; ^I
    66                              <2> LF	equ	0Ah		; ^J
    67                              <2> NL      equ     LF
    68                              <2> VT	equ	0Bh		; ^K
    69                              <2> FWD	equ	0Ch		; ^L
    70                              <2> CR	equ	0Dh
    71                              <2> XON     equ     (CTRL & 'Q')
    72                              <2> XOFF    equ     (CTRL & 'S')
    73                              <2> DC1     equ     XON
    74                              <2> DC3     equ     XOFF
    75                              <2> ESC     equ	1Bh
    76                              <2> 
    77                              <2> 
    58                              <1> 
    59                              <1> 
    60                              <1> ; POST error codes. Presently one byte but can expand to word.
    61                              <1> ER_BIOS equ	01h		; Bad ROM bios checksum, patch last byte
    62                              <1> ER_RAM	equ	02h		; Bad RAM in main memory, replace
    63                              <1> ER_CRT	equ	04h		; Bad RAM in video card, replace
    64                              <1> ER_FDC	equ	08h		; Bad FDC
    65                              <1> ER_UNK1	equ	10h		; {unassigned}
    66                              <1> ER_MEM	equ	20h		; Bad RAM in vector area, replace
    67                              <1> ER_ROM	equ	40h		; Bad ROM in expansion area, bad checksum
    68                              <1> ER_UNK2	equ	80h		; {unassigned}
    69                              <1> 
    70                              <1> 
    71                              <1> 
    72                              <1> ;; ************************ BIOS Data Segment ******************************
    73                              <1> ;; BIOS data segment - not all will  be used
    74                              <1> ;                struc   BIOS_DATA_AREA  ; at 0040:0000
    75                              <1> %include "bda.inc"
    76                              <2> ;/*======================================================================
    77                              <2> ; bda.inc -- BIOS data area definitions
    78                              <2> ;========================================================================
    79                              <2> ;   for the N8VEM SBC-188
    80                              <2> ;
    81                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    82                              <2> ;
    83                              <2> ; Copyright (C) 2013 John R. Coffman.  All rights reserved.
    84                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    85                              <2> ;
    86                              <2> ; This program is free software: you can redistribute it and/or modify
    87                              <2> ; it under the terms of the GNU General Public License as published by
    88                              <2> ; the Free Software Foundation, either version 3 of the License, or
    89                              <2> ; (at your option) any later version.
    90                              <2> ;
    91                              <2> ; This program is distributed in the hope that it will be useful,
    92                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    93                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    94                              <2> ; GNU General Public License for more details.
    95                              <2> ;
    96                              <2> ; You should have received a copy of the GNU General Public License
    97                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    98                              <2> ;
    99                              <2> ;========================================================================
   100                              <2> 
   101                              <2> 			;*/ extern				/*
   102                              <2> 	ABSOLUTE  0	;*/ struct BDA {			/*
   103 00000000 ????????????????    <2> serial_ports    resw    4	;*/	word	serial_ports[4];	/*
   104 00000008 ????????????????    <2> parallel_ports  resw    4	;*/	word	parallel_ports[4];	/*
   105 00000010 ????                <2> equipment_flag  resw    1	;*/	EQFL	equipment_flag;		/*
   106                              <2> ;	dw	?		; 40:10 	; Equipment present word
   107                              <2> ;  						;  = (1 iff floppies) *     1.
   108                              <2> ;                                               ;  + (1 iff 187     ) *     2.
   109                              <2> ;  						;  + (#+1 64K sys ram) *    4.
   110                              <2> ;  						;  + (init crt mode ) *    16.
   111                              <2> ;  						;  + (# of floppies ) *    64.
   112                              <2> ;  						;  + (# serial ports) *   512.
   113                              <2> ;  						;  + (1 iff toy port) *  4096.
   114                              <2> ;                                               ;  + (1 iff modem   ) *  8192.
   115                              <2> ;  						;  + (# parallel LPT) * 16384.
   116 00000012 ??                  <2> mfg_test_flags  resb    1	;*/	byte	mfg_test_flags;	/* 40:12 unused by us
   117 00000013 ????                <2> memory_size     resw    1	;*/	word	memory_size;	/* 40:13 kilobytes
   118                              <2> uart_kbd_ctrl_R	equ	$	;*/				/*** JRC: count of ctrl-R's for reboot
   119 00000015 ??                  <2> IPL_errors      resb    1	;*/	byte	IPL_errors;	/* 40:15 IPL errors<-table/scratchpad
   120 00000016 ??                  <2> sbc188_rev       resb    1	;*/	byte	sbc188_rev;	/* was 'unused_01' before BIOS047
   121                              <2> ;;---------------[Keyboard data area]------------;
   122 00000017 ????                <2> keyboard_flags_0 resw   1	;*/	word	keyboard_flags_0;  /* 40:17 Shift/Alt/etc. keyboard flags
   123                              <2> keyboard_flags_1 equ	$-1	;     2nd byte	keyboard_flags_1;  
   124 00000019 ??                  <2> keypad_char	resb	1	;*/	byte	keypad_char;	/* 40:19 Alt-KEYPAD char. goes here
   125 0000001A ????                <2> kbd_buffer_head resw    1	;*/	word	kbd_buffer_head;   /* 40:1A --> keyboard buffer head
   126 0000001C ????                <2> kbd_buffer_tail resw    1	;*/	word	kbd_buffer_tail;   /* 40:1C --> keyboard buffer tail
   127 0000001E <res 20h>           <2> kbd_buffer      resw    16	;*/	word	kbd_buffer[16];	/* 40:1E Keyboard Buffer (Scan,Value)
   128                              <2> kbd_buffer_last	equ	$	;*/				/*
   129                              <2> ;;---------------[Diskette data area]------------;
   130 0000003E ??                  <2> fdc_drv_calib   resb    1	;*/	byte	fdc_drive_calib;   /* 40:3E
   131 0000003F ??                  <2> fdc_motor_LDOR  resb    1	;*/	byte	fdc_motor_LDOR;	   /* 40:3F Motor, DMA, select control
   132 00000040 ??                  <2> fdc_motor_ticks resb    1	;*/	byte	fdc_motor_ticks;   /* 40:40 ticks til motor off
   133 00000041 ??                  <2> fdc_status      resb    1	;*/	byte	fdc_status;	   /* 40:41
   134                              <2> ;				Floppy return code stat byte
   135                              <2> ;				;  1 = bad ic 765 command req.
   136                              <2> ;				;  2 = address mark not found
   137                              <2> ;				;  3 = write to protected disk
   138                              <2> ;				;  4 = sector not found
   139                              <2> ;				;  8 = data late (DMA overrun)
   140                              <2> ;				;  9 = DMA failed 64K page end
   141                              <2> ;				; 16 = bad CRC on floppy read
   142                              <2> ;				; 32 = bad NEC 765 controller
   143                              <2> ;				; 64 = seek operation failed
   144                              <2> ;				;128 = disk drive timed out
   145 00000042 ??????????????      <2> fdc_ctrl_status resb    7	;*/	byte	fdc_ctrl_status[7];  /* 40:42 Status bytes from NEC 765
   146                              <2> ;;---------------[Video display area]------------;
   147 00000049 ??                  <2> video_mode      resb    1	;*/	byte	video_mode;	/* 40:49
   148                              <2> ;			 	; Current CRT mode  (software)
   149                              <2> ;				;  0 = 40 x 25 text (no color)
   150                              <2> ;				;  1 = 40 x 25 text (16 color)
   151                              <2> ;				;  2 = 80 x 25 text (no color)
   152                              <2> ;				;  3 = 80 x 25 text (16 color)
   153                              <2> ;				;  4 = 320 x 200 grafix 4 color
   154                              <2> ;				;  5 = 320 x 200 grafix 0 color
   155                              <2> ;				;  6 = 640 x 200 grafix 0 color
   156                              <2> ;				;  7 = 80 x 25 text (mono card)
   157 0000004A ????                <2> video_columns   resw    1	;*/	word video_columns;	/* 40:4A Columns on CRT screen
   158 0000004C ????                <2> video_regen_bytes  resw 1	;*/	word video_regen_bytes;	/* 40:4C Bytes in the regen region
   159 0000004E ????                <2> video_regen_offset resw 1	;*/	word video_regen_offset;/* 40:4E Byte offset in regen region
   160 00000050 <res 10h>           <2> video_cursor_pos  resw  8	;*/	word video_cursor_pos[8];  /* 40:50 Cursor pos for up to 8 pages
   161 00000060 ????                <2> video_cursor_mode resw  1	;*/	word video_cursor_mode;	/* 40:60 Current cursor mode setting
   162 00000062 ??                  <2> video_page      resb    1	;*/	byte video_page;	/* 40:62 Current page on display
   163 00000063 ????                <2> video_base_seg  resw    1	;*/	word video_base_seg;	/* 40:63 Base address (B000h or B800h)
   164 00000065 ??                  <2> video_hw_mode   resb    1	;*/	byte video_hw_mode;	/* 40:65 ic 6845 mode reg. (hardware)
   165 00000066 ??                  <2> video_cga_palette resb  1	;*/	byte video_cga_palette;	/* 40:66 Current CGA palette
   166                              <2> ;;---------------[Used to setup ROM]-------------;
   167 00000067 ????????            <2> eprom_address   resd    1	;*/	dword eprom_address;	/* 40:67 Eprom base Offset,Segment
   168 0000006B ??                  <2> spurious_irq    resb    1	;*/	byte spurious_irq;	/* 40:6B Last spurious interrupt IRQ
   169                              <2> ;;---------------[Timer data area]---------------;
   170 0000006C ????????            <2> timer_ticks     resd    1	;*/	dword timer_ticks;	/* 40:6C Ticks since midnight (lo,hi)
   171 00000070 ??                  <2> timer_new_day   resb    1	;*/	byte timer_new_day;	/* 40:70 Non-zero if new day
   172                              <2> ;;---------------[System data area]--------------;
   173 00000071 ??                  <2> break_flag      resb    1	;*/	byte break_flag;	/* 40:71 Sign bit set iff break
   174 00000072 ????                <2> warm_boot       resw    1	;*/	word warm_boot;		/* 40:72 Warm boot iff==1234h
   175                              <2> ;;---------------[Hard disk scratchpad]----------;
   176 00000074 ????????            <2> hdd_scratch     resd    1	;*/	word hdd_scratch[2];	/* 40:74
   177                              <2> ;;---------------[Timout areas/PRT/LPT]----------;
   178 00000078 ????????            <2> lpt_timeout     resb    4	;*/	byte lpt_timeout[4];	/* 40:78 Ticks for LPT 1-4 timeouts
   179 0000007C ????????            <2> com_timeout     resb    4	;*/	byte com_timeout[4];	/* 40:7C Ticks for COM 1-4 timeouts
   180                              <2> ;;---obsolete----[Keyboard buf start/end]---jrc--;
   181 00000080 ????                <2> kbd_buffer_start resw   1	;*/	word kbd_buffer_start;	/* 40:80 KBD buffer head (PC/AT)
   182 00000082 ????                <2> kbd_buffer_end  resw    1	;*/	word kbd_buffer_end;	/* 40:82 KBD buffer tail (PC/AT)
   183                              <2> ;;---------------[EGA stuff]---------------------;
   184 00000084 ??????????????      <2> EGA_stuff	resb	7	;*/	byte EGA_stuff[7];	/* 40:84 Unspecified EGA data
   185                              <2> ;;---------------[Floppy/Fixed Media Info]-------------;
   186 0000008B ??                  <2> fdc_last_rate	resb	1	;*/	byte fdc_last_rate;	/* 40:8B Last floppy step rate/data rate?
   187 0000008C ????????            <2> fx_misc_unused	resb	4	;*/	byte fx_misc_unused[4];	/* 40:8C Fixed disk miscellaneous ???
   188 00000090 ????                <2> fdc_disk_state	resb	2	;*/	byte fdc_disk_state[2];	/* 40:90 Floppy disk state
   189 00000092 ????                <2> fdc_op_start	resb	2	;*/	byte fdc_op_start[2];	/* 40:92 Floppy operation start state machine
   190 00000094 ????                <2> fdc_cylinder	resb	2	;*/	byte fdc_cylinder[2];	/* 40:94 Floppy present cylinder
   191                              <2> ;;---------------[Additional KBD flags]----------------;
   192 00000096 ??                  <2> kbd_flag_3	resb	1	;*/	byte kbd_flag_3;	/* 40:96 kbd ???
   193 00000097 ??                  <2> kbd_flag_2	resb	1	;*/	byte kbd_flag_2;	/* 40:97 kbd ???
   194                              <2> ;;---------------[RTC/timer1 data]---------------------;
   195 00000098 ????????            <2> user_semaphore	resw	2	;*/	byte *user_semaphore;	/* 40:98 User semaphore in (bit 7)
   196 0000009C ????????            <2> rtc_count	resd	1	;*/	dword rtc_count;	/* 40:9C RTC tick counter
   197 000000A0 ??                  <2> rtc_wait_active	resb	1	;*/	byte rtc_wait_active;	/* 40:A0 Busy=01, Posted=80h, 
   198                              <2> ;;---------------[Cassette I/O stuff]------------------;
   199 000000A1 ??                  <2> last_val	resb	1	;*/	byte last_val;		/* 40:A1 Last byte read value
   200 000000A2 ????                <2> crc_reg		resw	1	;*/	word crc_reg;		/* 40:A2 CRC accumulation area
   201                              <2> ;									Post Acknowleged=00;
   202 000000A4 ??                  <2> EGA_data	resb	1	;*/	byte EGA_data;		/* 40:A4 Various usage
   203 000000A5 ????                <2> SDstatus	resb	2	;*/	byte SDstatus[2];	/* 40:A5 Status byte from command
   204 000000A7 ????                <2> SDcardtype	resb	2	;*/	byte SDcardtype[2];	/* 40:A7 SDcard type SDSC=2, HC=3, ...
   205                              <2> ;
   206 000000A9 ????????            <2> fixed_disk_tab	resb	4	;*/	byte fixed_disk_tab[4];	/* dispatch table to fixed disk drivers
   207 000000AD ??                  <2> wait12_count	resb	1	;*/	byte wait12_count;	/* 40:AD 12usec CX count
   208 000000AE ??                  <2> lock_count	resb	1	;*/	byte lock_count;	/* 40:AE lock level counter
   209 000000AF ??                  <2> EMS_start       resb    1	;*/	byte EMS_start;		/* start EMS allocation from here
   210                              <2> fx80		equ	$	;*/	struct EDD_disk fx80;	/* fixed disk parameter area 0
   211 000000B0 ????                <2> fx_log_cylinders resw   1	;	word fx_log_cylinders;	 logical number of cylinders
   212 000000B2 ??                  <2> fx_log_heads    resb    1	;	byte fx_log_heads;	 logical number of heads
   213 000000B3 ??                  <2> fx_signature	resb	1	;	byte fx_signature;	 A0h signature = translated geom
   214 000000B4 ??                  <2> fx_phys_sectors	resb    1       ;	byte fx_phys_sectors;	 physical number of sectors per track
   215 000000B5 ????                <2> fx_LBA_high     resw    1       ;	word fx_LBA_high;	 high word of LBA28 number of sectors
   216 000000B7 ??                  <2> fx_reserved	resb	1	;	byte fx_reserved;	 reserved for future use
   217 000000B8 ??                  <2> fx_drive_control resb   1       ;	byte fx_drive_control;	 flag bits for IDE head register
   218 000000B9 ????                <2> fx_phys_cylinders resw	1	;	word fx_phys_cylinders;	 physical number of cylinders
   219 000000BB ??                  <2> fx_phys_heads	resb	1	;	byte fx_phys_heads;	 physical number of heads
   220 000000BC ????                <2> fx_LBA_low	resw	1	;	word fx_LBA_low;	 low word of LBA28 number of sectors
   221 000000BE ??                  <2> fx_log_sectors	resb	1	;	byte fx_log_sectors;	 logical number of sectors per track
   222 000000BF ??                  <2> fx_checksum	resb	1	;	byte fx_checksum;	 checksum, dunno how to compute
   223 000000C0 <res 10h>           <2> fx81            resb    16	;*/	struct EDD_disk fx81;	/* fixed disk parameter area 1
   224 000000D0 <res 10h>           <2> fx82            resb    16	;*/	struct EDD_disk fx82;	/* fixed disk parameter area 2
   225 000000E0 <res 10h>           <2> fx83            resb    16	;*/	struct EDD_disk fx83;	/* fixed disk parameter area 3
   226                              <2> ;
   227                              <2> ;
   228                              <2> 
   229 000000F0 ????                <2> FPEM_segment    resw    1       ;*/	word FPEM_segment;	/* FPEM data segment
   230                              <2> 
   231 000000F2 ????                <2> EBDA_paragraph  resw    1       ;*/	word EBDA_paragraph;	/* lowest EBDA paragraph
   232                              <2> 
   233 000000F4 ????                <2> dma0_cw         resw    1       ;*/	word dma0_cw;		/* end of dma control word
   234 000000F6 ????                <2> dma1_cw         resw    1       ;*/	word dma1_cw;		/*   ditto
   235                              <2> 
   236 000000F8 ????                <2> fdc_type	resb	2	;*/	byte fdc_type[2];	/* disk type in low nibble, alternate in hi nib 
   237                              <2> 
   238 000000FA ????????            <2> debug_static_ptr  resw	2	;*/	void *debug_static_ptr;	/* pointer to debug static area
   239                              <2> 
   240 000000FE ??                  <2> n_fixed_disks   resb    1       ;*/	byte n_fixed_disks;	/* number of fixed disks
   241                              <2> 
   242 000000FF ??                  <2> cpu_xtal        resb    1       ;*/	byte cpu_xtal;		/* CPU crystal frequency in Mhz 
   243                              <2> ;								   CPU clock is half of this
   244                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   245                              <2> ;
   246                              <2> ;  System configuration stuff below
   247                              <2> ;	c.f., CONFIG.ASM (ANSI.CFG, CVDU.CFG, etc.), User configuration stuff
   248                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   249                              <2> %if 0				;*/
   250                              <2> #define FIXED_DISK_MAX 4		/*
   251                              <2> %else
   252                              <2> %define FIXED_DISK_MAX 4
   253                              <2> %endif
   254                              <2> %if 0				;*/
   255                              <2> #define PPIDE_driver 1		/*
   256                              <2> %else
   257                              <2> %define PPIDE_driver 1
   258                              <2> %endif
   259                              <2> %if 0				;*/
   260                              <2> #define DIDE_driver 0		/*
   261                              <2> %else
   262                              <2> %define DIDE_driver 0
   263                              <2> %endif
   264                              <2> %if 0				;*/
   265                              <2> #define DISKIO_driver 1		/*
   266                              <2> %else
   267                              <2> %define DISKIO_driver 1
   268                              <2> %endif
   269                              <2> %if 0				;*/
   270                              <2> #define MFPIC_driver 1		/*
   271                              <2> %else
   272                              <2> %define MFPIC_driver 1
   273                              <2> %endif
   274                              <2> %if 0				;*/
   275                              <2> #define DSD_driver 1		/*
   276                              <2> %else
   277                              <2> %define DSD_driver 1
   278                              <2> %endif
   279                              <2> %if 0				;*/
   280                              <2> #define V3IDE8_driver (SBC188==3)		/*
   281                              <2> %else
   282                              <2> %define V3IDE8_driver (SBC188==3)
   283                              <2> %endif
   284                              <2> 				;*/
    76                              <1> 
    77                              <1> ;  this must be the same in EQUATES.H */
    78                              <1> %if SOFT_DEBUG
    79                              <1> %define NBREAK  8
    80                              <1> %endif
    81                              <1> 
    82                              <1> 
    83                              <1> %if 0
    84                              <1>         segment _TEXT
    85                              <1> ;; *************************************************************************
    86                              <1> 
    87                              <1> 
    88                              <1> 
    89                              <1> 
    90                              <1> ;; ************************ DOS Data Segment *******************************
    91                              <1> ;dosdir	SEGMENT at 50h				; Boot disk directory from IPL
    92                              <1> ;xerox	label	byte				;  0 if Print Screen idle
    93                              <1> ;						;  1 if PrtSc xeroxing screen
    94                              <1> ;						;255 if PrtSc error in xerox
    95                              <1> ;						;  ...non-grafix PrtSc in bios
    96                              <1> ;	db	200h dup(?)			; PC-DOS bootstrap procedure
    97                              <1> ;						;  ...IBMBIO.COM buffers the
    98                              <1> ;						;  ...directory of the boot
    99                              <1> ;						;  ...device here at IPL time
   100                              <1> ;						;  ...when locating the guts
   101                              <1> ;						;  ...of the operating system
   102                              <1> ;						;  ...filename "IBMDOS.COM"
   103                              <1> ;dosdir	ends
   104                              <1> ;; *************************************************************************
   105                              <1> ;; ************************ DOS IPL Segment ********************************
   106                              <1> ;dosseg	SEGMENT at 70h				; "Kernel" of PC-DOS op sys
   107                              <1> ;;IBMBIO.COM file loaded by boot block. Device Drivers/Bootstrap. CONTIGUOUS<---
   108                              <1> ;;IBMDOS.COM operating system nucleus immediately follows IBMBIO.COM and       !
   109                              <1> ;;     doesn`t have to be contiguous.  The IBMDOS operating system nucleus     !
   110                              <1> ;;     binary image is loaded by transient code in IBMBIO binary image	      !
   111                              <1> ;dosseg	ends					;			      !
   112                              <1> ;iplseg	SEGMENT at 0h				; Segment for boot block      !
   113                              <1> ;;The following boot block is loaded with 512 bytes on the first sector of     !
   114                              <1> ;;the bootable device by code resident in the ROM-resident bios.  Control is   !
   115                              <1> ;;then transferred to the first word 0000:7C00 of the disk-resident bootstrap  !
   116                              <1> ;	ORG	07C00h				;  ..offset for boot block    !
   117                              <1> ;boot	db	200h dup(?)			;  ..start disk resident boot--
   118                              <1> ;iplseg	ends
   119                              <1> 
   120                              <1> %endif
    28                                  
    29                                  %define DUMP 0
    30                                  
    31                                  ; sterilize SOFT_DEBUG for now
    32                                  %if SOFT_DEBUG > 1
    33                                  %undef SOFT_DEBUG
    34                                  %define SOFT_DEBUG 1
    35                                  %endif
    36                                  
    37                                  	global  BIOS_call_13h
    38                                  ;;	global  Floppy_BIOS_call_13h_entry
    39                                  	global  wait12
    40                                  	global	@enable, @disable
    41                                  %if SOFT_DEBUG
    42                                  	extern	_cprintf
    43                                  	global  undefined
    44                                  	global	fn00,fn02,fn03,fn04
    45                                  	global  get_msr
    46                                  	global	check_DL
    47                                  	global	get_disk_type
    48                                  	global	get_media
    49                                  	global	set_media_pointer
    50                                  	global	rwv_common
    51                                  	global	Seek, recalibrate, Specify
    52                                  	global	rwv_common.marker
    53                                  	global	end_rwv
    54                                  	global	xfer_read_sector, xfer_write_sector, xfer_verify_sector
    55                                  	global	xfer_format_track
    56                                   	global	Check_RW_Status
    57                                  %endif
    58                                  
    59                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    60                                  ; Error, Okay, Complete status conditions
    61                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    62                                  
    63                                  %define	Error		stc
    64                                  ;  test with:
    65                                  ;	JC xxx	(jump on error)
    66                                  ;	JNC xxx	(jump on no error)
    67                                  
    68                                  %define	Okay		xor ah,ah
    69                                  ;  test with:
    70                                  ;	JZ xxx	(jump okay)
    71                                  ;	JNZ xxx (jump not okay)
    72                                  
    73                                  %define Complete	or ah,3
    74                                  ;  test with:
    75                                  ;	JA xxx	(jump complete AND no error)
    76                                  ;	JNZ xxx	(jump complete)
    77                                  ;	JZ xxx	(jump not complete)
    78                                  
    79                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    80                                  
    81                                  
    82                                  ; at most we use 2 floppies
    83                                  %define FLOPPY_MAX	2
    84                                  
    85                                  ; there is some disagreement about whether ES:DI gets set
    86                                  ; for Floppy calls to "int 13h, function 8"
    87                                  FN08_SET_ES_DI   equ     1
    88                                  ;FN08_SET_ES_DI   equ     0
    89                                  
    90                                  ; Define the three modes of operation of the WD37C65B floppy controller
    91                                  %define BASE    0FFh
    92                                  %define SPECIAL 80h
    93                                  %define PC_AT   00h
    94                                  
    95                                  ; DMA watch threshhold
    96                                  %define THRESHHOLD  12
    97                                  
    98                                  ; Do we use DMA or Programmed I/O
    99                                  %define USE_DMA 1       ; We want this to be 1
   100                                  %define USE_DMA_INTs	1	; Use DMA interrupts
   101                                  
   102                                  ; Define the mode in which the WD37C65B is operated
   103                                  %define MODE    PC_AT   ; This MUST NOT be changed
   104                                  
   105                                  ; specify bits in the Operations Register
   106                                  %define DSEL1    00h
   107                                  %define DSEL2    01h
   108                                  %define DSEL_MASK (DSEL1|DSEL2)
   109                                  %define NO_RESET 04h
   110                                  %define RESET    00h
   111                                  %define DMAEN    08h
   112                                  %define MOEN1    10h
   113                                  %define MOEN2    20h
   114                                  %define MOEN_MASK (MOEN1|MOEN2)
   115                                  
   116                                  %define TurnOn	8			; used by all DSEL's
   117                                  
   118                                  ; the Motor turn-on delay in milliseconds
   119                                  %define MOTOR_DELAY     (TurnOn*125)
   120                                  
   121                                  ; define the disk density clock rate selects
   122                                  %define FDC_HD  00h
   123                                  %define FDC_DD  02h
   124                                  
   125                                  ; The individual floppy disk status bits
   126                                  %define FDC_DRIVE_PRESENT  1
   127                                  %define FDC_DRIVE_READY    2
   128                                  
   129                                  
   130                                  ; define the MSR bits:
   131                                  RQM     equ     80h             ; request for master
   132                                  DIO     equ     40h             ; data IN=1, out=0
   133                                  EXM     equ     20h             ; Execution phase in non-DMA mode
   134                                  				;  this should NEVER be set
   135                                  BUSY    equ     10h             ; Controller Busy
   136                                  FD3     equ     08h             ; DS3 is seeking
   137                                  FD2     equ     04h             ; DS2 is seeking
   138                                  FD1     equ     02h             ; DS1 is seeking
   139                                  FD0     equ     01h             ; DS0 is seeking
   140                                  
   141                                  ; MSR I/O status (in/out from CPU)
   142                                  MSR_IN	equ	RQM | DIO
   143                                  MSR_OUT	equ	RQM
   144                                  MSR_MASK equ	RQM | DIO
   145                                  
   146                                  ;  This is the list of controller commands that we use
   147                                  
   148                                  CMD_RECALIBRATE         equ     7       ; 1 param byte (unit #)
   149                                  					; No result bytes
   150                                  CMD_SENSE_INT_STATUS    equ     8       ; No paramter bytes
   151                                  					; 2 result bytes
   152                                  CMD_SENSE_DRIVE_STATUS  equ     4       ; 1 param byte
   153                                  					; 1 result byte
   154                                  CMD_SPECIFY             equ     3       ; 2 parameter bytes
   155                                  					; No result bytes
   156                                  CMD_SEEK                equ     15      ; 2 parameter bytes
   157                                  					; No result bytes
   158                                  CMD_READ_ID             equ     10      ; param in cmd; 1 param byte
   159                                  					; 7 result bytes
   160                                  CMD_READ_DATA           equ     6       ; params in cmd; 8 param bytes
   161                                  					; 7 result bytes
   162                                  CMD_WRITE_DATA          equ     5       ; params in cmd; 8 param bytes
   163                                  					; 7 result bytes
   164                                  CMD_READ_A_TRACK        equ     2       ; params in cmd; 8 param bytes
   165                                  					; 7 result bytes
   166                                  CMD_FORMAT_A_TRACK      equ     13      ; params in cmd; 5 param bytes
   167                                  					; 7 result bytes
   168                                  CMD_SCAN_EQUAL          equ     11h     ; params in cmd; 8 param bytes
   169                                  					; 7 result bytes
   170                                  CMD_SCAN_LOW_OR_EQUAL   equ     19h     ; params in cmd; 8 param bytes
   171                                  					; 7 result bytes
   172                                  CMD_SCAN_HIGH_OR_EQUAL  equ     1Dh     ; params in cmd; 8 param bytes
   173                                  					; 7 result bytes
   174                                  
   175                                  
   176                                  ; define the extra bits in some command codes
   177                                  
   178                                  CMD_MT          equ     80h             ; Multi-track operation
   179                                  CMD_MF          equ     40h             ; MFM recording mode
   180                                  CMD_SK          equ     20h             ; skip deleted data mark
   181                                  
   182                                  
   183                                  
   184                                  ; define the ST3 status bits
   185                                  
   186                                  ST3_WP          equ     40h             ; NOT Write Protected
   187                                  ST3_TR00        equ     10h             ; Track 0 signal
   188                                  ST3_WP2         equ     08h             ; duplicate of ST3_WP; ST3_2S for 8" floppies
   189                                  ST3_HS          equ     04h             ; head 0 or 1
   190                                  ST3_US          equ     03h             ; Unit mask (0..3)
   191                                  
   192                                  
   193                                  ; define the ST2 status bits
   194                                  
   195                                  ST2_CM          equ     40h             ; Control Mark (deleted data mark)
   196                                  ST2_DD          equ     20h             ; Data Error (data field)
   197                                  ST2_WC          equ     10h             ; Wrong Cylinder
   198                                  ST2_SH          equ     08h             ; Scan Hit (not used here)
   199                                  ST2_SN          equ     04h             ; Scan Not Satisfied (not used here)
   200                                  ST2_BC          equ     02h             ; Bad Cylinder
   201                                  ST2_MD          equ     01h             ; Missing address mark
   202                                  
   203                                  ST2_ANY         equ     ST2_CM+ST2_DD+ST2_WC+ST2_BC+ST2_MD
   204                                  
   205                                  
   206                                  ; define the ST1 status bits
   207                                  
   208                                  ST1_EN          equ     80h             ; End of cylinder
   209                                  ST1_DE          equ     20h             ; Data error (CRC err in address or data field)
   210                                  ST1_OR          equ     10h             ; Overrun (we will always see this flag)
   211                                  ST1_ND          equ     04h             ; No Data
   212                                  ST1_NW          equ     02h             ; Not writeable (WP is set)
   213                                  ST1_MA          equ     01h             ; Missing address mark
   214                                  
   215                                  %if FDC_PIGGYBACK_FIX
   216                                  ST1_ANY         equ     ST1_EN+ST1_DE+ST1_OR+ST1_ND+ST1_NW+ST1_MA
   217                                  %else
   218                                  ;ST1_ANY         equ     ST1_EN+ST1_DE+ST1_ND+ST1_NW+ST1_MA
   219                                  ST1_ANY         equ            ST1_DE+ST1_ND+ST1_NW+ST1_MA
   220                                  %endif
   221                                  
   222                                  ; define the ST0 status bits
   223                                  
   224                                  ST0_IC          equ     0C0h            ; Interrupt code mask
   225                                  					; 00 = normal termination
   226                                  					; 01 = abnormal termination
   227                                  					; 10 = invalid command
   228                                  					; 11 = abnormal termination -- change in ready status
   229                                  
   230                                  ST0_SE          equ     20h             ; Seek end
   231                                  ST0_EC          equ     10h             ; Equipment check
   232                                  ST0_NR          equ     08h             ; Not Ready (always 0 on WD37C65B)
   233                                  ST0_HS          equ     04h             ; Head Select
   234                                  ;ST0_US          equ     03h             ; Unit select mask
   235                                  ST0_US          equ     01h             ; Unit select mask
   236                                  
   237                                  ST0_ANY         equ     ST0_EC+ST0_NR   ; Any ST0 error
   238                                  
   239                                  
   240                                  
   241                                  ; The FDC interrupt control register
   242                                  fdc_int_control         equ     PIC_I3CON
   243                                  
   244                                  
   245                                  ; Standard int 13h stack frame layout is
   246                                  ; created by:   PUSHM  ALL,DS,ES
   247                                  ;               MOV    BP,SP
   248                                  ;
   249                                  offset_DI       equ     0
   250                                  offset_SI       equ     offset_DI+2
   251                                  offset_BP       equ     offset_SI+2
   252                                  offset_SP       equ     offset_BP+2
   253                                  offset_BX       equ     offset_SP+2
   254                                  offset_DX       equ     offset_BX+2
   255                                  offset_CX       equ     offset_DX+2
   256                                  offset_AX       equ     offset_CX+2
   257                                  offset_DS       equ     offset_AX+2
   258                                  offset_ES       equ     offset_DS+2
   259                                  offset_IP       equ     offset_ES+2
   260                                  offset_CS       equ     offset_IP+2
   261                                  offset_FLAGS    equ     offset_CS+2
   262                                  
   263                                  ; The byte registers in the stack
   264                                  offset_AL       equ     offset_AX
   265                                  offset_AH       equ     offset_AX+1
   266                                  offset_BL       equ     offset_BX
   267                                  offset_BH       equ     offset_BX+1
   268                                  offset_CL       equ     offset_CX
   269                                  offset_CH       equ     offset_CX+1
   270                                  offset_DL       equ     offset_DX
   271                                  offset_DH       equ     offset_DX+1
   272                                  
   273                                  
   274                                  ; FDC error codes (returned in AH)
   275                                  ;
   276                                  ERR_no_error            equ     0       ; no error (return Carry clear)
   277                                  ;   everything below returns with the Carry set to indicate an error
   278                                  ERR_invalid_command     equ     1
   279                                  ERR_address_mark_not_found      equ     2
   280                                  ERR_write_protect       equ     3
   281                                  ERR_sector_not_found    equ     4
   282                                  ERR_disk_removed        equ     6
   283                                  ERR_dma_overrun         equ     8
   284                                  ERR_dma_crossed_64k     equ     9
   285                                  
   286                                  
   287                                  ERR_media_type_not_found        equ     12	; 0Ch
   288                                  ERR_uncorrectable_CRC_error     equ     10h
   289                                  ERR_controller_failure  equ     20h
   290                                  ERR_seek_failed         equ     40h
   291                                  ERR_disk_timeout        equ     80h
   292                                  
   293                                  ERR_81			equ	81h	; fdc_ready_for_cmd, not rdy for input
   294                                  ERR_82			equ	82h	; fdc_ready_for_result, not rdy for output
   295                                  ERR_83			equ	83h	; input_result_from_fdc, after input, still busy
   296                                  ERR_84			equ	84h	; fdc_wait_seek_done, abnormal ST0_IC code
   297                                  ERR_85			equ	85h	; xfer_read_sector timeout
   298                                  ERR_86			equ	86h	; cylinder requested is invalid for drive
   299                                  ERR_87			equ	87h	; not on track 0 after recalibrate
   300                                  ERR_88			equ	88h	; wait for operation complete to be posted
   301                                  ERR_89			equ	89h	; fdc_ready_for_cmd, unexpectedly BUSY
   302                                  ERR_8A			equ	8Ah	; second "seek failed" error (ignore during Format)
   303                                  
   304                                  ERR_unknown		equ	8Fh	;   ADDED--JRC (may need to change)
   305                                  
   306                                  
   307                                  	SEGMENT	_TEXT
   308                                  %if SOFT_DEBUG > 1
   309                                  	extern  lites
   310                                  %endif
   311                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   312                                  ;  BIOS call entry for Floppy Disk driver
   313                                  ;       int  13h
   314                                  ;
   315                                  ; The Fixed Disk driver will move the vector from 13h to 40h
   316                                  ; At the moment there is no Fixed Disk Driver
   317                                  ;
   318                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   319                                  	global  BIOS_call_13h
   320                                  BIOS_call_13h:          ; Floppy driver entry
   321 00000000 FB                      	sti                     ; Enable interrupts
   322 00000001 061E60                  	pushm   all,ds,es       ; Standard register save
   323 00000004 89E5                    	mov     bp,sp           ; establish stack addressing
   324                                  
   325 00000006 FC                      	cld			; may NOT assume direction flag is clear
   326 00000007 6A40                    	push    bios_data_seg
   327 00000009 1F                      	popm	ds              ; establish addressability for all functions
   328 0000000A C606AE0000              	mov	byte [lock_count],0	; clear the lock counter
   329                                  
   330                                  %if SOFT_DEBUG & DUMP
   331                                  	pushm	ax,cx,dx,es
   332                                  
   333                                  	push	bx
   334                                  	push	es
   335                                  	xor	bh,bh
   336                                  	mov	bl,dl
   337                                  	push	bx
   338                                  	mov	bl,cl
   339                                  	push	bx
   340                                  	mov	bl,dh
   341                                  	push	bx
   342                                  	mov	bl,ch
   343                                  	push	bx
   344                                  	mov	bx,ax
   345                                  	push	bx
   346                                  	push	cs
   347                                  	push	rwvc
   348                                  	call	_cprintf
   349                                  	add	sp,18
   350                                  
   351                                  	popm	ax,cx,dx,es
   352                                  	xor	bh,bh
   353                                  %endif
   354 0000000F 88E3                    	mov     bl,ah           ; set to index into dispatch table
   355 00000011 80FC19                  	cmp     ah,max/2
   356 00000014 7202                    	jb	.1
   357 00000016 B314                    	mov	bl,14h		; fn not defined for Floppy diskette
   358 00000018 30FF                    .1:	xor     bh,bh
   359 0000001A D1E3                    	shl     bx,1            ; index words
   360 0000001C 2EFF97[3400]                cs  call    near [dispatch+bx]
   361                                  
   362                                  ; returns come here with AH set
   363                                  
   364 00000021 08E4                    	or	ah,ah		; is return code 0? sets carry=0, too
   365 00000023 7401                    	jz	exit_pops
   366                                  error_exit:
   367 00000025 F9                      	stc
   368                                  exit_pops:
   369 00000026 88660F                  	mov	[bp+offset_AH],ah	; store for return
   370 00000029 89EC                    	mov     sp,bp		; remove any allocated variables
   371                                  %if SOFT_DEBUG & DUMP
   372                                  	pushm	f	;  ,ax,bx,cx,dx,es
   373                                  	mov	al,ah		; save AH in AL
   374                                  	lahf			; get flags
   375                                  	xor	bh,bh		; Zap BH
   376                                  	mov	bl,[fdc_op_start+1]
   377                                  	push	bx
   378                                  	mov	bl,[fdc_op_start]
   379                                  	push	bx
   380                                  	mov	bl,ah
   381                                  	and	bx,1		; mask Carry
   382                                  	push	bx
   383                                  	mov	bl,al		; former AH
   384                                  	push	bx
   385                                  	push	cs		; far pointer to ...
   386                                  	push	fnret		;   format
   387                                  	call	_cprintf
   388                                  	add	sp,12
   389                                  	popm	f	; ,ax,bx,cx,dx,es
   390                                  %endif
   391 0000002B 611F07                  	popm    all,ds,es
   392 0000002E CA0200                  	retf	2			; return the carry
   393                                  
   394                                  
   395                                  
   396                                  ;fn00           ; Reset Disk System
   397                                  fn01:           ; Get Disk System Status
   398                                  ;fn02           ; Read Sector
   399                                  ;fn03           ; Write Sector
   400                                  ;fn04           ; Verify Sector
   401                                  ;fn05:           ; Format Track
   402                                  fn06:           ; Format Bad Track (fixed disk) [PC]
   403                                  fn07:           ; Format Drive (fixed disk)     [PC]
   404                                  ;fn08           ; Get Drive Parameters
   405                                  fn09:
   406                                  fn0A:
   407                                  fn0B:
   408                                  fn0C:
   409                                  fn0D:
   410                                  fn0E:
   411                                  fn0F:
   412                                  fn10:
   413                                  fn11:
   414                                  fn12:
   415                                  fn13:
   416                                  fn14:		; *** fixed disk only ***
   417                                  ;fn15:		; Get Disk Type                 [AT]
   418                                  ;fn16:           ; Get Disk Change Status (floppy)
   419                                  fn17:           ; Set Disk Type (floppy)
   420                                  ;fn18:           ; Set Media Type for Format (floppy)
   421                                  undefined:
   422 00000031 B401                    	mov     ah,ERR_invalid_command	; equ 1
   423 00000033 C3                      	ret
   424                                  
   425                                  
   426                                  dispatch:
   427 00000034 [7F02]                  	dw      fn00    ; Reset Disk System
   428 00000036 [3100]                  	dw      fn01    ;
   429 00000038 [2203]                  	dw      fn02
   430 0000003A [2C03]                  	dw      fn03
   431 0000003C [3603]                  	dw      fn04
   432 0000003E [B203]                  	dw      fn05
   433 00000040 [3100]                  	dw      fn06
   434 00000042 [3100]                  	dw      fn07
   435 00000044 [E602]                  	dw      fn08
   436 00000046 [3100]                  	dw      fn09
   437 00000048 [3100]                  	dw      fn0A
   438 0000004A [3100]                  	dw      fn0B
   439 0000004C [3100]                  	dw      fn0C
   440 0000004E [3100]                  	dw      fn0D
   441 00000050 [3100]                  	dw      fn0E
   442 00000052 [3100]                  	dw      fn0F
   443 00000054 [3100]                  	dw      fn10
   444 00000056 [3100]                  	dw      fn11
   445 00000058 [3100]                  	dw      fn12
   446 0000005A [3100]                  	dw      fn13
   447 0000005C [3100]                  	dw      fn14
   448 0000005E [4204]                  	dw      fn15
   449 00000060 [5804]                  	dw      fn16
   450 00000062 [3100]                  	dw      fn17
   451 00000064 [7004]                  	dw      fn18
   452                                  max     equ     $-dispatch
   453                                  
   454                                  
   455                                  ;
   456                                  ;   Floppy Drive Types  (fn08)
   457                                  ;
   458                                  ;                               We support:
   459                                  ;       1 = 5.25" 360K 40track     yes
   460                                  ;       2 = 5.25" 1.2M 80track     yes
   461                                  ;       3 = 3.5"  720K 80track     yes
   462                                  ;       4 = 3.5" 1.44M 80track     yes
   463                                  ;       6 = 3.5" 2.88M 80track      no  (WD37C65CJM & 32Mhz osc)
   464                                  ;	7 = 3.5" 1.28M 1024sect	    no  (Japan)
   465                                  ;
   466                                  ;   Floppy Combos
   467                                  ;       5 = 5.25" 360K 40track in Drive Type 2   	no
   468                                  ;	8 = 5.25" 512k 77track/128sector in Drv 2	(future) CP/M
   469                                  ;	9 = 3.5" 256k 77track/128sector in Drv 3	(future) CP/M
   470                                  ;      10 = 3.5" 512k 77track/128sector in Drv 4	(future) CP/M
   471                                  ;;
   472                                  
   473                                  D_table:
   474 00000066 0000                    	dw      0
   475 00000068 [7C00]                  	dw      DTAB1	; 360K	(MFM)
   476 0000006A [8900]                  	dw      DTAB2	; 1.2M
   477 0000006C [9600]                  	dw      DTAB3	; 720K
   478 0000006E [A300]                  	dw      DTAB4	; 1.44M
   479 00000070 0000                    	dw      0; DTAB5
   480 00000072 0000                    	dw      0; DTAB6
   481 00000074 [CA00]                  	dw      DTAB7	; 1024 byte sectors (Japan)
   482 00000076 [D700]                  	dw      DTAB8	; CP/M 26/77 in 1.2M drive	(128 byte FM sectors)
   483 00000078 [E400]                  	dw      DTAB9	; CP/M 13/77 in 720K drive
   484 0000007A [F100]                  	dw      DTAB10	; CP/M 26/77 in 1.44M drive
   485                                  L_table         equ     ($ - D_table)/2
   486                                  
   487                                  
   488                                  ;   Disk Information
   489                                  ;               specify  off   N  R  gp   DTL   gp3  fill  unk  on cyl clk
   490                                  ;;; The DOS MFM floppies
   491                                  ; 360K 5.25" DD floppy
   492 0000007C DF022502092AFF50F6-     DTAB1:  db      0DFh, 2, 25h,  2, 9, 2Ah, 0FFh, 50h, 0F6h, 0Fh, 8, 39, 80h
   492 00000085 0F082780           
   493                                  
   494                                  ; 1.2M 5.25" HD floppy
   495 00000089 DF0225020F1BFF54F6-     DTAB2:  db      0DFh, 2, 25h,  2, 15, 1Bh, 0FFh, 54h, 0F6h, 0Fh, 8, 79, 00h
   495 00000092 0F084F00           
   496                                  
   497                                  ; 720K 3.5" or 5.25" DD floppy
   498 00000096 DF022502092AFF50F6-     DTAB3:  db      0DFh, 2, 25h,  2, 9, 2Ah, 0FFh, 50h, 0F6h, 0Fh, 8, 79, 80h
   498 0000009F 0F084F80           
   499                                  
   500                                  ; 1.44M 3.5" HD floppy
   501 000000A3 AF022502121BFF6CF6-     DTAB4:  db      0AFh, 2, 25h,  2, 18, 1Bh, 0FFh, 6Ch, 0F6h, 0Fh, 8, 79, 00h
   501 000000AC 0F084F00           
   502                                  
   503                                  ; 360K 5.25" DD floppy in 1.2M HD drive
   504 000000B0 DF022502092AFF50F6-     DTAB5:	db	0DFh, 2, 25h,  2, 9, 2Ah, 0FFh, 50h, 0F6h, 0Fh, 8, 39, 40h
   504 000000B9 0F082740           
   505                                  
   506                                  ; 2.88M 3.5" XD floppy
   507 000000BD AF022502241BFF50F6-     DTAB6:	db      0AFh, 2, 25h,  2, 36, 1Bh, 0FFh, 50h, 0F6h, 0Fh, 8, 79, 0C0h
   507 000000C6 0F084FC0           
   508                                  
   509                                  ; 1.28M 3.5" HD floppy with 1K sectors (Japan)
   510 000000CA AF0225030835FF74F6-     DTAB7:	db	0AFh, 2, 25h,  3,  8, 35h, 0FFh, 74h, 0F6h, 0Fh, 8, 79, 00h
   510 000000D3 0F084F00           
   511                                  
   512                                  ;               specify  off   N  R  gp   DTL   gp3  fill  unk  on cyl clk
   513                                  ;;; The CP/M FM floppies
   514                                  ; 500K 5.25" CP/M (FM) floppy in 1.2M drive
   515 000000D7 DF0225001A098023E5-     DTAB8:  db      0DFh, 2, 25h,  0, 26,  9, 80h, 35, 0E5h, 0Fh, 8, 76, 00h
   515 000000E0 0F084C00           
   516                                  ;;;				       7h      1Bh
   517                                  
   518                                  ; 250K 3.5" CP/M (FM) floppy in 720K drive
   519 000000E4 DF0225000D138046E5-     DTAB9:  db      0DFh, 2, 25h,  0, 13, 19, 80h, 70, 0E5h, 0Fh, 8, 76, 80h
   519 000000ED 0F084C80           
   520                                  
   521                                  ; 500K 3.5" CP/M (FM) floppy in 1.44M drive
   522 000000F1 AF0225001A15804BE5-     DTAB10: db      0AFh, 2, 25h,  0, 26, 21, 80h, 75, 0E5h, 0Fh, 8, 76, 00h
   522 000000FA 0F084C00           
   523                                  
   524                                  
   525                                  ; DTAB table offsets
   526                                  DTAB_specify    	equ     0
   527                                  DTAB_specify2   	equ     DTAB_specify+1
   528                                  DTAB_turnoff_ticks	equ     DTAB_specify2+1
   529                                  DTAB_N_param    	equ     DTAB_turnoff_ticks+1
   530                                  DTAB_EOT_nsect  	equ     DTAB_N_param+1
   531                                  DTAB_rw_gap     	equ     DTAB_EOT_nsect+1
   532                                  DTAB_data_len   	equ     DTAB_rw_gap+1
   533                                  DTAB_fmt_gap3   	equ     DTAB_data_len+1
   534                                  DTAB_fmt_fill   	equ     DTAB_fmt_gap3+1
   535                                  DTAB_unknown    equ     DTAB_fmt_fill+1
   536                                  DTAB_startup		equ     DTAB_unknown+1	; in 1/8 seconds
   537                                  DTAB_max_cylinder	equ     DTAB_startup+1
   538                                  DTAB_control    equ     DTAB_max_cylinder+1
   539                                  
   540                                  
   541                                  
   542                                  ;
   543                                  ; Returns:
   544                                  ;	AL = contents of FDC_MSR  (Main Status Register)
   545                                  ;
   546                                  get_msr:
   547 000000FE 52                      	push	dx
   548 000000FF BA0006                  	mov     dx,FDC_MSR
   549 00000102 EC                      	in      al,dx
   550                                  %if SOFT_DEBUG > 1
   551                                  	push    ax
   552                                  	call    lites
   553                                  %endif
   554 00000103 5A                      	pop	dx
   555 00000104 C3                      	ret
   556                                  
   557                                  ; delay for about 12 microseconds for MSR to be set
   558                                  	extern  microsecond
   559                                  	global  wait12
   560                                  wait12:
   561 00000105 51                      	push    cx
   562                                  %if 1
   563                                  ;	mov	cx,12		; 12 microseconds
   564 00000106 30ED                    	xor	ch,ch
   565 00000108 8A0EFF00                	mov	cl,[cpu_xtal]	; 2x clock (32usec on 16Mhz CPU)
   566 0000010C D0E9                    	shr	cl,1
   567 0000010E 83E905                  	sub	cx,5		; fudge factor for overhead
   568                                  %else
   569                                  	xor	ch,ch
   570                                  	mov	cl,[wait12_count]
   571                                  %endif
   572 00000111 E8(0000)                	call    microsecond
   573 00000114 59                      	pop     cx
   574 00000115 C3                      	ret
   575                                  
   576                                  
   577                                  wait1000:
   578 00000116 51                      	push	cx
   579 00000117 B9E803                  	mov	cx,1000		; 1 ms delay
   580 0000011A E8(0000)                	call	microsecond
   581 0000011D 59                      	pop	cx
   582 0000011E C3                      	ret
   583                                  
   584                                  ;
   585                                  ;  Convention used below
   586                                  ;     Flags:           Meaning:
   587                                  ;       C=1             error
   588                                  ;       C=0, AH=0       okay
   589                                  ;       C=0, AH=3+      complete
   590                                  ;
   591                                  	global  fdc_ready_for_command
   592                                  fdc_ready_for_command:
   593 0000011F 51                      	push	cx
   594                                  
   595                                  .0:
   596 00000120 B9E803                  	mov	cx,1000
   597 00000123 E8DFFF                  .1:	call	wait12
   598 00000126 E8D5FF                  	call    get_msr
   599 00000129 A880                    	test    al,RQM 		; C=0
   600 0000012B E1F6                    	loopz	.1
   601                                  ; try to compensate for MSDOS anomaly with a BUSY test
   602 0000012D 7508                    	jnz	.req
   603 0000012F A810                    	test	al,BUSY		; How does MSDOS manage this???
   604 00000131 74ED                    	jz      .0
   605 00000133 B489                    	mov	ah,ERR_89
   606 00000135 EB06                    	jmp	.err
   607                                  
   608                                  .req:
   609 00000137 A840                    	test    al,DIO          ; C=0,	clear the carry
   610 00000139 7405                    	jz     .2               ; ready for input?
   611 0000013B B481                    	mov	ah,ERR_81	; not ready for input
   612 0000013D F9                      .err:	Error			; C=1, signal error
   613 0000013E EB02                    	jmp	.99
   614                                  
   615 00000140 30E4                    .2:	Okay			; AH=0, C=0
   616 00000142 59                      .99:	pop	cx
   617 00000143 C3                      	ret
   618                                  ; returns Error or Okay
   619                                  
   620                                  
   621                                  	global  fdc_ready_for_result
   622                                  fdc_ready_for_result:
   623 00000144 E8BEFF                  	call    wait12
   624 00000147 E8B4FF                  	call    get_msr
   625 0000014A A810                    	test    al,BUSY         ; controller busy?
   626 0000014C 7505                    	jnz	.0 		; jump if busy
   627 0000014E 80CC03                  	Complete		; not busy, return Complete
   628 00000151 EB15                    	jmp	.99
   629                                  .0:
   630 00000153 E8AFFF                  	call	wait12
   631 00000156 E8A5FF                  .1:	call    get_msr
   632 00000159 A880                    	test    al,RQM          ; wait for RQM
   633 0000015B 74F9                    	jz      .1
   634                                  
   635 0000015D A840                    	test    al,DIO		; set C=0, Z-flag
   636 0000015F 7505                    	jnz     .5		; DIO==1 means output
   637 00000161 B482                    	mov	ah,ERR_82
   638 00000163 F9                      	Error
   639 00000164 EB02                    	jmp	.99
   640                                  
   641 00000166 30E4                    .5:	Okay
   642 00000168 C3                      .99:	ret
   643                                  ; returns Error, Okay, or Complete
   644                                  
   645                                  
   646                                  
   647                                  ; byte to output is in AL
   648                                  ; AH=0 and Carry=0 if all Okay
   649                                  ; Carry=1, AH=code if FDC not ready
   650                                  	global  output_byte_to_fdc
   651                                  output_byte_to_fdc:
   652 00000169 52                      	pushm	dx
   653                                  
   654 0000016A 88C2                    	mov	dl,al
   655 0000016C E8B0FF                  	call    fdc_ready_for_command
   656 0000016F 88D0                    	mov	al,dl
   657 00000171 7206                    	jc      .8              ; propagate error
   658                                  
   659 00000173 BA0106                  	mov     dx,FDC_DATA
   660 00000176 EE                      	out     dx,al
   661 00000177 30E4                    	Okay			; C=0, AH=okay
   662                                  .8:
   663 00000179 5A                      	popm	dx
   664 0000017A C3                      	ret                     ; C=0, AH=okay
   665                                  ; returns Error or Okay
   666                                  
   667                                  
   668                                  	global  input_byte_from_fdc
   669                                  input_byte_from_fdc:
   670 0000017B 52                      	push	dx
   671 0000017C E8C5FF                  	call    fdc_ready_for_result
   672 0000017F 7208                    	jc      .9              ; propagate error
   673 00000181 7506                    	jnz	.9		; if (Complete) return Complete;
   674                                  
   675 00000183 BA0106                  	mov     dx,FDC_DATA
   676 00000186 EC                      	in      al,dx
   677 00000187 30E4                    	Okay			; return Okay
   678                                  .9:
   679 00000189 5A                      	pop	dx
   680 0000018A C3                      	ret                     ;
   681                                  ; returns Error, Okay, or Complete
   682                                  
   683                                  
   684                                  ;  CX = length of command
   685                                  ;  DX:SI = pointer to command (not DS:SI, we'll set this up)
   686                                  ;
   687                                  	global  output_cmd_to_fdc
   688                                  output_cmd_to_fdc:
   689 0000018B 0656                    	pushm   si,es
   690 0000018D 8EC2                    	mov     es,dx           ; DS:SI is now the source
   691                                  	cnop
   692                                  
   693                                  %if SOFT_DEBUG & DUMP
   694                                    es	mov	al,[si]			; record two bytes of command
   695                                    	mov	[fdc_op_start],al
   696                                    es	mov	al,[si+1]		; first & second
   697                                    	mov	[fdc_op_start+1],al
   698                                  %endif
   699                                  
   700 0000018F E82006                  	call	@disable
   701                                  .1:
   702 00000192 26AC                      es	lodsb			; note segment override
   703 00000194 E8D2FF                  	call    output_byte_to_fdc  ; returns error or okay
   704 00000197 7206                    	jc      .7              ; propagate any error
   705 00000199 E2F7                    	loop    .1
   706                                  
   707 0000019B 30E4                    	Okay			; return ok
   708 0000019D EB01                    	jmp	.9
   709                                  
   710 0000019F F9                      .7:	Error			; propagate error
   711                                  
   712 000001A0 E81E06                  .9:	call	@enable
   713 000001A3 5E07                    	popm	si,es
   714 000001A5 C3                      	ret
   715                                  ; returns Error or Okay
   716                                  
   717                                  
   718                                  
   719                                  ; assumes DS points at BIOS Data Area
   720                                  ; preserves DI
   721                                  	global  input_result_from_fdc
   722                                  input_result_from_fdc:
   723 000001A6 5157                    	pushm   di,cx
   724 000001A8 E80706                  	call	@disable	; lock the operation
   725                                  
   726 000001AB BF4200                  	mov     di,fdc_ctrl_status      ; in BIOS Data Area
   727 000001AE B90800                  	mov     cx,8            ; 7 bytes input, then 'complete'
   728                                  
   729 000001B1 E8C7FF                  .0:     call    input_byte_from_fdc
   730 000001B4 7217                    	jc      .9              ; propagate error
   731 000001B6 7511                    	jnz     .8              ; if complete, return okay
   732                                  
   733 000001B8 8805                    	mov     byte [di],al    ; store the result
   734 000001BA 47                      	inc     di
   735 000001BB E2F4                    	loop    .0
   736                                  
   737 000001BD E845FF                  	call	wait12		;
   738 000001C0 E83BFF                  	call	get_msr		; check for busy
   739 000001C3 A810                    	test	al,BUSY
   740                                  
   741 000001C5 B483                    	mov	ah,ERR_83
   742 000001C7 7504                    	jnz	.95		; return error if busy
   743                                  
   744                                  .8:
   745 000001C9 30E4                    	Okay			; return okay
   746 000001CB EB01                    	jmp	.99		; single return point
   747                                  
   748                                  .9:
   749 000001CD F9                      .95:	Error			; return error;
   750                                  
   751 000001CE E8F005                  .99:	call	@enable		; unlock the operation
   752 000001D1 5F59                    	popm	di,cx
   753 000001D3 C3                      	ret
   754                                  ; returns Error, Okay, or Complete
   755                                  
   756                                  
   757                                  %define INT_ENABLE 1
   758                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   759                                  ;
   760                                  ;  Floppy Disk Controller
   761                                  ;               Interrupt Handler
   762                                  ;
   763                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   764                                  	global  fdc_interrupt_level
   765                                  fdc_interrupt_level:
   766                                  %if INT_ENABLE
   767 000001D4 FB                      	sti
   768                                  %endif
   769 000001D5 1E60                    	pushm   all,ds
   770 000001D7 FC                      	cld                     ; just be sure
   771                                  
   772 000001D8 6A40                    	push    bios_data_seg
   773 000001DA 1F                      	popm    ds
   774                                  %if INT_ENABLE==0
   775                                  	inc	byte [lock_count]	; so we don't re-enable
   776                                  %endif
   777 000001DB E820FF                  	call    get_msr
   778 000001DE A810                    	test    al,BUSY         ; test for controller busy
   779 000001E0 740A                    	jz      .4
   780                                  ; BUSY is set
   781 000001E2 E8C1FF                  	call    input_result_from_fdc
   782 000001E5 18C0                    	sbb     al,al           ; carry to AL
   783 000001E7 A24100                  	mov     byte [fdc_status],al    ; FF=error, 0=okay
   784 000001EA EB2C                    	jmp     .9              ; we got the results
   785                                  
   786                                  
   787                                  ; FDC not busy:
   788                                  
   789                                  .4:
   790                                  ;;        xor     bh,bh           ; BH = false
   791 000001EC B008                    .5:     mov     al,CMD_SENSE_INT_STATUS
   792 000001EE E878FF                  	call    output_byte_to_fdc
   793 000001F1 7225                    	jc      .9              ; quit if error
   794 000001F3 E8B0FF                  	call    input_result_from_fdc
   795 000001F6 7220                    	jc      .9
   796                                  
   797 000001F8 A04200                  	mov	al,[fdc_ctrl_status]	; get ST0
   798 000001FB 3480                    	xor	al,80h			; IC= 10xxxxxxb (invalid)
   799 000001FD 24C0                    	and	al,ST0_IC		; isolate IC
   800 000001FF 7417                    	je	.9			; invalid command
   801                                  
   802 00000201 A14200                  	mov	ax,[fdc_ctrl_status]	; get ST0 + PCN (present cylinder)
   803 00000204 A820                    	test	al,ST0_SE		; test Seek End condition
   804 00000206 74E4                    	jz	.5
   805                                  
   806 00000208 89C7                    	mov	di,ax			;
   807 0000020A 83E701                  	and	di,ST0_US		; isolate unit number
   808 0000020D 88A59400                	mov	[fdc_cylinder+di],ah	; set PCN from controller
   809 00000211 800E3E0004              	or	byte [fdc_drv_calib],04h     ;POST Seek End seen
   810 00000216 EBD4                    	jmp     .5
   811                                  
   812                                  
   813                                  .9:
   814 00000218 800E3E0001              	or	byte [fdc_drv_calib],01h     ;POST end of FDC interrupt
   815                                  %if INT_ENABLE==0
   816                                  	dec	byte [lock_count]	; restore the lock count
   817                                  %endif
   818                                  ; signal EOI (End of Interrupt)
   819 0000021D BA22FF                  	mov     dx,PIC_EOI              ; EOI register
   820 00000220 B80080                  	mov     ax,EOI_NSPEC            ; non-specific
   821 00000223 EF                      	out     dx,ax                   ; signal it
   822                                  
   823 00000224 611F                    	popm    all,ds
   824 00000226 CF                      	iret
   825                                  
   826                                  
   827                                  
   828                                  	global  fdc_timer_hook
   829                                  ; called from Timer Tick code with DS->BIOS data area
   830                                  ; Destroys AX and DX
   831                                  	global  fdc_timer_hook
   832                                  fdc_timer_hook:
   833 00000227 803E400000              	cmp     byte [fdc_motor_ticks],0
   834 0000022C 740E                    	je      .9
   835 0000022E FE0E4000                	dec     byte [fdc_motor_ticks]
   836 00000232 7508                    	jnz     .9
   837                                  ; timer expired, stop the motors
   838 00000234 80263F00CF              	and     byte [fdc_motor_LDOR],~(MOEN1+MOEN2)
   839 00000239 E80100                  	call    out_LDOR_mem
   840 0000023C C3                      .9:     ret
   841                                  
   842                                  
   843                                  
   844                                  ; FDC Operations Register operations
   845                                  ; put out the LDOR write-only register
   846                                  ;  Assumes DS is BIOS data segment
   847                                  ; Destroys AX and DX
   848                                  out_LDOR_mem:
   849 0000023D A03F00                  	mov     al,[fdc_motor_LDOR]
   850 00000240 BA2006                  	mov     dx,FDC_LDOR
   851 00000243 EE                      	out     dx,al
   852 00000244 C3                      	ret
   853                                  
   854                                  
   855                                  ; wait until all seeking is done
   856                                  ; assumes DS is set to BIOS data area
   857                                  ;
   858                                  	global  fdc_wait_seek_done
   859                                  fdc_wait_seek_done:
   860                                  .1:
   861 00000245 E8BDFE                  	call    wait12
   862 00000248 E8B3FE                  	call    get_msr
   863 0000024B A80F                    	test    al,0Fh          ; test all the seek bits
   864 0000024D 740C                    	jz      .8
   865 0000024F 803E400000              	cmp     byte [fdc_motor_ticks],0
   866 00000254 75EF                    	jnz     .1
   867 00000256 B480                    	mov	ah,ERR_disk_timeout
   868 00000258 F9                      .7:     Error			; signal error
   869 00000259 EB22                    	jmp	.9
   870                                  
   871                                  .8:     ; seek is done, check ST0 bits
   872 0000025B F6063E0004              	test	byte [fdc_drv_calib],04h	; Seek End seen?
   873 00000260 7512                    	jnz	.okay
   874                                  
   875 00000262 F6064200C0              	test    byte [fdc_ctrl_status],ST0_IC   ; interrupt code
   876 00000267 B484                    	mov	ah,ERR_84
   877 00000269 75ED                    	jnz     .7
   878 0000026B F606420020              	test    byte [fdc_ctrl_status],ST0_SE   ; Seek End
   879 00000270 B440                    	mov	ah,ERR_seek_failed
   880 00000272 74E4                    	jz      .7
   881                                  .okay:
   882                                  
   883                                  %if 0
   884                                  ; add settle time -- may not really be needed
   885                                  	mov	al,[fdc_motor_ticks]
   886                                  	add	al,450/54
   887                                  	xchg	al,[fdc_motor_ticks]
   888                                  .settle:
   889                                  	cmp	[fdc_motor_ticks],al
   890                                  	ja	.settle
   891                                  %else
   892                                  ; add time for more revolutions if a seek occurs
   893 00000274 2E8A4702                  cs	mov	al,[DTAB_turnoff_ticks+bx]
   894 00000278 A24000                    	mov	[fdc_motor_ticks],al
   895                                  %endif
   896                                  
   897 0000027B 30E4                    	Okay					; IC==00 and SE=1
   898 0000027D C3                      .9	ret
   899                                  
   900                                  ;
   901                                  ;  power on init
   902                                  ;
   903                                  	global  @floppy_init
   904                                  @floppy_init:
   905                                  ;	mov     ah,0            ; fn00
   906                                  ;	int     13h
   907 0000027E C3                      	ret
   908                                  
   909                                  
   910                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   911                                  ;  Function 00h         Reset the Disk System
   912                                  ;       Used both at power on and after a serious error
   913                                  ;
   914                                  ;  Enter with:
   915                                  ;       AH = 00h
   916                                  ;       DL = drive 0 or 1
   917                                  ;
   918                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   919                                  fn00:
   920 0000027F B81700                  	mov     ax,0017h        ; LTM=1, MSK=0, PRI=7    (07h for LTM=0)
   921 00000282 BA3EFF                  	mov     dx,fdc_int_control
   922 00000285 EF                      	out     dx,ax           ; enable interrupt controller
   923 00000286 C606AD0020              	mov	byte [wait12_count],32	; this is about the max.
   924                                  
   925 0000028B E877FE                  	call    wait12          ; wait 12 microseconds
   926 0000028E E86DFE                  	call    get_msr         ; set BASE mode
   927 00000291 E871FE                  	call    wait12          ; wait 12 microseconds
   928                                  
   929 00000294 C6063F0008              	mov     byte [fdc_motor_LDOR],(MODE + RESET + DMAEN)         ; set PC_AT mode
   930 00000299 E8A1FF                  	call    out_LDOR_mem
   931 0000029C E866FE                  	call    wait12
   932                                  
   933                                  %if 1
   934                                  ;;; This read may not be necessary, unless Special Mode is set
   935 0000029F BA3006                  	mov     dx,FDC_LDCR
   936 000002A2 EC                      	in      al,dx           ; read a write-only register to latch Mode
   937                                  ;;;;;
   938                                  %endif
   939 000002A3 E870FE                  	call	wait1000
   940                                  
   941 000002A6 800E3F000C              	or	byte [fdc_motor_LDOR],(MODE + NO_RESET + DMAEN)      ; remove the RESET
   942 000002AB E88FFF                  	call    out_LDOR_mem
   943 000002AE E854FE                  	call	wait12
   944                                  
   945                                  %if 0
   946                                  	mov     dx,FDC_LDCR
   947                                  	mov     al,FDC_HD               ; set for HD disks
   948                                  	out     dx,al
   949                                  %endif
   950                                  
   951 000002B1 BACAFF                  	mov	dx,DMA0+DMACW
   952                                  %if 1
   953 000002B4 B80400                  	mov	ax,4			; set change bit
   954                                  %else
   955                                  	in	ax,dx
   956                                  	and	ax,~2			; clear the stop bit
   957                                  	or	ax,4			; set the change bit
   958                                  %endif
   959 000002B7 EF                      	out	dx,ax
   960                                  
   961 000002B8 BA34FF                  	mov     dx,PIC_DMA0CR
   962 000002BB B80700                  	mov     ax,0007h        ; MSK=0, PRI=7
   963 000002BE EF                      	out     dx,ax           ; enable DMA0 interrupts
   964                                  
   965 000002BF 31C0                    	xor	ax,ax
   966 000002C1 A24000                  	mov	[fdc_motor_ticks],al	; Zero the timer tick counter
   967 000002C4 A28B00                  	mov	[fdc_last_rate],al	; force a specify command
   968                                  
   969 000002C7 8EC0                    	mov	es,ax
   970                                  	cnop
   971 000002C9 26A37800                  es	mov	[1Eh*4],ax
   972 000002CD 26A37A00                  es	mov	[1Eh*4+2],ax		; Zap the parameter pointer
   973                                  
   974 000002D1 C7069400FFFF            	mov	word [fdc_cylinder],-1	; Specify & Recalibration needed
   975                                  ;***	mov	[fdc_cylinder+1],-1	; done by above instruction
   976                                  
   977                                  ; now allow time for the polling interrupts
   978 000002D7 B90100                  	mov	cx, 102400>>16		; 0.1 seconds
   979 000002DA 31D2                    	xor	dx,dx			; CX:DX is delay in usec
   980 000002DC B486                    	mov	ah,86h			; delay in microseconds
   981 000002DE CD15                    	int	15h
   982                                  
   983 000002E0 E8C3FE                  	call	input_result_from_fdc
   984                                  
   985 000002E3 30E4                    	Okay			; signal good execution
   986 000002E5 C3                      	ret			; end of FN00
   987                                  
   988                                  
   989                                  
   990                                  
   991                                  
   992                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   993                                  ;  Function 08h         Get Drive Parameters
   994                                  ;
   995                                  ;  Enter with:
   996                                  ;       AH = 08h
   997                                  ;       DL = drive 0 or 1
   998                                  ;
   999                                  ;  Return with:
  1000                                  ;       Carry clear if no error
  1001                                  ;       BL = drive type (2 or 4 for us)
  1002                                  ;       CH = max cylinder number
  1003                                  ;       CL = max sector number
  1004                                  ;       DH = max head number
  1005                                  ;       DL = number of drives
  1006                                  ;       ES:DI = address of disk parameter table
  1007                                  ;
  1008                                  ;       Carry set on error
  1009                                  ;       AH = error code
  1010                                  ;
  1011                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1012                                  fn08:           ; Get Drive Parameters
  1013 000002E6 A01000                  	mov	al,[equipment_flag]
  1014 000002E9 B401                    	mov	ah,1
  1015 000002EB 20C4                    	and	ah,al			; any floppies at all?
  1016 000002ED 7407                    	jz	.2
  1017 000002EF C0C002                  	rol	al,2			; at least one
  1018 000002F2 2403                    	and	al,3
  1019 000002F4 00C4                    	add	ah,al			; 1..4
  1020                                  .2:
  1021 000002F6 88660A                  	mov	[offset_DL+bp],ah		; return # of drives
  1022 000002F9 E8CF01                  	call	check_DL
  1023 000002FC 7221                    	jc	.err_no_drive
  1024 000002FE E8E101                  	call	get_disk_type
  1025 00000301 884608                  	mov	[offset_BL+bp],al		; return BL = disk type
  1026 00000304 E8EA01                  	call	get_media
  1027 00000307 2E8A670B                  cs	mov	ah,[DTAB_max_cylinder+bx]
  1028 0000030B 2E8A4704                  cs	mov	al,[DTAB_EOT_nsect+bx]
  1029 0000030F 89460C                    	mov	[offset_CX+bp],ax		; return CYL | SECT in CX
  1030 00000312 C6460B01                	mov	byte [offset_DH+bp],1		; head max. always 1
  1031 00000316 8C4E12                  	mov	[offset_ES+bp],cs		; return ES  param table
  1032 00000319 895E00                  	mov	[offset_DI+bp],bx		; return DI  param table
  1033                                  
  1034 0000031C 30E4                    	xor	ah,ah				; no error
  1035 0000031E C3                      	ret
  1036                                  
  1037                                  .err_no_drive:
  1038 0000031F B401                    	mov	ah,ERR_invalid_command		; error if no floppies
  1039 00000321 C3                      	ret					; DL is still zero !!!
  1040                                  
  1041                                  
  1042                                  
  1043                                  
  1044                                  
  1045                                  
  1046                                  %if 0
  1047                                  ; validate the READ/WRITE CHS,SC parameters
  1048                                  ;       Enter with DI pointing at the type table
  1049                                  ;
  1050                                  ;  Carry clear if okay
  1051                                  ;  Carry set if invalid
  1052                                  ;       AX & all other registers are preserved
  1053                                  validate_call:
  1054                                  	push    ax
  1055                                  
  1056                                     cs   cmp     ch,[DTAB_max_cyl+di]
  1057                                  	jnbe    .7
  1058                                     cs   mov     ah,[DI_heads+di]
  1059                                  	sub     ah,dh
  1060                                  	jbe     .7
  1061                                     cs   mov     al,[DTAB_EOT_nsect+di]
  1062                                  	dec     cl      ; base sectors at 0
  1063                                  	cmp     cl,al
  1064                                  	jnc     .6      ; JNC = JNB = JAE
  1065                                  	mul     ah
  1066                                  ; AX is 1 or 2 * sectors
  1067                                  	sub     al,cl
  1068                                  ; AL is the maximum number of sectors we can transfer
  1069                                  	cmp     al,[offset_AX+bp]       ; compare to sector count
  1070                                  .6:     inc     cl      ; back to sectors from 1
  1071                                  	jnc     .8      ; JAE = JNB = JNC
  1072                                  .7:     stc
  1073                                  .8:     pop     ax      ;
  1074                                  	ret
  1075                                  %endif
  1076                                  
  1077                                  
  1078                                  
  1079                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1080                                  ;  Function 02h         Read Sectors
  1081                                  ;  Function 03h         Write Sectors
  1082                                  ;  Function 04h         Verify Sectors
  1083                                  ;
  1084                                  ;  Enter with:
  1085                                  ;       AH = 02h (read)
  1086                                  ;       AH = 03h (write)
  1087                                  ;       AH = 04h (verify)
  1088                                  ;       AL = number of sectors to transfer
  1089                                  ;       CH = cylinder number
  1090                                  ;       CL = sector number
  1091                                  ;       DH = head number
  1092                                  ;       DL = drive 0 or 1
  1093                                  ;       ES:BX = buffer to read into or write from
  1094                                  ;
  1095                                  ;  Return with:
  1096                                  ;       Carry clear if no error
  1097                                  ;       AH = 0
  1098                                  ;       AL = number of sectors transferred
  1099                                  ;
  1100                                  ;       Carry set on error
  1101                                  ;       AH = error code
  1102                                  ;
  1103                                  ;       All other registers are preserved.
  1104                                  ;
  1105                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1106                                  ;
  1107                                  ;  Stack variables
  1108                                  ;
  1109                                  rwv_return	equ	-2	; offset from BP
  1110                                  rwv_dma		equ	rwv_return - 2
  1111                                  rwv_xfer	equ	rwv_dma - 2
  1112                                  rwv_cmd		equ	rwv_xfer - 9
  1113                                  rwv_AL		equ	rwv_cmd - 1
  1114                                  rwv_stack	equ	- rwv_AL
  1115                                  
  1116                                  ;FDC_DMA_READ	equ (101b<<13)+(011b<<10)+(11b<<8)+(01b<<6)+(00b<<4)+0110b
  1117                                  FDC_DMA_READ	equ (101b<<13)+(000b<<10)+(11b<<8)+(01b<<6)+(10b<<4)+0110b
  1118                                  
  1119                                  ;FDC_DMA_WRITE	equ (011b<<13)+(101b<<10)+(11b<<8)+(10b<<6)+(00b<<4)+0110b
  1120                                  FDC_DMA_WRITE	equ (000b<<13)+(101b<<10)+(11b<<8)+(10b<<6)+(10b<<4)+0110b
  1121                                  
  1122                                  ;FDC_DMA_READ	equ (101b<<13)+(000b<<10)+(11b<<8)+(01b<<6)+(10b<<4)+0110b
  1123                                  FDC_DMA_SCAN	equ (100b<<13)+(000b<<10)+(11b<<8)+(01b<<6)+(10b<<4)+0110b
  1124                                  
  1125                                  FDC_DMA_FORMAT	equ	FDC_DMA_WRITE
  1126                                  
  1127                                  
  1128                                  %if SOFT_DEBUG
  1129                                  	dw	FDC_DMA_READ
  1130                                  	dw	FDC_DMA_WRITE
  1131                                  	dw	FDC_DMA_SCAN
  1132                                  %endif
  1133                                  
  1134                                  fn02:	; READ
  1135 00000322 B4E6                    	mov	ah,(CMD_READ_DATA | CMD_MT | CMD_MF | CMD_SK)
  1136 00000324 BF66A3                  	mov	di,FDC_DMA_READ
  1137 00000327 BB[D305]                	mov	bx,xfer_read_sector
  1138 0000032A EB12                    	jmp	rwv_common
  1139                                  
  1140                                  %define EXTRA 0
  1141                                  fn03:	; WRITE
  1142                                  %if EXTRA
  1143                                  	cmp	al,1
  1144                                  	jbe	.10
  1145                                  
  1146                                  	mov	bx,[offset_BX+bp]	; restore BX
  1147                                  	mov	[offset_AH+bp],al	; use return code as counter
  1148                                  
  1149                                  .1:	mov	ax,0301h		; write 1 sector
  1150                                  	int	13h
  1151                                  	jc	.5
  1152                                  
  1153                                  	inc	cl			; increment sector number
  1154                                  	add	bx,200h			; increment transfer address
  1155                                  	dec	byte [offset_AH+bp]
  1156                                  	jnz	.1
  1157                                  
  1158                                  	Okay				; all went Okay
  1159                                  	ret
  1160                                  
  1161                                  ; process error return
  1162                                  ;  AH = error code
  1163                                  .5:	mov	al,[offset_AL+bp]	; sectors requested
  1164                                  	sub	al,[offset_AH+bp]	; sectors remaining
  1165                                  	mov	[offset_AL+bp],al	; set sectors transferred
  1166                                  	Error
  1167                                  	ret
  1168                                  
  1169                                  .10:
  1170                                  %endif
  1171 0000032C B4C5                    	mov	ah,(CMD_WRITE_DATA | CMD_MT | CMD_MF)
  1172 0000032E BFA617                  	mov	di,FDC_DMA_WRITE
  1173 00000331 BB[4E06]                	mov	bx,xfer_write_sector
  1174 00000334 EB08                    	jmp	rwv_common
  1175                                  
  1176                                  fn04:	; VERIFY
  1177 00000336 B4E6                    	mov	ah,(CMD_READ_DATA | CMD_MT | CMD_MF | CMD_SK)
  1178 00000338 BF6683                  	mov	di,FDC_DMA_SCAN
  1179 0000033B BB[8306]                	mov	bx,xfer_verify_sector
  1180                                  ;;;	jmp	rwv_common
  1181                                  
  1182                                  ;  Common code to READ, WRITE, and VERIFY
  1183                                  rwv_common:
  1184 0000033E 57                      	push	di			; dma control register
  1185 0000033F 53                      	push	bx			; transfer function
  1186 00000340 83EC08                  	sub	sp,rwv_stack - 8	; 4 words in stack by pushes or Call
  1187 00000343 50                      	push	ax			; including this push
  1188                                  
  1189 00000344 E88401                  	call	check_DL		; sets DI
  1190 00000347 B401                    	mov	ah,ERR_invalid_command
  1191 00000349 7263                    	jc	.exit
  1192 0000034B E89401                  	call	get_disk_type
  1193 0000034E E8A001                  	call	get_media		; get media pointer to CS:BX
  1194 00000351 E8A901                  	call	set_media_pointer	; set up Int 1Eh
  1195 00000354 E81702                  	call	motor_on		; use DI to start motor
  1196                                  
  1197 00000357 E8AD03                  	call	Seek			; use CH to seek to track
  1198                                  					; recalibrate is possible
  1199 0000035A 7252                    	jc	.exit			; AH is error code
  1200                                  
  1201 0000035C E85D02                  	call	make_head_unit		; AL is next byte
  1202                                  
  1203 0000035F 571E06                  	pushm	es,ds,di
  1204 00000362 8D7EF2                  	lea	di,[rwv_cmd+1+bp]		; SS override not needed
  1205 00000365 8D7703                  	lea	si,[DTAB_N_param+bx]
  1206 00000368 160E                    	pushm	cs,ss
  1207 0000036A 1F07                    	popm	ds,es
  1208 0000036C AA                      	stosb				; store head unit in cmd stream
  1209 0000036D 88E8                    	mov	al,ch			; cylinder
  1210 0000036F AA                      	stosb
  1211 00000370 88F0                    	mov	al,dh			; head
  1212 00000372 AA                      	stosb
  1213 00000373 88C8                    	mov	al,cl			; sector (R)
  1214 00000375 AA                      	stosb
  1215 00000376 AC                      	lodsb				; get N
  1216 00000377 88C1                    	mov	cl,al
  1217 00000379 AA                      	stosb				; store N
  1218 0000037A A4                      	movsb				; EOT
  1219 0000037B A4                      	movsb				; GPL
  1220 0000037C A4                      	movsb				; DTL = FF
  1221 0000037D 8D76F1                  	lea	si,[rwv_cmd+bp]		; get command start
  1222 00000380 071F5F                  	popm	es,ds,di
  1223                                  
  1224 00000383 B88000                  	mov	ax,128			; minimum sector size
  1225 00000386 F666F0                  	mul	byte [rwv_AL+bp]	; times number of sectors to transfer
  1226 00000389 D3E0                    	shl	ax,cl			; shift by N_param
  1227 0000038B 89C1                    	mov	cx,ax			; CX is byte count of transfer
  1228                                  
  1229 0000038D 53                      	pushm	bx			; save DTAB pointer
  1230                                  
  1231 0000038E 8B4608                  	mov	ax,[offset_BX+bp]	; get Xfer address offset
  1232 00000391 8CC3                    	mov	bx,es			; segment to AX
  1233 00000393 89DA                    	mov	dx,bx			; and to DX
  1234 00000395 C1EB0C                  	shr	bx,12			; high 4 bits of address
  1235 00000398 C1E204                  	shl	dx,4			; high part of offset from segment
  1236 0000039B 01D0                    	add	ax,dx			; form low 16 bits of 20-bit address
  1237 0000039D 83D300                  	adc	bx,0			; and carry into the high bits
  1238                                  
  1239 000003A0 8CD2                    	mov	dx,ss			; DX:SI points at command start
  1240                                  
  1241                                  .marker:
  1242                                  ;	BX:AX	transfer 20-bit address in memory
  1243                                  ;	CX	transfer byte count
  1244                                  ;	DX:SI	pointer to 9-byte FDC command
  1245                                  ;
  1246 000003A2 80263E0000              	and	byte [fdc_drv_calib],00h	;POST no interrupts received
  1247                                  
  1248 000003A7 FF56FA                  	call	near [rwv_xfer+bp]		;call specific transfer function
  1249                                  
  1250 000003AA 5B                      	popm	bx				; restor DTAB pointer (CS:BX)
  1251                                  ;;;	jc	.exit			; AH is set to error code
  1252                                  
  1253 000003AB E8BD03                  	call	Check_RW_Status		; get final return code
  1254                                  
  1255                                  .exit:
  1256 000003AE 8D66FE                  	lea	sp,[rwv_return+bp]
  1257 000003B1 C3                      	ret
  1258                                  
  1259                                  %if SOFT_DEBUG
  1260                                  end_rwv		equ	$
  1261                                  %endif
  1262                                  
  1263                                  
  1264                                  
  1265                                  ; Format stack layout
  1266                                  fmt_return	equ	-2			; return from fn05 call
  1267                                  fmt_dma		equ	fmt_return - 2
  1268                                  fmt_cmd		equ	fmt_dma - 6
  1269                                  fmt_stack	equ	-fmt_cmd		; stack size
  1270                                  
  1271                                  %if fmt_dma != rwv_dma
  1272                                  %error "fmt_dma != rwv_dma"
  1273                                  %endif
  1274                                  
  1275                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1276                                  ;  Function 05h         Format a Track
  1277                                  ;
  1278                                  ;  Precede with call to Function 18h (or 17h) to set the disk type
  1279                                  ;
  1280                                  ;  Enter with:
  1281                                  ;       AH = 05h
  1282                                  ;       CH = cylinder number
  1283                                  ;       DH = head number
  1284                                  ;       DL = drive 0 or 1
  1285                                  ;       ES:BX = segment/offset of address field list (C/H/R/N)
  1286                                  ;
  1287                                  ;  Return with:
  1288                                  ;       Carry clear if no error
  1289                                  ;       AH = 0
  1290                                  ;
  1291                                  ;       Carry set on error
  1292                                  ;       AH = error code
  1293                                  ;
  1294                                  ;       All other registers are preserved.
  1295                                  ;
  1296                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1297                                  fn05:
  1298 000003B2 83EC0A                  	sub	sp,fmt_stack		; allocate stack space
  1299 000003B5 C746FCA617              	mov	word [fmt_dma+bp],FDC_DMA_FORMAT
  1300                                  
  1301 000003BA E80E01                  	call	check_DL		; sets DI
  1302 000003BD B401                    	mov	ah,ERR_invalid_command
  1303 000003BF 726C                    	jc	.exit
  1304                                  
  1305 000003C1 06                      	pushm	es		; save ES
  1306 000003C2 6A00                    	push	0
  1307 000003C4 07                      	popm	es
  1308 000003C5 8CCB                    	mov	bx,cs		; get CS segment
  1309 000003C7 263B1E7A00                es	cmp	bx,[1Eh*4+2]	; check segment is CS
  1310 000003CC 755F                    	jne	.exit		; (will restore stack)
  1311                                  
  1312 000003CE 268B1E7800                es	mov	bx,[1Eh*4]	; get CS:BX as disk param table pointer
  1313 000003D3 07                      	popm	es     		; restore Stack
  1314                                  
  1315 000003D4 E89701                  	call	motor_on		; use DI to start motor
  1316                                  
  1317 000003D7 E82D03                  	call	Seek			; use CH to seek to track
  1318                                  					; recalibrate is possible
  1319 000003DA 7251                    	jc	.exit			; AH is error code
  1320                                  
  1321 000003DC E8DD01                  	call	make_head_unit		; AL is next byte
  1322 000003DF 88C4                    	mov	ah,al			; save head/unit in AH
  1323                                  
  1324 000003E1 571E06                  	pushm	es,ds,di
  1325                                  
  1326 000003E4 160E                    	pushm	cs,ss
  1327 000003E6 1F07                    	popm	ds,es
  1328 000003E8 8D7EF6                  	lea	di,[bp+fmt_cmd]
  1329 000003EB 8D7703                  	lea	si,[bx+DTAB_N_param]
  1330                                  
  1331 000003EE B00D                    	mov	al,CMD_FORMAT_A_TRACK
  1332 000003F0 803C00                  	cmp	byte [si],0		; is N==0
  1333 000003F3 7402                    	je	.2
  1334 000003F5 0C40                    	or	al,CMD_MF		; MFM recording
  1335                                  .2:
  1336 000003F7 AB                      	stosw				; AH=head/unit, AL=format cmd
  1337 000003F8 A4                      	movsb				; set N
  1338 000003F9 AC                      	lodsb				; get SC
  1339 000003FA 88C1                    	mov	cl,al			; save SC in AL
  1340 000003FC AA                      	stosb				; set SC
  1341 000003FD 83C602                  	add	si,2			; advance to GPL3
  1342 00000400 A5                      	movsw				; set GPL3 and Fill
  1343                                  
  1344 00000401 8D76F6                  	lea	si,[bp+fmt_cmd]
  1345 00000404 071F5F                  	popm	es,ds,di    		; restore regs
  1346                                  
  1347 00000407 30ED                    	xor	ch,ch			; CX = sector count
  1348 00000409 C1E102                  	shl	cx,2			; CX = byte count of param table
  1349                                  
  1350 0000040C 53                      	pushm	bx			; save DTAB pointer
  1351                                  
  1352 0000040D 8B4608                  	mov	ax,[offset_BX+bp]	; get Xfer address offset
  1353 00000410 8CC3                    	mov	bx,es			; segment to AX
  1354 00000412 89DA                    	mov	dx,bx			; and to DX
  1355 00000414 C1EB0C                  	shr	bx,12			; high 4 bits of address
  1356 00000417 C1E204                  	shl	dx,4			; high part of offset from segment
  1357 0000041A 01D0                    	add	ax,dx			; form low 16 bits of 20-bit address
  1358 0000041C 83D300                  	adc	bx,0			; and carry into the high bits
  1359                                  
  1360 0000041F 8CD2                    	mov	dx,ss			; DX:SI points at command start
  1361                                  
  1362                                  ;.marker:
  1363                                  ;	BX:AX	transfer 20-bit address in memory
  1364                                  ;	CX	transfer byte count
  1365                                  ;	DX:SI	pointer to 9-byte FDC command
  1366                                  ;
  1367 00000421 80263E0000              	and	byte [fdc_drv_calib],00h	;POST no interrupts received
  1368                                  
  1369 00000426 E82502                  	call	xfer_format_track	; format the track
  1370                                  
  1371 00000429 5B                      	popm	bx				; restor DTAB pointer (CS:BX)
  1372                                  ;;;	jc	.exit			; AH is set to error code
  1373                                  
  1374 0000042A E83E03                  	call	Check_RW_Status		; get final return code
  1375                                  
  1376                                  
  1377                                  .exit:
  1378 0000042D 8D66FE                  	lea	sp,[rwv_return+bp]	; restore stack location
  1379 00000430 C3                      	ret
  1380                                  
  1381                                  
  1382                                  
  1383                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1384                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1385                                  	global  dma0_interrupt
  1386                                  dma0_interrupt:
  1387 00000431 1E5250                  	pushm   ax,dx,ds
  1388                                  
  1389 00000434 6A40                    	push    bios_data_seg
  1390 00000436 1F                      	popm    ds
  1391                                  
  1392                                  %if SOFT_DEBUG
  1393                                  	or	byte [fdc_drv_calib],02h		;POST dma interrupt
  1394                                  %endif
  1395                                  
  1396                                  %if 0
  1397                                  	mov     dx,FDC_TC               ; Terminal Count
  1398                                  	in      al,dx                   ; pulse the line
  1399                                  %endif
  1400                                  
  1401                                  %if 0
  1402                                  	mov     dx,DMA0+DMACW           ; DMA0 control word
  1403                                  	in      ax,dx
  1404                                  	mov     [dma0_cw],ax            ; post the resulting CW
  1405                                  %endif
  1406                                  
  1407                                  ; signal EOI (End of Interrupt)
  1408 00000437 BA22FF                  	mov     dx,PIC_EOI              ; EOI register
  1409 0000043A B80080                  	mov     ax,EOI_NSPEC            ; non-specific
  1410 0000043D EF                      	out     dx,ax                   ; signal it
  1411                                  
  1412 0000043E 585A1F                  	popm    ax,dx,ds
  1413 00000441 CF                      	iret
  1414                                  
  1415                                  
  1416                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1417                                  ;  Function 15h         Get Disk Type
  1418                                  ;
  1419                                  ;  Enter with:
  1420                                  ;       AH = 15h
  1421                                  ;       DL = drive 0 or 1
  1422                                  ;
  1423                                  ;  Return with:
  1424                                  ;       Carry clear if no error
  1425                                  ;       AH = drive type code
  1426                                  ;               0 = no drive present
  1427                                  ;               1 = floppy without change line support
  1428                                  ;               2 = floppy with change line support
  1429                                  ;               3 = fixed disk
  1430                                  ;
  1431                                  ;       Carry set on error
  1432                                  ;       AH = error code
  1433                                  ;
  1434                                  ;       All other registers are preserved.
  1435                                  ;
  1436                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1437                                  fn15:
  1438 00000442 30E4                    	xor	ah,ah			; No drive present
  1439 00000444 E88400                  	call	check_DL
  1440 00000447 7309                    	jnc	.ok
  1441 00000449 83FFFF                  	cmp	di,-1
  1442 0000044C 7503E9E0FB              	je	undefined		; DL is really bad
  1443 00000451 C3                      	ret				; AH=0, no drive present
  1444                                  					; carry will be cleared
  1445                                  .ok:
  1446 00000452 FEC4                    	inc	ah			; drive ok, no change line support
  1447 00000454 F8                      	clc
  1448 00000455 E9CEFB                  	jmp	exit_pops		;
  1449                                  
  1450                                  
  1451                                  
  1452                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1453                                  ;  Function 16h         Get Disk Change Status
  1454                                  ;
  1455                                  ;  Enter with:
  1456                                  ;       AH = 16h
  1457                                  ;       DL = drive 0 or 1
  1458                                  ;
  1459                                  ;  Return with:
  1460                                  ;       Carry clear
  1461                                  ;       AH = 0  disk not changed
  1462                                  ;
  1463                                  ;       Carry set
  1464                                  ;       AH = 6  disk has been changed
  1465                                  ;            0  error
  1466                                  ;
  1467                                  ;       All other registers are preserved.
  1468                                  ;
  1469                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1470                                  fn16:
  1471 00000458 E87000                  	call	check_DL
  1472 0000045B 7303E9D1FB              	jc	undefined
  1473                                  
  1474 00000460 89F8                    	mov	ax,di			; AL = 0, 1	AH = 0
  1475                                  ; AH is now 0
  1476 00000462 FEC0                    	inc	al			; AL = 1, 2
  1477 00000464 C0C004                  	rol	al,4			; AL = MOEN1 or MOEN2
  1478 00000467 84063F00                	test	[fdc_motor_LDOR],al	; test if motor running
  1479 0000046B 7502                    	jnz     .on
  1480                                  
  1481 0000046D B406                    	mov     ah,ERR_disk_removed	; signal disk changed
  1482                                  .on:
  1483 0000046F C3                      	ret			; AH=6, Carry will be set
  1484                                  
  1485                                  
  1486                                  
  1487                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1488                                  ;  Function 17h		Set Disk Type for Format	(PC-AT)
  1489                                  ;
  1490                                  ;  Enter with:
  1491                                  ;	AH = 17h
  1492                                  ;	AL =	00h     not used
  1493                                  ;		01h     160, 180, 320, or 360Kb diskette in 360kb drive
  1494                                  ;		02h     360Kb diskette in 1.2Mb drive
  1495                                  ;		03h     1.2Mb diskette in 1.2Mb drive
  1496                                  ;		04h     720Kb diskette in 720Kb drive
  1497                                  ;	DL = drive number
  1498                                  ;
  1499                                  ;  Return with:
  1500                                  ;	AH = 0		success
  1501                                  ;	Carry clear
  1502                                  ;
  1503                                  ;	Carry set	error
  1504                                  ;	AH = error code
  1505                                  ;
  1506                                  ;  note 1) This function is probably enhanced for the PS/2 series to detect
  1507                                  ;	   1.44 in 1.44 and 720k in 1.44.
  1508                                  ;	2) This function is not supported for floppy disks on the PC or XT.
  1509                                  ;	3) If the change line is active for the specified drive, it is reset.
  1510                                  ;	4) The BIOS sets the data rate for the specified drive and media type.
  1511                                  ;	   The rate is 250k/sec for double-density media and 500k/sec for high
  1512                                  ;	   density media. The proper hardware is required.
  1513                                  ;	5) This function is used by DOS <= 3.1
  1514                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1515                                  ;fn17:
  1516                                  ;;;	ret
  1517                                  
  1518                                  
  1519                                  
  1520                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1521                                  ;  Function 18h		Set Media Type For Format  (diskette)   (AT, XT2, XT/286, PS/2)
  1522                                  ;
  1523                                  ;  Enter with:
  1524                                  ;	AH = 18h
  1525                                  ;	CH = max. cylinder number (80 or 40  minus  1)
  1526                                  ;	CL = number of sectors (9, 15, 18)
  1527                                  ;	DL = drive number
  1528                                  ;
  1529                                  ;  Return with:
  1530                                  ;	Carry clear -- no errors
  1531                                  ;	AH =	00h      if requested combination supported
  1532                                  ;	ES:DI	pointer to 13-byte parameter table
  1533                                  ;
  1534                                  ;	Carry set -- error
  1535                                  ;	AH =	01h      if function not available
  1536                                  ;		0Ch      if not suppported or drive type unknown
  1537                                  ;		80h      if there is no media in the drive
  1538                                  ;
  1539                                  ;  note 1) A floppy disk must be present in the drive.
  1540                                  ;	2) This function should be called prior to formatting a disk with Int 13h
  1541                                  ;	   Fn 05h so the BIOS can set the correct data rate for the media.
  1542                                  ;	3) If the change line is active for the specified drive, it is reset.
  1543                                  ;	4) This function is used by DOS >= 3.2
  1544                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1545                                  fn18:
  1546 00000470 E85800                  	call	check_DL		; check validity of drive no.
  1547 00000473 7303E9B9FB              	jc	undefined
  1548                                  
  1549 00000478 E86700                  	call	get_disk_type		; get disk type to AL
  1550 0000047B 3C0B                    	cmp	al,L_table
  1551 0000047D 7327                    	jnb	.alt
  1552 0000047F 88C3                    	mov	bl,al
  1553 00000481 30FF                    	xor	bh,bh
  1554 00000483 D1E3                    	shl	bx,1
  1555 00000485 2E8B9F[6600]              cs	mov	bx,[D_table+bx]		; get offset of DTAB entry
  1556 0000048A 85DB                    	test	bx,bx
  1557 0000048C 743A                    	jz	.errC
  1558 0000048E 2E384F04                  cs	cmp	[DTAB_EOT_nsect+bx],cl	; check number of sectors
  1559 00000492 7512                      	jne	.alt			; try alternate
  1560 00000494 2E386F0B                  cs	cmp	[DTAB_max_cylinder+bx],ch  ; check number of cylinders
  1561 00000498 750C                      	jne	.alt
  1562                                  .found:
  1563 0000049A E86000                         	call	set_media_pointer
  1564 0000049D 895E00                  	mov	[offset_DI+bp],bx
  1565 000004A0 8C4E12                  	mov	[offset_ES+bp],cs	; return in ES:DI
  1566 000004A3 30E4                    	xor	ah,ah
  1567 000004A5 C3                      	ret
  1568                                  
  1569                                  .alt:
  1570 000004A6 E84000                  	call	get_disk_alt_type	; get disk type to AL
  1571 000004A9 3C0B                    	cmp	al,L_table
  1572 000004AB 731B                    	jnb	.errC
  1573 000004AD 88C3                    	mov	bl,al
  1574 000004AF 30FF                    	xor	bh,bh
  1575 000004B1 D1E3                    	shl	bx,1
  1576 000004B3 2E8B9F[6600]              cs	mov	bx,[D_table+bx]		; get offset of DTAB entry
  1577 000004B8 85DB                    	test	bx,bx
  1578 000004BA 740C                    	jz	.errC
  1579 000004BC 2E384F04                  cs	cmp	[DTAB_EOT_nsect+bx],cl	; check number of sectors
  1580 000004C0 7506                      	jne	.errC			; no match?
  1581 000004C2 2E386F0B                  cs	cmp	[DTAB_max_cylinder+bx],ch  ; check number of cylinders
  1582 000004C6 74D2                    	je	.found
  1583                                  
  1584 000004C8 B40C                    .errC:	mov	ah,ERR_media_type_not_found
  1585 000004CA C3                      	ret
  1586                                  
  1587                                  
  1588                                  
  1589                                  
  1590                                  
  1591                                  check   cpu_xtal-0FFh
  1592                                  
  1593                                  
  1594                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1595                                  ;  check_DL -- check for valid disk #
  1596                                  ;
  1597                                  ;  Return:
  1598                                  ;	DI = 0 or 1 if DL is valid floppy
  1599                                  ;	Carry clear
  1600                                  ;
  1601                                  ;	DI not valid if DL is invalid
  1602                                  ;	Carry set
  1603                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1604                                  check_DL:
  1605 000004CB BFFFFF                  	mov	di,-1				; invalid DI
  1606 000004CE 80FA02                  	cmp	dl,FLOPPY_MAX
  1607 000004D1 730D                    	jnb	.err
  1608 000004D3 89D7                    	mov	di,dx
  1609 000004D5 83E701                  	and	di,FLOPPY_MAX-1			; clear the carry
  1610 000004D8 F685F8000F              	test	byte [fdc_type+di],0Fh		; drive present?
  1611 000004DD 7401                    	jz	.err
  1612 000004DF C3                      	ret					; carry is clear
  1613                                  
  1614 000004E0 F9                      .err:	stc
  1615 000004E1 C3                      	ret
  1616                                  
  1617                                  
  1618                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1619                                  ;  get_disk_type
  1620                                  ;
  1621                                  ;  Enter with:
  1622                                  ;	DI = drive no.
  1623                                  ;
  1624                                  ;  Return with:
  1625                                  ;	AL = drive type (0..4)
  1626                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1627                                  get_disk_type:
  1628 000004E2 8A85F800                	mov	al,[fdc_type+di]	; get type byte
  1629 000004E6 240F                    	and	al,0Fh			; mask low nibble
  1630 000004E8 C3                      	ret
  1631                                  
  1632                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1633                                  ;  get_disk_alt_type
  1634                                  ;
  1635                                  ;  Enter with:
  1636                                  ;	DI = drive no.
  1637                                  ;
  1638                                  ;  Return with:
  1639                                  ;	AL = drive type (0..4)
  1640                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1641                                  get_disk_alt_type:
  1642 000004E9 8A85F800                	mov	al,[fdc_type+di]	; get type byte
  1643 000004ED C0E804                  	shr	al,4
  1644 000004F0 C3                      	ret
  1645                                  
  1646                                  
  1647                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1648                                  ;  get_media
  1649                                  ;
  1650                                  ;  Call with:
  1651                                  ;	AL = disk type
  1652                                  ;
  1653                                  ;  Return with:
  1654                                  ;	CS:BX		pointer to 13-byte disk media table
  1655                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1656                                  get_media:
  1657 000004F1 88C3                    	mov	bl,al
  1658 000004F3 30FF                    	xor	bh,bh
  1659 000004F5 D1E3                    	shl	bx,1
  1660 000004F7 2E8B9F[6600]              cs	mov	bx,[D_table+bx]		; get offset of DTAB entry
  1661 000004FC C3                        	ret
  1662                                  
  1663                                  
  1664                                  
  1665                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1666                                  ;  set_media_pointer
  1667                                  ;
  1668                                  ;  Call with:
  1669                                  ;	CS:BX	pointer to 13-byte disk media table
  1670                                  ;	DS	BIOS data area pointer
  1671                                  ;
  1672                                  ;  Return with:
  1673                                  ;	CS:BX		pointer to 13-byte disk media table
  1674                                  ;	Int 1Eh 	floppy media pointer set
  1675                                  ;
  1676                                  ;	Carry Set = new media pointer (needed Specify command)
  1677                                  ;	Carry Clear = same media pointer (Specify not needed)
  1678                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1679                                  set_media_pointer:
  1680 000004FD 0651                    	pushm	cx,es			; save for later
  1681 000004FF 6A00                    	push	0			; address interrupt vectors
  1682 00000501 07                      	pop	es			; **
  1683 00000502 8CC9                    	mov	cx,cs
  1684 00000504 26391E7800                es	cmp	word [1Eh*4],bx
  1685 00000509 7508                    	jne	.diff
  1686 0000050B 26390E7A00                es	cmp	word [1Eh*4+2],cx	; segment
  1687 00000510 F8                      	clc
  1688 00000511 7410                    	jz	.same
  1689                                  .diff:
  1690 00000513 26891E7800                es	mov	word [1Eh*4],bx		; offset
  1691 00000518 26890E7A00                es	mov	word [1Eh*4+2],cx	; segment
  1692 0000051D 8EC1                    	mov	es,cx
  1693                                  	cnop
  1694 0000051F E80400                  	call	Specify			; ES:BX is table pointer
  1695 00000522 F9                      	stc
  1696                                  .same:
  1697 00000523 5907                    	popm	cx,es			; restore DS
  1698 00000525 C3                      	ret
  1699                                  
  1700                                  
  1701                                  
  1702                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1703                                  ;  Specify		issue specify command to FDC
  1704                                  ;
  1705                                  ;  Call with:
  1706                                  ;	ES:BX		pointer to 13-byte disk table
  1707                                  ;	DS		BIOS data area pointer
  1708                                  ;
  1709                                  ;  Return with:
  1710                                  ;	Nothing
  1711                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1712                                  Specify:
  1713 00000526 56525350                	pushm	ax,bx,dx,si
  1714 0000052A 83EC04                  	sub	sp,4			; allocate 4 bytes for command
  1715 0000052D 89E6                    	mov	si,sp
  1716                                  
  1717 0000052F 268A470C                  es	mov	al,[DTAB_control+bx]	; clock bits
  1718 00000533 C0C002                    	rol	al,2
  1719 00000536 BA3006                  	mov	dx,FDC_LDCR		; Control Register
  1720 00000539 EE                      	out	dx,al
  1721                                  
  1722 0000053A B20C                    	mov	dl,12			; 12 usec delay  = T time
  1723 0000053C 08C0                    	or	al,al			; test for hi (00) or lo (80) data rate
  1724 0000053E 7502                    	jnz	.3
  1725 00000540 D0EA                    	shr	dl,1			; crystal has factor of 2 already
  1726                                  .3:
  1727 00000542 A0FF00                  	mov	al,[cpu_xtal]		; 2x clock frequency
  1728 00000545 F6E2                    	mul	dl			; AX = 2xClock * T or 2xclock * T/2 (80 or 00)
  1729 00000547 83E82C                  	sub	ax,44			; overhead CPU clocks
  1730 0000054A B214                    	mov	dl,20			; loop clock count
  1731 0000054C F6F2                    	div	dl
  1732 0000054E FEC0                    	inc	al			; for good measure
  1733 00000550 A2AD00                  	mov	[wait12_count],al	; save count
  1734                                  
  1735 00000553 36C60403                  ss	mov	byte [si],CMD_SPECIFY
  1736 00000557 268B07                    es	mov	ax,[DTAB_specify+bx]	; get two specify bytes
  1737 0000055A 36894401                  ss	mov	word [si+1],ax
  1738 0000055E 8CD2                      	mov	dx,ss
  1739 00000560 B90300                  	mov	cx,3			; length of command = 3
  1740 00000563 E825FC                  	call	output_cmd_to_fdc
  1741 00000566 83C404                  	add	sp,4
  1742 00000569 585B5A5E                	popm	ax,bx,dx,si
  1743 0000056D C3                      	ret
  1744                                  
  1745                                  
  1746                                  
  1747                                  
  1748                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1749                                  ;  motor_on			Start the drive motor & wait
  1750                                  ;
  1751                                  ;  Call with:
  1752                                  ;	DI = drive to start (0, 1)
  1753                                  ;	CS:BX = drive parameter table pointer
  1754                                  ;
  1755                                  ;  Return with:
  1756                                  ;	motor is running and startup delay has been taken
  1757                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1758                                  	global	motor_on
  1759                                  motor_on:
  1760 0000056E 525150                  	pushm	ax,cx,dx
  1761 00000571 89F8                    	mov	ax,di			; drive # to AL
  1762 00000573 0401                    	add	al,MOEN1>>4		; form MOENx >> 4
  1763 00000575 C0E004                  	shl	al,4			; form MOENx bitmask
  1764 00000578 88C4                    	mov	ah,al			; MOENx -> AH
  1765 0000057A 01F8                    	add	ax,di			; MOENx + DSELx -> AL
  1766                                  
  1767 0000057C B1B6                    	mov	cl,182				;10 seconds
  1768 0000057E 880E4000                  	mov	byte [fdc_motor_ticks],cl	; set long timer = 10 seconds
  1769                                  
  1770 00000582 84263F00                	test	byte [fdc_motor_LDOR],ah	; motor already on?
  1771 00000586 88C5                    	mov	ch,al
  1772 00000588 750F                    	jnz	.its_on
  1773                                  
  1774                                  ; motor is not running
  1775 0000058A 2E8B470A                  cs	mov	ax,[DTAB_startup+bx]	; get startup delay in 1/8 seconds
  1776 0000058E 98                        	cbw
  1777 0000058F 6BC07D                    	imul	ax,125			; * 125 ms
  1778 00000592 B236                    	mov	dl,54
  1779 00000594 F6F2                    	div	dl			; divided by 54ms/tick
  1780 00000596 40                      	inc	ax			; one more tick for good measure
  1781 00000597 28C1                    	sub	cl,al			; CL is tick to wait for
  1782                                  
  1783                                  ; if motor was already running, then CL has not been changed
  1784                                  ; Do the select
  1785                                  .its_on:
  1786 00000599 322E3F00                	xor	ch,[fdc_motor_LDOR]	; set selected bits
  1787 0000059D 80E531                  	and	ch,(MOEN_MASK | DSEL_MASK)
  1788 000005A0 302E3F00                	xor	[fdc_motor_LDOR],ch
  1789 000005A4 E896FC                  	call	out_LDOR_mem		; Motor Starts here, or continues
  1790 000005A7 EB01                    	jmp	.wait
  1791                                  
  1792 000005A9 F4                      	hlt
  1793 000005AA 380E4000                .wait:	cmp	[fdc_motor_ticks],cl	; has tick counter expired?
  1794 000005AE 77F9                    	ja	.wait-1
  1795                                  
  1796                                  ; reduce timer to turn-off delay time
  1797 000005B0 2E8A4F02                  cs	mov	cl,[DTAB_turnoff_ticks+bx]	; 2 seconds
  1798 000005B4 880E4000                  	mov	[fdc_motor_ticks],cl
  1799                                  
  1800 000005B8 58595A                  	popm	ax,cx,dx
  1801 000005BB C3                      	ret
  1802                                  
  1803                                  
  1804                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1805                                  ;  make_head_unit
  1806                                  ;
  1807                                  ;  Enter with:
  1808                                  ;	DH = head number
  1809                                  ;	DI = unit number
  1810                                  ;
  1811                                  ;  Return with:
  1812                                  ;	AL = 0000 0huu
  1813                                  ;	Carry clear
  1814                                  ;
  1815                                  ;	Carry is set on error
  1816                                  ;
  1817                                  ;  Assumes "motor_on" has done the real unit select in the LDOR (operations register)
  1818                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1819                                  make_head_unit:
  1820 000005BC 88F0                    	mov	al,dh			; head number to AL
  1821 000005BE A8FE                    	test	al, ~1			; check for head 0 or 1
  1822 000005C0 F9                      	stc				; set to signal error
  1823 000005C1 7507                    	jnz	.err
  1824 000005C3 2401                    	and	al,1			; defensive programming
  1825 000005C5 C0E002                  	shl	al,2			; shift H to position
  1826 000005C8 09F8                    	or	ax,di			; clear the carry
  1827 000005CA C3                      .err:	ret
  1828                                  
  1829                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1830                                  ;  dma_outd		output a double word to a DMA double word register
  1831                                  ;
  1832                                  ;  Call with:
  1833                                  ;	BX:AX	double word to put out
  1834                                  ;	DX	low port address in the DMA controller
  1835                                  
  1836                                  ;  Exit with:
  1837                                  ;	DX incremented by 4
  1838                                  ;
  1839                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1840                                  dma_outd:
  1841 000005CB EF                      	out	dx,ax
  1842 000005CC 42                      	inc	dx
  1843 000005CD 42                      	inc	dx
  1844 000005CE 93                      	xchg	ax,bx
  1845 000005CF EF                      	out	dx,ax
  1846 000005D0 42                      	inc	dx
  1847 000005D1 42                      	inc	dx
  1848 000005D2 C3                      	ret
  1849                                  
  1850                                  
  1851                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1852                                  ;  xfer_read_sector
  1853                                  ;
  1854                                  ;  Call with:
  1855                                  ;	BX:AX	transfer address in memory
  1856                                  ;	CX	transfer byte count
  1857                                  ;	DX:SI	pointer to 9-byte FDC command
  1858                                  ;
  1859                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1860                                  xfer_read_sector:
  1861 000005D3 52                      	push	dx
  1862                                  
  1863                                  ;;;	and	byte [fdc_drv_calib],00h	;POST no interrupts
  1864                                  						; operation is not complete
  1865                                  
  1866                                  ;   BX:AX is the transfer destination address
  1867 000005D4 BAC4FF                  	mov	dx,DMA0+DMADPL		; set low destination
  1868 000005D7 E8F1FF                  	call	dma_outd
  1869                                  
  1870 000005DA 89C8                    	mov	ax,cx			; total byte count
  1871 000005DC EF                      	out	dx,ax			; set terminal count
  1872                                  
  1873 000005DD 31DB                    	xor	bx,bx
  1874 000005DF B81006                  	mov	ax,FDC_DACK
  1875                                  ;   BX:AX is the transfer source port
  1876 000005E2 BAC0FF                  	mov	dx,DMA0+DMASPL		; set low source pointer
  1877 000005E5 E8E3FF                  	call	dma_outd
  1878                                  
  1879 000005E8 8B46FC                  	mov	ax,[rwv_dma+bp]		; get Control register
  1880 000005EB BACAFF                  	mov	dx,DMA0+DMACW
  1881 000005EE EF                      	out	dx,ax			; starts the DMA
  1882                                  
  1883 000005EF 5A                      	pop	dx		; reset DX:SI command pointer
  1884                                  
  1885 000005F0 B90900                  	mov	cx,9			; 9-byte FDC command
  1886 000005F3 E895FB                  	call	output_cmd_to_fdc
  1887                                  
  1888                                  
  1889 000005F6 BBC0FF                  	mov	bx,DMA0+DMASPL
  1890 000005F9 B95006                  	mov	cx,FDC_DACK_TC
  1891                                  
  1892                                  xfer_common_wait:
  1893 000005FC BAC8FF                  	mov	dx,DMA0+DMATC
  1894                                  .loop1:
  1895 000005FF 803E400000              	cmp	byte [fdc_motor_ticks],0
  1896                                  ;;;	cmp	byte [fdc_motor_ticks],20h	; 2Fh - 0Fh in DTABx entries
  1897 00000604 7625                    	jbe	.timeout
  1898                                  
  1899 00000606 E8FCFA                  	call	wait12
  1900 00000609 ED                      	in	ax,dx
  1901 0000060A 83F80C                  	cmp	ax,THRESHHOLD
  1902 0000060D 73F0                    	jae	.loop1
  1903                                  
  1904 0000060F E8A001                  	call	@disable
  1905                                  .loop2:
  1906 00000612 90                      	nop
  1907 00000613 90                      	nop
  1908 00000614 ED                      	in	ax,dx
  1909 00000615 83F801                  	cmp	ax,1
  1910 00000618 77F8                    	ja	.loop2
  1911                                  
  1912 0000061A 89DA                    	mov	dx,bx	; Source low
  1913 0000061C 89C8                    	mov	ax,cx	; FDC_DACK_TC
  1914 0000061E EF                      	out	dx,ax
  1915                                  
  1916 0000061F E89F01                  	call	@enable
  1917                                  
  1918                                  ;;;	mov	ax,100b			; stop the channel
  1919                                  ;;;	mov	dx,DMA0+DMACW			; DMA control word
  1920                                  ;;;	out	dx,ax
  1921                                  
  1922 00000622 E81100                  	call	wait_operation_complete
  1923 00000625 720E                    	jc	.99
  1924                                  
  1925                                  ;;;	mov	ax,100b			; stop the channel
  1926                                  ;;;	mov	dx,DMA0+DMACW			; DMA control word
  1927                                  ;;;	out	dx,ax
  1928                                  
  1929 00000627 30E4                    	Okay
  1930 00000629 EB0A                    	jmp	.99
  1931                                  
  1932                                  .timeout:
  1933                                  ;;;	call	@enable
  1934                                  ; add the following:
  1935 0000062B B80400                  	mov	ax,100b			; stop the channel
  1936 0000062E BACAFF                  	mov	dx,DMA0+DMACW			; DMA control word
  1937 00000631 EF                      	out	dx,ax
  1938                                  
  1939 00000632 B485                    	mov	ah,ERR_85
  1940 00000634 F9                      	Error
  1941 00000635 C3                      .99:	ret
  1942                                  
  1943                                  
  1944                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1945                                  ;  wait_operation_complete		; wait for disk operation
  1946                                  ;					; to post a "complete" status
  1947                                  ;  Call with:
  1948                                  ;	DS = BIOS data area segment
  1949                                  ;
  1950                                  ;  Return with:
  1951                                  ;	CY = 0		success
  1952                                  ;	CY = 1		timed out, AH=error code
  1953                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1954                                  wait_operation_complete:
  1955 00000636 F6063E0001              .1:	test	byte [fdc_drv_calib],01h	; FDC interrupt posted "complete"?
  1956 0000063B 7509                    	jnz	.okay
  1957 0000063D 803E400000              	cmp	byte [fdc_motor_ticks],0
  1958 00000642 75F2                    	jne	.1
  1959 00000644 EB04                    	jmp	.timeout
  1960                                  
  1961 00000646 30E4                    .okay:	Okay
  1962 00000648 EB03                    	jmp	.99
  1963                                  
  1964                                  .timeout:
  1965 0000064A B488                    	mov	ah,ERR_88		; mark timeout
  1966 0000064C F9                      	Error
  1967 0000064D C3                      .99:	ret
  1968                                  
  1969                                  
  1970                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1971                                  ;  xfer_write_sector
  1972                                  ;  xfer_format_track	(only command count is different)
  1973                                  ;
  1974                                  ;  Call with:
  1975                                  ;	BX:AX	transfer address in memory
  1976                                  ;	CX	transfer byte count
  1977                                  ;	DX:SI	pointer to 9-byte FDC command
  1978                                  ;
  1979                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1980                                  xfer_format_track:
  1981                                  xfer_write_sector:
  1982 0000064E 52                      	push	dx
  1983                                  
  1984                                  ;   BX:AX is the transfer source address
  1985 0000064F BAC0FF                  	mov	dx,DMA0+DMASPL		; set low source address
  1986 00000652 E876FF                  	call	dma_outd
  1987                                  
  1988 00000655 31DB                    	xor	bx,bx
  1989 00000657 B81006                  	mov	ax,FDC_DACK
  1990                                  
  1991                                  ;   BX:AX is the transfer destination port
  1992 0000065A BAC4FF                  	mov	dx,DMA0+DMADPL		; set low destination port
  1993 0000065D E86BFF                  	call	dma_outd
  1994                                  
  1995 00000660 89C8                    	mov	ax,cx			; total byte count
  1996 00000662 EF                      	out	dx,ax			; set terminal count
  1997                                  
  1998 00000663 8B46FC                  	mov	ax,[rwv_dma+bp]		; get Control register
  1999 00000666 BACAFF                  	mov	dx,DMA0+DMACW
  2000 00000669 EF                      	out	dx,ax			; starts the DMA
  2001                                  
  2002 0000066A 5A                      	pop	dx		; reset DX:SI command pointer
  2003                                  
  2004 0000066B B90900                  	mov	cx,9			; 9-byte FDC command
  2005 0000066E 36F60408                  ss	test	byte [si], 01000b	; test for FORMAT command
  2006 00000672 7403                      	jz	.4
  2007 00000674 B90600                  	mov	cx,6			; it is FORMAT
  2008                                  .4:
  2009 00000677 E811FB                  	call	output_cmd_to_fdc
  2010                                  
  2011                                  
  2012 0000067A BBC4FF                  	mov	bx,DMA0+DMADPL		; Destination to be updated
  2013 0000067D B95006                  	mov	cx,FDC_DACK_TC
  2014                                  
  2015 00000680 E979FF                  	jmp	xfer_common_wait
  2016                                  
  2017                                  
  2018                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2019                                  ;  xfer_verify_sector
  2020                                  ;
  2021                                  ;  Call with:
  2022                                  ;	BX:AX	transfer address in memory
  2023                                  ;	CX	transfer byte count
  2024                                  ;	DX:SI	pointer to 9-byte FDC command
  2025                                  ;
  2026                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2027                                  xfer_verify_sector:
  2028 00000683 52                      	push	dx
  2029                                  
  2030 00000684 31DB                    	xor	bx,bx			; BX:AX is transfer address
  2031 00000686 B84204                  	mov	ax, (bios_data_seg<<4)+fdc_ctrl_status
  2032                                  
  2033                                  ;   BX:AX is the transfer destination address
  2034 00000689 BAC4FF                  	mov	dx,DMA0+DMADPL		; set low destination
  2035 0000068C E83CFF                  	call	dma_outd
  2036                                  
  2037 0000068F 89C8                    	mov	ax,cx			; total byte count
  2038 00000691 EF                      	out	dx,ax			; set terminal count
  2039                                  
  2040 00000692 31DB                    	xor	bx,bx
  2041 00000694 B81006                  	mov	ax,FDC_DACK
  2042                                  ;   BX:AX is the transfer source port
  2043 00000697 BAC0FF                  	mov	dx,DMA0+DMASPL		; set low source pointer
  2044 0000069A E82EFF                  	call	dma_outd
  2045                                  
  2046 0000069D 8B46FC                  	mov	ax,[rwv_dma+bp]		; get Control register
  2047 000006A0 BACAFF                  	mov	dx,DMA0+DMACW
  2048 000006A3 EF                      	out	dx,ax			; starts the DMA
  2049                                  
  2050 000006A4 5A                      	pop	dx		; reset DX:SI command pointer
  2051                                  
  2052 000006A5 B90900                  	mov	cx,9			; 9-byte FDC command
  2053 000006A8 E8E0FA                  	call	output_cmd_to_fdc
  2054                                  
  2055                                  
  2056 000006AB BBC0FF                  	mov	bx,DMA0+DMASPL
  2057 000006AE B95006                  	mov	cx,FDC_DACK_TC
  2058                                  
  2059 000006B1 E948FF                  	jmp	xfer_common_wait
  2060                                  
  2061                                  
  2062                                  
  2063                                  
  2064                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2065                                  ;  recalibrate
  2066                                  ;
  2067                                  ;  Enter with:
  2068                                  ;	DI = drive number
  2069                                  ;	CS:BX = parameter area pointer
  2070                                  ;	DS = BIOS data area pointer
  2071                                  ;
  2072                                  ;  Return with:
  2073                                  ;	Carry = 0 -- okay
  2074                                  ;
  2075                                  ;	Carry = 1 -- error
  2076                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2077                                  recalibrate:
  2078 000006B4 565251                  	pushm   cx,dx,si
  2079                                  
  2080                                  ;;;	call    motor_on
  2081                                  
  2082 000006B7 80263E0000              	and	byte [fdc_drv_calib],00h	;POST no interrupts
  2083                                  
  2084 000006BC B001                    	mov	al,ST0_US	; mask to 2 drives
  2085 000006BE 21F8                    	and	ax,di		; unit number to AL
  2086 000006C0 86C4                    	xchg    al,ah		; AH is second byte of command
  2087 000006C2 B007                    	mov     al,CMD_RECALIBRATE
  2088 000006C4 50                      	push    ax		; push 2 byte command
  2089 000006C5 89E6                    	mov     si,sp           ; form command pointer
  2090 000006C7 8CD2                    	mov     dx,ss           ; DX:SI points at command
  2091 000006C9 B90200                  	mov     cx,2
  2092 000006CC E8BCFA                  	call    output_cmd_to_fdc	; output the command
  2093 000006CF 7231                    	jc      .7
  2094                                  
  2095 000006D1 E862FF                  	call	wait_operation_complete
  2096 000006D4 722C                    	jc	.7
  2097                                  
  2098 000006D6 E86CFB                  	call    fdc_wait_seek_done
  2099 000006D9 7227                    	jc      .7
  2100                                  
  2101 000006DB 58                      	pop     ax		; get unit # to AH
  2102 000006DC B004                    	mov     al,CMD_SENSE_DRIVE_STATUS
  2103 000006DE 50                      	push    ax		; push 2 byte command again
  2104 000006DF B90200                  	mov     cx,2
  2105 000006E2 89E6                    	mov     si,sp
  2106 000006E4 8CD2                    	mov     dx,ss		; DX:SI points at the 2 byte command
  2107 000006E6 E8A2FA                  	call    output_cmd_to_fdc
  2108 000006E9 7217                    	jc      .7
  2109                                  
  2110 000006EB E88DFA                  	call    input_byte_from_fdc	; get ST3
  2111 000006EE 7212                    	jc      .7
  2112 000006F0 88859000                	mov     [fdc_disk_state+di],al	; save ST3 for drive
  2113 000006F4 B487                    	mov	ah,ERR_87		; not on track 0
  2114 000006F6 A810                    	test    al,ST3_TR00
  2115 000006F8 F9                      	Error				; signal error
  2116 000006F9 7407                    	jz      .7                      ; Not on Track 00, C=1 error
  2117                                  
  2118 000006FB C685940000              	mov	byte [fdc_cylinder+di],0	; set present cylinder
  2119                                  
  2120                                  %if SOFT_DEBUG > 1
  2121                                  	push    -1
  2122                                  	call    lites
  2123                                  %endif
  2124 00000700 30E4                    	Okay			;
  2125                                  
  2126 00000702 5E                      .7:     pop     si		; Command is still in the stack
  2127 00000703 595A5E                  	popm    cx,dx,si	; restore
  2128 00000706 C3                      	ret
  2129                                  
  2130                                  
  2131                                  
  2132                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2133                                  ;  Seek			seek to proper cylinder
  2134                                  ;
  2135                                  ;  Call with:
  2136                                  ;	CH = cylinder to which to position heads
  2137                                  ;	CS:BX = disk parameter area
  2138                                  ;	DI = unit number
  2139                                  ;	DS = BIOS data area pointer
  2140                                  ;
  2141                                  ;  Return with:
  2142                                  ;	Carry = 0	success
  2143                                  ;
  2144                                  ;	Carry = 1	error
  2145                                  ;
  2146                                  ;  Assumes "motor_on" has done the real unit select in the LDOR (operations register)
  2147                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2148                                  Seek:
  2149 00000707 565251                  	pushm	cx,dx,si
  2150                                  
  2151                                  ; check for a recalibration needed
  2152 0000070A 8A859400                	mov	al,[fdc_cylinder+di]	; get present cylinder (0FFh forces recalibrate)
  2153 0000070E 2E3A470B                 cs	cmp	al,[DTAB_max_cylinder+bx]	; compare to maximum
  2154 00000712 760E                    	jbe	.no_recal
  2155                                  
  2156 00000714 BE0200                  	mov	si,2			; two recalibrates max.
  2157                                  .rerecal:
  2158 00000717 E89AFF                  	call	recalibrate
  2159 0000071A 7306                    	jnc	.no_recal
  2160 0000071C 4E                      	dec	si
  2161 0000071D F9                      	Error
  2162 0000071E 7442                    	jz	.exit			; two have failed
  2163 00000720 EBF5                    	jmp	.rerecal		; try again
  2164                                  
  2165                                  .no_recal:
  2166 00000722 3AAD9400                	cmp	ch,[fdc_cylinder+di]	; sought : present cylinder
  2167 00000726 7438                    	je	.okay
  2168                                  
  2169                                  ; we are not on the cylinder we want
  2170                                  
  2171 00000728 2E3A6F0B                  cs	cmp	ch,[DTAB_max_cylinder+bx]  ; validate cylinder number
  2172 0000072C 7738                    	ja	.invalid
  2173                                  
  2174                                  .valid:
  2175 0000072E 80263E0000              	and	byte [fdc_drv_calib],00h	;POST no interrupts
  2176                                  
  2177 00000733 86CD                    	xchg	cl,ch			; cylinder to CL
  2178 00000735 51                      	push	cx			; CL = sought cylinder
  2179 00000736 E883FE                  	call	make_head_unit
  2180 00000739 B40F                    	mov	ah,CMD_SEEK		; command byte
  2181 0000073B 86C4                    	xchg	al,ah			; command byte must be first in stack
  2182 0000073D 50                      	push	ax			; push 3 byte command
  2183 0000073E 89E6                    	mov	si,sp
  2184 00000740 8CD2                    	mov	dx,ss			; DX:SI points at command
  2185 00000742 B90300                  	mov	cx,3			; 3 byte command
  2186 00000745 E843FA                  	call	output_cmd_to_fdc
  2187 00000748 5E59                    	popm	si,cx			; fix stack; get CL=seek to cylinder
  2188 0000074A 86CD                    	xchg	cl,ch			; CH=seek to cylinder
  2189 0000074C 7214                    	jc	.exit
  2190                                  
  2191 0000074E E8E5FE                  	call	wait_operation_complete
  2192 00000751 720F                    	jc	.exit
  2193                                  
  2194                                  ;;;	mov	[fdc_cylinder+di],ch	; set new cylinder number
  2195                                  
  2196 00000753 E8EFFA                  	call	fdc_wait_seek_done	; AH=error code if C=1
  2197 00000756 720A                    	jc	.exit
  2198                                  
  2199                                  %if 0
  2200                                  ; probably have to skip the following during Format
  2201                                  	call	read_track_id		; just to be sure
  2202                                  	jc	.exit
  2203                                  %endif
  2204                                  
  2205 00000758 B440                    	mov	ah,ERR_seek_failed
  2206 0000075A 3AAD9400                	cmp	ch,[fdc_cylinder+di]	; PCN filled in
  2207 0000075E 7508                    	jne	.err
  2208                                  ;;;	mov	ah,ERR_8A
  2209                                  ;;;	cmp	ch,[fdc_ctrl_status+3]	; read cylinder number
  2210                                  ;;;	jne	.err
  2211                                  
  2212                                  
  2213                                  .okay:
  2214 00000760 30E4                    	Okay
  2215                                  .exit:
  2216 00000762 595A5E                  	popm	cx,dx,si
  2217 00000765 C3                      	ret
  2218                                  
  2219                                  .invalid:
  2220                                  ; error -- the cylinder requested is invalid for this drive
  2221 00000766 B486                    	mov	ah,ERR_86
  2222 00000768 F9                      .err:	Error
  2223 00000769 EBF7                    	jmp	.exit		  	; jump WAY out
  2224                                  
  2225                                  
  2226                                  
  2227                                  
  2228                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2229                                  ;  Check_RW_Status		check ST0 & ST1 error bits
  2230                                  ;
  2231                                  ;  Call with:
  2232                                  ;	CY = 0,1	needs to be examined
  2233                                  ;
  2234                                  ;  Return with:
  2235                                  ;	CY = 0, AH = 0		no error detected
  2236                                  ;
  2237                                  ;	CY = 1, AH = final error code	error in status bits
  2238                                  ;
  2239                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2240                                   	global	Check_RW_Status
  2241                                  Check_RW_Status:
  2242 0000076B 061E56525153            	pushm	bx,cx,dx,si,ds,es
  2243                                  
  2244                                  %if SOFT_DEBUG & DUMP
  2245                                  	xchg	al,ah			; error code to AL
  2246                                  	lahf				; flags to AH
  2247                                  	push	ax
  2248                                  
  2249                                  	xor	ah,ah			; zero hi-byte
  2250                                  	mov	cx,7
  2251                                  	mov	si,fdc_ctrl_status+6	; byte to start
  2252                                  .1	std
  2253                                  	lodsb
  2254                                    	push	ax			; push argument
  2255                                  	loop	.1
  2256                                  	cld
  2257                                  	push	cs
  2258                                  	push	fcrw
  2259                                  	call	_cprintf
  2260                                  	add	sp,18
  2261                                  
  2262                                  	pop	ax
  2263                                  	sahf				; restore flags
  2264                                  	xchg	al,ah			; restore error code to AH
  2265                                  %endif
  2266                                  
  2267                                  %if 1
  2268 00000771 7309                    	jnc	.no_err
  2269                                  
  2270 00000773 C6460E00                	mov	byte [offset_AL+bp],0	; say nothing transferred
  2271                                  
  2272                                  ; Carry is set, what happened?
  2273 00000777 80FC81                  	cmp	ah,ERR_81		; first of our new error codes
  2274                                  	;;;
  2275 0000077A EB2E                    	jmp	.error		; for now
  2276                                  %endif
  2277                                  
  2278                                  
  2279                                  .no_err:
  2280 0000077C 8A264200                	mov	ah,[fdc_ctrl_status]	; get ST0 to AH
  2281 00000780 88E0                    	mov	al,ah			; retain copy in AL
  2282 00000782 80E4C0                  	and	ah,ST0_IC		; check interrupt code
  2283 00000785 7424                    	jz	.exit	; Okay is set
  2284                                  
  2285 00000787 B420                    	mov	ah,ERR_controller_failure
  2286 00000789 A810                    	test	al,ST0_EC
  2287 0000078B 751D                    	jnz	.error
  2288                                  
  2289 0000078D A04300                  	mov	al,[fdc_ctrl_status+1]	; get ST1 to AL
  2290 00000790 B402                    	mov	ah,ERR_address_mark_not_found
  2291 00000792 A801                    	test	al,ST1_MA		; test Missing Address mark
  2292 00000794 7514                    	jnz	.error
  2293                                  
  2294 00000796 FEC4                    	inc	ah			; Write Protect
  2295 00000798 A802                    	test	al,ST1_NW		;
  2296 0000079A 750E                    	jnz	.error
  2297                                  
  2298 0000079C FEC4                    	inc	ah			; Sector not Found
  2299 0000079E A804                    	test	al,ST1_ND		; No Data
  2300 000007A0 7508                    	jnz	.error
  2301                                  
  2302 000007A2 B410                    	mov	ah,ERR_uncorrectable_CRC_error
  2303 000007A4 A820                    	test	al,ST1_DE
  2304 000007A6 7502                    	jnz	.error
  2305                                  
  2306 000007A8 B48F                    	mov	ah,ERR_unknown		; may be in ST2
  2307                                  
  2308 000007AA F9                      .error:	Error				; code is in AH
  2309                                  .exit:
  2310 000007AB 5B595A5E1F07            	popm	bx,cx,dx,si,ds,es
  2311 000007B1 C3                      	ret
  2312                                  
  2313                                  
  2314                                  %if SOFT_DEBUG & DUMP
  2315                                  fcrw	db	NL,"ST0 %02x  ST1 %02x  ST2 %02x  C+ %02x  H+ %02x  S+ %02x  N %x", 0
  2316                                  rwvc	db	NL,"AX %04x  CHS %02x:%02x:%02x  DL %02x  ES:BX %04x:%04x", 0
  2317                                  fnret	db	NL,"AH %02x  CY %d  CMD %02x %02x",NL, 0
  2318                                  %endif
  2319                                  
  2320                                  
  2321                                  
  2322                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2323                                  ;  @enable / @disable		Interrupt enable/disable
  2324                                  ;
  2325                                  ;  On a @disable, increment the lock counter and CLI
  2326                                  ;  On an @enable, decrement the lock counter and if it goes to zero, STI
  2327                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2328                                  	global	@enable, @disable
  2329                                  @disable:
  2330 000007B2 1E50                    	pushm	ax,ds
  2331 000007B4 9F                      	lahf				; save user flags
  2332 000007B5 6A40                    	push	bios_data_seg		; universal addressing
  2333 000007B7 1F                      	popm	ds
  2334 000007B8 FA                      	cli				; guarantee locked operation
  2335 000007B9 FE06AE00                	inc	byte [lock_count]
  2336 000007BD 9E                      	sahf				; restore user flags
  2337 000007BE 581F                    	popm	ax,ds
  2338 000007C0 C3                      	ret
  2339                                  
  2340                                  @enable:
  2341 000007C1 1E50                    	pushm	ax,ds
  2342 000007C3 9F                      	lahf				; save user flags
  2343 000007C4 6A40                    	push	bios_data_seg
  2344 000007C6 1F                      	popm	ds
  2345 000007C7 FE0EAE00                	dec	byte [lock_count]	; test the lock count
  2346 000007CB 7501                    	jnz	.5
  2347 000007CD FB                      	sti				; lock count went to zero, re-enable
  2348                                  .5:
  2349 000007CE 9E                      	sahf				; restore user flags
  2350 000007CF 581F                    	popm	ax,ds
  2351 000007D1 C3                      	ret
  2352                                  
  2353                                  
  2354                                  
  2355                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2356                                  ;  read_track_id			; read address mark information
  2357                                  ;
  2358                                  ;  Call with:
  2359                                  ;	DS = BIOS data segment
  2360                                  ;	DI = unit number
  2361                                  ;	DH = head number
  2362                                  ;
  2363                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2364                                  read_track_id:
  2365 000007D2 525156                  	pushm	si,cx,dx
  2366                                  
  2367 000007D5 C6063E0000              	mov	byte [fdc_drv_calib],0	; clear interrupt flags
  2368                                  
  2369 000007DA E8DFFD                  	call	make_head_unit		; head/un
  2370 000007DD 88C4                    	mov	ah,al			; move to AH (second byte of command)
  2371 000007DF B04A                    	mov	al,CMD_READ_ID | CMD_MF
  2372 000007E1 50                      	push	ax			; push the 2-byte command
  2373 000007E2 89E6                    	mov	si,sp
  2374 000007E4 8CD2                    	mov	dx,ss			; DX:SI points at command
  2375 000007E6 B90200                  	mov	cx,2			; 2 bytes to READ_ID
  2376 000007E9 E89FF9                  	call 	output_cmd_to_fdc	; issue the command
  2377 000007EC 58                      	pop	ax			; discard word in stack
  2378                                  
  2379 000007ED E846FE                  	call	wait_operation_complete
  2380                                  
  2381 000007F0 5E595A                  	popm	si,cx,dx
  2382 000007F3 C3                      	ret
