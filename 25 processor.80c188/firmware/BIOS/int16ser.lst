     1                                  %ifndef SOFT_DEBUG
     2                                  ;;;%define SOFT_DEBUG 1
     3                                  %endif
     4                                  ;========================================================================
     5                                  ; int16ser.asm -- Keyboard service implementation using serial port
     6                                  ;========================================================================
     7                                  ;
     8                                  ; Compiles with NASM 2.07, might work with other versions
     9                                  ;
    10                                  ; Copyright (C) 2010 Sergey Kiselev.
    11                                  ; Provided for hobbyist use on the N8VEM SBC-188 board.
    12                                  ;  
    13                                  ; This program is free software: you can redistribute it and/or modify
    14                                  ; it under the terms of the GNU General Public License as published by
    15                                  ; the Free Software Foundation, either version 3 of the License, or
    16                                  ; (at your option) any later version.
    17                                  ;
    18                                  ; This program is distributed in the hope that it will be useful,
    19                                  ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    20                                  ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    21                                  ; GNU General Public License for more details.
    22                                  ;
    23                                  ; You should have received a copy of the GNU General Public License
    24                                  ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    25                                  ;
    26                                  ; UPDATES:
    27                                  ;       31-Dec-2010 -- JRCoffman - add HLT to fn00 code.
    28                                  ;	17-Oct-2010 -- JRCoffman - fix .5 label bug & add ctrl-B debugger
    29                                  ;			escape.
    30                                  ;
    31                                  ; TODO:
    32                                  ; - add UART autodetection and FIFO for 16550
    33                                  ; - add escape sequence handling for function keys
    34                                  ; - raw mode (e.g. for firmware uploads)
    35                                  ; - Ctrl-Alt-Del (not possible literally, some other keys for soft reboot)
    36                                  ;========================================================================
    37                                  
    38                                  %include	"config.asm"
    39                              <1> ;/*
    40                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    41                              <1> ; ANSI.CFG
    42                              <1> ;   Copied to CONFIG.ASM for general release.
    43                              <1> ;
    44                              <1> ;       Modify the parameters below to reflect your system
    45                              <1> ;
    46                              <1> ;
    47                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    48                              <1> ;
    49                              <1> ;   Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    50                              <1> ;   Provided for hobbyist use on the N8VEM SBC-188 board.
    51                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    52                              <1> ;
    53                              <1> ; Define the serial terminal that the Video BIOS must emulate
    54                              <1> ; Set one of the following to 1
    55                              <1> ; If you have no idea what to choose, set TTY to 1
    56                              <1> TTY     equ     0       ; hardcopy -- cannot position the cursor
    57                              <1> DUMB    equ     0       ; dumb CRT -- ^H, ^J, ^K, ^L can move the cursor
    58                              <1> ANSI    equ     1       ; very smart, like a VT-100
    59                              <1> WYSE    equ     0       ; very smart Wyse series (30, 50, ...)
    60                              <1> ; others may get added in the future
    61                              <1> ;  ONE OF THE ABOVE must BE SET TO 1!!!!!
    62                              <1> ;
    63                              <1> ; Does the hardware configuration contain the Color Video Display Unit?
    64                              <1> ; Both the 8563 and the 8242 are used.  The default is CVDU=0
    65                              <1> CVDU	equ	0	; system does not have the CVDU
    66                              <1> ;
    67                              <1> ; Does the hardware configuration contain the VGA3 a/n Video card?
    68                              <1> ; The 8563 will be disabled, but the 8242 code is shared with the CVDU
    69                              <1> ; The default is VGA3=0
    70                              <1> VGA3    equ     0       ; system does not have the VGA3
    71                              <1> %if 0
    72                              <1> 	*/
    73                              <1> #define VGA3 0
    74                              <1> /*
    75                              <1> %endif
    76                              <1> ;
    77                              <1> ; Boot up keyboard mode:  20h for NumLock on
    78                              <1> ;CVDU_KEYBOARD_STATUS	equ	0	; NumLock OFF
    79                              <1> CVDU_KEYBOARD_STATUS	equ	20h	; NumLock ON
    80                              <1> 
    81                              <1> ; Define the UART startup bit rate - 1200-19200 are most common
    82                              <1> ;UART_RATE	equ	0		; 1200
    83                              <1> ;UART_RATE	equ	1		; 2400
    84                              <1> ;UART_RATE	equ	2		; 4800
    85                              <1> UART_RATE	equ	3		; 9600
    86                              <1> ;UART_RATE	equ	4		; 19200
    87                              <1> ;UART_RATE	equ	5		; 38400
    88                              <1> ;UART_RATE	equ	6		; 57600
    89                              <1> ;UART_RATE	equ	7		; 115200
    90                              <1> 
    91                              <1> ; Does the serial terminal use the DSR/DTR protocol for flow control?
    92                              <1> ;UART_DSR_PROTOCOL	equ		1	; Yes!
    93                              <1> UART_DSR_PROTOCOL       equ             WYSE    ; Wyse always uses it
    94                              <1> 						; but not ANSI
    95                              <1> ; Define the size of the ROM image on the system in Kilobytes
    96                              <1> ; It may be smaller than the actual EPROM in use.
    97                              <1> ; The following sizes are supported:  32, 64, 128, and 256
    98                              <1> %ifndef ROM
    99                              <1> ROM             equ     32              ; 64 is the default
   100                              <1> %endif
   101                              <1> 
   102                              <1> ; Define the number of Wait States at which the ROM operates
   103                              <1> ROM_WS          equ     1               ; 0..3  (1 is the default)
   104                              <1> 
   105                              <1> ; Define the size in Kilobytes of DOS RAM (low SRAM plus EMM allocate RAM)
   106                              <1> ; This is a desired size and will only be present if a 4MEM board is added
   107                              <1> RAM_DOS         equ     640
   108                              <1> 
   109                              <1> ; Define the size of the low SRAM on the system in Kilobytes
   110                              <1> ; the default is 512 kilobytes
   111                              <1> RAM             equ     512             ; (512 is the default)
   112                              <1> 
   113                              <1> ; Define the number of Wait States at which the RAM operates
   114                              <1> RAM_WS          equ     0               ; 0..3  (0 is the default)
   115                              <1> 
   116                              <1> ; Define the number of Wait States for Local Peripheral devices (600-7FF)
   117                              <1> LCL_IO_WS       equ     1               ; 0..3  (1 is the default)
   118                              <1> 
   119                              <1> ; Define the number of Wait States for ECB BUS peripheral devices (4xx)
   120                              <1> BUS_IO_WS       equ     3               ; 0..3  (3 is the default)
   121                              <1> 
   122                              <1> ; Define the time zone in which we build the Relocatable BIOS
   123                              <1> %ifndef TIMEZONE
   124                              <1> %define TIMEZONE "PST"
   125                              <1> %endif
   126                              <1> 
   127                              <1> ; Has the REDBUG debugger been loaded?
   128                              <1> %ifndef SOFT_DEBUG
   129                              <1> %define SOFT_DEBUG 0
   130                              <1> %endif
   131                              <1> 
   132                              <1> ; Should the BIOS include "Tiny BASIC" in the image?
   133                              <1> %ifndef TBASIC
   134                              <1> TBASIC          equ     1		; default is 1
   135                              <1> %endif
   136                              <1> 
   137                              <1> ; Should the BIOS include the Floating Point Emulator?  The 80188 does
   138                              <1> ; not allow a floating point co-processor, so this is probably a good idea.
   139                              <1> %ifndef FPEM
   140                              <1> FPEM            equ     1               ; default is 1
   141                              <1> %endif
   142                              <1> 
   143                              <1> ; Define the maximum number of EMM (4MEM) boards supported
   144                              <1> EMM_BOARDS      equ     4
   145                              <1> 
   146                              <1> ; Should the Floating Point Emulator use temporary storage in the EBDA
   147                              <1> ; or at locations 0280h..3FFh in low memory?
   148                              <1> %if SOFT_DEBUG
   149                              <1> FPEM_USE_EBDA   equ     FPEM            ; default is 0
   150                              <1> %else
   151                              <1> FPEM_USE_EBDA   equ     0; FPEM            ; default is 0
   152                              <1> %endif
   153                              <1> 
   154                              <1> ; Define the size of the EPROM that is to be installed on the system
   155                              <1> ; It may be larger than the actual ROM image to be generated.
   156                              <1> %ifndef CHIP
   157                              <1> CHIP            equ     64
   158                              <1> %endif
   159                              <1> 
   160                              <1> ; Does the SBC-188 00.4 board have the LS138/LS08 piggyback fix
   161                              <1> ; Set to 1 for the SBC-188 v1.0 and later production boards
   162                              <1> ;FDC_PIGGYBACK_FIX       equ     0       ; Fix not installed
   163                              <1> FDC_PIGGYBACK_FIX       equ     1       ; fix  IS  installed
   164                              <1> 
   165                              <1> ; On SBC-188 rev 00.4 board, there is a published hardware fix (2010-09-18).
   166                              <1> ; If the wiring update is installed, or you have a later board, then
   167                              <1> ; set this to 0.  If you are using the software workaround, then set this
   168                              <1> ; to 1.  The rev 1.0 board has this fix already.
   169                              <1> NEED_TIMER_FIX  equ     0               ; have revised hardware
   170                              <1> ;NEED_TIMER_FIX  equ     1               ; use workaround
   171                              <1> 
   172                              <1> ; Define the UART oscillator speed
   173                              <1> UART_OSC        equ     1843200         ; 1.8432 Mhz is specified
   174                              <1> 
   175                              <1> 
   176                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   177                              <1> ; end of the User configuration
   178                              <1> ;       Do Not modify anything below this point
   179                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   180                              <1> 
   181                              <1> CVDU_8563	equ	CVDU		; separate inits
   182                              <1> CVDU_8242	equ	CVDU|VGA3 	; separate inits
   183                              <1> VGA3_6445       equ     VGA3            ; separate inits
   184                              <1> ; Suppress all UART output in color video Mode 3
   185                              <1> UART_MODE3_SUPPRESS	equ	CVDU_8563
   186                              <1> CVDU_USE_MSDOS_KLUDGE	equ	0; CVDU_8242	; bad, bad MSDOS
   187                              <1> CVDU_USE_KBD_HOOK		equ	CVDU_8242
   188                              <1> 
   189                              <1> ; Define existence of any uart chip
   190                              <1> UART		equ	TTY+DUMB+ANSI+WYSE
   191                              <1> startuplength   equ     512                     ; may be up to 1024
   192                              <1> startseg        equ     0FFFFh - (ROM*64) + 1
   193                              <1> highrom         equ     (ROM*400h)&0FFFFh
   194                              <1> startupseg      equ     0FFFFh - (startuplength>>4) + 1
   195                              <1> bios_data_seg   equ     040h            ; segment of BIOS data area
   196                              <1> 
   197                              <1> 
   198                              <1> %define ARG(n) [bp+2+(n)*2]
   199                              <1> 
   200                              <1> %macro  check   1.nolist
   201                              <1>  %if (%1)
   202                              <1>    %error Check Failure: %1
   203                              <1>  %endif
   204                              <1> %endm
   205                              <1> %macro  range   3.nolist
   206                              <1>  %if (%1)<(%2)
   207                              <1>    %error Out of Range: %1
   208                              <1>  %elif (%1)>(%3)
   209                              <1>    %error Out of Range: %1
   210                              <1>  %endif
   211                              <1> %endm
   212                              <1> _terminal equ UART+CVDU
   213                              <1>  check   RAM_DOS&15
   214                              <1>  check   RAM&(RAM-1)
   215                              <1>  check   ROM&(ROM-1)
   216                              <1>  range   RAM,32,512
   217                              <1>  range   ROM,32,256
   218                              <1>  range   RAM_WS,0,3
   219                              <1>  range   ROM_WS,0,3
   220                              <1>  range   RAM_DOS,RAM,(1024-ROM)
   221                              <1>  range   LCL_IO_WS,0,3
   222                              <1>  range   BUS_IO_WS,0,3
   223                              <1>  range   UART_OSC,500000,16000000
   224                              <1>  range   UART_RATE,0,7
   225                              <1>  range	 UART,0,1
   226                              <1>  range	 _terminal,1,2
   227                              <1> 
   228                              <1> %ifndef SOFT_DEBUG
   229                              <1> %define SOFT_DEBUG 0
   230                              <1> %endif
   231                              <1> 
   232                              <1> %ifndef TRACE
   233                              <1> %define TRACE 0
   234                              <1> %endif
   235                              <1> 
   236                              <1> %ifdef MAKE_OBJECT_FILE
   237                              <1>         segment _DATA WORD PUBLIC CLASS=DATA
   238                              <1>         export _ROMsize
   239                              <1>         export _CHIPsize
   240                              <1> _ROMsize        dw      ROM
   241                              <1> _CHIPsize       dw      CHIP
   242                              <1> %endif
   243                              <1> ; end of the Hardware configuration file
   244                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   245                              <1> ;*/
    39                                  %include	"cpuregs.asm"
    40                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    41                              <1> ; CPUREGS.ASM
    42                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    43                              <1> ;
    44                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    45                              <1> ;
    46                              <1> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    47                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    48                              <1> ;
    49                              <1> ; This program is free software: you can redistribute it and/or modify
    50                              <1> ; it under the terms of the GNU General Public License as published by
    51                              <1> ; the Free Software Foundation, either version 3 of the License, or
    52                              <1> ; (at your option) any later version.
    53                              <1> ;
    54                              <1> ; This program is distributed in the hope that it will be useful,
    55                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    56                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    57                              <1> ; GNU General Public License for more details.
    58                              <1> ;
    59                              <1> ; You should have received a copy of the GNU General Public License
    60                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    61                              <1> ;
    62                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    63                              <1> %include	"macros.inc"
    64                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    65                              <2> ; MACROS.INC  
    66                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    67                              <2> ;
    68                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    69                              <2> ;
    70                              <2> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    71                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    72                              <2> ;
    73                              <2> ; This program is free software: you can redistribute it and/or modify
    74                              <2> ; it under the terms of the GNU General Public License as published by
    75                              <2> ; the Free Software Foundation, either version 3 of the License, or
    76                              <2> ; (at your option) any later version.
    77                              <2> ;
    78                              <2> ; This program is distributed in the hope that it will be useful,
    79                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    80                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    81                              <2> ; GNU General Public License for more details.
    82                              <2> ;
    83                              <2> ; You should have received a copy of the GNU General Public License
    84                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    85                              <2> ;
    86                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    87                              <2> 
    88                              <2> ; general macros for the SBC188 BIOS ASSEMBLY
    89                              <2> ;
    90                              <2> ;
    91                              <2> %ifndef __MACROS_DEFINED_
    92                              <2> %define __MACROS_DEFINED_ 1
    93                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    94                              <2> ;
    95                              <2> ; some useful macros:
    96                              <2> ;
    97                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    98                              <2> ;
    99                              <2> 	cpu	186
   100                              <2> 
   101                              <2> %imacro setloc  1.nolist
   102                              <2>  times   (%1-($-$$)) db 0FFh
   103                              <2> %endm
   104                              <2> 
   105                              <2> %imacro db_lo   1
   106                              <2>  db (%1)&255
   107                              <2> %endm
   108                              <2> 
   109                              <2> %imacro cnop    0.nolist
   110                              <2> %if SOFT_DEBUG
   111                              <2>         nop
   112                              <2> %endif
   113                              <2> %endm
   114                              <2> 
   115                              <2> %imacro popm 1-*.nolist
   116                              <2> %rep %0
   117                              <2> %ifidni %1,ALL
   118                              <2>  popa
   119                              <2> %elifidni %1,F
   120                              <2>  popf
   121                              <2> %else
   122                              <2>  pop %1
   123                              <2> %ifidni %1,DS
   124                              <2>  cnop
   125                              <2> %elifidni %1,ES
   126                              <2>  cnop
   127                              <2> %endif
   128                              <2> %endif
   129                              <2> %rotate 1
   130                              <2> %endrep
   131                              <2> %endm
   132                              <2> 
   133                              <2> %imacro pushm 1-*.nolist
   134                              <2> %rep %0
   135                              <2> %rotate -1
   136                              <2> %ifidni %1,ALL
   137                              <2>  pusha
   138                              <2> %elifidni %1,F
   139                              <2>  pushf
   140                              <2> %else
   141                              <2>  push %1
   142                              <2> %endif
   143                              <2> %endrep
   144                              <2> %endm
   145                              <2> 
   146                              <2> ;
   147                              <2> ; added from the 386EX project
   148                              <2> ;
   149                              <2> 
   150                              <2> ; call arguments
   151                              <2> %define ARG(n) [bp+2+(n)*2]
   152                              <2> 
   153                              <2> ;
   154                              <2> ; format of the BYTE initialization table:  address, byte
   155                              <2> ;
   156                              <2> %imacro  binit 2
   157                              <2>         dw      %1
   158                              <2>         db      %2
   159                              <2> %endmacro
   160                              <2> ; end with DW -1
   161                              <2> 
   162                              <2> ;
   163                              <2> ; format of the WORD initialization table:  address, word
   164                              <2> ;
   165                              <2> %imacro  winit 2
   166                              <2>         dw      %1
   167                              <2>         dw      %2
   168                              <2> %endmacro
   169                              <2> ; end with DW -1
   170                              <2> 
   171                              <2> 
   172                              <2> ; get the BIOS Data Area segment pointer to a [segment] register
   173                              <2> %imacro get_bda	1.nolist
   174                              <2> 	push	0x0040
   175                              <2> 	pop	%1
   176                              <2> 	cnop
   177                              <2> %endm
   178                              <2> 
   179                              <2> 
   180                              <2> %endif
    64                              <1> 
    65                              <1> 	cpu     186
    66                              <1> ;
    67                              <1> ;
    68                              <1> ; IBM model byte -- must be less than a 286
    69                              <1> ;
    70                              <1> ;MODEL_BYTE		equ	0FEh	; PC-XT
    71                              <1> ;SUBMODEL_BYTE		equ	0FFh	; not used
    72                              <1> 
    73                              <1> MODEL_BYTE		equ	0FEh	; PC-XT
    74                              <1> SUBMODEL_BYTE		equ	00h	;  "
    75                              <1> 
    76                              <1> 
    77                              <1> ; 80188 peripheral control register block address
    78                              <1> CPU_CSCR	        equ	0FF00h
    79                              <1> 
    80                              <1> ; Compatible Mode registers
    81                              <1> 
    82                              <1> cpu_relocation          equ     CPU_CSCR+0FEh
    83                              <1> 
    84                              <1> ; The memory and peripheral chip select register offsets from 0FF00h
    85                              <1> 
    86                              <1> cpu_umcs                equ     CPU_CSCR+0A0h          ; Upper memory select
    87                              <1> cpu_lmcs                equ     CPU_CSCR+0A2h          ; Lower memory select
    88                              <1> cpu_pacs                equ     CPU_CSCR+0A4h          ; Peripheral select
    89                              <1> cpu_mmcs                equ     CPU_CSCR+0A6h          ; Middle memory base
    90                              <1> cpu_mpcs                equ     CPU_CSCR+0A8h          ; Mid mem. & peripherals
    91                              <1> 
    92                              <1> ; Enhanced Mode registers
    93                              <1> 
    94                              <1> cpu_mdram               equ     CPU_CSCR+0E0h          ; memory partition reg.
    95                              <1> cpu_cdram               equ     CPU_CSCR+0E2h          ; clock prescaler
    96                              <1> cpu_edram               equ     CPU_CSCR+0E4h          ; Enable refresh reg.
    97                              <1> cpu_pdcon               equ     CPU_CSCR+0F0h          ; Power-Save control
    98                              <1> 
    99                              <1> 
   100                              <1> ; On-board internal peripheral equates
   101                              <1> ; Programmable Interrupt Controller
   102                              <1> PIC	        equ	CPU_CSCR+020H
   103                              <1> PIC_EOI	        equ	PIC+2           ; End Of Interrupt
   104                              <1> PIC_POLLR	equ	PIC+4
   105                              <1> PIC_POLLSR	equ	PIC+6
   106                              <1> PIC_IMASK	equ	PIC+8
   107                              <1> PIC_PMREG	equ	PIC+0AH
   108                              <1> PIC_SRVR	equ	PIC+0CH
   109                              <1> PIC_IRQR	equ	PIC+0EH
   110                              <1> PIC_IRQSR	equ	PIC+10H
   111                              <1> PIC_TCR	        equ	PIC+12H
   112                              <1> PIC_DMA0CR	equ	PIC+14H
   113                              <1> PIC_DMA1CR	equ	PIC+16H
   114                              <1> PIC_I0CON	equ	PIC+18H
   115                              <1> PIC_I1CON	equ	PIC+1AH
   116                              <1> PIC_I2CON	equ	PIC+1CH
   117                              <1> PIC_I3CON	equ	PIC+1EH
   118                              <1> 
   119                              <1> EOI_NSPEC       equ     8000h           ; Non-Specific EOI
   120                              <1> 
   121                              <1> ; Interrupt masks (Master Mode)
   122                              <1> ;
   123                              <1> mask_timer_all          equ     0001h
   124                              <1> mask_dma0               equ     0004h
   125                              <1> mask_dma1               equ     0008h
   126                              <1> mask_int0               equ     0010h
   127                              <1> mask_int1               equ     0020h
   128                              <1> mask_int2               equ     0040h
   129                              <1> mask_int3               equ     0080h
   130                              <1> 
   131                              <1> 
   132                              <1> 
   133                              <1> ; Timers
   134                              <1> TIM0	        equ	CPU_CSCR+050H
   135                              <1> TIM1	        equ	CPU_CSCR+058H
   136                              <1> TIM2	        equ	CPU_CSCR+060H
   137                              <1> 
   138                              <1> TCNT	        equ	0	; count register
   139                              <1> CMPA	        equ	2	; max count A
   140                              <1> CMPB	        equ	4	; max count B (not present on TIM2)
   141                              <1> TCON	        equ	6	; mode/control word
   142                              <1> 
   143                              <1> ; Timer control bits:
   144                              <1> tc_EN           equ     8000h   ; Enable bit
   145                              <1> tc_nINH         equ     4000h   ; not Inhibit Enable
   146                              <1> tc_INT          equ     2000h   ; Interrupt Enable
   147                              <1> tc_RIU          equ     1000h   ; Register A/B (0/1) in Use
   148                              <1> tc_MC           equ     0020h   ; Maximum Count reached
   149                              <1> tc_RTG          equ     0010h   ; Retrigger (internal source)
   150                              <1> tc_P            equ     0008h   ; Prescale internal clock (timers 0 & 1 only)
   151                              <1> tc_EXT          equ     0004h   ; External clock
   152                              <1> tc_ALT          equ     0002h   ; Alternate between A & B max count registers
   153                              <1> tc_CONT         equ     0001h   ; Continuous: continue after max count
   154                              <1> 
   155                              <1> 
   156                              <1> 
   157                              <1> 
   158                              <1> ; DMA
   159                              <1> DMA0	        equ	CPU_CSCR+0C0H
   160                              <1> DMA1	        equ	CPU_CSCR+0D0H
   161                              <1> DMASPL	        equ	0	; source pointer low
   162                              <1> DMASPU	        equ	2	; source pointer high
   163                              <1> DMADPL	        equ	4	; destination pointer low
   164                              <1> DMADPU	        equ	6	; destination pointer high
   165                              <1> DMATC	        equ	8	; terminal count
   166                              <1> DMACW	        equ	0AH	; control word
   167                              <1> 
   168                              <1> 
   169                              <1> 
   170                              <1> 
   171                              <1> 
   172                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   173                              <1> ;
   174                              <1> ;       SBC-188 external devices
   175                              <1> ;
   176                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   177                              <1> 
   178                              <1> IO_BASE			equ	0400h
   179                              <1> 
   180                              <1> 
   181                              <1> 
   182                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   183                              <1> ; The UART registers
   184                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   185                              <1> 
   186                              <1> uart_base               equ     IO_BASE+0280h
   187                              <1> uart_rbr                equ     uart_base       ;Rcvr Buffer / read only
   188                              <1> uart_thr                equ     uart_base       ;Transmit Holding / write only
   189                              <1> uart_ier                equ     uart_base+1     ;Interrupt Enable
   190                              <1> uart_iir                equ     uart_base+2     ;Interrupt Ident / read only
   191                              <1> uart_fcr                equ     uart_base+2     ;FIFO Control / write only
   192                              <1> uart_lcr                equ     uart_base+3     ;Line Control
   193                              <1> uart_mcr                equ     uart_base+4     ;Modem Control
   194                              <1> uart_lsr                equ     uart_base+5     ;Line Status
   195                              <1> uart_msr                equ     uart_base+6     ;Modem Status
   196                              <1> uart_sr			equ	uart_base+7	;Scratch
   197                              <1> 
   198                              <1> uart_dll                equ     uart_base       ;Divisor Latch LS Byte
   199                              <1> uart_dlm                equ     uart_base+1     ;Divisor Latch MS Byte
   200                              <1> 
   201                              <1> 
   202                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   203                              <1> ; Floppy controller
   204                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   205                              <1> FDC	        equ	IO_BASE+0200H
   206                              <1> FDC_MSR         equ     FDC
   207                              <1> FDC_DATA        equ     FDC_MSR+1
   208                              <1> FDC_DACK        equ	FDC+10H
   209                              <1> FDC_LDOR	equ	FDC+20H
   210                              <1> FDC_LDCR	equ	FDC+30H
   211                              <1> FDC_TC	        equ	FDC+40H
   212                              <1> FDC_DACK_TC     equ     FDC_DACK | FDC_TC
   213                              <1> 
   214                              <1> 
   215                              <1> %if SBC188==1
   216                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   217                              <1> ;DS1302 RTC
   218                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   219                              <1> RTC	equ	IO_BASE+0300H
   220                              <1> %endif
   221                              <1> 
   222                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   223                              <1> ; PIO 82C55 I/O 
   224                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   225                              <1> ; for the SBCv1/v2 with PPIDE adapter board
   226                              <1> ; and for the SBCv3 with PPIDE connector
   227                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   228                              <1> PPI	        equ	IO_BASE+0260H
   229                              <1> 
   230                              <1> PIO_A	        equ	PPI+0	; (OUTPUT)
   231                              <1> PIO_B	        equ	PPI+1	; (INPUT)
   232                              <1> PIO_C	        equ	PPI+2	; (CENTRONICS control low nibble)  
   233                              <1> PIO_CTRL	equ	PPI+3	; CONTROL BYTE PIO 82C55
   234                              <1> 
   235                              <1> portA           equ     PPI+0   ;
   236                              <1> portB           equ     PPI+1   ;
   237                              <1> portC           equ     PPI+2   ;
   238                              <1> 
   239                              <1> 
   240                              <1> 
   241                              <1> ;;;%if SBC188==3   startup.asm is universal
   242                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   243                              <1> ; CONTROL LS259 PORT ON SBC188 V3
   244                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   245                              <1> CTRL259		equ	IO_BASE+0270H
   246                              <1> ; LEDS are at addresses 0..3
   247                              <1> ; other control ports on 4..7
   248                              <1> LED0		equ	CTRL259+0
   249                              <1> LED1		equ	LED0+1
   250                              <1> LED2		equ	LED0+2
   251                              <1> LED3		equ	LED0+3
   252                              <1> T1OSC18		equ	CTRL259+4	; ON=1.8432mhz, OFF="1" (for use of TIMER2)
   253                              <1> ;unused		equ	CTRL259+5
   254                              <1> FDC_RES		equ	CTRL259+6	; RESET IS ACTIVE HIGH
   255                              <1> IDE8_RES	equ	CTRL259+7	; fast IDE RESET IS ACTIVE LOW
   256                              <1> 
   257                              <1> 
   258                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   259                              <1> ; FIDE8 8-bit IDE on the 80C188 bus
   260                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   261                              <1> FIDE_BASE       equ     IO_BASE+2C0h
   262                              <1> 
   263                              <1> IDE8_CS0        equ     FIDE_BASE
   264                              <1> IDE8_CS1        equ     FIDE_BASE+0x10
   265                              <1> 
   266                              <1> ;;;%endif   startup.asm is universal
   267                              <1> 
   268                              <1> 
   269                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   270                              <1> ; Dual [DMA] IDE devices
   271                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   272                              <1> DIDE		equ	IO_BASE + 20H	; range 0x20..0x3F
   273                              <1> 
   274                              <1> DIDE0		equ	DIDE		; first interface (master & slave)
   275                              <1> DIDE1		equ	DIDE+10h	; second interface (master & slave)
   276                              <1> 
   277                              <1> 
   278                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   279                              <1> ; DISK I/O v3 device codes (PPIDE only)
   280                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   281                              <1> DISKIO		equ	IO_BASE + 20h	; range 0x20..0x3F
   282                              <1> 
   283                              <1> DISKIO_PPIDE	equ	DISKIO		; 82c55
   284                              <1> DISKIO_FDC	equ	DISKIO + 10h	; FDC 9266
   285                              <1> DISKIO_DOR	equ	DISKIO + 18h	; OPERATION REGISTER	
   286                              <1> 
   287                              <1> 
   288                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   289                              <1> ; MF/PIC interfaces
   290                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   291                              <1> MFPIC		equ	IO_BASE + 40h	; range 0x40..0x4F
   292                              <1> 
   293                              <1> ;MFPIC_202	equ	MFPIC		; NS32202 is not usable on SBC-188
   294                              <1> MFPIC_PPIDE	equ	MFPIC + 4	; PPIDE disk interface
   295                              <1> MFPIC_UART	equ	MFPIC + 8	; TL16Cx50 SIO chip
   296                              <1> 
   297                              <1> 
   298                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   299                              <1> ; Cassette I/O
   300                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   301                              <1> cuart_base	EQU 	IO_BASE+80H	; BASE IO ADDRESS OF CASSETTE UART
   302                              <1> cuart_rbr	equ     cuart_base	;Rcvr Buffer / read only
   303                              <1> cuart_thr	equ     cuart_base	;Transmit Holding / write only
   304                              <1> cuart_ier	equ     cuart_base+1	;Interrupt Enable
   305                              <1> cuart_iir	equ     cuart_base+2	;Interrupt Ident / read only
   306                              <1> cuart_fcr	equ     cuart_base+2	;FIFO Control / write only
   307                              <1> cuart_lcr	equ     cuart_base+3	;Line Control
   308                              <1> cuart_mcr	equ     cuart_base+4	;Modem Control
   309                              <1> cuart_lsr	equ     cuart_base+5	;Line Status
   310                              <1> cuart_msr	equ     cuart_base+6	;Modem Status
   311                              <1> cuart_sr	equ	cuart_base+7	;Scratch
   312                              <1> 
   313                              <1> cuart_dll	equ     cuart_base	;Divisor Latch LS Byte
   314                              <1> cuart_dlm	equ	cuart_base+1	;Divisor Latch MS Byte
   315                              <1> 
   316                              <1> 
   317                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   318                              <1> ;
   319                              <1> ;       4MEM control registers
   320                              <1> ;
   321                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   322                              <1> EMM_addr        equ     1               ; high 6 bits of 20-bit address
   323                              <1> EMM_page        equ     0               ; 4MEM page in [0..254]
   324                              <1> 
   325                              <1> EMM_BASE        equ     IO_BASE + 000h          ; first EMM (4MEM) board
   326                              <1> EMM_unmapped    equ     255             ; unmapped 4MEM page
   327                              <1> 
   328                              <1> EMM0            equ     EMM_BASE        ; first  EMM board
   329                              <1> EMM1            equ     EMM0 + 2        ; second EMM board
   330                              <1> EMM2            equ     EMM1 + 2        ; third  EMM board
   331                              <1> EMM3            equ     EMM2 + 2        ; fourth EMM board
   332                              <1> 
   333                              <1> 
   334                              <1> 
   335                              <1> 
   336                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   337                              <1> ;
   338                              <1> ;	ColorVDU devices
   339                              <1> ;
   340                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   341                              <1> ;
   342                              <1> ;	major select on the Z80 bus
   343                              <1> ;
   344                              <1> devCVDU_8bit	equ	0xE0		; this may change to 0x10
   345                              <1> 
   346                              <1> devCVDUbase 	equ	IO_BASE + devCVDU_8bit
   347                              <1> 
   348                              <1> M8563status	equ	devCVDUbase + 4		; 4 == bitrev(2)
   349                              <1> M8563register	equ	devCVDUbase + 4
   350                              <1> M8563data	equ	devCVDUbase + 12	; 12 == bitrev(3)
   351                              <1> 
   352                              <1> %if CVDU_8563
   353                              <1> I8242status	equ	devCVDUbase + 10	; 10 == bitrev(5)
   354                              <1> I8242command	equ	devCVDUbase + 10
   355                              <1> I8242data	equ	devCVDUbase + 2		; 2 == bitrev(4)
   356                              <1> %endif
   357                              <1> 
   358                              <1> 
   359                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   360                              <1> ;
   361                              <1> ;	VGA3 devices
   362                              <1> ;
   363                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   364                              <1> ;
   365                              <1> ;	major select on the Z80 bus
   366                              <1> ;
   367                              <1> devVGA3_8bit    equ     0xE0                    ; same as CVDU
   368                              <1> 
   369                              <1> devVGA3base       equ     IO_BASE + devVGA3_8bit
   370                              <1> 
   371                              <1> %if VGA3_6445
   372                              <1> I8242status	equ	devVGA3base + 1
   373                              <1> I8242command	equ	devVGA3base + 1
   374                              <1> I8242data	equ	devVGA3base + 0
   375                              <1> %endif
   376                              <1> HD6445addr	equ	devVGA3base + 2		; to address the HD6445 registers
   377                              <1> HD6445reg	equ	devVGA3base + 3		; to r/w a register on the CRTC
   378                              <1> 
   379                              <1> vga3cfg		equ	devVGA3base + 4
   380                              <1> ; the following are probably not used on the SBC-188, except for testing/checking
   381                              <1> vga3adhi	equ	devVGA3base + 5
   382                              <1> vga3adlo	equ	devVGA3base + 6
   383                              <1> vga3data	equ	devVGA3base + 7
   384                              <1> 
   385                              <1> 
   386                              <1> 
   387                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   388                              <1> ;
   389                              <1> ;       2S1P registers
   390                              <1> ;
   391                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   392                              <1> dev_2S1P_loc		equ	0xC0	; same as 4UART !!!
   393                              <1> 
   394                              <1> dev_2S1P_base		equ	IO_BASE + dev_2S1P_loc	
   395                              <1> 
   396                              <1> dev_2S1P_A		equ	dev_2S1P_base		; serial port
   397                              <1> dev_2S1P_B		equ	dev_2S1P_base + 8h	; serial port
   398                              <1> 
   399                              <1> dev_2S1P_C		equ	dev_2S1P_base + 10h	; parallel port
   400                              <1> 
   401                              <1> 
   402                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   403                              <1> ;
   404                              <1> ;       4UART registers
   405                              <1> ;
   406                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   407                              <1> dev_4UART_loc		equ	0xC0	; same as 2S1P !!!
   408                              <1> ;				0xA0	; possible alternate
   409                              <1> dev_4UART_alt_offset	equ	0xA0 - dev_4UART_loc
   410                              <1> 
   411                              <1> dev_4UART_base		equ	IO_BASE + dev_4UART_loc	
   412                              <1> 
   413                              <1> dev_4UART_A		equ	dev_4UART_base
   414                              <1> dev_4UART_B		equ	dev_4UART_base + 8h
   415                              <1> dev_4UART_C		equ	dev_4UART_base + 10h
   416                              <1> dev_4UART_D		equ	dev_4UART_base + 18h
   417                              <1> 
   418                              <1> dev_4UART_config	equ	dev_4UART_B + 7		; overlays scratch register
   419                              <1> 
   420                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   421                              <1> ; debug port -- JRC only
   422                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   423                              <1> portD		equ	IO_BASE + 0FFh		; 0x04FF
   424                              <1> ;portD		equ	portB		     ; older 8255 output on PPI
   425                              <1> 
   426                              <1> ; end CPUREGS.ASM
   427                              <1> 
    40                                  %include	"equates.asm"
    41                              <1> ;========================================================================
    42                              <1> ; EQUATES.ASM -- Lots of Defintions for Relocatable BIOS
    43                              <1> ;========================================================================
    44                              <1> ;   for the N8VEM SBC-188 v.00.4 and 00.5
    45                              <1> ;
    46                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    47                              <1> ;
    48                              <1> ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
    49                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    50                              <1> ;
    51                              <1> ; This program is free software: you can redistribute it and/or modify
    52                              <1> ; it under the terms of the GNU General Public License as published by
    53                              <1> ; the Free Software Foundation, either version 3 of the License, or
    54                              <1> ; (at your option) any later version.
    55                              <1> ;
    56                              <1> ; This program is distributed in the hope that it will be useful,
    57                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    58                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    59                              <1> ; GNU General Public License for more details.
    60                              <1> ;
    61                              <1> ; You should have received a copy of the GNU General Public License
    62                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    63                              <1> ;
    64                              <1> ;========================================================================
    65                              <1> 
    66                              <1>         global  FPEM_segment
    67                              <1> 
    68                              <1> 
    69                              <1> %include "segdef.asm"
    70                              <2> ;========================================================================
    71                              <2> ; SEGDEF.ASM -- Lots of Defintions for Relocatable BIOS
    72                              <2> ;========================================================================
    73                              <2> ;   for the N8VEM SBC-188 v.00.4 and 00.5
    74                              <2> ;
    75                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    76                              <2> ;
    77                              <2> ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
    78                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    79                              <2> ;
    80                              <2> ; This program is free software: you can redistribute it and/or modify
    81                              <2> ; it under the terms of the GNU General Public License as published by
    82                              <2> ; the Free Software Foundation, either version 3 of the License, or
    83                              <2> ; (at your option) any later version.
    84                              <2> ;
    85                              <2> ; This program is distributed in the hope that it will be useful,
    86                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    87                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    88                              <2> ; GNU General Public License for more details.
    89                              <2> ;
    90                              <2> ; You should have received a copy of the GNU General Public License
    91                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    92                              <2> ;
    93                              <2> ;========================================================================
    94                              <2> 
    95                              <2> %ifndef __SEGDEF_
    96                              <2> %define __SEGDEF_
    97                              <2> 
    98                              <2> 	SEGMENT  _TEXT ALIGN=2 PUBLIC CLASS=CODE
    99                              <2>         SEGMENT  CONST ALIGN=2 PUBLIC CLASS=DATA
   100                              <2>         SEGMENT  CONST2 ALIGN=2 PUBLIC CLASS=DATA
   101                              <2> 	SEGMENT  _DATA ALIGN=16 PUBLIC CLASS=DATA
   102                              <2> 	SEGMENT  _BSS  ALIGN=2 PUBLIC CLASS=BSS
   103                              <2> ;;;        SEGMENT  _BASIC ALIGN=16 PUBLIC CLASS=BASIC
   104                              <2> 
   105                              <2> 	GROUP	DGROUP CONST CONST2 _DATA _BSS
   106                              <2> 
   107                              <2> %endif
   108                              <2> 
    70                              <1> %include "ascii.asm"
    71                              <2> ; ascii.asm
    72                              <2> ;
    73                              <2> CTRL            equ     1Fh     ; masks a character to CTRL-x
    74                              <2> 
    75                              <2> NUL     equ     00h
    76                              <2> BEL     equ     (CTRL & 'G')
    77                              <2> BS      equ     08h		; ^H
    78                              <2> HT      equ     09h		; ^I
    79                              <2> LF	equ	0Ah		; ^J
    80                              <2> NL      equ     LF
    81                              <2> VT	equ	0Bh		; ^K
    82                              <2> FWD	equ	0Ch		; ^L
    83                              <2> CR	equ	0Dh
    84                              <2> XON     equ     (CTRL & 'Q')
    85                              <2> XOFF    equ     (CTRL & 'S')
    86                              <2> DC1     equ     XON
    87                              <2> DC3     equ     XOFF
    88                              <2> ESC     equ	1Bh
    89                              <2> 
    90                              <2> 
    71                              <1> 
    72                              <1> 
    73                              <1> ; POST error codes. Presently one byte but can expand to word.
    74                              <1> ER_BIOS equ	01h		; Bad ROM bios checksum, patch last byte
    75                              <1> ER_RAM	equ	02h		; Bad RAM in main memory, replace
    76                              <1> ER_CRT	equ	04h		; Bad RAM in video card, replace
    77                              <1> ER_FDC	equ	08h		; Bad FDC
    78                              <1> ER_UNK1	equ	10h		; {unassigned}
    79                              <1> ER_MEM	equ	20h		; Bad RAM in vector area, replace
    80                              <1> ER_ROM	equ	40h		; Bad ROM in expansion area, bad checksum
    81                              <1> ER_UNK2	equ	80h		; {unassigned}
    82                              <1> 
    83                              <1> 
    84                              <1> 
    85                              <1> ;; ************************ BIOS Data Segment ******************************
    86                              <1> ;; BIOS data segment - not all will  be used
    87                              <1> ;                struc   BIOS_DATA_AREA  ; at 0040:0000
    88                              <1> %include "bda.inc"
    89                              <2> ;/*======================================================================
    90                              <2> ; bda.inc -- BIOS data area definitions
    91                              <2> ;========================================================================
    92                              <2> ;   for the N8VEM SBC-188
    93                              <2> ;
    94                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    95                              <2> ;
    96                              <2> ; Copyright (C) 2013 John R. Coffman.  All rights reserved.
    97                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    98                              <2> ;
    99                              <2> ; This program is free software: you can redistribute it and/or modify
   100                              <2> ; it under the terms of the GNU General Public License as published by
   101                              <2> ; the Free Software Foundation, either version 3 of the License, or
   102                              <2> ; (at your option) any later version.
   103                              <2> ;
   104                              <2> ; This program is distributed in the hope that it will be useful,
   105                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   106                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   107                              <2> ; GNU General Public License for more details.
   108                              <2> ;
   109                              <2> ; You should have received a copy of the GNU General Public License
   110                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   111                              <2> ;
   112                              <2> ;========================================================================
   113                              <2> 
   114                              <2> 			;*/ extern				/*
   115                              <2> 	ABSOLUTE  0	;*/ struct BDA {			/*
   116 00000000 ????????????????    <2> serial_ports    resw    4	;*/	word	serial_ports[4];	/*
   117 00000008 ????????????????    <2> parallel_ports  resw    4	;*/	word	parallel_ports[4];	/*
   118 00000010 ????                <2> equipment_flag  resw    1	;*/	EQFL	equipment_flag;		/*
   119                              <2> ;	dw	?		; 40:10 	; Equipment present word
   120                              <2> ;  						;  = (1 iff floppies) *     1.
   121                              <2> ;                                               ;  + (1 iff 187     ) *     2.
   122                              <2> ;  						;  + (#+1 64K sys ram) *    4.
   123                              <2> ;  						;  + (init crt mode ) *    16.
   124                              <2> ;  						;  + (# of floppies ) *    64.
   125                              <2> ;  						;  + (# serial ports) *   512.
   126                              <2> ;  						;  + (1 iff toy port) *  4096.
   127                              <2> ;                                               ;  + (1 iff modem   ) *  8192.
   128                              <2> ;  						;  + (# parallel LPT) * 16384.
   129 00000012 ??                  <2> mfg_test_flags  resb    1	;*/	byte	mfg_test_flags;	/* 40:12 unused by us
   130 00000013 ????                <2> memory_size     resw    1	;*/	word	memory_size;	/* 40:13 kilobytes
   131                              <2> uart_kbd_ctrl_R	equ	$	;*/				/*** JRC: count of ctrl-R's for reboot
   132 00000015 ??                  <2> IPL_errors      resb    1	;*/	byte	IPL_errors;	/* 40:15 IPL errors<-table/scratchpad
   133 00000016 ??                  <2> sbc188_rev       resb    1	;*/	byte	sbc188_rev;	/* was 'unused_01' before BIOS047
   134                              <2> ;;---------------[Keyboard data area]------------;
   135 00000017 ????                <2> keyboard_flags_0 resw   1	;*/	word	keyboard_flags_0;  /* 40:17 Shift/Alt/etc. keyboard flags
   136                              <2> keyboard_flags_1 equ	$-1	;     2nd byte	keyboard_flags_1;  
   137 00000019 ??                  <2> keypad_char	resb	1	;*/	byte	keypad_char;	/* 40:19 Alt-KEYPAD char. goes here
   138 0000001A ????                <2> kbd_buffer_head resw    1	;*/	word	kbd_buffer_head;   /* 40:1A --> keyboard buffer head
   139 0000001C ????                <2> kbd_buffer_tail resw    1	;*/	word	kbd_buffer_tail;   /* 40:1C --> keyboard buffer tail
   140 0000001E <res 20h>           <2> kbd_buffer      resw    16	;*/	word	kbd_buffer[16];	/* 40:1E Keyboard Buffer (Scan,Value)
   141                              <2> kbd_buffer_last	equ	$	;*/				/*
   142                              <2> ;;---------------[Diskette data area]------------;
   143 0000003E ??                  <2> fdc_drv_calib   resb    1	;*/	byte	fdc_drive_calib;   /* 40:3E
   144 0000003F ??                  <2> fdc_motor_LDOR  resb    1	;*/	byte	fdc_motor_LDOR;	   /* 40:3F Motor, DMA, select control
   145 00000040 ??                  <2> fdc_motor_ticks resb    1	;*/	byte	fdc_motor_ticks;   /* 40:40 ticks til motor off
   146 00000041 ??                  <2> fdc_status      resb    1	;*/	byte	fdc_status;	   /* 40:41
   147                              <2> ;				Floppy return code stat byte
   148                              <2> ;				;  1 = bad ic 765 command req.
   149                              <2> ;				;  2 = address mark not found
   150                              <2> ;				;  3 = write to protected disk
   151                              <2> ;				;  4 = sector not found
   152                              <2> ;				;  8 = data late (DMA overrun)
   153                              <2> ;				;  9 = DMA failed 64K page end
   154                              <2> ;				; 16 = bad CRC on floppy read
   155                              <2> ;				; 32 = bad NEC 765 controller
   156                              <2> ;				; 64 = seek operation failed
   157                              <2> ;				;128 = disk drive timed out
   158 00000042 ??????????????      <2> fdc_ctrl_status resb    7	;*/	byte	fdc_ctrl_status[7];  /* 40:42 Status bytes from NEC 765
   159                              <2> ;;---------------[Video display area]------------;
   160 00000049 ??                  <2> video_mode      resb    1	;*/	byte	video_mode;	/* 40:49
   161                              <2> ;			 	; Current CRT mode  (software)
   162                              <2> ;				;  0 = 40 x 25 text (no color)
   163                              <2> ;				;  1 = 40 x 25 text (16 color)
   164                              <2> ;				;  2 = 80 x 25 text (no color)
   165                              <2> ;				;  3 = 80 x 25 text (16 color)
   166                              <2> ;				;  4 = 320 x 200 grafix 4 color
   167                              <2> ;				;  5 = 320 x 200 grafix 0 color
   168                              <2> ;				;  6 = 640 x 200 grafix 0 color
   169                              <2> ;				;  7 = 80 x 25 text (mono card)
   170 0000004A ????                <2> video_columns   resw    1	;*/	word video_columns;	/* 40:4A Columns on CRT screen
   171 0000004C ????                <2> video_regen_bytes  resw 1	;*/	word video_regen_bytes;	/* 40:4C Bytes in the regen region
   172 0000004E ????                <2> video_regen_offset resw 1	;*/	word video_regen_offset;/* 40:4E Byte offset in regen region
   173 00000050 <res 10h>           <2> video_cursor_pos  resw  8	;*/	word video_cursor_pos[8];  /* 40:50 Cursor pos for up to 8 pages
   174 00000060 ????                <2> video_cursor_mode resw  1	;*/	word video_cursor_mode;	/* 40:60 Current cursor mode setting
   175 00000062 ??                  <2> video_page      resb    1	;*/	byte video_page;	/* 40:62 Current page on display
   176 00000063 ????                <2> video_base_seg  resw    1	;*/	word video_base_seg;	/* 40:63 Base address (B000h or B800h)
   177 00000065 ??                  <2> video_hw_mode   resb    1	;*/	byte video_hw_mode;	/* 40:65 ic 6845 mode reg. (hardware)
   178 00000066 ??                  <2> video_cga_palette resb  1	;*/	byte video_cga_palette;	/* 40:66 Current CGA palette
   179                              <2> ;;---------------[Used to setup ROM]-------------;
   180 00000067 ????????            <2> eprom_address   resd    1	;*/	dword eprom_address;	/* 40:67 Eprom base Offset,Segment
   181 0000006B ??                  <2> spurious_irq    resb    1	;*/	byte spurious_irq;	/* 40:6B Last spurious interrupt IRQ
   182                              <2> ;;---------------[Timer data area]---------------;
   183 0000006C ????????            <2> timer_ticks     resd    1	;*/	dword timer_ticks;	/* 40:6C Ticks since midnight (lo,hi)
   184 00000070 ??                  <2> timer_new_day   resb    1	;*/	byte timer_new_day;	/* 40:70 Non-zero if new day
   185                              <2> ;;---------------[System data area]--------------;
   186 00000071 ??                  <2> break_flag      resb    1	;*/	byte break_flag;	/* 40:71 Sign bit set iff break
   187 00000072 ????                <2> warm_boot       resw    1	;*/	word warm_boot;		/* 40:72 Warm boot iff==1234h
   188                              <2> ;;---------------[Hard disk scratchpad]----------;
   189 00000074 ????????            <2> hdd_scratch     resd    1	;*/	word hdd_scratch[2];	/* 40:74
   190                              <2> ;;---------------[Timout areas/PRT/LPT]----------;
   191 00000078 ????????            <2> lpt_timeout     resb    4	;*/	byte lpt_timeout[4];	/* 40:78 Ticks for LPT 1-4 timeouts
   192 0000007C ????????            <2> com_timeout     resb    4	;*/	byte com_timeout[4];	/* 40:7C Ticks for COM 1-4 timeouts
   193                              <2> ;;---obsolete----[Keyboard buf start/end]---jrc--;
   194 00000080 ????                <2> kbd_buffer_start resw   1	;*/	word kbd_buffer_start;	/* 40:80 KBD buffer head (PC/AT)
   195 00000082 ????                <2> kbd_buffer_end  resw    1	;*/	word kbd_buffer_end;	/* 40:82 KBD buffer tail (PC/AT)
   196                              <2> ;;---------------[EGA stuff]---------------------;
   197 00000084 ??????????????      <2> EGA_stuff	resb	7	;*/	byte EGA_stuff[7];	/* 40:84 Unspecified EGA data
   198                              <2> ;;---------------[Floppy/Fixed Media Info]-------------;
   199 0000008B ??                  <2> fdc_last_rate	resb	1	;*/	byte fdc_last_rate;	/* 40:8B Last floppy step rate/data rate?
   200 0000008C ????????            <2> fx_misc_unused	resb	4	;*/	byte fx_misc_unused[4];	/* 40:8C Fixed disk miscellaneous ???
   201 00000090 ????                <2> fdc_disk_state	resb	2	;*/	byte fdc_disk_state[2];	/* 40:90 Floppy disk state
   202 00000092 ????                <2> fdc_op_start	resb	2	;*/	byte fdc_op_start[2];	/* 40:92 Floppy operation start state machine
   203 00000094 ????                <2> fdc_cylinder	resb	2	;*/	byte fdc_cylinder[2];	/* 40:94 Floppy present cylinder
   204                              <2> ;;---------------[Additional KBD flags]----------------;
   205 00000096 ??                  <2> kbd_flag_3	resb	1	;*/	byte kbd_flag_3;	/* 40:96 kbd ???
   206 00000097 ??                  <2> kbd_flag_2	resb	1	;*/	byte kbd_flag_2;	/* 40:97 kbd ???
   207                              <2> ;;---------------[RTC/timer1 data]---------------------;
   208 00000098 ????????            <2> user_semaphore	resw	2	;*/	byte *user_semaphore;	/* 40:98 User semaphore in (bit 7)
   209 0000009C ????????            <2> rtc_count	resd	1	;*/	dword rtc_count;	/* 40:9C RTC tick counter
   210 000000A0 ??                  <2> rtc_wait_active	resb	1	;*/	byte rtc_wait_active;	/* 40:A0 Busy=01, Posted=80h, 
   211                              <2> ;;---------------[Cassette I/O stuff]------------------;
   212 000000A1 ??                  <2> last_val	resb	1	;*/	byte last_val;		/* 40:A1 Last byte read value
   213 000000A2 ????                <2> crc_reg		resw	1	;*/	word crc_reg;		/* 40:A2 CRC accumulation area
   214                              <2> ;									Post Acknowleged=00;
   215 000000A4 ??                  <2> EGA_data	resb	1	;*/	byte EGA_data;		/* 40:A4 Various usage
   216 000000A5 ????                <2> SDstatus	resb	2	;*/	byte SDstatus[2];	/* 40:A5 Status byte from command
   217 000000A7 ????                <2> SDcardtype	resb	2	;*/	byte SDcardtype[2];	/* 40:A7 SDcard type SDSC=2, HC=3, ...
   218                              <2> ;
   219 000000A9 ????????            <2> fixed_disk_tab	resb	4	;*/	byte fixed_disk_tab[4];	/* dispatch table to fixed disk drivers
   220 000000AD ??                  <2> wait12_count	resb	1	;*/	byte wait12_count;	/* 40:AD 12usec CX count
   221 000000AE ??                  <2> lock_count	resb	1	;*/	byte lock_count;	/* 40:AE lock level counter
   222 000000AF ??                  <2> EMS_start       resb    1	;*/	byte EMS_start;		/* start EMS allocation from here
   223                              <2> fx80		equ	$	;*/	struct EDD_disk fx80;	/* fixed disk parameter area 0
   224 000000B0 ????                <2> fx_log_cylinders resw   1	;	word fx_log_cylinders;	 logical number of cylinders
   225 000000B2 ??                  <2> fx_log_heads    resb    1	;	byte fx_log_heads;	 logical number of heads
   226 000000B3 ??                  <2> fx_signature	resb	1	;	byte fx_signature;	 A0h signature = translated geom
   227 000000B4 ??                  <2> fx_phys_sectors	resb    1       ;	byte fx_phys_sectors;	 physical number of sectors per track
   228 000000B5 ????                <2> fx_LBA_high     resw    1       ;	word fx_LBA_high;	 high word of LBA28 number of sectors
   229 000000B7 ??                  <2> fx_reserved	resb	1	;	byte fx_reserved;	 reserved for future use
   230 000000B8 ??                  <2> fx_drive_control resb   1       ;	byte fx_drive_control;	 flag bits for IDE head register
   231 000000B9 ????                <2> fx_phys_cylinders resw	1	;	word fx_phys_cylinders;	 physical number of cylinders
   232 000000BB ??                  <2> fx_phys_heads	resb	1	;	byte fx_phys_heads;	 physical number of heads
   233 000000BC ????                <2> fx_LBA_low	resw	1	;	word fx_LBA_low;	 low word of LBA28 number of sectors
   234 000000BE ??                  <2> fx_log_sectors	resb	1	;	byte fx_log_sectors;	 logical number of sectors per track
   235 000000BF ??                  <2> fx_checksum	resb	1	;	byte fx_checksum;	 checksum, dunno how to compute
   236 000000C0 <res 10h>           <2> fx81            resb    16	;*/	struct EDD_disk fx81;	/* fixed disk parameter area 1
   237 000000D0 <res 10h>           <2> fx82            resb    16	;*/	struct EDD_disk fx82;	/* fixed disk parameter area 2
   238 000000E0 <res 10h>           <2> fx83            resb    16	;*/	struct EDD_disk fx83;	/* fixed disk parameter area 3
   239                              <2> ;
   240                              <2> ;
   241                              <2> 
   242 000000F0 ????                <2> FPEM_segment    resw    1       ;*/	word FPEM_segment;	/* FPEM data segment
   243                              <2> 
   244 000000F2 ????                <2> EBDA_paragraph  resw    1       ;*/	word EBDA_paragraph;	/* lowest EBDA paragraph
   245                              <2> 
   246 000000F4 ????                <2> dma0_cw         resw    1       ;*/	word dma0_cw;		/* end of dma control word
   247 000000F6 ????                <2> dma1_cw         resw    1       ;*/	word dma1_cw;		/*   ditto
   248                              <2> 
   249 000000F8 ????                <2> fdc_type	resb	2	;*/	byte fdc_type[2];	/* disk type in low nibble, alternate in hi nib 
   250                              <2> 
   251 000000FA ????????            <2> debug_static_ptr  resw	2	;*/	void *debug_static_ptr;	/* pointer to debug static area
   252                              <2> 
   253 000000FE ??                  <2> n_fixed_disks   resb    1       ;*/	byte n_fixed_disks;	/* number of fixed disks
   254                              <2> 
   255 000000FF ??                  <2> cpu_xtal        resb    1       ;*/	byte cpu_xtal;		/* CPU crystal frequency in Mhz 
   256                              <2> ;								   CPU clock is half of this
   257                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   258                              <2> ;
   259                              <2> ;  System configuration stuff below
   260                              <2> ;	c.f., CONFIG.ASM (ANSI.CFG, CVDU.CFG, etc.), User configuration stuff
   261                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   262                              <2> %if 0				;*/
   263                              <2> #define FIXED_DISK_MAX 4		/*
   264                              <2> %else
   265                              <2> %define FIXED_DISK_MAX 4
   266                              <2> %endif
   267                              <2> %if 0				;*/
   268                              <2> #define PPIDE_driver 1		/*
   269                              <2> %else
   270                              <2> %define PPIDE_driver 1
   271                              <2> %endif
   272                              <2> %if 0				;*/
   273                              <2> #define DIDE_driver 0		/*
   274                              <2> %else
   275                              <2> %define DIDE_driver 0
   276                              <2> %endif
   277                              <2> %if 0				;*/
   278                              <2> #define DISKIO_driver 1		/*
   279                              <2> %else
   280                              <2> %define DISKIO_driver 1
   281                              <2> %endif
   282                              <2> %if 0				;*/
   283                              <2> #define MFPIC_driver 1		/*
   284                              <2> %else
   285                              <2> %define MFPIC_driver 1
   286                              <2> %endif
   287                              <2> %if 0				;*/
   288                              <2> #define DSD_driver 1		/*
   289                              <2> %else
   290                              <2> %define DSD_driver 1
   291                              <2> %endif
   292                              <2> %if 0				;*/
   293                              <2> #define V3IDE8_driver (SBC188==3)		/*
   294                              <2> %else
   295                              <2> %define V3IDE8_driver (SBC188==3)
   296                              <2> %endif
   297                              <2> 				;*/
    89                              <1> 
    90                              <1> ;  this must be the same in EQUATES.H */
    91                              <1> %if SOFT_DEBUG
    92                              <1> %define NBREAK  8
    93                              <1> %endif
    94                              <1> 
    95                              <1> 
    96                              <1> %if 0
    97                              <1>         segment _TEXT
    98                              <1> ;; *************************************************************************
    99                              <1> 
   100                              <1> 
   101                              <1> 
   102                              <1> 
   103                              <1> ;; ************************ DOS Data Segment *******************************
   104                              <1> ;dosdir	SEGMENT at 50h				; Boot disk directory from IPL
   105                              <1> ;xerox	label	byte				;  0 if Print Screen idle
   106                              <1> ;						;  1 if PrtSc xeroxing screen
   107                              <1> ;						;255 if PrtSc error in xerox
   108                              <1> ;						;  ...non-grafix PrtSc in bios
   109                              <1> ;	db	200h dup(?)			; PC-DOS bootstrap procedure
   110                              <1> ;						;  ...IBMBIO.COM buffers the
   111                              <1> ;						;  ...directory of the boot
   112                              <1> ;						;  ...device here at IPL time
   113                              <1> ;						;  ...when locating the guts
   114                              <1> ;						;  ...of the operating system
   115                              <1> ;						;  ...filename "IBMDOS.COM"
   116                              <1> ;dosdir	ends
   117                              <1> ;; *************************************************************************
   118                              <1> ;; ************************ DOS IPL Segment ********************************
   119                              <1> ;dosseg	SEGMENT at 70h				; "Kernel" of PC-DOS op sys
   120                              <1> ;;IBMBIO.COM file loaded by boot block. Device Drivers/Bootstrap. CONTIGUOUS<---
   121                              <1> ;;IBMDOS.COM operating system nucleus immediately follows IBMBIO.COM and       !
   122                              <1> ;;     doesn`t have to be contiguous.  The IBMDOS operating system nucleus     !
   123                              <1> ;;     binary image is loaded by transient code in IBMBIO binary image	      !
   124                              <1> ;dosseg	ends					;			      !
   125                              <1> ;iplseg	SEGMENT at 0h				; Segment for boot block      !
   126                              <1> ;;The following boot block is loaded with 512 bytes on the first sector of     !
   127                              <1> ;;the bootable device by code resident in the ROM-resident bios.  Control is   !
   128                              <1> ;;then transferred to the first word 0000:7C00 of the disk-resident bootstrap  !
   129                              <1> ;	ORG	07C00h				;  ..offset for boot block    !
   130                              <1> ;boot	db	200h dup(?)			;  ..start disk resident boot--
   131                              <1> ;iplseg	ends
   132                              <1> 
   133                              <1> %endif
    41                                  
    42                                  offset_BP	equ	0
    43                                  offset_BX	equ	offset_BP+2
    44                                  offset_DS	equ	offset_BX+2
    45                                  offset_IP	equ	offset_DS+2
    46                                  offset_CS	equ	offset_IP+2
    47                                  offset_FLAGS	equ	offset_CS+2
    48                                  
    49                                  
    50                                  	SEGMENT	_TEXT
    51                                  ;========================================================================
    52                                  ; BIOS call entry for keyboard service
    53                                  ;	int  16h
    54                                  ;========================================================================
    55                                  	global  BIOS_call_16h
    56                                  BIOS_call_16h:			; Keyboard service entry
    57 00000000 FB                      	sti			; Enable interrupts
    58 00000001 1E5355                  	pushm   bp,bx,ds	; Standard register save
    59 00000004 89E5                    	mov	bp,sp		; establish stack addressing
    60                                  
    61 00000006 6A40                    	push	bios_data_seg
    62 00000008 1F                      	popm	ds		; establish addressability
    63                                  
    64 00000009 88E3                    	mov     bl,ah		; set to index into dispatch table
    65 0000000B B700                    	mov	bh,0
    66                                  
    67 0000000D 80FB06                  	cmp     bl,.max/2
    68 00000010 7307                    	jae    	.testEnh
    69 00000012 01DB                    	add	bx,bx		; index words
    70 00000014 2EFFA7[2800]                cs	jmp     near [.dispatch+bx]
    71                                  
    72                                  .testEnh:
    73 00000019 80EB10                  	sub	bl,10h
    74 0000001C 80FB03                  	cmp	bl,.max10/2
    75 0000001F 7319                    	jae	err_exit
    76 00000021 01DB                    	add	bx,bx		; index words
    77 00000023 2EFFA7[3400]                cs	jmp	near [.dispatch10+bx]
    78                                  	
    79                                  .dispatch:
    80 00000028 [4300]                  	dw      fn00		; Read char from buffer, wait if empty
    81 0000002A [5F00]                  	dw      fn01		; Check buffer, do not clear
    82 0000002C [7700]                  	dw      fn02		; Return Keyboard flags in AL
    83 0000002E [3A00]                  	dw	err_exit	; Set Repeat Rate
    84 00000030 [3A00]                  	dw	err_exit	; Set Keyclick
    85 00000032 [8100]                  	dw	fn05		; Push Char and Scan Code in CX
    86                                  .max	equ     $-.dispatch
    87                                  
    88                                  .dispatch10:
    89 00000034 [4300]                  	dw	fn10		; Read Enhanced Keyboard
    90 00000036 [5F00]                  	dw	fn11		; Check Enh. kbd buffer
    91 00000038 [7C00]                  	dw	fn12		; Get Enh. kbd flags in AX
    92                                  .max10	equ	$-.dispatch10
    93                                  
    94                                  err_exit:
    95 0000003A 834E0A41                	or	word [offset_FLAGS+bp],41h	; set the Carry & Zero flags
    96                                  exit:
    97 0000003E 5D5B1F                  	popm	bp,bx,ds
    98 00000041 CF                      	iret
    99                                  
   100                                  ;========================================================================
   101                                  ; Function 00h - Read char from buffer, wait if empty
   102                                  ; Input:
   103                                  ;	AH = 00h	PC
   104                                  ;	AH = 10h	enhanced
   105                                  ; Output:
   106                                  ;	AH = scan code
   107                                  ;	AL = character
   108                                  ;========================================================================
   109                                  fn00w:
   110                                  %if SOFT_DEBUG
   111                                  	jmp	fn001
   112                                  %else
   113 00000042 F4                              hlt                     ; wait for interrupt
   114                                  %endif
   115                                  ;;;	jmp	fn001
   116                                  
   117                                  fn00:
   118                                  fn10:
   119                                  
   120                                  fn001:
   121 00000043 8B1E1A00                	mov	bx,word [kbd_buffer_head]
   122 00000047 3B1E1C00                	cmp	bx,word [kbd_buffer_tail]
   123 0000004B 74F5                    	jz	fn00w		; buffer is empty - let's wait
   124 0000004D 8B07                    	mov	ax,word [bx]
   125                                  
   126 0000004F 43                      	inc	bx		; move kbd_buffer_head to the next location
   127 00000050 43                      	inc	bx
   128 00000051 83FB3E                  	cmp	bx,kbd_buffer_last
   129 00000054 7503                    	jne	.1
   130 00000056 BB1E00                  	mov	bx,kbd_buffer
   131                                  .1:
   132 00000059 891E1A00                	mov	word [kbd_buffer_head],bx
   133 0000005D EBDF                    	jmp	exit
   134                                  
   135                                  ;========================================================================
   136                                  ; Function 01h - Check buffer, do not clear
   137                                  ; Function 11h - Check Enhanced Keyboard buffer
   138                                  ; Input:
   139                                  ;	AH = 01h	PC
   140                                  ;	AH = 11h	enhanced
   141                                  ; Output:
   142                                  ;	ZF - clear if character in buffer
   143                                  ;		AH = scan code
   144                                  ;		AL = character
   145                                  ;	ZF - set if no character in buffer
   146                                  ;========================================================================
   147                                  fn01:
   148                                  fn11:
   149 0000005F 8B1E1A00                	mov	bx,word [kbd_buffer_head]
   150 00000063 3B1E1C00                	cmp	bx,word [kbd_buffer_tail]
   151 00000067 7408                    	jz	.1
   152 00000069 8B07                    	mov	ax,word [bx]
   153 0000006B 83660ABF                	and	word [bp+offset_FLAGS],~40h	; clear ZF in the stack
   154 0000006F EBCD                    	jmp	exit
   155                                  .1:
   156 00000071 834E0A40                	or	word [bp+offset_FLAGS],40h	; set ZF in the stack
   157 00000075 EBC7                    	jmp	exit
   158                                  
   159                                  ;========================================================================
   160                                  ; Function 02h - Return Keyboard Shift Key Status
   161                                  ; Function 12h - Return Enhanced Keyboard Shift/Alt/Ctrl/NumLock Status
   162                                  ; Input:
   163                                  ;	AH = 02h	PC-keyboard
   164                                  ;	AH = 12h	enhanced
   165                                  ; Output:
   166                                  ;	AL = shift status bits
   167                                  ;		0 = right shift key depressed
   168                                  ;		1 = left shift key depressed
   169                                  ;		2 = CTRL depressed
   170                                  ;		3 = ALT depressed
   171                                  ;		4 = SCROLL LOCK active
   172                                  ;		5 = NUM LOCK active
   173                                  ;		6 = CAPS LOCK active
   174                                  ;		7 = INSERT state active
   175                                  ;
   176                                  ;  and for Function 12h:
   177                                  ;	AX = enhanced keyboard status, above plus:
   178                                  ;		8 = left CTRL key down
   179                                  ;		9 = left ALT key down
   180                                  ;		10 = right CTRL key down
   181                                  ;		11 = right ALT key down
   182                                  ;		12 = SCROLL key is down
   183                                  ;		13 = NUM LOCK key is down
   184                                  ;		14 = CAPS LOCK key is down
   185                                  ;		15 = SYSREQ key is down
   186                                  ;
   187                                  ;========================================================================
   188                                  fn02:
   189 00000077 A01700                  	mov	al,byte [keyboard_flags_0]
   190 0000007A EBC2                    	jmp	exit
   191                                  fn12:
   192 0000007C A11700                  	mov	ax,word [keyboard_flags_0]
   193 0000007F EBBD                    	jmp	exit
   194                                  
   195                                  ;========================================================================
   196                                  ; Function 05h - Check buffer, do not clear
   197                                  ; Input:
   198                                  ;	AH = 05h
   199                                  ;	CH = scan code
   200                                  ;	CL = character
   201                                  ; Output:
   202                                  ;	CF - clear if successful
   203                                  ;	AL = 00h
   204                                  ;
   205                                  ;	CF - set if buffer full
   206                                  ;	AL = 01h
   207                                  ;========================================================================
   208                                  fn05:
   209 00000081 89C8                    	mov	ax,cx		; AX is argument to enqueue
   210 00000083 E81000                  	call	enqueue		; DS is bios_data_seg
   211 00000086 7205                    	jc	.2
   212 00000088 B80105                  	mov	ax,0501h
   213 0000008B EBAD                    	jmp	err_exit
   214                                  
   215 0000008D B80005                  .2:	mov	ax,0500h
   216 00000090 83660AFE                	and	word [offset_FLAGS+bp],~01h	; clear the carry
   217 00000094 EBA8                    	jmp	exit
   218                                  
   219                                  
   220                                  
   221                                  ;========================================================================
   222                                  ; enqueue - add a word in AX to the keyboard buffer
   223                                  ;
   224                                  ;  Input:
   225                                  ;	DS = bios data area pointer
   226                                  ;	AH = scan code
   227                                  ;	AL = character
   228                                  ;  Uses:
   229                                  ;	BX
   230                                  ;
   231                                  ;  Output:
   232                                  ;	the word is enqueued or discarded if buffer is full
   233                                  ;========================================================================
   234                                  enqueue:
   235                                  ; do we have space in the buffer?
   236 00000096 8B1E1C00                	mov	bx,word [kbd_buffer_tail]
   237 0000009A 43                      	inc	bx
   238 0000009B 43                      	inc	bx
   239 0000009C 83FB3E                  	cmp	bx,kbd_buffer_last
   240 0000009F 7503                    	jne	.3
   241 000000A1 BB1E00                  	mov	bx,kbd_buffer
   242                                  .3:
   243 000000A4 3B1E1A00                	cmp	bx,word [kbd_buffer_head]
   244 000000A8 7502                    	jne	.4
   245                                  			; no space in buffer, throw away char
   246                                  			; but check for the next one anyway
   247 000000AA F9                      	stc
   248 000000AB C3                      	ret		; Return with carry Set if no space
   249                                  
   250                                  .4:	; we have some space in the buffer
   251 000000AC 8B1E1C00                	mov	bx,word [kbd_buffer_tail]
   252 000000B0 8907                    	mov	word [bx],ax	; store ASCII and scan code to the buffer
   253 000000B2 43                      	inc	bx
   254 000000B3 43                      	inc	bx
   255 000000B4 83FB3E                  	cmp	bx,kbd_buffer_last
   256 000000B7 7503                    	jne	.5
   257 000000B9 BB1E00                  	mov	bx,kbd_buffer
   258                                  .5:
   259 000000BC 891E1C00                	mov	word [kbd_buffer_tail],bx
   260 000000C0 F8                      	clc		; Return with carry clear if A-okay
   261                                  ;;;.1:
   262 000000C1 C3                      	ret
   263                                  
   264                                  %if CVDU_8242
   265                                  ;========================================================================
   266                                  ; cvdu_kbd_int - Color VDU keyboard interrupt	MSDOS messes with this
   267                                  ; cvdu_kbd_hook - examine keyboard on every timer tick
   268                                  ;
   269                                  ;========================================================================
   270                                  %if CVDU_USE_KBD_HOOK
   271                                  	global	cvdu_kbd_hook
   272                                  cvdu_kbd_hook:
   273                                  	call	I8242GetValue_
   274                                  	jnc	.2
   275                                  	ret
   276                                  .2:
   277                                  	pushm	all,ds,es	; save EVERYTHING
   278                                  .1:
   279                                  %else
   280                                  	global	cvdu_kbd_int
   281                                  cvdu_kbd_int:
   282                                  	pushm	all,ds,es	; save EVERYTHING
   283                                  .1:	call	I8242GetValue_
   284                                  ;;	cmp	ax,-1
   285                                  ;;	je	.exit
   286                                  	jc	.exit		; new return in flag
   287                                  
   288                                  %endif
   289                                  %if 1
   290                                  	mov	AH,4Fh		; keyboard intercept
   291                                  	stc			; so we can respond with IRET
   292                                  	int	15h
   293                                  	jnc	.20		; scancode to be bypassed
   294                                  %endif
   295                                  
   296                                  	push	DGROUP
   297                                  	popm	ds		; establish addressability
   298                                  	extern	@I8242process
   299                                  	call	@I8242process	; convert to scan code // character
   300                                  
   301                                  	push	bios_data_seg
   302                                  	popm	ds
   303                                  
   304                                  	or	ax,ax		; test for zero (unknown input)
   305                                  	jnz	.21
   306                                  
   307                                  .20:
   308                                  	call	I8242GetValue_
   309                                  	jc	.exit
   310                                  	jmp	.1
   311                                  .21:
   312                                  	cmp	al,0E0h		; enhanced keyboard?
   313                                  	jne	.3
   314                                  	xor	al,al		; old PC keyboard
   315                                  .3:
   316                                  	cmp	ax,1234h	; Ctrl-Alt-DEL
   317                                  	jne	.33
   318                                  %if 1
   319                                  	int	19h		; re-boot the system
   320                                  %else
   321                                  	mov	[warm_boot],ax	; set Warm Boot condition
   322                                  	jmp	0FFFFh:0000	; re-boot
   323                                  %endif
   324                                  
   325                                  .33:
   326                                  	call	enqueue
   327                                  	mov	byte [uart_kbd_ctrl_R], 0
   328                                  	
   329                                  .exit:
   330                                  
   331                                  %if CVDU_USE_KBD_HOOK
   332                                  ;   Hook service
   333                                  	popm	all,ds,es
   334                                  	ret
   335                                  %else
   336                                  ;   Interrupt service
   337                                  ; signal EOI (End of Interrupt)
   338                                  	mov	dx,PIC_EOI	; EOI register
   339                                  	mov	ax,EOI_NSPEC	; non-specific
   340                                  	out	dx,ax		; signal it
   341                                  
   342                                  	popm	all,ds,es
   343                                  	iret
   344                                  %endif
   345                                  %endif
   346                                  
   347                                  
   348                                  ;========================================================================
   349                                  ; UART interrupt handler
   350                                  ; This routine does most of the keyboard driver work
   351                                  ;========================================================================
   352                                  	global	uart_int
   353                                  uart_int:
   354 000000C2 1E525350                	pushm	ax,bx,dx,ds
   355 000000C6 6A40                    	push	bios_data_seg
   356 000000C8 1F                      	popm	ds		; establish addressability
   357                                  %if SOFT_DEBUG
   358                                  	push	0xFF
   359                                  	extern	lites
   360                                  	call	lites
   361                                  	hlt
   362                                  %endif
   363                                  .1:
   364 000000C9 BA8506                  	mov	dx,uart_lsr
   365 000000CC EC                      	in	al,dx
   366 000000CD 2401                    	and	al,01h		; do we have any data in receive buffer?
   367 000000CF 742E                    	jz	int_exit
   368                                  
   369 000000D1 BA8006                  	mov	dx,uart_rbr
   370 000000D4 EC                      	in	al,dx		; get next character
   371                                  
   372 000000D5 B400                    	mov	ah,0
   373 000000D7 3C80                    	cmp	al,80h		; the ASCII code =< 80?
   374 000000D9 73EE                    	jae	.1		; ignore, check for the next character
   375                                  %if SOFT_DEBUG
   376                                  	cmp	al,'B' & 01Fh	; ctrl-B
   377                                  	je	v.redbug
   378                                  %endif
   379 000000DB 3C12                    	cmp	al,('R' & 01Fh)	; ctrl-R
   380 000000DD 750D                    	jne	.20
   381 000000DF FE061500                	inc	byte [uart_kbd_ctrl_R]
   382 000000E3 803E150003              	cmp	byte [uart_kbd_ctrl_R], 3	; 3 ctrl-R's will re-boot
   383 000000E8 7207                    	jb	.2
   384                                  %if 1
   385 000000EA CD19                    	int	19h		; does not return
   386                                  %else
   387                                  	mov	word [warm_boot],1234h		; signal warm boot
   388                                  	jmp	0FFFFh:0000h
   389                                  %endif
   390                                  .20:
   391 000000EC C606150000              	mov	byte [uart_kbd_ctrl_R], 0	; zero the re-boot count
   392                                  .2:
   393 000000F1 88C3                    	mov	bl,al		; find the scan code
   394 000000F3 B700                    	mov	bh,0
   395 000000F5 2E8AA7[0B01]                cs	mov	ah,byte [ascii2scan+bx]
   396                                  
   397 000000FA E899FF                      	call	enqueue
   398                                  
   399 000000FD EBCA                    	jmp	.1		; check for the next character
   400                                  
   401                                  int_exit:
   402                                  ; signal EOI (End of Interrupt)
   403 000000FF BA22FF                  	mov	dx,PIC_EOI	; EOI register
   404 00000102 B80080                  	mov	ax,EOI_NSPEC	; non-specific
   405 00000105 EF                      	out	dx,ax		; signal it
   406                                  
   407 00000106 585B5A1F                	popm	ax,bx,dx,ds
   408 0000010A CF                      	iret
   409                                  
   410                                  ; Debugging code added 10/17/2010 -- JRC
   411                                  ;  Use ctrl-B (^B) as immediate entry into the debugger
   412                                  %if SOFT_DEBUG
   413                                  	extern	redbug
   414                                  v.redbug:
   415                                  ; signal EOI (End of Interrupt)
   416                                  	mov	dx,PIC_EOI	; EOI register
   417                                  	mov	ax,EOI_NSPEC	; non-specific
   418                                  	out	dx,ax		; signal it
   419                                  ; restore the registers
   420                                  	popm	ax,bx,dx,ds
   421                                  ; keep the 'iret' block on the stack
   422                                  	jmp	redbug
   423                                  %endif
   424                                  
   425                                  ascii2scan:
   426                                  	;	NUL,SOH,STX,ETX,EOT,ENQ,ACL,BEL
   427 0000010B 0000000000000000        	db	0,  0,  0,  0,  0,  0,  0,  0, 
   428                                  	;	BS, TAB,LF, VT, FF, CR, SO, SI
   429 00000113 0E0F0000001C0000        	db      0Eh,0Fh,0,  0,  0,  1Ch,0  ,0
   430                                  	;	DLE,DC1,DC2,DC3,DC4,NAK,SYN,ETB
   431 0000011B 0000000000000000        	db	0,  0,  0,  0,  0,  0,  0,  0,
   432                                  	;	CAN,EM, SUB,ESC,FS, GS, RS, US
   433 00000123 0000000100000000        	db      0,  0,  0,  01h,0,  0,  0,  0,
   434                                  	;	 ,  !,  ",  #,  $,  %,  &,  '
   435 0000012B 3902280405060828        	db	39h,02h,28h,04h,05h,06h,08h,28h
   436                                  	;	(,  ),  *,  +,  ,,  -,  .,  /  
   437 00000133 0A0B090D330C3435        	db	0Ah,0Bh,09h,0Dh,33h,0Ch,34h,35h
   438                                  	;	0,  1,  2,  3,  4,  5,  6,  7
   439 0000013B 0B02030405060708        	db	0Bh,02h,03h,04h,05h,06h,07h,08h
   440                                  	;	8,  9,  :,  ;,  <,  =,  >,  ?
   441 00000143 090A2727330D3435        	db	09h,0Ah,27h,27h,33h,0Dh,34h,35h
   442                                  	;	@,  A,  B,  C,  D,  E,  F,  G
   443 0000014B 031E302E20122122        	db	03h,1Eh,30h,2Eh,20h,12h,21h,22h
   444                                  	;	H,  I,  J,  K,  L,  M,  N,  O
   445 00000153 2317242526323118        	db	23h,17h,24h,25h,26h,32h,31h,18h
   446                                  	;	P,  Q,  R,  S,  T,  U,  V,  W
   447 0000015B 1910131F14162F11        	db	19h,10h,13h,1Fh,14h,16h,2Fh,11h
   448                                  	;	X,  Y,  Z,  [,  \,  ],  ^,  _
   449 00000163 2D152C1A2B1B070C        	db	2Dh,15h,2Ch,1Ah,2Bh,1Bh,07h,0Ch
   450                                  	;	`,  a,  b,  c,  d,  e,  f,  g
   451 0000016B 291E302E20122122        	db	29h,1Eh,30h,2Eh,20h,12h,21h,22h
   452                                  	;	h,  i,  j,  k,  l,  m,  n,  o
   453 00000173 2317242526323118        	db	23h,17h,24h,25h,26h,32h,31h,18h
   454                                  	;	p,  q,  r,  s,  t,  u,  v,  w
   455 0000017B 1910131F14162F11        	db	19h,10h,13h,1Fh,14h,16h,2Fh,11h
   456                                  	;	x,  y,  z,  {,  |,  },  ~,  DEL
   457 00000183 2D152C1A2B1B2953        	db	2Dh,15h,2Ch,1Ah,2Bh,1Bh,29h,53h
   458                                  	
   459                                  ;========================================================================
   460                                  ; keyboart_init - initialize keyboard
   461                                  ;========================================================================
   462                                  	global	keyboard_init
   463                                  keyboard_init:
   464 0000018B 061E60                  	pushm	all,ds,es	; was AX,DS,ES
   465                                  	
   466                                  %if CVDU_8242
   467                                  	push	bios_data_seg
   468                                  	popm	ds
   469                                  
   470                                  	mov	word [keyboard_flags_0],CVDU_KEYBOARD_STATUS	; set NumLock Status early
   471                                  %endif
   472                                  
   473 0000018E 68[ssss]                	push	DGROUP
   474 00000191 1F                      	popm	ds
   475                                  %if CVDU_8242
   476                                  
   477                                  %if  1-CVDU_USE_KBD_HOOK
   478                                  	mov	dx,PIC_I0CON	; Int 0 control register
   479                                  	in	ax,dx
   480                                  ;jrc	or	al,10h		; set Level Trigger Mode
   481                                  	and	al,~8		; clear mask bit
   482                                  	out	dx,ax
   483                                  %endif
   484                                  
   485                                  	extern	Init8242_
   486                                  	call	Init8242_
   487                                  %endif
   488                                  
   489 00000192 6A40                    	push	bios_data_seg
   490 00000194 1F                      	popm	ds
   491                                  
   492 00000195 B81E00                  	mov	ax,kbd_buffer	; setup keyboard buffer
   493 00000198 A31A00                  	mov	word [kbd_buffer_head],ax
   494 0000019B A31C00                  	mov	word [kbd_buffer_tail],ax
   495                                  %if CVDU_8242==0
   496 0000019E 31C0                    	xor	ax,ax		; clear keyboard flags
   497 000001A0 A31700                  	mov	word [keyboard_flags_0],ax
   498                                  %endif
   499                                  
   500                                  %if UART
   501 000001A3 B001                    	mov	al,01h
   502 000001A5 BA8106                  	mov	dx,uart_ier
   503 000001A8 EE                      	out	dx,al		; Enable interrupts on receive
   504                                  
   505 000001A9 BA3AFF                  	mov	dx,PIC_I1CON	; Int 1 control register
   506 000001AC ED                      	in	ax,dx
   507 000001AD 83E0F7                  	and	ax,~08h		; clear the mask bit
   508 000001B0 EF                      	out	dx,ax
   509                                  %endif
   510 000001B1 611F07                  	popm	all,ds,es
   511 000001B4 C3                      	ret
   512                                  
   513                                  ;========================================================================
   514                                  ; uart_getchar - Read char from buffer, wait if empty
   515                                  ; Input:
   516                                  ; 	none
   517                                  ; Output:
   518                                  ;	AL = character
   519                                  ;	AH = 0
   520                                  ;========================================================================
   521                                  	global	@uart_getchar
   522                                  @uart_getchar:
   523 000001B5 B400                    	mov	ah,0
   524 000001B7 CD16                    	int	16h
   525 000001B9 B400                    	mov	ah,0
   526 000001BB C3                      	ret
   527                                  
   528                                  
   529                                  %if CVDU_8242
   530                                  ;========================================================================
   531                                  ;  void I8242CommandPut(byte value);	
   532                                  ; Input:
   533                                  ;	AL = command byte
   534                                  ; Output:
   535                                  ;	none
   536                                  ;========================================================================
   537                                  	global I8242CommandPut_
   538                                  I8242CommandPut_:
   539                                  	push	dx
   540                                  	mov	ah,al		; save the command byte
   541                                  .1:	mov	dx,I8242status
   542                                  	in	al,dx
   543                                  	test	al,2
   544                                  	jnz	.1
   545                                  	mov	dx,I8242command
   546                                  	mov	al,ah
   547                                  	out	dx,al
   548                                  	pop	dx
   549                                  	ret
   550                                  
   551                                  
   552                                  ;========================================================================
   553                                  ;  int I8242GetValue(void);
   554                                  ; Input:
   555                                  ;	none
   556                                  ; Output:
   557                                  ;	AX = -1		no value available (C-flag set)
   558                                  ;	AX = input byte	if available	   (C-flag clear)
   559                                  ;
   560                                  ;========================================================================
   561                                  	global	I8242GetValue_
   562                                  I8242GetValue_:
   563                                  	push	dx
   564                                  	mov	dx,I8242status
   565                                  	in	al,dx
   566                                  	test	al,1
   567                                  	jz	.7
   568                                  	mov	dx,I8242data
   569                                  	in	al,dx
   570                                  	xor	ah,ah		; clear high byte for 'int' return
   571                                  	jmp	.9
   572                                  .7:
   573                                  	mov	ax,-1
   574                                  	stc
   575                                  .9:	pop	dx
   576                                  	ret
   577                                  %endif
