     1                                  ;========================================================================
     2                                  ; int16ser.asm -- Keyboard service implementation using serial port
     3                                  ;========================================================================
     4                                  ;
     5                                  ; Compiles with NASM 2.07, might work with other versions
     6                                  ;
     7                                  ; Copyright (C) 2010 Sergey Kiselev.
     8                                  ; Provided for hobbyist use on the N8VEM SBC-188 board.
     9                                  ;  
    10                                  ; This program is free software: you can redistribute it and/or modify
    11                                  ; it under the terms of the GNU General Public License as published by
    12                                  ; the Free Software Foundation, either version 3 of the License, or
    13                                  ; (at your option) any later version.
    14                                  ;
    15                                  ; This program is distributed in the hope that it will be useful,
    16                                  ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    17                                  ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    18                                  ; GNU General Public License for more details.
    19                                  ;
    20                                  ; You should have received a copy of the GNU General Public License
    21                                  ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    22                                  ;
    23                                  ; UPDATES:
    24                                  ;       31-Dec-2010 -- JRCoffman - add HLT to fn00 code.
    25                                  ;	17-Oct-2010 -- JRCoffman - fix .5 label bug & add ctrl-B debugger
    26                                  ;			escape.
    27                                  ;
    28                                  ; TODO:
    29                                  ; - add UART autodetection and FIFO for 16550
    30                                  ; - add escape sequence handling for function keys
    31                                  ; - raw mode (e.g. for firmware uploads)
    32                                  ; - Ctrl-Alt-Del (not possible literally, some other keys for soft reboot)
    33                                  ;========================================================================
    34                                  
    35                                  %include	"config.asm"
     1                              <1> ;/*
     2                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     3                              <1> ; VGA3.CFG
     4                              <1> ;   Copied to CONFIG.ASM for general release.
     5                              <1> ;
     6                              <1> ;       Modify the parameters below to reflect your system
     7                              <1> ;
     8                              <1> ;
     9                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    10                              <1> ;
    11                              <1> ;   Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    12                              <1> ;   Provided for hobbyist use on the N8VEM SBC-188 board.
    13                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    14                              <1> ;
    15                              <1> ; Define the serial terminal that the Video BIOS must emulate
    16                              <1> ; Set one of the following to 1
    17                              <1> ; If you have no idea what to choose, set TTY to 1
    18                              <1> TTY     equ     0       ; hardcopy -- cannot position the cursor
    19                              <1> DUMB    equ     0       ; dumb CRT -- ^H, ^J, ^K, ^L can move the cursor
    20                              <1> ANSI    equ     1       ; very smart, like a VT-100
    21                              <1> WYSE    equ     0       ; very smart Wyse series (30, 50, ...)
    22                              <1> ; others may get added in the future
    23                              <1> ;  ONE OF THE ABOVE must BE SET TO 1!!!!!
    24                              <1> ;
    25                              <1> ; Does the hardware configuration contain the Color Video Display Unit?
    26                              <1> ; Both the 8563 and the 8242 are used.  The default is CVDU=0
    27                              <1> CVDU	equ	0	; system does not have the CVDU
    28                              <1> ;
    29                              <1> ; Does the hardware configuration contain the VGA3 a/n Video card?
    30                              <1> ; The 8563 will be disabled, but the 8242 code is shared with the CVDU
    31                              <1> ; The default is VGA3=0
    32                              <1> VGA3   equ     1       ; system has the VGA3
    33                              <1> ;
    34                              <1> ; Does the hardware configuration contain the front panel card?
    35                              <1> ; The default is FRONT_PANEL=0
    36                              <1> ;
    37                              <1> FRONT_PANEL   equ     1       ; system has the VGA3
    38                              <1> %if 0
    39                              <1> 	*/
    40                              <1> #define VGA3 1
    41                              <1> /*
    42                              <1> %endif
    43                              <1> ;
    44                              <1> ; Boot up keyboard mode:  20h for NumLock on
    45                              <1> ;CVDU_KEYBOARD_STATUS	equ	0	; NumLock OFF
    46                              <1> CVDU_KEYBOARD_STATUS	equ	20h	; NumLock ON
    47                              <1> 
    48                              <1> ; Define the UART startup bit rate - 1200-19200 are most common
    49                              <1> ;UART_RATE	equ	0		; 1200
    50                              <1> ;UART_RATE	equ	1		; 2400
    51                              <1> ;UART_RATE	equ	2		; 4800
    52                              <1> ;UART_RATE	equ	3		; 9600
    53                              <1> ;UART_RATE	equ	4		; 19200
    54                              <1> UART_RATE	equ	5		; 38400
    55                              <1> ;UART_RATE	equ	6		; 57600
    56                              <1> ;UART_RATE	equ	7		; 115200
    57                              <1> 
    58                              <1> ; Does the serial terminal use the DSR/DTR protocol for flow control?
    59                              <1> ;UART_DSR_PROTOCOL	equ		1	; Yes!
    60                              <1> UART_DSR_PROTOCOL       equ             WYSE    ; Wyse always uses it
    61                              <1> 						; but not ANSI
    62                              <1> ; Define the size of the ROM image on the system in Kilobytes
    63                              <1> ; It may be smaller than the actual EPROM in use.
    64                              <1> ; The following sizes are supported:  32, 64, 128, and 256
    65                              <1> %ifndef ROM
    66                              <1> ROM             equ     32              ; 64 is the default
    67                              <1> %endif
    68                              <1> 
    69                              <1> ; Define the number of Wait States at which the ROM operates
    70                              <1> ROM_WS          equ     1               ; 0..3  (1 is the default)
    71                              <1> 
    72                              <1> ; Define the size in Kilobytes of DOS RAM (low SRAM plus EMM allocate RAM)
    73                              <1> ; This is a desired size and will only be present if a 4MEM board is added
    74                              <1> RAM_DOS         equ     640
    75                              <1> 
    76                              <1> ; Define the size of the low SRAM on the system in Kilobytes
    77                              <1> ; the default is 512 kilobytes
    78                              <1> RAM             equ     512             ; (512 is the default)
    79                              <1> 
    80                              <1> ; Define the number of Wait States at which the RAM operates
    81                              <1> RAM_WS          equ     0               ; 0..3  (0 is the default)
    82                              <1> 
    83                              <1> ; Define the number of Wait States for Local Peripheral devices (600-7FF)
    84                              <1> LCL_IO_WS       equ     1               ; 0..3  (1 is the default)
    85                              <1> 
    86                              <1> ; Define the number of Wait States for ECB BUS peripheral devices (4xx)
    87                              <1> BUS_IO_WS       equ     3               ; 0..3  (3 is the default)
    88                              <1> 
    89                              <1> ; Define the time zone in which we build the Relocatable BIOS
    90                              <1> %ifndef TIMEZONE
    91                              <1> %define TIMEZONE "CDT"
    92                              <1> %endif
    93                              <1> 
    94                              <1> ; Has the REDBUG debugger been loaded?
    95                              <1> %ifndef SOFT_DEBUG
    96                              <1> %define SOFT_DEBUG 0
    97                              <1> %endif
    98                              <1> 
    99                              <1> ; Should the BIOS include "Tiny BASIC" in the image?
   100                              <1> %ifndef TBASIC
   101                              <1> TBASIC          equ     1		; default is 1
   102                              <1> %endif
   103                              <1> 
   104                              <1> ; Should the BIOS include the Floating Point Emulator?  The 80188 does
   105                              <1> ; not allow a floating point co-processor, so this is probably a good idea.
   106                              <1> %ifndef FPEM
   107                              <1> FPEM            equ     1               ; default is 1
   108                              <1> %endif
   109                              <1> 
   110                              <1> ; Define the maximum number of EMM (4MEM) boards supported
   111                              <1> EMM_BOARDS      equ     4
   112                              <1> 
   113                              <1> ; Should the Floating Point Emulator use temporary storage in the EBDA
   114                              <1> ; or at locations 0280h..3FFh in low memory?
   115                              <1> %if SOFT_DEBUG
   116                              <1> FPEM_USE_EBDA   equ     FPEM            ; default is 0
   117                              <1> %else
   118                              <1> FPEM_USE_EBDA   equ     0; FPEM            ; default is 0
   119                              <1> %endif
   120                              <1> 
   121                              <1> ; Define the size of the EPROM that is to be installed on the system
   122                              <1> ; It may be larger than the actual ROM image to be generated.
   123                              <1> %ifndef CHIP
   124                              <1> CHIP            equ     64
   125                              <1> %endif
   126                              <1> 
   127                              <1> ; Does the SBC-188 00.4 board have the LS138/LS08 piggyback fix
   128                              <1> ; Set to 1 for the SBC-188 v1.0 and later production boards
   129                              <1> FDC_PIGGYBACK_FIX       equ     0       ; Fix not installed
   130                              <1> ;FDC_PIGGYBACK_FIX       equ     1       ; fix  IS  installed
   131                              <1> 
   132                              <1> ; On SBC-188 rev 00.4 board, there is a published hardware fix (2010-09-18).
   133                              <1> ; If the wiring update is installed, or you have a later board, then
   134                              <1> ; set this to 0.  If you are using the software workaround, then set this
   135                              <1> ; to 1.  The rev 1.0 board has this fix already.
   136                              <1> NEED_TIMER_FIX  equ     0               ; have revised hardware
   137                              <1> ;NEED_TIMER_FIX  equ     1               ; use workaround
   138                              <1> 
   139                              <1> ; Define the UART oscillator speed
   140                              <1> UART_OSC        equ     1843200         ; 1.8432 Mhz is specified
   141                              <1> 
   142                              <1> 
   143                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   144                              <1> ; end of the User configuration
   145                              <1> ;       Do Not modify anything below this point
   146                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   147                              <1> 
   148                              <1> CVDU_8563	equ	CVDU		; separate inits
   149                              <1> CVDU_8242	equ	CVDU|VGA3 	; separate inits
   150                              <1> VGA3_6445       equ     VGA3            ; separate inits
   151                              <1> ; Suppress all UART output in color video Mode 3
   152                              <1> ;UART_MODE3_SUPPRESS	equ	0
   153                              <1> UART_MODE3_SUPPRESS	equ	CVDU_8563 | VGA3_6445
   154                              <1> CVDU_USE_MSDOS_KLUDGE	equ	0; CVDU_8242	; bad, bad MSDOS
   155                              <1> CVDU_USE_KBD_HOOK		equ	CVDU_8242
   156                              <1> 
   157                              <1> ; Define existence of any uart chip
   158                              <1> UART		equ	TTY+DUMB+ANSI+WYSE
   159                              <1> startuplength   equ     128                     ; may be up to 1024
   160                              <1> startseg        equ     0FFFFh - (ROM*64) + 1
   161                              <1> highrom         equ     (ROM*400h)&0FFFFh
   162                              <1> startupseg      equ     0FFFFh - (startuplength>>4) + 1
   163                              <1> bios_data_seg   equ     040h            ; segment of BIOS data area
   164                              <1> 
   165                              <1> 
   166                              <1> %define ARG(n) [bp+2+(n)*2]
   167                              <1> 
   168                              <1> %macro  check   1.nolist
   169                              <1>  %if (%1)
   170                              <1>    %error Check Failure: %1
   171                              <1>  %endif
   172                              <1> %endm
   173                              <1> %macro  range   3.nolist
   174                              <1>  %if (%1)<(%2)
   175                              <1>    %error Out of Range: %1
   176                              <1>  %elif (%1)>(%3)
   177                              <1>    %error Out of Range: %1
   178                              <1>  %endif
   179                              <1> %endm
   180                              <1> _terminal equ UART+CVDU
   181                              <1>  check   RAM_DOS&15
   182                              <1>  check   RAM&(RAM-1)
   183                              <1>  check   ROM&(ROM-1)
   184                              <1>  range   RAM,32,512
   185                              <1>  range   ROM,32,256
   186                              <1>  range   RAM_WS,0,3
   187                              <1>  range   ROM_WS,0,3
   188                              <1>  range   RAM_DOS,RAM,(1024-ROM)
   189                              <1>  range   LCL_IO_WS,0,3
   190                              <1>  range   BUS_IO_WS,0,3
   191                              <1>  range   UART_OSC,500000,16000000
   192                              <1>  range   UART_RATE,0,7
   193                              <1>  range	 UART,0,1
   194                              <1>  range	 _terminal,1,2
   195                              <1> 
   196                              <1> %ifndef SOFT_DEBUG
   197                              <1> %define SOFT_DEBUG 0
   198                              <1> %endif
   199                              <1> 
   200                              <1> %ifndef TRACE
   201                              <1> %define TRACE 0
   202                              <1> %endif
   203                              <1> 
   204                              <1> %ifdef MAKE_OBJECT_FILE
   205                              <1>         segment _DATA WORD PUBLIC CLASS=DATA
   206                              <1>         export _ROMsize
   207                              <1>         export _CHIPsize
   208                              <1> _ROMsize        dw      ROM
   209                              <1> _CHIPsize       dw      CHIP
   210                              <1> %endif
   211                              <1> ; end of the Hardware configuration file
   212                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   213                              <1> ;*/
    36                                  %include	"cpuregs.asm"
     1                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     2                              <1> ; CPUREGS.ASM
     3                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     4                              <1> ;
     5                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
     6                              <1> ;
     7                              <1> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
     8                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
     9                              <1> ;
    10                              <1> ; This program is free software: you can redistribute it and/or modify
    11                              <1> ; it under the terms of the GNU General Public License as published by
    12                              <1> ; the Free Software Foundation, either version 3 of the License, or
    13                              <1> ; (at your option) any later version.
    14                              <1> ;
    15                              <1> ; This program is distributed in the hope that it will be useful,
    16                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    17                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    18                              <1> ; GNU General Public License for more details.
    19                              <1> ;
    20                              <1> ; You should have received a copy of the GNU General Public License
    21                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    22                              <1> ;
    23                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    24                              <1>         cpu     186
    25                              <1> ;
    26                              <1> ;
    27                              <1> ; IBM model byte -- must be less than a 286
    28                              <1> ;
    29                              <1> ;MODEL_BYTE		equ	0FEh	; PC-XT
    30                              <1> ;SUBMODEL_BYTE		equ	0FFh	; not used
    31                              <1> 
    32                              <1> MODEL_BYTE		equ	0FEh	; PC-XT
    33                              <1> SUBMODEL_BYTE		equ	00h	;  "
    34                              <1> 
    35                              <1> 
    36                              <1> ; 80188 peripheral control register block address
    37                              <1> CPU_CSCR	        equ	0FF00h
    38                              <1> 
    39                              <1> ; Compatible Mode registers
    40                              <1> 
    41                              <1> cpu_relocation          equ     CPU_CSCR+0FEh
    42                              <1> 
    43                              <1> ; The memory and peripheral chip select register offsets from 0FF00h
    44                              <1> 
    45                              <1> cpu_umcs                equ     CPU_CSCR+0A0h          ; Upper memory select
    46                              <1> cpu_lmcs                equ     CPU_CSCR+0A2h          ; Lower memory select
    47                              <1> cpu_pacs                equ     CPU_CSCR+0A4h          ; Peripheral select
    48                              <1> cpu_mmcs                equ     CPU_CSCR+0A6h          ; Middle memory base
    49                              <1> cpu_mpcs                equ     CPU_CSCR+0A8h          ; Mid mem. & peripherals
    50                              <1> 
    51                              <1> ; Enhanced Mode registers
    52                              <1> 
    53                              <1> cpu_mdram               equ     CPU_CSCR+0E0h          ; memory partition reg.
    54                              <1> cpu_cdram               equ     CPU_CSCR+0E2h          ; clock prescaler
    55                              <1> cpu_edram               equ     CPU_CSCR+0E4h          ; Enable refresh reg.
    56                              <1> cpu_pdcon               equ     CPU_CSCR+0F0h          ; Power-Save control
    57                              <1> 
    58                              <1> 
    59                              <1> ; On-board internal peripheral equates
    60                              <1> ; Programmable Interrupt Controller
    61                              <1> PIC	        equ	CPU_CSCR+020H
    62                              <1> PIC_EOI	        equ	PIC+2           ; End Of Interrupt
    63                              <1> PIC_POLLR	equ	PIC+4
    64                              <1> PIC_POLLSR	equ	PIC+6
    65                              <1> PIC_IMASK	equ	PIC+8
    66                              <1> PIC_PMREG	equ	PIC+0AH
    67                              <1> PIC_SRVR	equ	PIC+0CH
    68                              <1> PIC_IRQR	equ	PIC+0EH
    69                              <1> PIC_IRQSR	equ	PIC+10H
    70                              <1> PIC_TCR	        equ	PIC+12H
    71                              <1> PIC_DMA0CR	equ	PIC+14H
    72                              <1> PIC_DMA1CR	equ	PIC+16H
    73                              <1> PIC_I0CON	equ	PIC+18H
    74                              <1> PIC_I1CON	equ	PIC+1AH
    75                              <1> PIC_I2CON	equ	PIC+1CH
    76                              <1> PIC_I3CON	equ	PIC+1EH
    77                              <1> 
    78                              <1> EOI_NSPEC       equ     8000h           ; Non-Specific EOI
    79                              <1> 
    80                              <1> ; Interrupt masks (Master Mode)
    81                              <1> ;
    82                              <1> mask_timer_all          equ     0001h
    83                              <1> mask_dma0               equ     0004h
    84                              <1> mask_dma1               equ     0008h
    85                              <1> mask_int0               equ     0010h
    86                              <1> mask_int1               equ     0020h
    87                              <1> mask_int2               equ     0040h
    88                              <1> mask_int3               equ     0080h
    89                              <1> 
    90                              <1> 
    91                              <1> 
    92                              <1> ; Timers
    93                              <1> TIM0	        equ	CPU_CSCR+050H
    94                              <1> TIM1	        equ	CPU_CSCR+058H
    95                              <1> TIM2	        equ	CPU_CSCR+060H
    96                              <1> 
    97                              <1> TCNT	        equ	0	; count register
    98                              <1> CMPA	        equ	2	; max count A
    99                              <1> CMPB	        equ	4	; max count B (not present on TIM2)
   100                              <1> TCON	        equ	6	; mode/control word
   101                              <1> 
   102                              <1> ; Timer control bits:
   103                              <1> tc_EN           equ     8000h   ; Enable bit
   104                              <1> tc_nINH         equ     4000h   ; not Inhibit Enable
   105                              <1> tc_INT          equ     2000h   ; Interrupt Enable
   106                              <1> tc_RIU          equ     1000h   ; Register A/B (0/1) in Use
   107                              <1> tc_MC           equ     0020h   ; Maximum Count reached
   108                              <1> tc_RTG          equ     0010h   ; Retrigger (internal source)
   109                              <1> tc_P            equ     0008h   ; Prescale internal clock (timers 0 & 1 only)
   110                              <1> tc_EXT          equ     0004h   ; External clock
   111                              <1> tc_ALT          equ     0002h   ; Alternate between A & B max count registers
   112                              <1> tc_CONT         equ     0001h   ; Continuous: continue after max count
   113                              <1> 
   114                              <1> 
   115                              <1> 
   116                              <1> 
   117                              <1> ; DMA
   118                              <1> DMA0	        equ	CPU_CSCR+0C0H
   119                              <1> DMA1	        equ	CPU_CSCR+0D0H
   120                              <1> DMASPL	        equ	0	; source pointer low
   121                              <1> DMASPU	        equ	2	; source pointer high
   122                              <1> DMADPL	        equ	4	; destination pointer low
   123                              <1> DMADPU	        equ	6	; destination pointer high
   124                              <1> DMATC	        equ	8	; terminal count
   125                              <1> DMACW	        equ	0AH	; control word
   126                              <1> 
   127                              <1> 
   128                              <1> 
   129                              <1> 
   130                              <1> 
   131                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   132                              <1> ;
   133                              <1> ;       SBC-188 external devices
   134                              <1> ;
   135                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   136                              <1> 
   137                              <1> IO_BASE			equ	0400h
   138                              <1> 
   139                              <1> 
   140                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   141                              <1> ; The UART registers
   142                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   143                              <1> uart_base               equ     IO_BASE+0280h
   144                              <1> uart_rbr                equ     uart_base       ;Rcvr Buffer / read only
   145                              <1> uart_thr                equ     uart_base       ;Transmit Holding / write only
   146                              <1> uart_ier                equ     uart_base+1     ;Interrupt Enable
   147                              <1> uart_iir                equ     uart_base+2     ;Interrupt Ident / read only
   148                              <1> uart_fcr                equ     uart_base+2     ;FIFO Control / write only
   149                              <1> uart_lcr                equ     uart_base+3     ;Line Control
   150                              <1> uart_mcr                equ     uart_base+4     ;Modem Control
   151                              <1> uart_lsr                equ     uart_base+5     ;Line Status
   152                              <1> uart_msr                equ     uart_base+6     ;Modem Status
   153                              <1> uart_sr			equ	uart_base+7	;Scratch
   154                              <1> 
   155                              <1> uart_dll                equ     uart_base       ;Divisor Latch LS Byte
   156                              <1> uart_dlm                equ     uart_base+1     ;Divisor Latch MS Byte
   157                              <1> 
   158                              <1> 
   159                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   160                              <1> ; Floppy controller
   161                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   162                              <1> FDC	        equ	IO_BASE+0200H
   163                              <1> FDC_MSR         equ     FDC
   164                              <1> FDC_DATA        equ     FDC_MSR+1
   165                              <1> FDC_DACK        equ	FDC+10H
   166                              <1> FDC_LDOR	equ	FDC+20H
   167                              <1> FDC_LDCR	equ	FDC+30H
   168                              <1> FDC_TC	        equ	FDC+40H
   169                              <1> FDC_DACK_TC     equ     FDC_DACK | FDC_TC
   170                              <1> 
   171                              <1> 
   172                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   173                              <1> ;DS1302 RTC
   174                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   175                              <1> RTC	equ	IO_BASE+0300H
   176                              <1> 
   177                              <1> 
   178                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   179                              <1> ; PIO 82C55 I/O 
   180                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   181                              <1> PPI	        equ	IO_BASE+0260H
   182                              <1> PIO_A	        equ	PPI+0	; (OUTPUT)
   183                              <1> PIO_B	        equ	PPI+1	; (INPUT)
   184                              <1> PIO_C	        equ	PPI+2	; (CENTRONICS control low nibble)  
   185                              <1> PIO_CTRL	equ	PPI+3	; CONTROL BYTE PIO 82C55
   186                              <1> 
   187                              <1> portA           equ     PPI+0   ;
   188                              <1> portB           equ     PPI+1   ;     LITES uses this for output
   189                              <1> portC           equ     PPI+2   ;
   190                              <1> 
   191                              <1> 
   192                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   193                              <1> ; Dual [DMA] IDE devices
   194                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   195                              <1> DIDE		equ	IO_BASE + 20H	; range 0x20..0x3F
   196                              <1> 
   197                              <1> DIDE0		equ	DIDE		; first interface (master & slave)
   198                              <1> DIDE1		equ	DIDE+10h	; second interface (master & slave)
   199                              <1> 
   200                              <1> 
   201                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   202                              <1> ; Cassette I/O
   203                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   204                              <1> cuart_base	EQU 	IO_BASE+80H	; BASE IO ADDRESS OF CASSETTE UART
   205                              <1> cuart_rbr	equ     cuart_base	;Rcvr Buffer / read only
   206                              <1> cuart_thr	equ     cuart_base	;Transmit Holding / write only
   207                              <1> cuart_ier	equ     cuart_base+1	;Interrupt Enable
   208                              <1> cuart_iir	equ     cuart_base+2	;Interrupt Ident / read only
   209                              <1> cuart_fcr	equ     cuart_base+2	;FIFO Control / write only
   210                              <1> cuart_lcr	equ     cuart_base+3	;Line Control
   211                              <1> cuart_mcr	equ     cuart_base+4	;Modem Control
   212                              <1> cuart_lsr	equ     cuart_base+5	;Line Status
   213                              <1> cuart_msr	equ     cuart_base+6	;Modem Status
   214                              <1> cuart_sr	equ	cuart_base+7	;Scratch
   215                              <1> 
   216                              <1> cuart_dll	equ     cuart_base	;Divisor Latch LS Byte
   217                              <1> cuart_dlm	equ	cuart_base+1	;Divisor Latch MS Byte
   218                              <1> 
   219                              <1> 
   220                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   221                              <1> ;
   222                              <1> ;       4MEM control registers
   223                              <1> ;
   224                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   225                              <1> EMM_addr        equ     1               ; high 6 bits of 20-bit address
   226                              <1> EMM_page        equ     0               ; 4MEM page in [0..254]
   227                              <1> 
   228                              <1> EMM_BASE        equ     IO_BASE + 000h          ; first EMM (4MEM) board
   229                              <1> EMM_unmapped    equ     255             ; unmapped 4MEM page
   230                              <1> 
   231                              <1> EMM0            equ     EMM_BASE        ; first  EMM board
   232                              <1> EMM1            equ     EMM0 + 2        ; second EMM board
   233                              <1> EMM2            equ     EMM1 + 2        ; third  EMM board
   234                              <1> EMM3            equ     EMM2 + 2        ; fourth EMM board
   235                              <1> 
   236                              <1> 
   237                              <1> 
   238                              <1> 
   239                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   240                              <1> ;
   241                              <1> ;	ColorVDU devices
   242                              <1> ;
   243                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   244                              <1> ;
   245                              <1> ;	major select on the Z80 bus
   246                              <1> ;
   247                              <1> devCVDU_8bit	equ	0xE0		; this may change to 0x10
   248                              <1> 
   249                              <1> devCVDUbase 	equ	IO_BASE + devCVDU_8bit
   250                              <1> 
   251                              <1> M8563status	equ	devCVDUbase + 4		; 4 == bitrev(2)
   252                              <1> M8563register	equ	devCVDUbase + 4
   253                              <1> M8563data	equ	devCVDUbase + 12	; 12 == bitrev(3)
   254                              <1> 
   255                              <1> %if CVDU_8563
   256                              <1> I8242status	equ	devCVDUbase + 10	; 10 == bitrev(5)
   257                              <1> I8242command	equ	devCVDUbase + 10
   258                              <1> I8242data	equ	devCVDUbase + 2		; 2 == bitrev(4)
   259                              <1> %endif
   260                              <1> 
   261                              <1> 
   262                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   263                              <1> ;
   264                              <1> ;	VGA3 devices
   265                              <1> ;
   266                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   267                              <1> ;
   268                              <1> ;	major select on the Z80 bus
   269                              <1> ;
   270                              <1> devVGA3_8bit    equ     0xE0                    ; same as CVDU
   271                              <1> 
   272                              <1> devVGA3base       equ     IO_BASE + devVGA3_8bit
   273                              <1> 
   274                              <1> %if VGA3_6445
   275                              <1> I8242status	equ	devVGA3base + 1
   276                              <1> I8242command	equ	devVGA3base + 1
   277                              <1> I8242data	equ	devVGA3base + 0
   278                              <1> %endif
   279                              <1> HD6445addr	equ	devVGA3base + 2		; to address the HD6445 registers
   280                              <1> HD6445reg	equ	devVGA3base + 3		; to r/w a register on the CRTC
   281                              <1> 
   282                              <1> vga3cfg		equ	devVGA3base + 4
   283                              <1> ; the following are probably not used on the SBC-188, except for testing/checking
   284                              <1> vga3adhi	equ	devVGA3base + 5
   285                              <1> vga3adlo	equ	devVGA3base + 6
   286                              <1> vga3data	equ	devVGA3base + 7
   287                              <1> 
   288                              <1> 
   289                              <1> 
   290                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   291                              <1> ;
   292                              <1> ;	Front Panel devices
   293                              <1> ;
   294                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   295                              <1> ;
   296                              <1> ; Front Panel 82C55 I/O 
   297                              <1> FPPPI	        equ	IO_BASE+0A0H
   298                              <1> FPPORTA         equ     FPPPI+0   	;
   299                              <1> FPPORTB         equ     FPPPI+1   	;    
   300                              <1> FPPORTC         equ     FPPPI+2   	;
   301                              <1> FPPIOCONT       equ     FPPPI+3   	;
   302                              <1> 
   303                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   304                              <1> ; debug port -- JRC only
   305                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   306                              <1> portD		equ	IO_BASE + 0FFh		; 0x04FF
   307                              <1> ;portD		equ	portB		     ; older 8255 output on PPI
   308                              <1> 
   309                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   310                              <1> ;
   311                              <1> ; some useful macros:
   312                              <1> ;
   313                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   314                              <1> ;
   315                              <1> 
   316                              <1> %imacro setloc  1.nolist
   317                              <1>  times   (%1-($-$$)) db 0FFh
   318                              <1> %endm
   319                              <1> 
   320                              <1> %imacro db_lo   1
   321                              <1>  db (%1)&255
   322                              <1> %endm
   323                              <1> 
   324                              <1> %imacro cnop    0.nolist
   325                              <1> %if SOFT_DEBUG
   326                              <1>         nop
   327                              <1> %endif
   328                              <1> %endm
   329                              <1> 
   330                              <1> %imacro popm 1-*.nolist
   331                              <1> %rep %0
   332                              <1> %ifidni %1,ALL
   333                              <1>  popa
   334                              <1> %elifidni %1,F
   335                              <1>  popf
   336                              <1> %else
   337                              <1>  pop %1
   338                              <1> %ifidni %1,DS
   339                              <1>  cnop
   340                              <1> %elifidni %1,ES
   341                              <1>  cnop
   342                              <1> %endif
   343                              <1> %endif
   344                              <1> %rotate 1
   345                              <1> %endrep
   346                              <1> %endm
   347                              <1> 
   348                              <1> %imacro pushm 1-*.nolist
   349                              <1> %rep %0
   350                              <1> %rotate -1
   351                              <1> %ifidni %1,ALL
   352                              <1>  pusha
   353                              <1> %elifidni %1,F
   354                              <1>  pushf
   355                              <1> %else
   356                              <1>  push %1
   357                              <1> %endif
   358                              <1> %endrep
   359                              <1> %endm
   360                              <1> 
   361                              <1> ; end CPUREGS.ASM
   362                              <1> 
    37                                  %include	"equates.asm"
     1                              <1> ;========================================================================
     2                              <1> ; EQUATES.ASM -- Lots of Defintions for Relocatable BIOS
     3                              <1> ;========================================================================
     4                              <1> ;   for the N8VEM SBC-188 v.00.4 and 00.5
     5                              <1> ;
     6                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
     7                              <1> ;
     8                              <1> ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
     9                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    10                              <1> ;
    11                              <1> ; This program is free software: you can redistribute it and/or modify
    12                              <1> ; it under the terms of the GNU General Public License as published by
    13                              <1> ; the Free Software Foundation, either version 3 of the License, or
    14                              <1> ; (at your option) any later version.
    15                              <1> ;
    16                              <1> ; This program is distributed in the hope that it will be useful,
    17                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    18                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    19                              <1> ; GNU General Public License for more details.
    20                              <1> ;
    21                              <1> ; You should have received a copy of the GNU General Public License
    22                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    23                              <1> ;
    24                              <1> ;========================================================================
    25                              <1> 
    26                              <1> %if 1
    27                              <1> 	SEGMENT  _TEXT ALIGN=16 PUBLIC CLASS=CODE
    28                              <1>         SEGMENT  CONST ALIGN=2 PUBLIC CLASS=DATA
    29                              <1> 	SEGMENT  _DATA ALIGN=2 PUBLIC CLASS=DATA
    30                              <1>         SEGMENT  CONST2 ALIGN=2 PUBLIC CLASS=DATA
    31                              <1> 	SEGMENT  _BSS  ALIGN=2 PUBLIC CLASS=BSS
    32                              <1> ;;;        SEGMENT  _BASIC ALIGN=16 PUBLIC CLASS=BASIC
    33                              <1> 
    34                              <1> 	GROUP	DGROUP CONST _DATA CONST2 _BSS
    35                              <1> 
    36                              <1>         global  FPEM_segment
    37                              <1> %endif
    38                              <1> 
    39                              <1> %include "ascii.asm"
     1                              <2> ; ascii.asm
     2                              <2> ;
     3                              <2> CTRL            equ     1Fh     ; masks a character to CTRL-x
     4                              <2> 
     5                              <2> NUL     equ     00h
     6                              <2> BEL     equ     (CTRL & 'G')
     7                              <2> BS      equ     08h
     8                              <2> HT      equ     09h
     9                              <2> LF	equ	0Ah
    10                              <2> NL      equ     LF
    11                              <2> CR	equ	0Dh
    12                              <2> XON     equ     (CTRL & 'Q')
    13                              <2> XOFF    equ     (CTRL & 'S')
    14                              <2> DC1     equ     XON
    15                              <2> DC3     equ     XOFF
    16                              <2> ESC     equ	1Bh
    17                              <2> 
    18                              <2> 
    40                              <1> 
    41                              <1> 
    42                              <1> ; POST error codes. Presently one byte but can expand to word.
    43                              <1> ER_BIOS equ	01h		; Bad ROM bios checksum, patch last byte
    44                              <1> ER_RAM	equ	02h		; Bad RAM in main memory, replace
    45                              <1> ER_CRT	equ	04h		; Bad RAM in video card, replace
    46                              <1> ER_FDC	equ	08h		; Bad FDC
    47                              <1> ER_UNK1	equ	10h		; {unassigned}
    48                              <1> ER_MEM	equ	20h		; Bad RAM in vector area, replace
    49                              <1> ER_ROM	equ	40h		; Bad ROM in expansion area, bad checksum
    50                              <1> ER_UNK2	equ	80h		; {unassigned}
    51                              <1> 
    52                              <1> 
    53                              <1> 
    54                              <1> ;; ************************ BIOS Data Segment ******************************
    55                              <1> ;; BIOS data segment - not all will  be used
    56                              <1> ;                struc   BIOS_DATA_AREA  ; at 0040:0000
    57                              <1> %include "bda.inc"
     1                              <2> ;/*======================================================================
     2                              <2> ; bda.inc -- BIOS data area definitions
     3                              <2> ;========================================================================
     4                              <2> ;   for the N8VEM SBC-188
     5                              <2> ;
     6                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
     7                              <2> ;
     8                              <2> ; Copyright (C) 2013 John R. Coffman.  All rights reserved.
     9                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    10                              <2> ;
    11                              <2> ; This program is free software: you can redistribute it and/or modify
    12                              <2> ; it under the terms of the GNU General Public License as published by
    13                              <2> ; the Free Software Foundation, either version 3 of the License, or
    14                              <2> ; (at your option) any later version.
    15                              <2> ;
    16                              <2> ; This program is distributed in the hope that it will be useful,
    17                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    18                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    19                              <2> ; GNU General Public License for more details.
    20                              <2> ;
    21                              <2> ; You should have received a copy of the GNU General Public License
    22                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    23                              <2> ;
    24                              <2> ;========================================================================
    25                              <2> 
    26                              <2> 			;*/ extern				/*
    27                              <2> 	ABSOLUTE  0	;*/ struct BDA {			/*
    28 00000000 <res 00000008>      <2> serial_ports    resw    4	;*/	word	serial_ports[4];	/*
    29 00000008 <res 00000008>      <2> parallel_ports  resw    4	;*/	word	parallel_ports[4];	/*
    30 00000010 <res 00000002>      <2> equipment_flag  resw    1	;*/	EQFL	equipment_flag;		/*
    31                              <2> ;	dw	?		; 40:10 	; Equipment present word
    32                              <2> ;  						;  = (1 iff floppies) *     1.
    33                              <2> ;                                               ;  + (1 iff 187     ) *     2.
    34                              <2> ;  						;  + (#+1 64K sys ram) *    4.
    35                              <2> ;  						;  + (init crt mode ) *    16.
    36                              <2> ;  						;  + (# of floppies ) *    64.
    37                              <2> ;  						;  + (# serial ports) *   512.
    38                              <2> ;  						;  + (1 iff toy port) *  4096.
    39                              <2> ;                                               ;  + (1 iff modem   ) *  8192.
    40                              <2> ;  						;  + (# parallel LPT) * 16384.
    41 00000012 <res 00000001>      <2> mfg_test_flags  resb    1	;*/	byte	mfg_test_flags;	/* 40:12 unused by us
    42 00000013 <res 00000002>      <2> memory_size     resw    1	;*/	word	memory_size;	/* 40:13 kilobytes
    43                              <2> uart_kbd_ctrl_R	equ	$	;*/				/*** JRC: count of ctrl-R's for reboot
    44 00000015 <res 00000001>      <2> IPL_errors      resb    1	;*/	byte	IPL_errors;	/* 40:15 IPL errors<-table/scratchpad
    45 00000016 <res 00000001>      <2> unused_01       resb    1	;*/	byte	unused_01;	/*
    46                              <2> ;;---------------[Keyboard data area]------------;
    47 00000017 <res 00000002>      <2> keyboard_flags_0 resw   1	;*/	word	keyboard_flags_0;  /* 40:17 Shift/Alt/etc. keyboard flags
    48                              <2> keyboard_flags_1 equ	$-1	;     2nd byte	keyboard_flags_1;  
    49 00000019 <res 00000001>      <2> keypad_char	resb	1	;*/	byte	keypad_char;	/* 40:19 Alt-KEYPAD char. goes here
    50 0000001A <res 00000002>      <2> kbd_buffer_head resw    1	;*/	word	kbd_buffer_head;   /* 40:1A --> keyboard buffer head
    51 0000001C <res 00000002>      <2> kbd_buffer_tail resw    1	;*/	word	kbd_buffer_tail;   /* 40:1C --> keyboard buffer tail
    52 0000001E <res 00000020>      <2> kbd_buffer      resw    16	;*/	word	kbd_buffer[16];	/* 40:1E Keyboard Buffer (Scan,Value)
    53                              <2> kbd_buffer_last	equ	$	;*/				/*
    54                              <2> ;;---------------[Diskette data area]------------;
    55 0000003E <res 00000001>      <2> fdc_drv_calib   resb    1	;*/	byte	fdc_drive_calib;   /* 40:3E
    56 0000003F <res 00000001>      <2> fdc_motor_LDOR  resb    1	;*/	byte	fdc_motor_LDOR;	   /* 40:3F Motor, DMA, select control
    57 00000040 <res 00000001>      <2> fdc_motor_ticks resb    1	;*/	byte	fdc_motor_ticks;   /* 40:40 ticks til motor off
    58 00000041 <res 00000001>      <2> fdc_status      resb    1	;*/	byte	fdc_status;	   /* 40:41
    59                              <2> ;				Floppy return code stat byte
    60                              <2> ;				;  1 = bad ic 765 command req.
    61                              <2> ;				;  2 = address mark not found
    62                              <2> ;				;  3 = write to protected disk
    63                              <2> ;				;  4 = sector not found
    64                              <2> ;				;  8 = data late (DMA overrun)
    65                              <2> ;				;  9 = DMA failed 64K page end
    66                              <2> ;				; 16 = bad CRC on floppy read
    67                              <2> ;				; 32 = bad NEC 765 controller
    68                              <2> ;				; 64 = seek operation failed
    69                              <2> ;				;128 = disk drive timed out
    70 00000042 <res 00000007>      <2> fdc_ctrl_status resb    7	;*/	byte	fdc_ctrl_status[7];  /* 40:42 Status bytes from NEC 765
    71                              <2> ;;---------------[Video display area]------------;
    72 00000049 <res 00000001>      <2> video_mode      resb    1	;*/	byte	video_mode;	/* 40:49
    73                              <2> ;			 	; Current CRT mode  (software)
    74                              <2> ;				;  0 = 40 x 25 text (no color)
    75                              <2> ;				;  1 = 40 x 25 text (16 color)
    76                              <2> ;				;  2 = 80 x 25 text (no color)
    77                              <2> ;				;  3 = 80 x 25 text (16 color)
    78                              <2> ;				;  4 = 320 x 200 grafix 4 color
    79                              <2> ;				;  5 = 320 x 200 grafix 0 color
    80                              <2> ;				;  6 = 640 x 200 grafix 0 color
    81                              <2> ;				;  7 = 80 x 25 text (mono card)
    82 0000004A <res 00000002>      <2> video_columns   resw    1	;*/	word video_columns;	/* 40:4A Columns on CRT screen
    83 0000004C <res 00000002>      <2> video_regen_bytes  resw 1	;*/	word video_regen_bytes;	/* 40:4C Bytes in the regen region
    84 0000004E <res 00000002>      <2> video_regen_offset resw 1	;*/	word video_regen_offset;/* 40:4E Byte offset in regen region
    85 00000050 <res 00000010>      <2> video_cursor_pos  resw  8	;*/	word video_cursor_pos[8];  /* 40:50 Cursor pos for up to 8 pages
    86 00000060 <res 00000002>      <2> video_cursor_mode resw  1	;*/	word video_cursor_mode;	/* 40:60 Current cursor mode setting
    87 00000062 <res 00000001>      <2> video_page      resb    1	;*/	byte video_page;	/* 40:62 Current page on display
    88 00000063 <res 00000002>      <2> video_base_seg  resw    1	;*/	word video_base_seg;	/* 40:63 Base address (B000h or B800h)
    89 00000065 <res 00000001>      <2> video_hw_mode   resb    1	;*/	byte video_hw_mode;	/* 40:65 ic 6845 mode reg. (hardware)
    90 00000066 <res 00000001>      <2> video_cga_palette resb  1	;*/	byte video_cga_palette;	/* 40:66 Current CGA palette
    91                              <2> ;;---------------[Used to setup ROM]-------------;
    92 00000067 <res 00000004>      <2> eprom_address   resd    1	;*/	dword eprom_address;	/* 40:67 Eprom base Offset,Segment
    93 0000006B <res 00000001>      <2> spurious_irq    resb    1	;*/	byte spurious_irq;	/* 40:6B Last spurious interrupt IRQ
    94                              <2> ;;---------------[Timer data area]---------------;
    95 0000006C <res 00000004>      <2> timer_ticks     resd    1	;*/	dword timer_ticks;	/* 40:6C Ticks since midnight (lo,hi)
    96 00000070 <res 00000001>      <2> timer_new_day   resb    1	;*/	byte timer_new_day;	/* 40:70 Non-zero if new day
    97                              <2> ;;---------------[System data area]--------------;
    98 00000071 <res 00000001>      <2> break_flag      resb    1	;*/	byte break_flag;	/* 40:71 Sign bit set iff break
    99 00000072 <res 00000002>      <2> warm_boot       resw    1	;*/	word warm_boot;		/* 40:72 Warm boot iff==1234h
   100                              <2> ;;---------------[Hard disk scratchpad]----------;
   101 00000074 <res 00000004>      <2> hdd_scratch     resd    1	;*/	word hdd_scratch[2];	/* 40:74
   102                              <2> ;;---------------[Timout areas/PRT/LPT]----------;
   103 00000078 <res 00000004>      <2> lpt_timeout     resb    4	;*/	byte lpt_timeout[4];	/* 40:78 Ticks for LPT 1-4 timeouts
   104 0000007C <res 00000004>      <2> com_timeout     resb    4	;*/	byte com_timeout[4];	/* 40:7C Ticks for COM 1-4 timeouts
   105                              <2> ;;---obsolete----[Keyboard buf start/end]---jrc--;
   106 00000080 <res 00000002>      <2> kbd_buffer_start resw   1	;*/	word kbd_buffer_start;	/* 40:80 KBD buffer head (PC/AT)
   107 00000082 <res 00000002>      <2> kbd_buffer_end  resw    1	;*/	word kbd_buffer_end;	/* 40:82 KBD buffer tail (PC/AT)
   108                              <2> ;;---------------[EGA stuff]---------------------;
   109 00000084 <res 00000007>      <2> EGA_stuff	resb	7	;*/	byte EGA_stuff[7];	/* 40:84 Unspecified EGA data
   110                              <2> ;;---------------[Floppy/Fixed Media Info]-------------;
   111 0000008B <res 00000001>      <2> fdc_last_rate	resb	1	;*/	byte fdc_last_rate;	/* 40:8B Last floppy step rate/data rate?
   112 0000008C <res 00000004>      <2> fx_misc_unused	resb	4	;*/	byte fx_misc_unused[4];	/* 40:8C Fixed disk miscellaneous ???
   113 00000090 <res 00000002>      <2> fdc_disk_state	resb	2	;*/	byte fdc_disk_state[2];	/* 40:90 Floppy disk state
   114 00000092 <res 00000002>      <2> fdc_op_start	resb	2	;*/	byte fdc_op_start[2];	/* 40:92 Floppy operation start state machine
   115 00000094 <res 00000002>      <2> fdc_cylinder	resb	2	;*/	byte fdc_cylinder[2];	/* 40:94 Floppy present cylinder
   116                              <2> ;;---------------[Additional KBD flags]----------------;
   117 00000096 <res 00000001>      <2> kbd_flag_3	resb	1	;*/	byte kbd_flag_3;	/* 40:96 kbd ???
   118 00000097 <res 00000001>      <2> kbd_flag_2	resb	1	;*/	byte kbd_flag_2;	/* 40:97 kbd ???
   119                              <2> ;;---------------[RTC/timer1 data]---------------------;
   120 00000098 <res 00000004>      <2> user_semaphore	resw	2	;*/	byte *user_semaphore;	/* 40:98 User semaphore in (bit 7)
   121 0000009C <res 00000004>      <2> rtc_count	resd	1	;*/	dword rtc_count;	/* 40:9C RTC tick counter
   122 000000A0 <res 00000001>      <2> rtc_wait_active	resb	1	;*/	byte rtc_wait_active;	/* 40:A0 Busy=01, Posted=80h, 
   123                              <2> ;;---------------[Cassette I/O stuff]------------------;
   124 000000A1 <res 00000001>      <2> last_val	resb	1	;*/	byte last_val;		/* 40:A1 Last byte read value
   125 000000A2 <res 00000002>      <2> crc_reg		resw	1	;*/	word crc_reg;		/* 40:A2 CRC accumulation area
   126                              <2> ;									Post Acknowleged=00;
   127 000000A4 <res 00000001>      <2> EGA_data	resb	1	;*/	byte EGA_data;		/* 40:A4 Various usage
   128 000000A5 <res 00000002>      <2> SDstatus	resb	2	;*/	byte SDstatus[2];	/* 40:A5 Status byte from command
   129 000000A7 <res 00000002>      <2> SDcardtype	resb	2	;*/	byte SDcardtype[2];	/* 40:A7 SDcard type SDSC=2, HC=3, ...
   130                              <2> ;
   131 000000A9 <res 00000004>      <2> fixed_disk_tab	resb	4	;*/	byte fixed_disk_tab[4];	/* dispatch table to fixed disk drivers
   132 000000AD <res 00000001>      <2> wait12_count	resb	1	;*/	byte wait12_count;	/* 40:AD 12usec CX count
   133 000000AE <res 00000001>      <2> lock_count	resb	1	;*/	byte lock_count;	/* 40:AE lock level counter
   134 000000AF <res 00000001>      <2> EMS_start       resb    1	;*/	byte EMS_start;		/* start EMS allocation from here
   135                              <2> fx80		equ	$	;*/	struct EDD_disk fx80;	/* fixed disk parameter area 0
   136 000000B0 <res 00000002>      <2> fx_log_cylinders resw   1	;	word fx_log_cylinders;	 logical number of cylinders
   137 000000B2 <res 00000001>      <2> fx_log_heads    resb    1	;	byte fx_log_heads;	 logical number of heads
   138 000000B3 <res 00000001>      <2> fx_signature	resb	1	;	byte fx_signature;	 A0h signature = translated geom
   139 000000B4 <res 00000001>      <2> fx_phys_sectors	resb    1       ;	byte fx_phys_sectors;	 physical number of sectors per track
   140 000000B5 <res 00000002>      <2> fx_LBA_high     resw    1       ;	word fx_LBA_high;	 high word of LBA28 number of sectors
   141 000000B7 <res 00000001>      <2> fx_reserved7    resb	1	;	byte fx_reserved;	 MBZ
   142 000000B8 <res 00000001>      <2> fx_drive_control resb   1       ;	byte fx_drive_control;	 flag bits for IDE head register
   143 000000B9 <res 00000002>      <2> fx_phys_cylinders resw	1	;	word fx_phys_cylinders;	 physical number of cylinders
   144 000000BB <res 00000001>      <2> fx_phys_heads	resb	1	;	byte fx_phys_heads;	 physical number of heads
   145 000000BC <res 00000002>      <2> fx_LBA_low	resw	1	;	word fx_LBA_low;	 low word of LBA28 number of sectors
   146 000000BE <res 00000001>      <2> fx_log_sectors	resb	1	;	byte fx_log_sectors;	 logical number of sectors per track
   147 000000BF <res 00000001>      <2> fx_checksum	resb	1	;	byte fx_checksum;	 checksum, dunno how to compute
   148 000000C0 <res 00000010>      <2> fx81            resb    16	;*/	struct EDD_disk fx81;	/* fixed disk parameter area 1
   149 000000D0 <res 00000010>      <2> fx82            resb    16	;*/	struct EDD_disk fx82;	/* fixed disk parameter area 2
   150 000000E0 <res 00000010>      <2> fx83            resb    16	;*/	struct EDD_disk fx83;	/* fixed disk parameter area 3
   151                              <2> ;
   152                              <2> ;
   153                              <2> 
   154 000000F0 <res 00000002>      <2> FPEM_segment    resw    1       ;*/	word FPEM_segment;	/* FPEM data segment
   155                              <2> 
   156 000000F2 <res 00000002>      <2> EBDA_paragraph  resw    1       ;*/	word EBDA_paragraph;	/* lowest EBDA paragraph
   157                              <2> 
   158 000000F4 <res 00000002>      <2> dma0_cw         resw    1       ;*/	word dma0_cw;		/* end of dma control word
   159 000000F6 <res 00000002>      <2> dma1_cw         resw    1       ;*/	word dma1_cw;		/*   ditto
   160                              <2> 
   161 000000F8 <res 00000002>      <2> fdc_type	resb	2	;*/	byte fdc_type[2];	/* disk type in low nibble, alternate in hi nib 
   162                              <2> 
   163 000000FA <res 00000004>      <2> debug_static_ptr  resw	2	;*/	void *debug_static_ptr;	/* pointer to debug static area
   164                              <2> 
   165 000000FE <res 00000001>      <2> n_fixed_disks   resb    1       ;*/	byte n_fixed_disks;	/* number of fixed disks
   166                              <2> 
   167 000000FF <res 00000001>      <2> cpu_xtal        resb    1       ;*/	byte cpu_xtal;		/* CPU crystal frequency in Mhz 
   168                              <2> ;								   CPU clock is half of this
   169                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   170                              <2> ;
   171                              <2> ;  System configuration stuff below
   172                              <2> ;	c.f., CONFIG.ASM (ANSI.CFG, CVDU.CFG, etc.), User configuration stuff
   173                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   174                              <2> %if 0				;*/
   175                              <2> #define FIXED_DISK_MAX 4		/*
   176                              <2> %else
   177                              <2> %define FIXED_DISK_MAX 4
   178                              <2> %endif
   179                              <2> %if 0				;*/
   180                              <2> #define PPIDE_driver 1		/*
   181                              <2> %else
   182                              <2> %define PPIDE_driver 1
   183                              <2> %endif
   184                              <2> %if 0				;*/
   185                              <2> #define DIDE_driver 1		/*
   186                              <2> %else
   187                              <2> %define DIDE_driver 1
   188                              <2> %endif
   189                              <2> %if 0				;*/
   190                              <2> #define DSD_driver 1		/*
   191                              <2> %else
   192                              <2> %define DSD_driver 1
   193                              <2> %endif
   194                              <2> 				;*/
    58                              <1> 
    59                              <1> ;  this must be the same in EQUATES.H */
    60                              <1> %if SOFT_DEBUG
    61                              <1> %define NBREAK  8
    62                              <1> %endif
    63                              <1> 
    64                              <1> 
    65                              <1> %if 0
    66                              <1>         segment _TEXT
    67                              <1> ;; *************************************************************************
    68                              <1> 
    69                              <1> 
    70                              <1> 
    71                              <1> 
    72                              <1> ;; ************************ DOS Data Segment *******************************
    73                              <1> ;dosdir	SEGMENT at 50h				; Boot disk directory from IPL
    74                              <1> ;xerox	label	byte				;  0 if Print Screen idle
    75                              <1> ;						;  1 if PrtSc xeroxing screen
    76                              <1> ;						;255 if PrtSc error in xerox
    77                              <1> ;						;  ...non-grafix PrtSc in bios
    78                              <1> ;	db	200h dup(?)			; PC-DOS bootstrap procedure
    79                              <1> ;						;  ...IBMBIO.COM buffers the
    80                              <1> ;						;  ...directory of the boot
    81                              <1> ;						;  ...device here at IPL time
    82                              <1> ;						;  ...when locating the guts
    83                              <1> ;						;  ...of the operating system
    84                              <1> ;						;  ...filename "IBMDOS.COM"
    85                              <1> ;dosdir	ends
    86                              <1> ;; *************************************************************************
    87                              <1> ;; ************************ DOS IPL Segment ********************************
    88                              <1> ;dosseg	SEGMENT at 70h				; "Kernel" of PC-DOS op sys
    89                              <1> ;;IBMBIO.COM file loaded by boot block. Device Drivers/Bootstrap. CONTIGUOUS<---
    90                              <1> ;;IBMDOS.COM operating system nucleus immediately follows IBMBIO.COM and       !
    91                              <1> ;;     doesn`t have to be contiguous.  The IBMDOS operating system nucleus     !
    92                              <1> ;;     binary image is loaded by transient code in IBMBIO binary image	      !
    93                              <1> ;dosseg	ends					;			      !
    94                              <1> ;iplseg	SEGMENT at 0h				; Segment for boot block      !
    95                              <1> ;;The following boot block is loaded with 512 bytes on the first sector of     !
    96                              <1> ;;the bootable device by code resident in the ROM-resident bios.  Control is   !
    97                              <1> ;;then transferred to the first word 0000:7C00 of the disk-resident bootstrap  !
    98                              <1> ;	ORG	07C00h				;  ..offset for boot block    !
    99                              <1> ;boot	db	200h dup(?)			;  ..start disk resident boot--
   100                              <1> ;iplseg	ends
   101                              <1> 
   102                              <1> %endif
    38                                  
    39                                  offset_BP	equ	0
    40                                  offset_BX	equ	offset_BP+2
    41                                  offset_DS	equ	offset_BX+2
    42                                  offset_IP	equ	offset_DS+2
    43                                  offset_CS	equ	offset_IP+2
    44                                  offset_FLAGS	equ	offset_CS+2
    45                                  
    46                                  
    47                                  	SEGMENT	_TEXT
    48                                  ;========================================================================
    49                                  ; BIOS call entry for keyboard service
    50                                  ;	int  16h
    51                                  ;========================================================================
    52                                  	global  BIOS_call_16h
    53                                  BIOS_call_16h:			; Keyboard service entry
    54 00000000 FB                      	sti			; Enable interrupts
    55 00000001 1E5355                  	pushm   bp,bx,ds	; Standard register save
    56 00000004 89E5                    	mov	bp,sp		; establish stack addressing
    57                                  
    58 00000006 6A40                    	push	bios_data_seg
    59 00000008 1F                      	popm	ds		; establish addressability
    60                                  
    61 00000009 88E3                    	mov     bl,ah		; set to index into dispatch table
    62 0000000B B700                    	mov	bh,0
    63                                  
    64 0000000D 80FB06                  	cmp     bl,.max/2
    65 00000010 7307                    	jae    	.testEnh
    66 00000012 01DB                    	add	bx,bx		; index words
    67 00000014 2EFFA7[2800]                cs	jmp     near [.dispatch+bx]
    68                                  
    69                                  .testEnh:
    70 00000019 80EB10                  	sub	bl,10h
    71 0000001C 80FB03                  	cmp	bl,.max10/2
    72 0000001F 7319                    	jae	err_exit
    73 00000021 01DB                    	add	bx,bx		; index words
    74 00000023 2EFFA7[3400]                cs	jmp	near [.dispatch10+bx]
    75                                  	
    76                                  .dispatch:
    77 00000028 [4300]                  	dw      fn00		; Read char from buffer, wait if empty
    78 0000002A [5F00]                  	dw      fn01		; Check buffer, do not clear
    79 0000002C [7700]                  	dw      fn02		; Return Keyboard flags in AL
    80 0000002E [3A00]                  	dw	err_exit	; Set Repeat Rate
    81 00000030 [3A00]                  	dw	err_exit	; Set Keyclick
    82 00000032 [8100]                  	dw	fn05		; Push Char and Scan Code in CX
    83                                  .max	equ     $-.dispatch
    84                                  
    85                                  .dispatch10:
    86 00000034 [4300]                  	dw	fn10		; Read Enhanced Keyboard
    87 00000036 [5F00]                  	dw	fn11		; Check Enh. kbd buffer
    88 00000038 [7C00]                  	dw	fn12		; Get Enh. kbd flags in AX
    89                                  .max10	equ	$-.dispatch10
    90                                  
    91                                  err_exit:
    92 0000003A 834E0A41                	or	word [offset_FLAGS+bp],41h	; set the Carry & Zero flags
    93                                  exit:
    94 0000003E 5D5B1F                  	popm	bp,bx,ds
    95 00000041 CF                      	iret
    96                                  
    97                                  ;========================================================================
    98                                  ; Function 00h - Read char from buffer, wait if empty
    99                                  ; Input:
   100                                  ;	AH = 00h	PC
   101                                  ;	AH = 10h	enhanced
   102                                  ; Output:
   103                                  ;	AH = scan code
   104                                  ;	AL = character
   105                                  ;========================================================================
   106                                  fn00w:
   107 00000042 F4                              hlt                     ; wait for interrupt
   108                                  ;;;	jmp	fn001
   109                                  fn00:
   110                                  fn10:
   111                                  
   112                                  fn001:
   113 00000043 8B1E1A00                	mov	bx,word [kbd_buffer_head]
   114 00000047 3B1E1C00                	cmp	bx,word [kbd_buffer_tail]
   115 0000004B 74F5                    	jz	fn00w		; buffer is empty - let's wait
   116 0000004D 8B07                    	mov	ax,word [bx]
   117                                  
   118 0000004F 43                      	inc	bx		; move kbd_buffer_head to the next location
   119 00000050 43                      	inc	bx
   120 00000051 83FB3E                  	cmp	bx,kbd_buffer_last
   121 00000054 7503                    	jne	.1
   122 00000056 BB1E00                  	mov	bx,kbd_buffer
   123                                  .1:
   124 00000059 891E1A00                	mov	word [kbd_buffer_head],bx
   125 0000005D EBDF                    	jmp	exit
   126                                  
   127                                  ;========================================================================
   128                                  ; Function 01h - Check buffer, do not clear
   129                                  ; Function 11h - Check Enhanced Keyboard buffer
   130                                  ; Input:
   131                                  ;	AH = 01h	PC
   132                                  ;	AH = 11h	enhanced
   133                                  ; Output:
   134                                  ;	ZF - clear if character in buffer
   135                                  ;		AH = scan code
   136                                  ;		AL = character
   137                                  ;	ZF - set if no character in buffer
   138                                  ;========================================================================
   139                                  fn01:
   140                                  fn11:
   141 0000005F 8B1E1A00                	mov	bx,word [kbd_buffer_head]
   142 00000063 3B1E1C00                	cmp	bx,word [kbd_buffer_tail]
   143 00000067 7408                    	jz	.1
   144 00000069 8B07                    	mov	ax,word [bx]
   145 0000006B 83660ABF                	and	word [bp+offset_FLAGS],~40h	; clear ZF in the stack
   146 0000006F EBCD                    	jmp	exit
   147                                  .1:
   148 00000071 834E0A40                	or	word [bp+offset_FLAGS],40h	; set ZF in the stack
   149 00000075 EBC7                    	jmp	exit
   150                                  
   151                                  ;========================================================================
   152                                  ; Function 02h - Return Keyboard Shift Key Status
   153                                  ; Function 12h - Return Enhanced Keyboard Shift/Alt/Ctrl/NumLock Status
   154                                  ; Input:
   155                                  ;	AH = 02h	PC-keyboard
   156                                  ;	AH = 12h	enhanced
   157                                  ; Output:
   158                                  ;	AL = shift status bits
   159                                  ;		0 = right shift key depressed
   160                                  ;		1 = left shift key depressed
   161                                  ;		2 = CTRL depressed
   162                                  ;		3 = ALT depressed
   163                                  ;		4 = SCROLL LOCK active
   164                                  ;		5 = NUM LOCK active
   165                                  ;		6 = CAPS LOCK active
   166                                  ;		7 = INSERT state active
   167                                  ;
   168                                  ;  and for Function 12h:
   169                                  ;	AX = enhanced keyboard status, above plus:
   170                                  ;		8 = left CTRL key down
   171                                  ;		9 = left ALT key down
   172                                  ;		10 = right CTRL key down
   173                                  ;		11 = right ALT key down
   174                                  ;		12 = SCROLL key is down
   175                                  ;		13 = NUM LOCK key is down
   176                                  ;		14 = CAPS LOCK key is down
   177                                  ;		15 = SYSREQ key is down
   178                                  ;
   179                                  ;========================================================================
   180                                  fn02:
   181 00000077 A01700                  	mov	al,byte [keyboard_flags_0]
   182 0000007A EBC2                    	jmp	exit
   183                                  fn12:
   184 0000007C A11700                  	mov	ax,word [keyboard_flags_0]
   185 0000007F EBBD                    	jmp	exit
   186                                  
   187                                  ;========================================================================
   188                                  ; Function 05h - Check buffer, do not clear
   189                                  ; Input:
   190                                  ;	AH = 05h
   191                                  ;	CH = scan code
   192                                  ;	CL = character
   193                                  ; Output:
   194                                  ;	CF - clear if successful
   195                                  ;	AL = 00h
   196                                  ;
   197                                  ;	CF - set if buffer full
   198                                  ;	AL = 01h
   199                                  ;========================================================================
   200                                  fn05:
   201 00000081 89C8                    	mov	ax,cx		; AX is argument to enqueue
   202 00000083 E81000                  	call	enqueue		; DS is bios_data_seg
   203 00000086 7205                    	jc	.2
   204 00000088 B80105                  	mov	ax,0501h
   205 0000008B EBAD                    	jmp	err_exit
   206                                  
   207 0000008D B80005                  .2:	mov	ax,0500h
   208 00000090 83660AFE                	and	word [offset_FLAGS+bp],~01h	; clear the carry
   209 00000094 EBA8                    	jmp	exit
   210                                  
   211                                  
   212                                  
   213                                  ;========================================================================
   214                                  ; enqueue - add a word in AX to the keyboard buffer
   215                                  ;
   216                                  ;  Input:
   217                                  ;	DS = bios data area pointer
   218                                  ;	AH = scan code
   219                                  ;	AL = character
   220                                  ;  Uses:
   221                                  ;	BX
   222                                  ;
   223                                  ;  Output:
   224                                  ;	the word is enqueued or discarded if buffer is full
   225                                  ;========================================================================
   226                                  enqueue:
   227                                  ; do we have space in the buffer?
   228 00000096 8B1E1C00                	mov	bx,word [kbd_buffer_tail]
   229 0000009A 43                      	inc	bx
   230 0000009B 43                      	inc	bx
   231 0000009C 83FB3E                  	cmp	bx,kbd_buffer_last
   232 0000009F 7503                    	jne	.3
   233 000000A1 BB1E00                  	mov	bx,kbd_buffer
   234                                  .3:
   235 000000A4 3B1E1A00                	cmp	bx,word [kbd_buffer_head]
   236 000000A8 7502                    	jne	.4
   237                                  			; no space in buffer, throw away char
   238                                  			; but check for the next one anyway
   239 000000AA F9                      	stc
   240 000000AB C3                      	ret		; Return with carry Set if no space
   241                                  
   242                                  .4:	; we have some space in the buffer
   243 000000AC 8B1E1C00                	mov	bx,word [kbd_buffer_tail]
   244 000000B0 8907                    	mov	word [bx],ax	; store ASCII and scan code to the buffer
   245 000000B2 43                      	inc	bx
   246 000000B3 43                      	inc	bx
   247 000000B4 83FB3E                  	cmp	bx,kbd_buffer_last
   248 000000B7 7503                    	jne	.5
   249 000000B9 BB1E00                  	mov	bx,kbd_buffer
   250                                  .5:
   251 000000BC 891E1C00                	mov	word [kbd_buffer_tail],bx
   252 000000C0 F8                      	clc		; Return with carry clear if A-okay
   253                                  ;;;.1:
   254 000000C1 C3                      	ret
   255                                  
   256                                  %if CVDU_8242
   257                                  ;========================================================================
   258                                  ; cvdu_kbd_int - Color VDU keyboard interrupt	MSDOS messes with this
   259                                  ; cvdu_kbd_hook - examine keyboard on every timer tick
   260                                  ;
   261                                  ;========================================================================
   262                                  %if CVDU_USE_KBD_HOOK
   263                                  	global	cvdu_kbd_hook
   264                                  cvdu_kbd_hook:
   265 000000C2 E84E01                  	call	I8242GetValue_
   266 000000C5 7301                    	jnc	.2
   267 000000C7 C3                      	ret
   268                                  .2:
   269 000000C8 061E60                  	pushm	all,ds,es	; save EVERYTHING
   270                                  .1:
   271                                  %else
   272                                  	global	cvdu_kbd_int
   273                                  cvdu_kbd_int:
   274                                  	pushm	all,ds,es	; save EVERYTHING
   275                                  .1:	call	I8242GetValue_
   276                                  ;;	cmp	ax,-1
   277                                  ;;	je	.exit
   278                                  	jc	.exit		; new return in flag
   279                                  
   280                                  %endif
   281                                  %if 1
   282 000000CB B44F                    	mov	AH,4Fh		; keyboard intercept
   283 000000CD CD15                    	int	15h
   284 000000CF 730E                    	jnc	.20		; scancode to be bypassed
   285                                  %endif
   286                                  
   287 000000D1 68[0000]                	push	DGROUP
   288 000000D4 1F                      	popm	ds		; establish addressability
   289                                  	extern	@I8242process
   290 000000D5 E8(0000)                	call	@I8242process	; convert to scan code // character
   291                                  
   292 000000D8 6A40                    	push	bios_data_seg
   293 000000DA 1F                      	popm	ds
   294                                  
   295 000000DB 09C0                    	or	ax,ax		; test for zero (unknown input)
   296 000000DD 7507                    	jnz	.21
   297                                  
   298                                  .20:
   299 000000DF E83101                  	call	I8242GetValue_
   300 000000E2 7217                    	jc	.exit
   301 000000E4 EBE5                    	jmp	.1
   302                                  .21:
   303 000000E6 3CE0                    	cmp	al,0E0h		; enhanced keyboard?
   304 000000E8 7502                    	jne	.3
   305 000000EA 30C0                    	xor	al,al		; old PC keyboard
   306                                  .3:
   307 000000EC 3D3412                  	cmp	ax,1234h	; Ctrl-Alt-DEL
   308 000000EF 7502                    	jne	.33
   309                                  %if 1
   310 000000F1 CD19                    	int	19h		; re-boot the system
   311                                  %else
   312                                  	mov	[warm_boot],ax	; set Warm Boot condition
   313                                  	jmp	0FFFFh:0000	; re-boot
   314                                  %endif
   315                                  
   316                                  .33:
   317 000000F3 E8A0FF                  	call	enqueue
   318 000000F6 C606150000              	mov	byte [uart_kbd_ctrl_R], 0
   319                                  	
   320                                  .exit:
   321                                  
   322                                  %if CVDU_USE_KBD_HOOK
   323                                  ;   Hook service
   324 000000FB 611F07                  	popm	all,ds,es
   325 000000FE C3                      	ret
   326                                  %else
   327                                  ;   Interrupt service
   328                                  ; signal EOI (End of Interrupt)
   329                                  	mov	dx,PIC_EOI	; EOI register
   330                                  	mov	ax,EOI_NSPEC	; non-specific
   331                                  	out	dx,ax		; signal it
   332                                  
   333                                  	popm	all,ds,es
   334                                  	iret
   335                                  %endif
   336                                  %endif
   337                                  
   338                                  
   339                                  ;========================================================================
   340                                  ; UART interrupt handler
   341                                  ; This routine does most of the keyboard driver work
   342                                  ;========================================================================
   343                                  	global	uart_int
   344                                  uart_int:
   345 000000FF 1E525350                	pushm	ax,bx,dx,ds
   346 00000103 6A40                    	push	bios_data_seg
   347 00000105 1F                      	popm	ds		; establish addressability
   348                                  .1:
   349 00000106 BA8506                  	mov	dx,uart_lsr
   350 00000109 EC                      	in	al,dx
   351 0000010A 2401                    	and	al,01h		; do we have any data in receive buffer?
   352 0000010C 742E                    	jz	int_exit
   353                                  
   354 0000010E BA8006                  	mov	dx,uart_rbr
   355 00000111 EC                      	in	al,dx		; get next character
   356                                  
   357 00000112 B400                    	mov	ah,0
   358 00000114 3C80                    	cmp	al,80h		; the ASCII code =< 80?
   359 00000116 73EE                    	jae	.1		; ignore, check for the next character
   360                                  %if SOFT_DEBUG
   361                                  	cmp	al,'B' & 01Fh	; ctrl-B
   362                                  	je	v.redbug
   363                                  %endif
   364 00000118 3C12                    	cmp	al,('R' & 01Fh)	; ctrl-R
   365 0000011A 750D                    	jne	.20
   366 0000011C FE061500                	inc	byte [uart_kbd_ctrl_R]
   367 00000120 803E150003              	cmp	byte [uart_kbd_ctrl_R], 3	; 3 ctrl-R's will re-boot
   368 00000125 7207                    	jb	.2
   369                                  %if 1
   370 00000127 CD19                    	int	19h		; does not return
   371                                  %else
   372                                  	mov	word [warm_boot],1234h		; signal warm boot
   373                                  	jmp	0FFFFh:0000h
   374                                  %endif
   375                                  .20:
   376 00000129 C606150000              	mov	byte [uart_kbd_ctrl_R], 0	; zero the re-boot count
   377                                  .2:
   378 0000012E 88C3                    	mov	bl,al		; find the scan code
   379 00000130 B700                    	mov	bh,0
   380 00000132 2E8AA7[4801]                cs	mov	ah,byte [ascii2scan+bx]
   381                                  
   382 00000137 E85CFF                      	call	enqueue
   383                                  
   384 0000013A EBCA                    	jmp	.1		; check for the next character
   385                                  
   386                                  int_exit:
   387                                  ; signal EOI (End of Interrupt)
   388 0000013C BA22FF                  	mov	dx,PIC_EOI	; EOI register
   389 0000013F B80080                  	mov	ax,EOI_NSPEC	; non-specific
   390 00000142 EF                      	out	dx,ax		; signal it
   391                                  
   392 00000143 585B5A1F                	popm	ax,bx,dx,ds
   393 00000147 CF                      	iret
   394                                  
   395                                  ; Debugging code added 10/17/2010 -- JRC
   396                                  ;  Use ctrl-B (^B) as immediate entry into the debugger
   397                                  %if SOFT_DEBUG
   398                                  	extern	redbug
   399                                  v.redbug:
   400                                  ; signal EOI (End of Interrupt)
   401                                  	mov	dx,PIC_EOI	; EOI register
   402                                  	mov	ax,EOI_NSPEC	; non-specific
   403                                  	out	dx,ax		; signal it
   404                                  ; restore the registers
   405                                  	popm	ax,bx,dx,ds
   406                                  ; keep the 'iret' block on the stack
   407                                  	jmp	redbug
   408                                  %endif
   409                                  
   410                                  ascii2scan:
   411                                  	;	NUL,SOH,STX,ETX,EOT,ENQ,ACL,BEL
   412 00000148 0000000000000000        	db	0,  0,  0,  0,  0,  0,  0,  0, 
   413                                  	;	BS, TAB,LF, VT, FF, CR, SO, SI
   414 00000150 0E0F0000001C0000        	db      0Eh,0Fh,0,  0,  0,  1Ch,0  ,0
   415                                  	;	DLE,DC1,DC2,DC3,DC4,NAK,SYN,ETB
   416 00000158 0000000000000000        	db	0,  0,  0,  0,  0,  0,  0,  0,
   417                                  	;	CAN,EM, SUB,ESC,FS, GS, RS, US
   418 00000160 0000000100000000        	db      0,  0,  0,  01h,0,  0,  0,  0,
   419                                  	;	 ,  !,  ",  #,  $,  %,  &,  '
   420 00000168 3902280405060828        	db	39h,02h,28h,04h,05h,06h,08h,28h
   421                                  	;	(,  ),  *,  +,  ,,  -,  .,  /  
   422 00000170 0A0B090D330C3435        	db	0Ah,0Bh,09h,0Dh,33h,0Ch,34h,35h
   423                                  	;	0,  1,  2,  3,  4,  5,  6,  7
   424 00000178 0B02030405060708        	db	0Bh,02h,03h,04h,05h,06h,07h,08h
   425                                  	;	8,  9,  :,  ;,  <,  =,  >,  ?
   426 00000180 090A2727330D3435        	db	09h,0Ah,27h,27h,33h,0Dh,34h,35h
   427                                  	;	@,  A,  B,  C,  D,  E,  F,  G
   428 00000188 031E302E20122122        	db	03h,1Eh,30h,2Eh,20h,12h,21h,22h
   429                                  	;	H,  I,  J,  K,  L,  M,  N,  O
   430 00000190 2317242526323118        	db	23h,17h,24h,25h,26h,32h,31h,18h
   431                                  	;	P,  Q,  R,  S,  T,  U,  V,  W
   432 00000198 1910131F14162F11        	db	19h,10h,13h,1Fh,14h,16h,2Fh,11h
   433                                  	;	X,  Y,  Z,  [,  \,  ],  ^,  _
   434 000001A0 2D152C1A2B1B070C        	db	2Dh,15h,2Ch,1Ah,2Bh,1Bh,07h,0Ch
   435                                  	;	`,  a,  b,  c,  d,  e,  f,  g
   436 000001A8 291E302E20122122        	db	29h,1Eh,30h,2Eh,20h,12h,21h,22h
   437                                  	;	h,  i,  j,  k,  l,  m,  n,  o
   438 000001B0 2317242526323118        	db	23h,17h,24h,25h,26h,32h,31h,18h
   439                                  	;	p,  q,  r,  s,  t,  u,  v,  w
   440 000001B8 1910131F14162F11        	db	19h,10h,13h,1Fh,14h,16h,2Fh,11h
   441                                  	;	x,  y,  z,  {,  |,  },  ~,  DEL
   442 000001C0 2D152C1A2B1B2953        	db	2Dh,15h,2Ch,1Ah,2Bh,1Bh,29h,53h
   443                                  	
   444                                  ;========================================================================
   445                                  ; keyboart_init - initialize keyboard
   446                                  ;========================================================================
   447                                  	global	keyboard_init
   448                                  keyboard_init:
   449 000001C8 061E60                  	pushm	all,ds,es	; was AX,DS,ES
   450                                  	
   451                                  %if CVDU_8242
   452 000001CB 6A40                    	push	bios_data_seg
   453 000001CD 1F                      	popm	ds
   454                                  
   455 000001CE C70617002000            	mov	word [keyboard_flags_0],CVDU_KEYBOARD_STATUS	; set NumLock Status early
   456                                  %endif
   457                                  
   458 000001D4 68[0000]                	push	DGROUP
   459 000001D7 1F                      	popm	ds
   460                                  %if CVDU_8242
   461                                  
   462                                  %if  1-CVDU_USE_KBD_HOOK
   463                                  	mov	dx,PIC_I0CON	; Int 0 control register
   464                                  	in	ax,dx
   465                                  ;jrc	or	al,10h		; set Level Trigger Mode
   466                                  	and	al,~8		; clear mask bit
   467                                  	out	dx,ax
   468                                  %endif
   469                                  
   470                                  	extern	Init8242_
   471 000001D8 E8(0000)                	call	Init8242_
   472                                  %endif
   473                                  
   474 000001DB 6A40                    	push	bios_data_seg
   475 000001DD 1F                      	popm	ds
   476                                  
   477 000001DE B81E00                  	mov	ax,kbd_buffer	; setup keyboard buffer
   478 000001E1 A31A00                  	mov	word [kbd_buffer_head],ax
   479 000001E4 A31C00                  	mov	word [kbd_buffer_tail],ax
   480                                  %if CVDU_8242==0
   481                                  	xor	ax,ax		; clear keyboard flags
   482                                  	mov	word [keyboard_flags_0],ax
   483                                  %endif
   484                                  
   485                                  %if UART
   486 000001E7 B001                    	mov	al,01h
   487 000001E9 BA8106                  	mov	dx,uart_ier
   488 000001EC EE                      	out	dx,al		; Enable interrupts on receive
   489                                  
   490 000001ED BA3AFF                  	mov	dx,PIC_I1CON	; Int 1 control register
   491 000001F0 ED                      	in	ax,dx
   492 000001F1 83E0F7                  	and	ax,~08h		; clear the mask bit
   493 000001F4 EF                      	out	dx,ax
   494                                  %endif
   495 000001F5 611F07                  	popm	all,ds,es
   496 000001F8 C3                      	ret
   497                                  
   498                                  ;========================================================================
   499                                  ; uart_getchar - Read char from buffer, wait if empty
   500                                  ; Input:
   501                                  ; 	none
   502                                  ; Output:
   503                                  ;	AL = character
   504                                  ;	AH = 0
   505                                  ;========================================================================
   506                                  	global	@uart_getchar
   507                                  @uart_getchar:
   508 000001F9 B400                    	mov	ah,0
   509 000001FB CD16                    	int	16h
   510 000001FD B400                    	mov	ah,0
   511 000001FF C3                      	ret
   512                                  
   513                                  
   514                                  %if CVDU_8242
   515                                  ;========================================================================
   516                                  ;  void I8242CommandPut(byte value);	
   517                                  ; Input:
   518                                  ;	AL = command byte
   519                                  ; Output:
   520                                  ;	none
   521                                  ;========================================================================
   522                                  	global I8242CommandPut_
   523                                  I8242CommandPut_:
   524 00000200 52                      	push	dx
   525 00000201 88C4                    	mov	ah,al		; save the command byte
   526 00000203 BAE104                  .1:	mov	dx,I8242status
   527 00000206 EC                      	in	al,dx
   528 00000207 A802                    	test	al,2
   529 00000209 75F8                    	jnz	.1
   530 0000020B BAE104                  	mov	dx,I8242command
   531 0000020E 88E0                    	mov	al,ah
   532 00000210 EE                      	out	dx,al
   533 00000211 5A                      	pop	dx
   534 00000212 C3                      	ret
   535                                  
   536                                  
   537                                  ;========================================================================
   538                                  ;  int I8242GetValue(void);
   539                                  ; Input:
   540                                  ;	none
   541                                  ; Output:
   542                                  ;	AX = -1		no value available (C-flag set)
   543                                  ;	AX = input byte	if available	   (C-flag clear)
   544                                  ;
   545                                  ;========================================================================
   546                                  	global	I8242GetValue_
   547                                  I8242GetValue_:
   548 00000213 52                      	push	dx
   549 00000214 BAE104                  	mov	dx,I8242status
   550 00000217 EC                      	in	al,dx
   551 00000218 A801                    	test	al,1
   552 0000021A 7408                    	jz	.7
   553 0000021C BAE004                  	mov	dx,I8242data
   554 0000021F EC                      	in	al,dx
   555 00000220 30E4                    	xor	ah,ah		; clear high byte for 'int' return
   556 00000222 EB04                    	jmp	.9
   557                                  .7:
   558 00000224 B8FFFF                  	mov	ax,-1
   559 00000227 F9                      	stc
   560 00000228 5A                      .9:	pop	dx
   561 00000229 C3                      	ret
   562                                  %endif
