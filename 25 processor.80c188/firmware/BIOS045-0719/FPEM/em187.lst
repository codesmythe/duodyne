     1                                  ; em187.asm -- special emulator for 80186/80187
     2                                  ;
     3                                  %define ABSLOAD 1
     4                                  %define even align 2
     5                                  
     6                                  ;;;        .list		; ignored by Watcom ASSembler
     7                                  ;page 64,160
     8                                  	cpu	186	;        .186
     9                                  
    10                                  
    11                                  %ifdef   LONG
    12                                             ; use BIG=1 to assemble for 64 bit mantissa
    13                                  %define BIG 1
    14                                  %else
    15                                             ; use BIG=0 to assemble for 32 bit mantissa
    16                                  %define BIG 0
    17                                  %endif
    18                                  
    19                                  
    20                                   	segment	_TEXT public align=2 class='CODE'
    21                                  ;;;	segment EM187_DATA public align=2 class='DATA'
    22                                  
    23                                  %include "..\config.asm"
     1                              <1> ;/*
     2                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     3                              <1> ; VGA3.CFG
     4                              <1> ;   Copied to CONFIG.ASM for general release.
     5                              <1> ;
     6                              <1> ;       Modify the parameters below to reflect your system
     7                              <1> ;
     8                              <1> ;
     9                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    10                              <1> ;
    11                              <1> ;   Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    12                              <1> ;   Provided for hobbyist use on the N8VEM SBC-188 board.
    13                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    14                              <1> ;
    15                              <1> ; Define the serial terminal that the Video BIOS must emulate
    16                              <1> ; Set one of the following to 1
    17                              <1> ; If you have no idea what to choose, set TTY to 1
    18                              <1> TTY     equ     0       ; hardcopy -- cannot position the cursor
    19                              <1> DUMB    equ     0       ; dumb CRT -- ^H, ^J, ^K, ^L can move the cursor
    20                              <1> ANSI    equ     1       ; very smart, like a VT-100
    21                              <1> WYSE    equ     0       ; very smart Wyse series (30, 50, ...)
    22                              <1> ; others may get added in the future
    23                              <1> ;  ONE OF THE ABOVE must BE SET TO 1!!!!!
    24                              <1> ;
    25                              <1> ; Does the hardware configuration contain the Color Video Display Unit?
    26                              <1> ; Both the 8563 and the 8242 are used.  The default is CVDU=0
    27                              <1> CVDU	equ	0	; system does not have the CVDU
    28                              <1> ;
    29                              <1> ; Does the hardware configuration contain the VGA3 a/n Video card?
    30                              <1> ; The 8563 will be disabled, but the 8242 code is shared with the CVDU
    31                              <1> ; The default is VGA3=0
    32                              <1> VGA3   equ     1       ; system has the VGA3
    33                              <1> ;
    34                              <1> ; Does the hardware configuration contain the front panel card?
    35                              <1> ; The default is FRONT_PANEL=0
    36                              <1> ;
    37                              <1> FRONT_PANEL   equ     1       ; system has the VGA3
    38                              <1> %if 0
    39                              <1> 	*/
    40                              <1> #define VGA3 1
    41                              <1> /*
    42                              <1> %endif
    43                              <1> ;
    44                              <1> ; Boot up keyboard mode:  20h for NumLock on
    45                              <1> ;CVDU_KEYBOARD_STATUS	equ	0	; NumLock OFF
    46                              <1> CVDU_KEYBOARD_STATUS	equ	20h	; NumLock ON
    47                              <1> 
    48                              <1> ; Define the UART startup bit rate - 1200-19200 are most common
    49                              <1> ;UART_RATE	equ	0		; 1200
    50                              <1> ;UART_RATE	equ	1		; 2400
    51                              <1> ;UART_RATE	equ	2		; 4800
    52                              <1> ;UART_RATE	equ	3		; 9600
    53                              <1> ;UART_RATE	equ	4		; 19200
    54                              <1> UART_RATE	equ	5		; 38400
    55                              <1> ;UART_RATE	equ	6		; 57600
    56                              <1> ;UART_RATE	equ	7		; 115200
    57                              <1> 
    58                              <1> ; Does the serial terminal use the DSR/DTR protocol for flow control?
    59                              <1> ;UART_DSR_PROTOCOL	equ		1	; Yes!
    60                              <1> UART_DSR_PROTOCOL       equ             WYSE    ; Wyse always uses it
    61                              <1> 						; but not ANSI
    62                              <1> ; Define the size of the ROM image on the system in Kilobytes
    63                              <1> ; It may be smaller than the actual EPROM in use.
    64                              <1> ; The following sizes are supported:  32, 64, 128, and 256
    65                              <1> %ifndef ROM
    66                              <1> ROM             equ     32              ; 64 is the default
    67                              <1> %endif
    68                              <1> 
    69                              <1> ; Define the number of Wait States at which the ROM operates
    70                              <1> ROM_WS          equ     1               ; 0..3  (1 is the default)
    71                              <1> 
    72                              <1> ; Define the size in Kilobytes of DOS RAM (low SRAM plus EMM allocate RAM)
    73                              <1> ; This is a desired size and will only be present if a 4MEM board is added
    74                              <1> RAM_DOS         equ     640
    75                              <1> 
    76                              <1> ; Define the size of the low SRAM on the system in Kilobytes
    77                              <1> ; the default is 512 kilobytes
    78                              <1> RAM             equ     512             ; (512 is the default)
    79                              <1> 
    80                              <1> ; Define the number of Wait States at which the RAM operates
    81                              <1> RAM_WS          equ     0               ; 0..3  (0 is the default)
    82                              <1> 
    83                              <1> ; Define the number of Wait States for Local Peripheral devices (600-7FF)
    84                              <1> LCL_IO_WS       equ     1               ; 0..3  (1 is the default)
    85                              <1> 
    86                              <1> ; Define the number of Wait States for ECB BUS peripheral devices (4xx)
    87                              <1> BUS_IO_WS       equ     3               ; 0..3  (3 is the default)
    88                              <1> 
    89                              <1> ; Define the time zone in which we build the Relocatable BIOS
    90                              <1> %ifndef TIMEZONE
    91                              <1> %define TIMEZONE "CDT"
    92                              <1> %endif
    93                              <1> 
    94                              <1> ; Has the REDBUG debugger been loaded?
    95                              <1> %ifndef SOFT_DEBUG
    96                              <1> %define SOFT_DEBUG 0
    97                              <1> %endif
    98                              <1> 
    99                              <1> ; Should the BIOS include "Tiny BASIC" in the image?
   100                              <1> %ifndef TBASIC
   101                              <1> TBASIC          equ     1		; default is 1
   102                              <1> %endif
   103                              <1> 
   104                              <1> ; Should the BIOS include the Floating Point Emulator?  The 80188 does
   105                              <1> ; not allow a floating point co-processor, so this is probably a good idea.
   106                              <1> %ifndef FPEM
   107                              <1> FPEM            equ     1               ; default is 1
   108                              <1> %endif
   109                              <1> 
   110                              <1> ; Define the maximum number of EMM (4MEM) boards supported
   111                              <1> EMM_BOARDS      equ     4
   112                              <1> 
   113                              <1> ; Should the Floating Point Emulator use temporary storage in the EBDA
   114                              <1> ; or at locations 0280h..3FFh in low memory?
   115                              <1> %if SOFT_DEBUG
   116                              <1> FPEM_USE_EBDA   equ     FPEM            ; default is 0
   117                              <1> %else
   118                              <1> FPEM_USE_EBDA   equ     0; FPEM            ; default is 0
   119                              <1> %endif
   120                              <1> 
   121                              <1> ; Define the size of the EPROM that is to be installed on the system
   122                              <1> ; It may be larger than the actual ROM image to be generated.
   123                              <1> %ifndef CHIP
   124                              <1> CHIP            equ     64
   125                              <1> %endif
   126                              <1> 
   127                              <1> ; Does the SBC-188 00.4 board have the LS138/LS08 piggyback fix
   128                              <1> ; Set to 1 for the SBC-188 v1.0 and later production boards
   129                              <1> FDC_PIGGYBACK_FIX       equ     0       ; Fix not installed
   130                              <1> ;FDC_PIGGYBACK_FIX       equ     1       ; fix  IS  installed
   131                              <1> 
   132                              <1> ; On SBC-188 rev 00.4 board, there is a published hardware fix (2010-09-18).
   133                              <1> ; If the wiring update is installed, or you have a later board, then
   134                              <1> ; set this to 0.  If you are using the software workaround, then set this
   135                              <1> ; to 1.  The rev 1.0 board has this fix already.
   136                              <1> NEED_TIMER_FIX  equ     0               ; have revised hardware
   137                              <1> ;NEED_TIMER_FIX  equ     1               ; use workaround
   138                              <1> 
   139                              <1> ; Define the UART oscillator speed
   140                              <1> UART_OSC        equ     1843200         ; 1.8432 Mhz is specified
   141                              <1> 
   142                              <1> 
   143                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   144                              <1> ; end of the User configuration
   145                              <1> ;       Do Not modify anything below this point
   146                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   147                              <1> 
   148                              <1> CVDU_8563	equ	CVDU		; separate inits
   149                              <1> CVDU_8242	equ	CVDU|VGA3 	; separate inits
   150                              <1> VGA3_6445       equ     VGA3            ; separate inits
   151                              <1> ; Suppress all UART output in color video Mode 3
   152                              <1> ;UART_MODE3_SUPPRESS	equ	0
   153                              <1> UART_MODE3_SUPPRESS	equ	CVDU_8563 | VGA3_6445
   154                              <1> CVDU_USE_MSDOS_KLUDGE	equ	0; CVDU_8242	; bad, bad MSDOS
   155                              <1> CVDU_USE_KBD_HOOK		equ	CVDU_8242
   156                              <1> 
   157                              <1> ; Define existence of any uart chip
   158                              <1> UART		equ	TTY+DUMB+ANSI+WYSE
   159                              <1> startuplength   equ     128                     ; may be up to 1024
   160                              <1> startseg        equ     0FFFFh - (ROM*64) + 1
   161                              <1> highrom         equ     (ROM*400h)&0FFFFh
   162                              <1> startupseg      equ     0FFFFh - (startuplength>>4) + 1
   163                              <1> bios_data_seg   equ     040h            ; segment of BIOS data area
   164                              <1> 
   165                              <1> 
   166                              <1> %define ARG(n) [bp+2+(n)*2]
   167                              <1> 
   168                              <1> %macro  check   1.nolist
   169                              <1>  %if (%1)
   170                              <1>    %error Check Failure: %1
   171                              <1>  %endif
   172                              <1> %endm
   173                              <1> %macro  range   3.nolist
   174                              <1>  %if (%1)<(%2)
   175                              <1>    %error Out of Range: %1
   176                              <1>  %elif (%1)>(%3)
   177                              <1>    %error Out of Range: %1
   178                              <1>  %endif
   179                              <1> %endm
   180                              <1> _terminal equ UART+CVDU
   181                              <1>  check   RAM_DOS&15
   182                              <1>  check   RAM&(RAM-1)
   183                              <1>  check   ROM&(ROM-1)
   184                              <1>  range   RAM,32,512
   185                              <1>  range   ROM,32,256
   186                              <1>  range   RAM_WS,0,3
   187                              <1>  range   ROM_WS,0,3
   188                              <1>  range   RAM_DOS,RAM,(1024-ROM)
   189                              <1>  range   LCL_IO_WS,0,3
   190                              <1>  range   BUS_IO_WS,0,3
   191                              <1>  range   UART_OSC,500000,16000000
   192                              <1>  range   UART_RATE,0,7
   193                              <1>  range	 UART,0,1
   194                              <1>  range	 _terminal,1,2
   195                              <1> 
   196                              <1> %ifndef SOFT_DEBUG
   197                              <1> %define SOFT_DEBUG 0
   198                              <1> %endif
   199                              <1> 
   200                              <1> %ifndef TRACE
   201                              <1> %define TRACE 0
   202                              <1> %endif
   203                              <1> 
   204                              <1> %ifdef MAKE_OBJECT_FILE
   205                              <1>         segment _DATA WORD PUBLIC CLASS=DATA
   206                              <1>         export _ROMsize
   207                              <1>         export _CHIPsize
   208                              <1> _ROMsize        dw      ROM
   209                              <1> _CHIPsize       dw      CHIP
   210                              <1> %endif
   211                              <1> ; end of the Hardware configuration file
   212                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   213                              <1> ;*/
    24                                  %include "..\bda.inc"
     1                              <1> ;/*======================================================================
     2                              <1> ; bda.inc -- BIOS data area definitions
     3                              <1> ;========================================================================
     4                              <1> ;   for the N8VEM SBC-188
     5                              <1> ;
     6                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
     7                              <1> ;
     8                              <1> ; Copyright (C) 2013 John R. Coffman.  All rights reserved.
     9                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    10                              <1> ;
    11                              <1> ; This program is free software: you can redistribute it and/or modify
    12                              <1> ; it under the terms of the GNU General Public License as published by
    13                              <1> ; the Free Software Foundation, either version 3 of the License, or
    14                              <1> ; (at your option) any later version.
    15                              <1> ;
    16                              <1> ; This program is distributed in the hope that it will be useful,
    17                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    18                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    19                              <1> ; GNU General Public License for more details.
    20                              <1> ;
    21                              <1> ; You should have received a copy of the GNU General Public License
    22                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    23                              <1> ;
    24                              <1> ;========================================================================
    25                              <1> 
    26                              <1> 			;*/ extern				/*
    27                              <1> 	ABSOLUTE  0	;*/ struct BDA {			/*
    28 00000000 <res 00000008>      <1> serial_ports    resw    4	;*/	word	serial_ports[4];	/*
    29 00000008 <res 00000008>      <1> parallel_ports  resw    4	;*/	word	parallel_ports[4];	/*
    30 00000010 <res 00000002>      <1> equipment_flag  resw    1	;*/	EQFL	equipment_flag;		/*
    31                              <1> ;	dw	?		; 40:10 	; Equipment present word
    32                              <1> ;  						;  = (1 iff floppies) *     1.
    33                              <1> ;                                               ;  + (1 iff 187     ) *     2.
    34                              <1> ;  						;  + (#+1 64K sys ram) *    4.
    35                              <1> ;  						;  + (init crt mode ) *    16.
    36                              <1> ;  						;  + (# of floppies ) *    64.
    37                              <1> ;  						;  + (# serial ports) *   512.
    38                              <1> ;  						;  + (1 iff toy port) *  4096.
    39                              <1> ;                                               ;  + (1 iff modem   ) *  8192.
    40                              <1> ;  						;  + (# parallel LPT) * 16384.
    41 00000012 <res 00000001>      <1> mfg_test_flags  resb    1	;*/	byte	mfg_test_flags;	/* 40:12 unused by us
    42 00000013 <res 00000002>      <1> memory_size     resw    1	;*/	word	memory_size;	/* 40:13 kilobytes
    43                              <1> uart_kbd_ctrl_R	equ	$	;*/				/*** JRC: count of ctrl-R's for reboot
    44 00000015 <res 00000001>      <1> IPL_errors      resb    1	;*/	byte	IPL_errors;	/* 40:15 IPL errors<-table/scratchpad
    45 00000016 <res 00000001>      <1> unused_01       resb    1	;*/	byte	unused_01;	/*
    46                              <1> ;;---------------[Keyboard data area]------------;
    47 00000017 <res 00000002>      <1> keyboard_flags_0 resw   1	;*/	word	keyboard_flags_0;  /* 40:17 Shift/Alt/etc. keyboard flags
    48                              <1> keyboard_flags_1 equ	$-1	;     2nd byte	keyboard_flags_1;  
    49 00000019 <res 00000001>      <1> keypad_char	resb	1	;*/	byte	keypad_char;	/* 40:19 Alt-KEYPAD char. goes here
    50 0000001A <res 00000002>      <1> kbd_buffer_head resw    1	;*/	word	kbd_buffer_head;   /* 40:1A --> keyboard buffer head
    51 0000001C <res 00000002>      <1> kbd_buffer_tail resw    1	;*/	word	kbd_buffer_tail;   /* 40:1C --> keyboard buffer tail
    52 0000001E <res 00000020>      <1> kbd_buffer      resw    16	;*/	word	kbd_buffer[16];	/* 40:1E Keyboard Buffer (Scan,Value)
    53                              <1> kbd_buffer_last	equ	$	;*/				/*
    54                              <1> ;;---------------[Diskette data area]------------;
    55 0000003E <res 00000001>      <1> fdc_drv_calib   resb    1	;*/	byte	fdc_drive_calib;   /* 40:3E
    56 0000003F <res 00000001>      <1> fdc_motor_LDOR  resb    1	;*/	byte	fdc_motor_LDOR;	   /* 40:3F Motor, DMA, select control
    57 00000040 <res 00000001>      <1> fdc_motor_ticks resb    1	;*/	byte	fdc_motor_ticks;   /* 40:40 ticks til motor off
    58 00000041 <res 00000001>      <1> fdc_status      resb    1	;*/	byte	fdc_status;	   /* 40:41
    59                              <1> ;				Floppy return code stat byte
    60                              <1> ;				;  1 = bad ic 765 command req.
    61                              <1> ;				;  2 = address mark not found
    62                              <1> ;				;  3 = write to protected disk
    63                              <1> ;				;  4 = sector not found
    64                              <1> ;				;  8 = data late (DMA overrun)
    65                              <1> ;				;  9 = DMA failed 64K page end
    66                              <1> ;				; 16 = bad CRC on floppy read
    67                              <1> ;				; 32 = bad NEC 765 controller
    68                              <1> ;				; 64 = seek operation failed
    69                              <1> ;				;128 = disk drive timed out
    70 00000042 <res 00000007>      <1> fdc_ctrl_status resb    7	;*/	byte	fdc_ctrl_status[7];  /* 40:42 Status bytes from NEC 765
    71                              <1> ;;---------------[Video display area]------------;
    72 00000049 <res 00000001>      <1> video_mode      resb    1	;*/	byte	video_mode;	/* 40:49
    73                              <1> ;			 	; Current CRT mode  (software)
    74                              <1> ;				;  0 = 40 x 25 text (no color)
    75                              <1> ;				;  1 = 40 x 25 text (16 color)
    76                              <1> ;				;  2 = 80 x 25 text (no color)
    77                              <1> ;				;  3 = 80 x 25 text (16 color)
    78                              <1> ;				;  4 = 320 x 200 grafix 4 color
    79                              <1> ;				;  5 = 320 x 200 grafix 0 color
    80                              <1> ;				;  6 = 640 x 200 grafix 0 color
    81                              <1> ;				;  7 = 80 x 25 text (mono card)
    82 0000004A <res 00000002>      <1> video_columns   resw    1	;*/	word video_columns;	/* 40:4A Columns on CRT screen
    83 0000004C <res 00000002>      <1> video_regen_bytes  resw 1	;*/	word video_regen_bytes;	/* 40:4C Bytes in the regen region
    84 0000004E <res 00000002>      <1> video_regen_offset resw 1	;*/	word video_regen_offset;/* 40:4E Byte offset in regen region
    85 00000050 <res 00000010>      <1> video_cursor_pos  resw  8	;*/	word video_cursor_pos[8];  /* 40:50 Cursor pos for up to 8 pages
    86 00000060 <res 00000002>      <1> video_cursor_mode resw  1	;*/	word video_cursor_mode;	/* 40:60 Current cursor mode setting
    87 00000062 <res 00000001>      <1> video_page      resb    1	;*/	byte video_page;	/* 40:62 Current page on display
    88 00000063 <res 00000002>      <1> video_base_seg  resw    1	;*/	word video_base_seg;	/* 40:63 Base address (B000h or B800h)
    89 00000065 <res 00000001>      <1> video_hw_mode   resb    1	;*/	byte video_hw_mode;	/* 40:65 ic 6845 mode reg. (hardware)
    90 00000066 <res 00000001>      <1> video_cga_palette resb  1	;*/	byte video_cga_palette;	/* 40:66 Current CGA palette
    91                              <1> ;;---------------[Used to setup ROM]-------------;
    92 00000067 <res 00000004>      <1> eprom_address   resd    1	;*/	dword eprom_address;	/* 40:67 Eprom base Offset,Segment
    93 0000006B <res 00000001>      <1> spurious_irq    resb    1	;*/	byte spurious_irq;	/* 40:6B Last spurious interrupt IRQ
    94                              <1> ;;---------------[Timer data area]---------------;
    95 0000006C <res 00000004>      <1> timer_ticks     resd    1	;*/	dword timer_ticks;	/* 40:6C Ticks since midnight (lo,hi)
    96 00000070 <res 00000001>      <1> timer_new_day   resb    1	;*/	byte timer_new_day;	/* 40:70 Non-zero if new day
    97                              <1> ;;---------------[System data area]--------------;
    98 00000071 <res 00000001>      <1> break_flag      resb    1	;*/	byte break_flag;	/* 40:71 Sign bit set iff break
    99 00000072 <res 00000002>      <1> warm_boot       resw    1	;*/	word warm_boot;		/* 40:72 Warm boot iff==1234h
   100                              <1> ;;---------------[Hard disk scratchpad]----------;
   101 00000074 <res 00000004>      <1> hdd_scratch     resd    1	;*/	word hdd_scratch[2];	/* 40:74
   102                              <1> ;;---------------[Timout areas/PRT/LPT]----------;
   103 00000078 <res 00000004>      <1> lpt_timeout     resb    4	;*/	byte lpt_timeout[4];	/* 40:78 Ticks for LPT 1-4 timeouts
   104 0000007C <res 00000004>      <1> com_timeout     resb    4	;*/	byte com_timeout[4];	/* 40:7C Ticks for COM 1-4 timeouts
   105                              <1> ;;---obsolete----[Keyboard buf start/end]---jrc--;
   106 00000080 <res 00000002>      <1> kbd_buffer_start resw   1	;*/	word kbd_buffer_start;	/* 40:80 KBD buffer head (PC/AT)
   107 00000082 <res 00000002>      <1> kbd_buffer_end  resw    1	;*/	word kbd_buffer_end;	/* 40:82 KBD buffer tail (PC/AT)
   108                              <1> ;;---------------[EGA stuff]---------------------;
   109 00000084 <res 00000007>      <1> EGA_stuff	resb	7	;*/	byte EGA_stuff[7];	/* 40:84 Unspecified EGA data
   110                              <1> ;;---------------[Floppy/Fixed Media Info]-------------;
   111 0000008B <res 00000001>      <1> fdc_last_rate	resb	1	;*/	byte fdc_last_rate;	/* 40:8B Last floppy step rate/data rate?
   112 0000008C <res 00000004>      <1> fx_misc_unused	resb	4	;*/	byte fx_misc_unused[4];	/* 40:8C Fixed disk miscellaneous ???
   113 00000090 <res 00000002>      <1> fdc_disk_state	resb	2	;*/	byte fdc_disk_state[2];	/* 40:90 Floppy disk state
   114 00000092 <res 00000002>      <1> fdc_op_start	resb	2	;*/	byte fdc_op_start[2];	/* 40:92 Floppy operation start state machine
   115 00000094 <res 00000002>      <1> fdc_cylinder	resb	2	;*/	byte fdc_cylinder[2];	/* 40:94 Floppy present cylinder
   116                              <1> ;;---------------[Additional KBD flags]----------------;
   117 00000096 <res 00000001>      <1> kbd_flag_3	resb	1	;*/	byte kbd_flag_3;	/* 40:96 kbd ???
   118 00000097 <res 00000001>      <1> kbd_flag_2	resb	1	;*/	byte kbd_flag_2;	/* 40:97 kbd ???
   119                              <1> ;;---------------[RTC/timer1 data]---------------------;
   120 00000098 <res 00000004>      <1> user_semaphore	resw	2	;*/	byte *user_semaphore;	/* 40:98 User semaphore in (bit 7)
   121 0000009C <res 00000004>      <1> rtc_count	resd	1	;*/	dword rtc_count;	/* 40:9C RTC tick counter
   122 000000A0 <res 00000001>      <1> rtc_wait_active	resb	1	;*/	byte rtc_wait_active;	/* 40:A0 Busy=01, Posted=80h, 
   123                              <1> ;;---------------[Cassette I/O stuff]------------------;
   124 000000A1 <res 00000001>      <1> last_val	resb	1	;*/	byte last_val;		/* 40:A1 Last byte read value
   125 000000A2 <res 00000002>      <1> crc_reg		resw	1	;*/	word crc_reg;		/* 40:A2 CRC accumulation area
   126                              <1> ;									Post Acknowleged=00;
   127 000000A4 <res 00000001>      <1> EGA_data	resb	1	;*/	byte EGA_data;		/* 40:A4 Various usage
   128 000000A5 <res 00000002>      <1> SDstatus	resb	2	;*/	byte SDstatus[2];	/* 40:A5 Status byte from command
   129 000000A7 <res 00000002>      <1> SDcardtype	resb	2	;*/	byte SDcardtype[2];	/* 40:A7 SDcard type SDSC=2, HC=3, ...
   130                              <1> ;
   131 000000A9 <res 00000004>      <1> fixed_disk_tab	resb	4	;*/	byte fixed_disk_tab[4];	/* dispatch table to fixed disk drivers
   132 000000AD <res 00000001>      <1> wait12_count	resb	1	;*/	byte wait12_count;	/* 40:AD 12usec CX count
   133 000000AE <res 00000001>      <1> lock_count	resb	1	;*/	byte lock_count;	/* 40:AE lock level counter
   134 000000AF <res 00000001>      <1> EMS_start       resb    1	;*/	byte EMS_start;		/* start EMS allocation from here
   135                              <1> fx80		equ	$	;*/	struct EDD_disk fx80;	/* fixed disk parameter area 0
   136 000000B0 <res 00000002>      <1> fx_log_cylinders resw   1	;	word fx_log_cylinders;	 logical number of cylinders
   137 000000B2 <res 00000001>      <1> fx_log_heads    resb    1	;	byte fx_log_heads;	 logical number of heads
   138 000000B3 <res 00000001>      <1> fx_signature	resb	1	;	byte fx_signature;	 A0h signature = translated geom
   139 000000B4 <res 00000001>      <1> fx_phys_sectors	resb    1       ;	byte fx_phys_sectors;	 physical number of sectors per track
   140 000000B5 <res 00000002>      <1> fx_LBA_high     resw    1       ;	word fx_LBA_high;	 high word of LBA28 number of sectors
   141 000000B7 <res 00000001>      <1> fx_reserved7    resb	1	;	byte fx_reserved;	 MBZ
   142 000000B8 <res 00000001>      <1> fx_drive_control resb   1       ;	byte fx_drive_control;	 flag bits for IDE head register
   143 000000B9 <res 00000002>      <1> fx_phys_cylinders resw	1	;	word fx_phys_cylinders;	 physical number of cylinders
   144 000000BB <res 00000001>      <1> fx_phys_heads	resb	1	;	byte fx_phys_heads;	 physical number of heads
   145 000000BC <res 00000002>      <1> fx_LBA_low	resw	1	;	word fx_LBA_low;	 low word of LBA28 number of sectors
   146 000000BE <res 00000001>      <1> fx_log_sectors	resb	1	;	byte fx_log_sectors;	 logical number of sectors per track
   147 000000BF <res 00000001>      <1> fx_checksum	resb	1	;	byte fx_checksum;	 checksum, dunno how to compute
   148 000000C0 <res 00000010>      <1> fx81            resb    16	;*/	struct EDD_disk fx81;	/* fixed disk parameter area 1
   149 000000D0 <res 00000010>      <1> fx82            resb    16	;*/	struct EDD_disk fx82;	/* fixed disk parameter area 2
   150 000000E0 <res 00000010>      <1> fx83            resb    16	;*/	struct EDD_disk fx83;	/* fixed disk parameter area 3
   151                              <1> ;
   152                              <1> ;
   153                              <1> 
   154 000000F0 <res 00000002>      <1> FPEM_segment    resw    1       ;*/	word FPEM_segment;	/* FPEM data segment
   155                              <1> 
   156 000000F2 <res 00000002>      <1> EBDA_paragraph  resw    1       ;*/	word EBDA_paragraph;	/* lowest EBDA paragraph
   157                              <1> 
   158 000000F4 <res 00000002>      <1> dma0_cw         resw    1       ;*/	word dma0_cw;		/* end of dma control word
   159 000000F6 <res 00000002>      <1> dma1_cw         resw    1       ;*/	word dma1_cw;		/*   ditto
   160                              <1> 
   161 000000F8 <res 00000002>      <1> fdc_type	resb	2	;*/	byte fdc_type[2];	/* disk type in low nibble, alternate in hi nib 
   162                              <1> 
   163 000000FA <res 00000004>      <1> debug_static_ptr  resw	2	;*/	void *debug_static_ptr;	/* pointer to debug static area
   164                              <1> 
   165 000000FE <res 00000001>      <1> n_fixed_disks   resb    1       ;*/	byte n_fixed_disks;	/* number of fixed disks
   166                              <1> 
   167 000000FF <res 00000001>      <1> cpu_xtal        resb    1       ;*/	byte cpu_xtal;		/* CPU crystal frequency in Mhz 
   168                              <1> ;								   CPU clock is half of this
   169                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   170                              <1> ;
   171                              <1> ;  System configuration stuff below
   172                              <1> ;	c.f., CONFIG.ASM (ANSI.CFG, CVDU.CFG, etc.), User configuration stuff
   173                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   174                              <1> %if 0				;*/
   175                              <1> #define FIXED_DISK_MAX 4		/*
   176                              <1> %else
   177                              <1> %define FIXED_DISK_MAX 4
   178                              <1> %endif
   179                              <1> %if 0				;*/
   180                              <1> #define PPIDE_driver 1		/*
   181                              <1> %else
   182                              <1> %define PPIDE_driver 1
   183                              <1> %endif
   184                              <1> %if 0				;*/
   185                              <1> #define DIDE_driver 1		/*
   186                              <1> %else
   187                              <1> %define DIDE_driver 1
   188                              <1> %endif
   189                              <1> %if 0				;*/
   190                              <1> #define DSD_driver 1		/*
   191                              <1> %else
   192                              <1> %define DSD_driver 1
   193                              <1> %endif
   194                              <1> 				;*/
    25                                  %include  "em187d.asm"
     1                              <1> ; em187d.asm -- definitions for em187.asm
     2                              <1> 
     3                              <1> ; define the structure of a floating point accumulator
     4                              <1> 
     5                              <1> ;ACCUM   struc
     6                              <1> 	struc	ACCUM
     7 00000000 <res 00000001>      <1> tag     resb	1
     8 00000001 <res 00000001>      <1> sign    resb	1
     9 00000002 <res 00000002>      <1> expon   resw	1
    10 00000004 <res 00000002>      <1> mantis  resw	1           ; high order word in low address
    11 00000006 <res 00000002>      <1>         resw	1
    12                              <1> %if  BIG
    13 00000008 <res 00000002>      <1>         resw	1           ; lower order words in higher addresses
    14 0000000A <res 00000002>      <1>         resw	1
    15                              <1> %endif
    16                              <1> lenACCUM	equ	$
    17                              <1> ;ACCUM   ends
    18                              <1> ;	endstruc
    19                              <1> 
    20                              <1> ; define the condition code bits
    21                              <1> C3      equ     40H
    22                              <1> C2      equ     04H
    23                              <1> C1      equ     02H
    24                              <1> C0      equ     01H
    25                              <1> 
    26                              <1> ; define the tag conditions
    27                              <1> tag_valid   equ     0
    28                              <1> tag_zero    equ     1
    29                              <1> tag_infin   equ     2
    30                              <1> tag_empty   equ     3
    31                              <1> tag_invalid equ     6
    32                              <1> 
    33                              <1> ;define the funny exponent internal zero has
    34                              <1> exp_of_FPzero   equ   8001H         ;minimum negative number
    35                              <1> exp_of_FPinf    equ   7FFFH         ;maximum positive number
    36                              <1> 
    37                              <1> ;define the instruction bits
    38                              <1> Rbit        equ     4               ;reverse source and destination
    39                              <1> Pbit        equ     2               ;pop bit
    40                              <1> FMbits      equ     6               ;memory format bits
    41                              <1> 
    42                              <1> ;define the exception bits
    43                              <1> Iexcept     equ     1       ;invalid operation
    44                              <1> Dexcept     equ     2       ;denormalized operand
    45                              <1> Zexcept     equ     4       ;zero divide
    46                              <1> Oexcept     equ     8       ;overflow
    47                              <1> Uexcept     equ    10h      ;underflow
    48                              <1> Pexcept     equ    20h      ;precision
    49                              <1> 
    50                              <1> Sflag       equ    40h      ;stack flag     (new with 80187)
    51                              <1> Estatus     equ    80h      ;error summary status
    52                              <1> 
    53                              <1> ;define the high order error codes
    54                              <1> errUnemulated   equ     0100h   ;unemulated operation
    55                              <1> errSqrt         equ     0200h   ;error in SQRT
    56                              <1> ;unassigned
    57                              <1> errStkOverflow  equ     0800h   ;
    58                              <1> errStkUnderflow equ     1000h   ;
    59                              <1> 
    60                              <1> ;define the layout of the saved registers
    61                              <1> v7_regs equ   0
    62                              <1> v7_ds   equ     v7_regs
    63                              <1> v7_ss   equ     v7_ds+2
    64                              <1> v7_es   equ     v7_ss+2
    65                              <1> 
    66                              <1> v7_di   equ     v7_es+2
    67                              <1> v7_si   equ     v7_di+2
    68                              <1> v7_bp   equ     v7_si+2
    69                              <1> v7_sp   equ     v7_bp+2
    70                              <1> v7_bx   equ     v7_sp+2
    71                              <1> v7_dx   equ     v7_bx+2
    72                              <1> v7_cx   equ     v7_dx+2
    73                              <1> v7_ax   equ     v7_cx+2
    74                              <1> 
    75                              <1> v7_ip   equ     v7_ax+2
    76                              <1> v7_cs   equ     v7_ip+2
    77                              <1> v7_flag equ     v7_cs+2
    78                              <1> 
    79                              <1> CR      equ     0dH             ;carriage return
    80                              <1> LF      equ     0aH             ;line feed
    81                              <1> 
    82                              <1> ; end em187d.asm
    26                                  
    27                                  
    28                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    29                                  ;  The following are handled by "bda.inc"
    30                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    31                                  
    32                                  ;bios_data_seg	equ	40h	; BIOS data area segment
    33                                  
    34                                  ;  FPEM_segment	equ	0E6h	; use '../sizer' to determine
    35                                  ;        extrn  FPEM_segment:near
    36                                  
    37                                  
    38                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    39                                  ;  Offsets in the EM187 data area are all
    40                                  ;    relative to the segment address
    41                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    42                                  ;;;	segment	EM187_DATA
    43                                  	absolute  0
    44                                  ;
    45                                  ; the order:  Control, then Status may be important in the future
    46                                  ;  for FSTENV, FLDENV
    47                                  ;
    48                                  ;Control label   word
    49                                  Control:
    50 00000000 <res 00000001>          masks   resb	1               ; interrupt masks (see 'enables', below)
    51 00000001 <res 00000001>          ctrl    resb	1               ; high order control bytes
    52                                  
    53                                  ;Status  label   word
    54                                  Status:
    55 00000002 <res 00000001>          flags   resb	1               ; error flags
    56 00000003 <res 00000001>          codes   resb	1               ; condition codes
    57                                  
    58                                  ; the Tag word bits are distributed through the Accumulator data structure
    59                                  
    60 00000004 <res 00000002>          save_ip:  resw	1		; IP of instruction causing exception
    61 00000006 <res 00000002>          save_cs:  resw	1		; CS of ditto
    62 00000008 <res 00000002>          data_offset:	resw	1
    63 0000000A <res 00000002>          data_segment:	resw	1	; Data address in full
    64 0000000C <res 00000002>          instruct    resw	1               ; copy of instruction saved here
    65 0000000E <res 00000002>          round       resw	1               ; rounding control bits times 2 (0,2,4,6)
    66 00000010 <res 00000001>          tos     resb	1               ; top of stack ptr
    67 00000011 <res 00000001>          enables resb	1               ;interrupts that are enabled (not 'masks')
    68                                  
    69                                  nFINIT	equ	($-Status)/2	; number of WORDs to clear
    70                                  
    71                                  ;guard_sticky  label word
    72                                  guard_sticky:
    73 00000012 <res 00000001>          sticky  resb	1               ;sticky if any bits set
    74 00000013 <res 00000001>          guard   resb	1               ;guard bit in bit7
    75                                  
    76                                  %if BIG
    77 00000014 <res 00000002>          mptr    resw	1               ;multiplicand pointer
    78                                  %endif
    79                                  
    80 00000016 <res 00000002>          trptr   resw	1               ;transcendental pointer
    81 00000018 <res 00000002>          trptr2  resw	1
    82                                  
    83 0000001A <res 00000001>          ctr     resb	1               ;loop counter for MUL/DIV and FBLD
    84                                  
    85 0000001B <res 00000001>          trctr   resb	1               ;transcendental counter
    86                                  
    87                                  ;mtemp   dw      8 dup (?)       ;mantissa temporary for 64x64 bit multiplication
    88 0000001C <res 00000010>          mtemp	resw	8
    89                                  
    90                                  
    91                                  ;Areg    ACCUM   <>
    92 0000002C <res 0000000C>          Areg	resb	lenACCUM
    93                                  lenAccum    equ     $-Areg
    94                                  ;Breg    ACCUM   <>
    95 00000038 <res 0000000C>          Breg	resb	lenACCUM
    96                                  
    97                                  %if BIG
    98                                     
    99                                  %define maxcon 19
   100                                  %else
   101                                  %define maxcon 11
   102                                  %endif
   103                                  
   104                                  ;fp0     ACCUM   <>
   105 00000044 <res 0000000C>          fp0	resb	lenACCUM
   106                                  ;fp1     ACCUM   <>
   107 00000050 <res 0000000C>          fp1	resb	lenACCUM
   108                                  ;fp2     ACCUM   <>
   109 0000005C <res 0000000C>          fp2	resb	lenACCUM
   110                                  ;fp3     ACCUM   <>
   111 00000068 <res 0000000C>          fp3	resb	lenACCUM
   112                                  ;fp4     ACCUM   <>
   113 00000074 <res 0000000C>          fp4	resb	lenACCUM
   114                                  ;fp5     ACCUM   <>
   115 00000080 <res 0000000C>          fp5	resb	lenACCUM
   116                                  ;fp6     ACCUM   <>
   117 0000008C <res 0000000C>          fp6	resb	lenACCUM
   118                                  ;fp7     ACCUM   <>
   119 00000098 <res 0000000C>          fp7	resb	lenACCUM
   120                                  
   121                                  
   122                                  ;Creg    ACCUM   maxcon DUP (<>)
   123                                  Creg	equ	$
   124                                  	%rep	maxcon
   125                                  	resb	lenACCUM
   126                                  	%endrep
   126 000000A4 <res 0000000C>      <1>  resb lenACCUM
   126 000000B0 <res 0000000C>      <1>  resb lenACCUM
   126 000000BC <res 0000000C>      <1>  resb lenACCUM
   126 000000C8 <res 0000000C>      <1>  resb lenACCUM
   126 000000D4 <res 0000000C>      <1>  resb lenACCUM
   126 000000E0 <res 0000000C>      <1>  resb lenACCUM
   126 000000EC <res 0000000C>      <1>  resb lenACCUM
   126 000000F8 <res 0000000C>      <1>  resb lenACCUM
   126 00000104 <res 0000000C>      <1>  resb lenACCUM
   126 00000110 <res 0000000C>      <1>  resb lenACCUM
   126 0000011C <res 0000000C>      <1>  resb lenACCUM
   126 00000128 <res 0000000C>      <1>  resb lenACCUM
   126 00000134 <res 0000000C>      <1>  resb lenACCUM
   126 00000140 <res 0000000C>      <1>  resb lenACCUM
   126 0000014C <res 0000000C>      <1>  resb lenACCUM
   126 00000158 <res 0000000C>      <1>  resb lenACCUM
   126 00000164 <res 0000000C>      <1>  resb lenACCUM
   126 00000170 <res 0000000C>      <1>  resb lenACCUM
   126 0000017C <res 0000000C>      <1>  resb lenACCUM
   127                                  lenCreg     equ     $-Creg
   128                                  
   129                                  ;        public  EM187_DATA_PARAS
   130                                  	global	EM187_DATA_PARAS
   131                                  EM187_DATA_PARAS  equ     ($-Control+15)/16
   132                                  
   133                                  ;EM187_DATA   ENDS
   134                                  
   135                                  
   136                                  ;        assume  cs:_TEXT, ds:EM187_DATA
   137                                  
   138                                  
   139                                  ;_TEXT SEGMENT
   140                                  	segment	_TEXT
   141                                  ;        assume  cs:_TEXT
   142                                  
   143                                  
   144                                  ; vector7 is entered when an ESC trap occurs, for any co-processor
   145                                  ;   instruction
   146                                  
   147                                  	global  vector7
   148                                  
   149                                  	even
   150                                  
   151                                  vector7:	;  proc    far
   152 00000000 FB                              sti             ;re-enable interrupts
   153                                  vector7a:
   154 00000001 60                              pusha           ;save all the registers
   155 00000002 06                              push    es      ; **
   156 00000003 16                              push    ss
   157 00000004 1E                              push    ds      ; the order of these push'es is important
   158 00000005 89E5                            mov     bp,sp   ;establish stack addressability
   159 00000007 8CD8                            mov     ax,ds   ;most used segment
   160 00000009 8EC0                            mov     es,ax   ;for argument address  ES:DI  -- used later
   161 0000000B FC                      	cld		;will return with IRET
   162                                  
   163 0000000C C57616                          lds     si,[v7_ip+bp]        ;get instruction stream pointer
   164                                  
   165                                  %ifdef DEBUG
   166                                          mov     bx,[insptr]               ;get trace pointer
   167                                          sub     bx,4
   168                                  ;;;        cmp     bx,offset trace
   169                                          cmp     bx,trace
   170                                          jae     nowrap
   171                                  ;;;        mov     bx,offset tracee-4
   172                                          mov     bx,tracee-4
   173                                  nowrap:
   174                                          mov     [insptr],bx               ;restore trace pointer
   175                                    cs    mov     word [bx],si      ;save IP of instruction
   176                                    cs    mov     word [bx+2],ds    ;save CS of instruction
   177                                          mov     [savesp],sp               ;save SP before pop
   178                                  %endif
   179                                  
   180                                  ; check for segment override prefix
   181                                  
   182 0000000F AC                              lodsb
   183 00000010 08C0                            or      al,al               ;test hi-bit of first byte
   184 00000012 7825                            js      vec002              ;not segment override
   185 00000014 88C3                            mov     bl,al               ;move prefix to BX
   186 00000016 D0EB                            shr     bl,1                ;shift two bits to position
   187 00000018 D0EB                            shr     bl,1                ;**
   188 0000001A 83E306                          and     bx,0006h            ;mask for vectored jump
   189 0000001D 2EFFA7[FE01]               cs   jmp     [override+bx]
   190                                  
   191                                  	even
   192                                  
   193                                  cs_over:
   194 00000022 8CD8                            mov     ax,ds               ;former CS to AX
   195 00000024 EB0D                            jmp     short vec001a       ;go continue
   196                                  	even
   197                                  ss_over:
   198 00000026 8CD0                            mov     ax,ss               ;set up override
   199 00000028 EB0C                            jmp     short vec001
   200                                  	even
   201                                  ds_over:
   202 0000002A 8B4600                          mov     ax,[v7_ds+bp]        ;get saved DS
   203 0000002D EB04                            jmp     short vec001a       ;go continue
   204 0000002F 90                      	even
   205                                  es_over:
   206 00000030 8B4604                          mov     ax,[v7_es+bp]        ;get saved ES
   207                                  
   208                                  vec001a:
   209 00000033 894602                          mov     [v7_ss+bp],ax        ;set for [bp] addressing
   210                                  vec001:
   211 00000036 8EC0                            mov     es,ax               ;set up override segment
   212                                  
   213                                  ; get first instruction byte
   214                                  
   215 00000038 AC                              lodsb                       ;get first instruction byte
   216                                  vec002:
   217                                  ;;;;;;;;;;;
   218                                  ;  check for FWAIT
   219 00000039 3C9B                    	cmp	al,9Bh		; FWAIT
   220 0000003B 7503E97601              	je	restore_segs
   221                                  ;;;;;;;;;;;
   222 00000040 88C5                            mov     ch,al               ;save first instr. byte in ch
   223 00000042 AC                              lodsb
   224 00000043 88C1                            mov     cl,al               ;save second in cl
   225                                  
   226                                  ; fast instruction decode
   227                                  
   228 00000045 89CB                            mov     bx,cx               ;get mod, op-B, r/m bits
   229 00000047 D0C3                            rol     bl,1                ;
   230 00000049 D0C3                            rol     bl,1                ;get  r/m, mod  in low 5 bits
   231                                  ; may want to save BX at this point
   232 0000004B 89DA                            mov     dx,bx               ;save BX in DX for now
   233 0000004D 83E31F                          and     bx,1Fh              ;mask to 5 bits
   234 00000050 D1E3                            shl     bx,1                ;set for word addressing
   235 00000052 2EFFA7[BE01]              cs    jmp     [adrmode+bx]         ;dispatch to proper address mode
   236                                  
   237                                  mod_0_10:                           ;[bx+si]+d16
   238 00000057 8B7E08                          mov     di,[v7_si+bp]
   239 0000005A 037E0E                          add     di,[v7_bx+bp]
   240 0000005D E9A100                          jmp     vvw
   241                                  
   242                                  mod_1_10:                           ;[bx+di]+d16
   243                                  ;;;        mov     di,[v7_di+bp]
   244 00000060 037E0E                          add     di,[v7_bx+bp]
   245 00000063 E99B00                          jmp     vvw
   246                                  
   247                                  mod_2_10:                           ;[bp+si]+d16
   248 00000066 8B7E08                          mov     di,[v7_si+bp]
   249 00000069 037E0A                          add     di,[v7_bp+bp]
   250 0000006C 8E4602                          mov     es,[v7_ss+bp]        ;SS is used
   251 0000006F E98F00                          jmp     vvw
   252                                  
   253                                  mod_0_01:                           ;[bx+si]+d8
   254 00000072 8B7E08                          mov     di,[v7_si+bp]
   255 00000075 037E0E                          add     di,[v7_bx+bp]
   256 00000078 AC                              lodsb
   257 00000079 98                              cbw
   258 0000007A E98500                          jmp     vvb
   259                                  
   260                                  mod_3_10:                           ;[bp+di]+d16
   261                                  ;;;        mov     di,[v7_di+bp]
   262 0000007D 037E0A                          add     di,[v7_bp+bp]
   263 00000080 8E4602                          mov     es,[v7_ss+bp]        ;SS is used
   264 00000083 EB7C                            jmp     vvw
   265                                  
   266                                  mod_1_01:                           ;[bx+di]+d8
   267                                  ;;;        mov     di,[v7_di+bp]
   268 00000085 037E0E                          add     di,[v7_bx+bp]
   269 00000088 AC                              lodsb
   270 00000089 98                              cbw
   271 0000008A EB76                            jmp     vvb
   272                                  
   273                                  mod_2_01:                           ;[bp+si]+d8
   274 0000008C 8B7E08                          mov     di,[v7_si+bp]
   275 0000008F 037E0A                          add     di,[v7_bp+bp]
   276 00000092 8E4602                          mov     es,[v7_ss+bp]        ;SS is used
   277 00000095 AC                              lodsb
   278 00000096 98                              cbw
   279 00000097 EB69                            jmp     short vvb
   280                                  
   281                                  mod_3_01:                           ;[bp+di]+d8
   282                                  ;;;        mov     di,[v7_di+bp]
   283 00000099 037E0A                          add     di,[v7_bp+bp]
   284 0000009C 8E4602                          mov     es,[v7_ss+bp]        ;SS is used
   285 0000009F AC                              lodsb
   286 000000A0 98                              cbw
   287 000000A1 EB5F                            jmp     short vvb
   288                                  
   289                                  mod_0_00:                           ;[bx+si]
   290 000000A3 8B7E08                          mov     di,[v7_si+bp]
   291 000000A6 037E0E                          add     di,[v7_bx+bp]
   292 000000A9 EB59                            jmp     short vvv
   293                                  
   294                                  mod_1_00:                           ;[bx+di]
   295                                  ;;;        mov     di,[v7_di+bp]
   296 000000AB 037E0E                          add     di,[v7_bx+bp]
   297 000000AE EB54                            jmp     short vvv
   298                                  
   299                                  mod_2_00:                           ;[bp+si]
   300 000000B0 8B7E08                          mov     di,[v7_si+bp]
   301 000000B3 037E0A                          add     di,[v7_bp+bp]
   302 000000B6 8E4602                          mov     es,[v7_ss+bp]        ;SS is used
   303 000000B9 EB49                            jmp     short vvv
   304                                  
   305                                  mod_3_00:                           ;[bp+di]
   306                                  ;;;        mov     di,[v7_di+bp]
   307 000000BB 037E0A                          add     di,[v7_bp+bp]
   308 000000BE 8E4602                          mov     es,[v7_ss+bp]        ;SS is used
   309 000000C1 EB41                            jmp     short vvv
   310                                  
   311                                  mod_4_01:                           ;[si]+d8
   312 000000C3 8B7E08                          mov     di,[v7_si+bp]
   313 000000C6 AC                              lodsb
   314 000000C7 98                              cbw
   315 000000C8 EB38                            jmp     short vvb
   316                                  
   317                                  mod_5_01:                           ;[di]+d8
   318                                  ;;;        mov     di,[v7_di+bp]
   319 000000CA AC                              lodsb
   320 000000CB 98                              cbw
   321 000000CC EB34                            jmp     short vvb
   322                                  
   323                                  mod_6_01:                           ;[bp]+d8
   324 000000CE 8B7E0A                          mov     di,[v7_bp+bp]
   325 000000D1 8E4602                          mov     es,[v7_ss+bp]        ;SS is used
   326 000000D4 AC                              lodsb
   327 000000D5 98                              cbw
   328 000000D6 EB2A                            jmp     short vvb
   329                                  
   330                                  mod_7_01:                           ;[bx]+d8
   331 000000D8 8B7E0E                          mov     di,[v7_bx+bp]
   332 000000DB AC                              lodsb
   333 000000DC 98                              cbw
   334 000000DD EB23                            jmp     short vvb
   335                                  
   336                                  mod_4_10:                           ;[si]+d16
   337 000000DF 8B7E08                          mov     di,[v7_si+bp]
   338 000000E2 EB1D                            jmp     short vvw
   339                                  
   340                                  mod_5_10:                           ;[di]+d16
   341                                  ;;;        mov     di,[v7_di+bp]
   342 000000E4 EB1B                            jmp     short vvw
   343                                  
   344                                  mod_6_10:                           ;[bp]+d16
   345 000000E6 8B7E0A                          mov     di,[v7_bp+bp]
   346 000000E9 8E4602                          mov     es,[v7_ss+bp]        ;SS is used
   347 000000EC EB13                            jmp     short vvw
   348                                  
   349                                  mod_7_10:                           ;[bx]+d16
   350 000000EE 8B7E0E                          mov     di,[v7_bx+bp]
   351 000000F1 EB0E                            jmp     short vvw
   352                                  
   353                                  mod_4_00:                           ;[si]
   354 000000F3 8B7E08                          mov     di,[v7_si+bp]
   355 000000F6 EB0C                            jmp     short vvv
   356                                  
   357                                  mod_5_00:                           ;[di]
   358                                  ;;;        mov     di,[v7_di+bp]
   359 000000F8 EB0A                            jmp     short vvv
   360                                  
   361                                  mod_7_00:                           ;[bx]
   362 000000FA 8B7E0E                          mov     di,[v7_bx+bp]
   363 000000FD EB05                            jmp     short vvv
   364                                  
   365                                  mod_6_00:                           ;D16 -- simple variable
   366 000000FF 31FF                            xor     di,di
   367                                  vvw:
   368 00000101 AD                              lodsw
   369                                  vvb:
   370 00000102 01C7                            add     di,ax
   371                                  vvv:
   372                                  
   373                                  ;  ES:DI is pointer to argument
   374                                  
   375                                  ;;;        mov     ax,seg EM187_DATA
   376 00000104 E8D21A                  	call	get_data_segment	; to AX and DS
   377                                  ;;;
   378                                  ;;;        mov     ds,ax               ;set up addressing
   379                                  ;;;        assume  ds:EM187_DATA
   380                                  
   381 00000107 890E0C00                        mov     [instruct],cx       ;save instruction
   382                                  ;;
   383 0000010B 89D3                    	mov	bx,dx
   384 0000010D C1EB05                  	shr	bx,5
   385 00000110 83E31F                  	and	bx,0011111b	 ; FSTENV or FSAVE? mask (5bits)
   386 00000113 83FB0E                  	cmp	bx,0001110b	; one of the above?
   387 00000116 7416                    	je	bypass_SAV_ENV  ; do not muck up save areas if FSAVE or FSTENV
   388 00000118 893E0800                	mov	[data_offset],di	; save data address
   389 0000011C 8C060A00                	mov	[data_segment],es	; save data segment
   390 00000120 8B5E16                  	mov	bx,[v7_ip+bp]	; save instruction IP
   391 00000123 891E0400                	mov	[save_ip],bx
   392 00000127 8B5E18                  	mov	bx,[v7_cs+bp]	; save instruction CS
   393 0000012A 891E0600                	mov	[save_cs],bx
   394                                  bypass_SAV_ENV:
   395                                  ;;
   396 0000012E 897616                          mov     [v7_ip+bp],si        ;update return address
   397 00000131 89D3                            mov     bx,dx               ;move opA-opB to BX
   398 00000133 C1EB04                          shr     bx,4                ;get fmt12t dispatch index
   399 00000136 83E37E                          and     bx,7Eh              ;mask to 6 bits, set for word address
   400 00000139 2EFFA7[1602]              cs    jmp     [fmt12t+bx]          ;dispatch
   401                                  
   402                                  ;
   403                                  ; MOD == 11 --  R/R instructions
   404                                  
   405                                  mod_x_11:
   406 0000013E 897616                          mov     [v7_ip+bp],si        ;update return address
   407                                  
   408                                  ;;;        mov     ax,seg EM187_DATA
   409 00000141 E8951A                  	call	get_data_segment	; to AX and DS
   410                                  ;;;        mov     ds,ax               ;set up addressing
   411                                  
   412 00000144 8EC0                            mov     es,ax               ; from both DS and ES
   413 00000146 890E0C00                        mov     [instruct],cx         ;save instruction
   414                                  
   415                                  
   416 0000014A B82007                          mov     ax,0720H            ;get special mask
   417 0000014D 21C8                            and     ax,cx               ;mask instruction word
   418 0000014F 3D2001                          cmp     ax,0120H            ;test for format 4
   419 00000152 7418                            je      fmt04
   420 00000154 3D2003                          cmp     ax,0320H            ;test for format 5
   421 00000157 741F                            je      fmt05
   422                                  fmt03:
   423 00000159 80E401                          and     ah,01H              ;mask op-A
   424 0000015C D0E4                            shl     ah,1
   425 0000015E BB3800                          mov     bx,38H
   426 00000161 20CB                            and     bl,cl               ;form op-B
   427 00000163 D1EB                            shr     bx,1
   428 00000165 00E3                            add     bl,ah               ;form  op-B || op-A
   429 00000167 2EFFA7[9602]              cs    jmp     [fmt03t+bx]
   430                                  fmt04:
   431 0000016C BB1F00                          mov     bx,001fH            ;5 bit mask
   432 0000016F 21CB                            and     bx,cx               ;form op
   433 00000171 D1E3                            shl     bx,1
   434 00000173 2EFFA7[B602]              cs    jmp     [fmt04t+bx]
   435                                  fmt05:
   436 00000178 BB1F00                          mov     bx,001fH            ;5 bit mask
   437 0000017B 21CB                            and     bx,cx
   438 0000017D D1E3                            shl     bx,1
   439 0000017F 2EFFA7[F602]              cs    jmp     [fmt05t+bx]
   440                                  
   441                                  
   442                                  gFYL2XP1:
   443                                  
   444                                  gFENI:
   445                                  gFDISI:
   446                                  gSETPM:
   447                                  gFLDENV:
   448                                  gFSTENV:
   449                                  gFRSTOR:
   450                                  gFSAVE:
   451                                  unimplemented:
   452 00000184 680001                          push    errUnemulated
   453 00000187 E8671A                          call    exception
   454 0000018A EB2A                            jmp     short restore_segs
   455                                  
   456                                  underflow:
   457                                  ;;;        and     codes,NOT C1                ;indicate underflow
   458 0000018C 80260300FD                      and     byte [codes],~C1                ;indicate underflow
   459 00000191 684110                          push    errStkUnderflow+Sflag+Iexcept
   460 00000194 E85A1A                          call    exception
   461 00000197 EB11                            jmp     short pop001
   462                                  
   463                                  test_pop:
   464 00000199 F6060D0002                      test    byte [instruct+1],Pbit     ;test for pop
   465 0000019E 7416                            jz      restore_segs
   466                                  ;
   467                                  ;   pop stack, not knowing where ST(0) is
   468                                  ;
   469                                  pop_the_tos:
   470 000001A0 31DB                            xor     bx,bx               ;use ST(0)
   471 000001A2 E8B904                          call    regptr              ;get pointer in BX
   472                                  ;
   473                                  ;   pop stack, assuming FPac pointer is in BX
   474                                  ;
   475                                  pop_stack:
   476 000001A5 803F03                          cmp     byte [bx+tag], tag_empty
   477 000001A8 74E2                            je      underflow           ;can't pop an empty register
   478                                  pop001:
   479 000001AA C60703                          mov     byte [bx+tag], tag_empty     ;tag it empty
   480 000001AD FE061000                        inc     byte [tos]                 ;pop the stack
   481 000001B1 8026100007                      and     byte [tos],7               ; **
   482                                  
   483                                  restore_segs:
   484                                  %ifdef DEBUG
   485                                          cmp     [savesp],sp           ;check sp on exit
   486                                          je      rExit
   487                                          jmp     short restore_segs
   488                                  rExit:
   489                                  %endif
   490 000001B6 1F                              pop     ds
   491 000001B7 83C402                          add     sp,2    ;skip over ss
   492 000001BA 07                              pop     es
   493 000001BB 61                              popa            ;pop the rest
   494                                  vector7z:
   495 000001BC CF                              iret            ;and return
   496                                  
   497                                  ;;;vector7 endp
   498                                  
   499                                  
   500                                  
   501 000001BD 90                      	even
   502                                  %ifdef DEBUG
   503                                  insptr      dw      trace
   504                                  savesp      resw	1
   505                                  %endif
   506                                  
   507                                  
   508                                  
   509 000001BE [A300][7200][5700]-     adrmode dw      mod_0_00, mod_0_01, mod_0_10, mod_x_11
   509 000001C4 [3E01]             
   510 000001C6 [AB00][8500][6000]-             dw      mod_1_00, mod_1_01, mod_1_10, mod_x_11
   510 000001CC [3E01]             
   511 000001CE [B000][8C00][6600]-             dw      mod_2_00, mod_2_01, mod_2_10, mod_x_11
   511 000001D4 [3E01]             
   512 000001D6 [BB00][9900][7D00]-             dw      mod_3_00, mod_3_01, mod_3_10, mod_x_11
   512 000001DC [3E01]             
   513 000001DE [F300][C300][DF00]-             dw      mod_4_00, mod_4_01, mod_4_10, mod_x_11
   513 000001E4 [3E01]             
   514 000001E6 [F800][CA00][E400]-             dw      mod_5_00, mod_5_01, mod_5_10, mod_x_11
   514 000001EC [3E01]             
   515 000001EE [FF00][CE00][E600]-             dw      mod_6_00, mod_6_01, mod_6_10, mod_x_11
   515 000001F4 [3E01]             
   516 000001F6 [FA00][D800][EE00]-             dw      mod_7_00, mod_7_01, mod_7_10, mod_x_11
   516 000001FC [3E01]             
   517                                  
   518                                  %include "em187a.asm"
     1                              <1> ; em187a.asm
     2                              <1> 
     3                              <1> 	even
     4 000001FE [3000][2200][2600]- <1> override dw     es_over, cs_over, ss_over, ds_over
     4 00000204 [2A00]              <1>
     5 00000206 440050005C00680074- <1> fp0tab  dw      fp0,fp1,fp2,fp3,fp4,fp5,fp6,fp7
     5 0000020F 0080008C009800      <1>
     6                              <1> 
     7                              <1> ;                                 opA opB
     8 00000216 [DC08]              <1> fmt12t  dw      genFADD         ; 000 000       R32
     9 00000218 [1F10]              <1>         dw      genFMUL         ; 000 001       R32
    10 0000021A [9C13]              <1>         dw      genFCOM         ; 000 010       R32
    11 0000021C [BF13]              <1>         dw      genFCOMP        ; 000 011       R32
    12 0000021E [F608]              <1>         dw      genFSUB         ; 000 100       R32
    13 00000220 [1409]              <1>         dw      genFSUBR        ; 000 101       R32
    14 00000222 [6811]              <1>         dw      genFDIV         ; 000 110       R32
    15 00000224 [8211]              <1>         dw      genFDIVR        ; 000 111       R32
    16                              <1> 
    17 00000226 [3E03]              <1>         dw      genFLD          ; 001 000       R32
    18 00000228 [8401]              <1>         dw      unimplemented   ; 001 001
    19 0000022A [9E04]              <1>         dw      genFST          ; 001 010       R32
    20 0000022C [B204]              <1>         dw      genFSTP         ; 001 011       R32
    21 0000022E [8401]              <1>         dw      gFLDENV         ; 001 100       14 bytes
    22 00000230 [D104]              <1>         dw      gFLDCW          ; 001 101
    23 00000232 [8401]              <1>         dw      gFSTENV         ; 001 110       14 bytes
    24 00000234 [C804]              <1>         dw      gFSTCW          ; 001 111
    25                              <1> 
    26 00000236 [DC08]              <1>         dw      genFADD         ; 010 000       I32
    27 00000238 [1F10]              <1>         dw      genFMUL         ; 010 001       I32
    28 0000023A [9C13]              <1>         dw      genFCOM         ; 010 010       I32
    29 0000023C [BF13]              <1>         dw      genFCOMP        ; 010 011       I32
    30 0000023E [F608]              <1>         dw      genFSUB         ; 010 100       I32
    31 00000240 [1409]              <1>         dw      genFSUBR        ; 010 101       I32
    32 00000242 [6811]              <1>         dw      genFDIV         ; 010 110       I32
    33 00000244 [8211]              <1>         dw      genFDIVR        ; 010 111       I32
    34                              <1> 
    35 00000246 [3E03]              <1>         dw      genFLD          ; 011 000       I32
    36 00000248 [8401]              <1>         dw      unimplemented   ; 011 001
    37 0000024A [9E04]              <1>         dw      genFST          ; 011 010       I32
    38 0000024C [B204]              <1>         dw      genFSTP         ; 011 011       I32
    39 0000024E [8401]              <1>         dw      unimplemented   ; 011 100
    40 00000250 [4217]              <1>         dw      FLDtmp          ; 011 101
    41 00000252 [8401]              <1>         dw      unimplemented   ; 011 110
    42 00000254 [C917]              <1>         dw      FSTPtmp         ; 011 111
    43                              <1> 
    44 00000256 [DC08]              <1>         dw      genFADD         ; 100 000       R64
    45 00000258 [1F10]              <1>         dw      genFMUL         ; 100 001       R64
    46 0000025A [9C13]              <1>         dw      genFCOM         ; 100 010       R64
    47 0000025C [BF13]              <1>         dw      genFCOMP        ; 100 011       R64
    48 0000025E [F608]              <1>         dw      genFSUB         ; 100 100       R64
    49 00000260 [1409]              <1>         dw      genFSUBR        ; 100 101       R64
    50 00000262 [6811]              <1>         dw      genFDIV         ; 100 110       R64
    51 00000264 [8211]              <1>         dw      genFDIVR        ; 100 111       R64
    52                              <1> 
    53 00000266 [3E03]              <1>         dw      genFLD          ; 101 000       R64
    54 00000268 [8401]              <1>         dw      unimplemented   ; 101 001
    55 0000026A [9E04]              <1>         dw      genFST          ; 101 010       R64
    56 0000026C [B204]              <1>         dw      genFSTP         ; 101 011       R64
    57 0000026E [8401]              <1>         dw      gFRSTOR         ; 101 100       94 bytes
    58 00000270 [8401]              <1>         dw      unimplemented   ; 101 101
    59 00000272 [8401]              <1>         dw      gFSAVE          ; 101 110       94 bytes
    60 00000274 [F404]              <1>         dw      gFSTSW          ; 101 111
    61                              <1> 
    62 00000276 [DC08]              <1>         dw      genFADD         ; 110 000       I16
    63 00000278 [1F10]              <1>         dw      genFMUL         ; 110 001       I16
    64 0000027A [9C13]              <1>         dw      genFCOM         ; 110 010       I16
    65 0000027C [BF13]              <1>         dw      genFCOMP        ; 110 011       I16
    66 0000027E [F608]              <1>         dw      genFSUB         ; 110 100       I16
    67 00000280 [1409]              <1>         dw      genFSUBR        ; 110 101       I16
    68 00000282 [6811]              <1>         dw      genFDIV         ; 110 110       I16
    69 00000284 [8211]              <1>         dw      genFDIVR        ; 110 111       I16
    70                              <1> 
    71 00000286 [3E03]              <1>         dw      genFLD          ; 111 000       I16
    72 00000288 [8401]              <1>         dw      unimplemented   ; 111 001
    73 0000028A [9E04]              <1>         dw      genFST          ; 111 010       I16
    74 0000028C [B204]              <1>         dw      genFSTP         ; 111 011       I16
    75 0000028E [3F14]              <1>         dw      gFBLD           ; 111 100
    76 00000290 [B507]              <1>         dw      FLDi64          ; 111 101
    77 00000292 [0015]              <1>         dw      gFBSTP          ; 111 110
    78 00000294 [D916]              <1>         dw      FSTPi64         ; 111 111
    79                              <1> 
    80 00000296 [3404]              <1> fmt03t  dw      FADDrr              ; 0000      & FADDP
    81 00000298 [1205]              <1>         dw      FLD_i_to_0          ; 0001      & FFREE (R==1)
    82 0000029A [1510]              <1>         dw      FMULrr              ; 0010
    83 0000029C [4105]              <1>         dw      gFXCH               ; 0011
    84 0000029E [E213]              <1>         dw      FCOMrr              ; 0100
    85 000002A0 [2705]              <1>         dw      FST_0_to_i          ; 0101      & FNOP
    86 000002A2 [F413]              <1>         dw      FCOMPrr             ; 0110      & FCOMPP
    87 000002A4 [3305]              <1>         dw      FSTP_0_to_i         ; 0111
    88 000002A6 [3F04]              <1>         dw      FSUBi               ; 1000      ST - ST(i)
    89 000002A8 [EB04]              <1>         dw      FSTSW_ax            ; 1001
    90 000002AA [6A04]              <1>         dw      FSUB0               ; 1010      ST(i) - ST
    91 000002AC [8401]              <1>         dw      unimplemented       ; 1011
    92 000002AE [9E11]              <1>         dw      FDIVi               ; 1100      ST / ST(i)
    93 000002B0 [8401]              <1>         dw      unimplemented       ; 1101
    94 000002B2 [BF11]              <1>         dw      FDIV0               ; 1110      ST(i) / ST
    95 000002B4 [8401]              <1>         dw      unimplemented       ; 1111
    96                              <1> 
    97 000002B6 [C408]              <1> fmt04t  dw      gFCHS               ; 00000
    98 000002B8 [D008]              <1>         dw      gFABS               ; 00001
    99 000002BA [8401]              <1>         dw      unimplemented       ; 00010
   100 000002BC [8401]              <1>         dw      unimplemented       ; 00011
   101 000002BE [5211]              <1>         dw      gFTST               ; 00100
   102 000002C0 [1311]              <1>         dw      gFXAM               ; 00101
   103 000002C2 [8401]              <1>         dw      unimplemented       ; 00110
   104 000002C4 [8401]              <1>         dw      unimplemented       ; 00111
   105 000002C6 [6005]              <1>         dw      gFLD1               ; 01000
   106 000002C8 [7105]              <1>         dw      gFLDL2T             ; 01001
   107 000002CA [8205]              <1>         dw      gFLDL2E             ; 01010
   108 000002CC [9305]              <1>         dw      gFLDPI              ; 01011
   109 000002CE [A405]              <1>         dw      gFLDLG2             ; 01100
   110 000002D0 [B505]              <1>         dw      gFLDLN2             ; 01101
   111 000002D2 [C605]              <1>         dw      gFLDZ               ; 01110
   112 000002D4 [8401]              <1>         dw      unimplemented       ; 01111
   113                              <1> 
   114 000002D6 [B00A]              <1>         dw      gF2XM1              ; 10000
   115 000002D8 [DB0C]              <1>         dw      gFYL2X              ; 10001
   116 000002DA [B609]              <1>         dw      gFPTAN              ; 10010
   117 000002DC [2A1B]              <1>         dw      gFPATAN             ; 10011
   118 000002DE [7E16]              <1>         dw      gFXTRACT            ; 10100
   119 000002E0 [8401]              <1>         dw      unimplemented       ; 10101
   120 000002E2 [3209]              <1>         dw      gFDECSTP            ; 10110
   121 000002E4 [3E09]              <1>         dw      gFINCSTP            ; 10111
   122 000002E6 [5B19]              <1>         dw      gFPREM              ; 11000
   123 000002E8 [8401]              <1>         dw      gFYL2XP1            ; 11001
   124 000002EA [B818]              <1>         dw      gFSQRT              ; 11010
   125 000002EC [8401]              <1>         dw      unimplemented       ; 11011
   126 000002EE [6E18]              <1>         dw      gFRNDINT            ; 11100
   127 000002F0 [B416]              <1>         dw      gFSCALE             ; 11101
   128 000002F2 [8401]              <1>         dw      unimplemented       ; 11110
   129 000002F4 [8401]              <1>         dw      unimplemented       ; 11111
   130                              <1> 
   131 000002F6 [8401]              <1> fmt05t  dw      gFENI               ; 00000
   132 000002F8 [8401]              <1>         dw      gFDISI              ; 00001
   133 000002FA [7503]              <1>         dw      gFCLEX              ; 00010
   134 000002FC [5003]              <1>         dw      gFINIT              ; 00011
   135 000002FE [8401]              <1>         dw      unimplemented       ; 00100
   136 00000300 [8401]              <1>         dw      unimplemented       ; 00101
   137 00000302 [8401]              <1>         dw      unimplemented       ; 00110
   138 00000304 [8401]              <1>         dw      unimplemented       ; 00111
   139 00000306 [8401]              <1>         dw      unimplemented       ; 01000
   140 00000308 [8401]              <1>         dw      unimplemented       ; 01001
   141 0000030A [8401]              <1>         dw      unimplemented       ; 01010
   142 0000030C [8401]              <1>         dw      unimplemented       ; 01011
   143 0000030E [8401]              <1>         dw      unimplemented       ; 01100
   144 00000310 [8401]              <1>         dw      unimplemented       ; 01101
   145 00000312 [8401]              <1>         dw      unimplemented       ; 01110
   146 00000314 [8401]              <1>         dw      unimplemented       ; 01111
   147                              <1> 
   148 00000316 [8401]              <1>         dw      unimplemented       ; 10000
   149 00000318 [8401]              <1>         dw      unimplemented       ; 10001
   150 0000031A [8401]              <1>         dw      unimplemented       ; 10010
   151 0000031C [8401]              <1>         dw      unimplemented       ; 10011
   152 0000031E [8401]              <1>         dw      unimplemented       ; 10100
   153 00000320 [8401]              <1>         dw      unimplemented       ; 10101
   154 00000322 [8401]              <1>         dw      unimplemented       ; 10110
   155 00000324 [8401]              <1>         dw      unimplemented       ; 10111
   156 00000326 [8401]              <1>         dw      unimplemented       ; 11000
   157 00000328 [8401]              <1>         dw      unimplemented       ; 11001
   158 0000032A [8401]              <1>         dw      unimplemented       ; 11010
   159 0000032C [8401]              <1>         dw      unimplemented       ; 11011
   160 0000032E [8401]              <1>         dw      unimplemented       ; 11100
   161 00000330 [8401]              <1>         dw      unimplemented       ; 11101
   162 00000332 [8401]              <1>         dw      unimplemented       ; 11110
   163 00000334 [8401]              <1>         dw      unimplemented       ; 11111
   164                              <1> 
   165                              <1> 
   166                              <1> 	even
   167 00000336 [6D06][2E07][FF0D]- <1> vecFLD  dw  load_R32, load_I32, load_R64, load_I16  
   167 0000033C [1D07]              <1>
   168                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   169                              <1> ;
   170                              <1> ; FLD of i16, i32, r32, and r64
   171                              <1> ;   Floating point load
   172                              <1> ;
   173                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   174                              <1> genFLD:
   175 0000033E E8F702              <1>         call    alloc
   176 00000341 89DE                <1>         mov     si,bx
   177 00000343 BB0600              <1>         mov     bx,FMbits           ;get format mask
   178 00000346 20EB                <1>         and     bl,ch
   179                              <1> ;;;        push    OFFSET restore_segs
   180 00000348 68[B601]            <1>         push    restore_segs
   181 0000034B 2EFFA7[3603]        <1>   cs    jmp     [vecFLD+bx]
   182                              <1> 
   183                              <1> 
   184                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   185                              <1> ;
   186                              <1> ; do overall emulator initialization -- FINIT instruction
   187                              <1> ;
   188                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   189                              <1> gFINIT:
   190 00000350 C606030040          <1>         mov     byte [codes], C3
   191                              <1> ;;;        mov     byte [masks], 7Fh      ;mask all interrupts
   192                              <1> ;;;        mov     byte [ctrl], 03H
   193 00000355 C70600007F03        <1> 	mov	word [Control],037Fh
   194 0000035B 31C0                <1>         xor     ax,ax           ;get Zero
   195                              <1> %if 1
   196 0000035D 1E                  <1> 	push	ds
   197 0000035E 07                  <1> 	pop	es
   198 0000035F BF0200              <1> 	mov	di,Status
   199 00000362 B90800              <1> 	mov	cx,nFINIT
   200 00000365 F3AB                <1> 	rep	stosw
   201                              <1> %else
   202                              <1> ; clear CS:IP, data DS:PTR, instruct
   203                              <1> 	mov	[Status],ax	; Zap flags & codes
   204                              <1>         mov     [enables],al      ;mask all interrupts
   205                              <1>         mov     [tos],al
   206                              <1>         mov     [round],ax        ;set round to nearest
   207                              <1> %endif
   208 00000367 B90800              <1>         mov     cx,8
   209                              <1> ;;;        mov     si,offset fp0
   210 0000036A BE4400              <1>         mov     si, fp0
   211                              <1> gFINIT1:
   212 0000036D C60403              <1>         mov     byte [si+tag], tag_empty
   213 00000370 83C60C              <1>         add     si, lenAccum
   214 00000373 E2F8                <1>         loop    gFINIT1
   215                              <1> ; fall into
   216                              <1> 
   217                              <1> ; clear exceptions
   218                              <1> 
   219                              <1> gFCLEX:
   220 00000375 C606020000          <1>         mov     byte [flags], 0
   221 0000037A E939FE              <1>         jmp     restore_segs
   222                              <1> 
   223                              <1> 
   224                              <1> 
   225                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   226                              <1> ;
   227                              <1> ;   RRsetup -- setup for ST(i) - ST(0) operations
   228                              <1> ;
   229                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   230                              <1> RRsetup:	;	 proc    near
   231                              <1> 
   232 0000037D 88CB                <1>         mov     bl,cl           ;get source register
   233 0000037F E8DC02              <1>         call    regptr          ;get pointer to source
   234 00000382 89DE                <1>         mov     si,bx           ;source ptr to SI
   235 00000384 31DB                <1>         xor     bx,bx           ;get ST(0)
   236 00000386 E8D502              <1>         call    regptr          ;get pointer to destination
   237 00000389 89DF                <1>         mov     di,bx           ;dest. ptr to DI
   238 0000038B F6C504              <1>         test    ch,Rbit         ;test reversal bit
   239 0000038E 7402                <1>         jz      RR010           ;don't reverse
   240 00000390 87F7                <1>         xchg    si,di           ;reverse source and destination
   241                              <1> RR010:
   242 00000392 C3                  <1>         ret
   243                              <1> 
   244                              <1> ;RRsetup endp
   245                              <1> 
   246                              <1> 
   247                              <1> 
   248                              <1> ;  something is rotten in Source or Destination
   249                              <1> 
   250                              <1> FA200:              ;;;; ****
   251 00000393 5E                  <1>         pop     si                  ; clean up the stack for now
   252 00000394 C60406              <1>         mov     byte [si+tag], tag_invalid
   253 00000397 6A01                <1>         push    Iexcept             ;signal exception
   254 00000399 E85518              <1>         call    exception
   255 0000039C E99400              <1>         jmp     FA100
   256                              <1> 
   257                              <1> 
   258                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   259                              <1> ;
   260                              <1> ;   Add register - register
   261                              <1> ;       SI and DI point to operands
   262                              <1> ;       BX is place to put result, may be same as SI or DI
   263                              <1> ;
   264                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   265                              <1> do_add:		;      proc    near
   266 0000039F 53                  <1>         push    bx              ;save place to which to move result
   267 000003A0 8A04                <1>         mov     al,[si+tag]     ;get source tag
   268 000003A2 0A05                <1>         or      al,[di+tag]     ;or on destination tag
   269 000003A4 A802                <1>         test    al, tag_infin   ;test for infinity, empty, or invalid
   270 000003A6 75EB                <1>         jnz     FA200           ;if not both valid, something needs checking
   271                              <1> ; both tags are valid
   272 000003A8 8B4402              <1>         mov     ax,[si+expon]   ;get source exponent
   273 000003AB 3B4502              <1>         cmp     ax,[di+expon]   ;get dest exponent
   274 000003AE 7D02                <1>         jge     FA040           ;jump if source exponent is bigger
   275 000003B0 87F7                <1>         xchg    si,di           ;source has bigger or equal exponent
   276                              <1> FA040:
   277 000003B2 89FB                <1>         mov     bx,di           ;smaller exponent
   278 000003B4 8B4C02              <1>         mov     cx,[si+expon]   ;larger exponent
   279 000003B7 2B4F02              <1>         sub     cx,[bx+expon]   ;smaller exponent
   280                              <1> 
   281 000003BA 8A6401              <1>         mov     ah,[si+sign]    ;get sign of source
   282 000003BD 326701              <1>         xor     ah,[bx+sign]    ;get sign of destination
   283 000003C0 743E                <1>         jz      FA070           ;go do add if signs are the same
   284                              <1> ; signs are different
   285 000003C2 E81602              <1>         call    vloadshift      ;get right shifted mantissa
   286                              <1> %if BIG
   287 000003C5 8B7C0A              <1>         mov     di,[si+mantis+6]
   288 000003C8 29CF                <1>         sub     di,cx
   289 000003CA 8B4C08              <1>         mov     cx,[si+mantis+4]
   290 000003CD 19D9                <1>         sbb     cx,bx
   291 000003CF 8B5C06              <1>         mov     bx,[si+mantis+2]
   292 000003D2 19C3                <1>         sbb     bx,ax
   293 000003D4 8B4404              <1>         mov     ax,[si+mantis]
   294 000003D7 19D0                <1>         sbb     ax,dx
   295 000003D9 87D7                <1>         xchg    dx,di               ; AX:BX:CX:DX
   296                              <1> %else
   297                              <1>         mov     bx,[si+mantis+2]
   298                              <1>         sub     bx,ax
   299                              <1>         mov     ax,[si+mantis]
   300                              <1>         sbb     ax,dx               ; AX:BX
   301                              <1> %endif
   302 000003DB 5F                  <1>         pop     di                  ;get where to put it
   303 000003DC 8B2C                <1>         mov     bp,[si]             ;get sign & exponent
   304 000003DE 892D                <1>         mov     [di],bp             ;store at destination
   305 000003E0 8B7402              <1>         mov     si,[si+expon]       ;get result exponent
   306 000003E3 7316                <1>         jnc     FA050
   307                              <1> ; carry is set, invert the sign, and negate the mantissa
   308 000003E5 80750101            <1>         xor     byte [di+sign],01h
   309                              <1> %if BIG
   310 000003E9 F7DA                <1>         neg     dx
   311 000003EB F5                  <1>         cmc
   312 000003EC F7D1                <1>         not     cx
   313 000003EE 83D100              <1>         adc     cx,0
   314 000003F1 F7D3                <1>         not     bx
   315 000003F3 83D300              <1>         adc     bx,0
   316                              <1> %else
   317                              <1>         neg     bx
   318                              <1>         cmc
   319                              <1> %endif
   320 000003F6 F7D0                <1>         not     ax
   321 000003F8 83D000              <1>         adc     ax,0                ;end of negate
   322                              <1> FA050:
   323                              <1> ; will have to normalize the result
   324                              <1> ; result exponent is currently in SI
   325 000003FB 87F7                <1>         xchg    si,di               ;swap exponent to DI, dest to SI
   326 000003FD E95A03              <1>         jmp     normalize_and_exit
   327                              <1> 
   328                              <1> ;  Actually add the mantissas
   329                              <1> 
   330                              <1> FA070:
   331 00000400 E8D801              <1>         call    vloadshift      ;get right shifted mantissa
   332                              <1> %if BIG
   333 00000403 034C0A              <1>         add     cx,[si+mantis+6]
   334 00000406 135C08              <1>         adc     bx,[si+mantis+4]
   335 00000409 134406              <1>         adc     ax,[si+mantis+2]
   336                              <1> %else
   337                              <1>         add     ax,[si+mantis+2]
   338                              <1> %endif
   339 0000040C 135404              <1>         adc     dx,[si+mantis]
   340 0000040F 5F                  <1>         pop     di
   341 00000410 8B2C                <1>         mov     bp,[si]             ;get sign & tag
   342 00000412 892D                <1>         mov     [di],bp             ;store them
   343                              <1> ; 
   344 00000414 8B7402              <1>         mov     si,[si+expon]       ;get exponent
   345 00000417 7309                <1>         jnc     FA080
   346 00000419 D1DA                <1>         rcr     dx,1                ;carry bit to DX
   347 0000041B D1D8                <1>         rcr     ax,1
   348                              <1> %if BIG
   349 0000041D D1DB                <1>         rcr     bx,1
   350 0000041F D1D9                <1>         rcr     cx,1
   351                              <1> %endif
   352 00000421 46                  <1>         inc     si                  ;increment exponent
   353                              <1> FA080:
   354 00000422 897502              <1>         mov     [di+expon],si       ;store result exponent
   355 00000425 895504              <1>         mov     [di+mantis],dx      ;store result
   356 00000428 894506              <1>         mov     [di+mantis+2],ax
   357                              <1> %if BIG
   358 0000042B 895D08              <1>         mov     [di+mantis+4],bx
   359 0000042E 894D0A              <1>         mov     [di+mantis+6],cx
   360                              <1> %endif
   361 00000431 87F7                <1>         xchg    si,di               ;return pointer in SI
   362                              <1> FA100:
   363 00000433 C3                  <1>         ret
   364                              <1> 
   365                              <1> ;do_add      endp
   366                              <1> 
   367                              <1> 
   368                              <1> 
   369                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   370                              <1> ;
   371                              <1> ;   FADD    ST,ST(i)        R=0, P=0
   372                              <1> ;   FADD    ST(i),ST        R=1, P=0
   373                              <1> ;   FADDP   ST(i),ST        R=1, P=1
   374                              <1> ;
   375                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   376                              <1> FADDrr:
   377 00000434 E846FF              <1>         call    RRsetup         ;get source and destination reg. ptrs
   378 00000437 89FB                <1>         mov     bx,di           ;BX is where final result will go
   379 00000439 E863FF              <1>         call    do_add          ;do the register to register add
   380 0000043C E95AFD              <1>         jmp     test_pop        ;test stack for pop
   381                              <1> 
   382                              <1> 
   383                              <1> 
   384                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   385                              <1> ;
   386                              <1> ;   FSUB    ST,ST(i)        R=0, P=0
   387                              <1> ;   FSUBR   ST(i),ST        R=1, P=0
   388                              <1> ;   FSUBRP  ST(i),ST        R=1, P=1
   389                              <1> ;
   390                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   391                              <1> FSUBi:
   392 0000043F 88CB                <1>         mov     bl,cl           ;get ST(i)
   393 00000441 E81A02              <1>         call    regptr          ;BX is ST(i) pointer
   394 00000444 89DE                <1>         mov     si,bx           ;SI is ST(i) pointer
   395 00000446 31DB                <1>         xor     bx,bx           ;get ST
   396 00000448 E81302              <1>         call    regptr          ;BX is ST pointer
   397 0000044B 89DF                <1>         mov     di,bx           ;DI is ST pointer
   398 0000044D 80740101            <1>         xor     byte [si+sign],01    ;invert ST(i) sign
   399 00000451 F6C504              <1>         test    ch,Rbit         ;see who gets the result
   400 00000454 750C                <1>         jnz     FSUBi01         ;ST(i) does
   401                              <1> ; ST gets the result
   402 00000456 56                  <1>         push    si              ;save ST(i) pointer
   403 00000457 E845FF              <1>         call    do_add          ;get the answer
   404 0000045A 5E                  <1>         pop     si              ;restore ST(i) pointer
   405 0000045B 80740101            <1>         xor     byte [si+sign],01    ;invert ST(i) sign
   406 0000045F E954FD              <1>         jmp     restore_segs    ;no pop is possible
   407                              <1> FSUBi01:
   408 00000462 89F3                <1>         mov     bx,si           ;result to ST(i)
   409                              <1> ;;;     push    OFFSET test_pop ;pop is possible
   410 00000464 68[9901]            <1>         push    test_pop	;pop is possible
   411 00000467 E935FF              <1>         jmp     do_add          ;will return to 'test_pop'
   412                              <1> 
   413                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   414                              <1> ;
   415                              <1> ;   FSUBR   ST,ST(i)        R=0, P=0
   416                              <1> ;   FSUB    ST(i),ST        R=1, P=0
   417                              <1> ;   FSUBP   ST(i),ST        R=1, P=1
   418                              <1> ;
   419                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   420                              <1> FSUB0:
   421 0000046A 88CB                <1>         mov     bl,cl           ;get ST(i)
   422 0000046C E8EF01              <1>         call    regptr          ;BX is ST(i) pointer
   423 0000046F 89DE                <1>         mov     si,bx           ;SI is ST(i) pointer
   424 00000471 31DB                <1>         xor     bx,bx           ;get ST
   425 00000473 E8E801              <1>         call    regptr          ;BX is ST pointer
   426 00000476 89DF                <1>         mov     di,bx           ;DI is ST pointer
   427 00000478 80750101            <1>         xor     byte [di+sign],01h   ;invert ST sign
   428 0000047C F6C504              <1>         test    ch,Rbit         ;see if ST(i) gets result
   429 0000047F 7506                <1>         jnz     FSUB001         ;
   430                              <1> ; ST gets the result
   431                              <1> ;;;     push    OFFSET restore_segs ;no pop is possible
   432 00000481 68[B601]            <1>         push    restore_segs	;no pop is possible
   433 00000484 E918FF              <1>         jmp     do_add          ;will return to exit sequence
   434                              <1> 
   435                              <1> FSUB001:    ; ST(i) will get the result
   436 00000487 89F3                <1>         mov     bx,si           ;ST(i) gets the result
   437 00000489 57                  <1>         push    di              ;save pointer to ST
   438 0000048A E812FF              <1>         call    do_add          ;do the register to register add
   439 0000048D 5F                  <1>         pop     di              ;restore pointer
   440 0000048E 80750101            <1>         xor     byte [di+sign],01h   ;restore the original sign
   441 00000492 E904FD              <1>         jmp     test_pop        ;possible pop of ST
   442                              <1> 
   443                              <1> 
   444                              <1> ; end em187a.asm
   519                                  %include "em187b.asm"
     1                              <1> ; em187b.asm
     2                              <1> 
     3 00000495 90                  <1> 	even
     4 00000496 [4D08][CD0F][EF0E]- <1> vecFST  dw  store_R32, store_I32, store_R64, store_I16  
     4 0000049C [930F]              <1>
     5                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     6                              <1> ;
     7                              <1> ;   FST     mem
     8                              <1> ;
     9                              <1> ;       ES:DI is the destination address
    10                              <1> ;
    11                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    12                              <1> genFST:
    13 0000049E 31DB                <1>         xor     bx,bx               ;get ST(0)
    14 000004A0 E8BB01              <1>         call    regptr              ;   pointer to BX
    15 000004A3 89DE                <1>         mov     si,bx               ;put source pointer in SI
    16 000004A5 BB0600              <1>         mov     bx,FMbits           ;get format mask
    17 000004A8 20EB                <1>         and     bl,ch
    18                              <1> 
    19                              <1> ;;;     push    OFFSET restore_segs
    20 000004AA 68[B601]            <1>         push    restore_segs
    21 000004AD 2EFFA7[9604]        <1>   cs    jmp     [vecFST+bx]          ;dispatch to proper store routine
    22                              <1>         
    23                              <1> 
    24                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    25                              <1> ;
    26                              <1> ;   FSTP    mem
    27                              <1> ;
    28                              <1> ;       ES:DI is the destination address
    29                              <1> ;
    30                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    31                              <1> genFSTP:
    32 000004B2 31DB                <1>         xor     bx,bx               ;get ST(0)
    33 000004B4 E8A701              <1>         call    regptr              ;   pointer to BX
    34 000004B7 89DE                <1>         mov     si,bx               ;put source pointer in SI
    35 000004B9 BB0600              <1>         mov     bx,FMbits           ;get format mask
    36 000004BC 20EB                <1>         and     bl,ch
    37 000004BE 56                  <1>         push    si                  ;save pointer to ST(0)
    38 000004BF 2EFF97[9604]        <1>   cs    call    [vecFST+bx]          ;dispatch to proper store routine
    39 000004C4 5B                  <1>         pop     bx                  ;get ST(0) pointer
    40 000004C5 E9DDFC              <1>         jmp     pop_stack           ;pop stack with BX set
    41                              <1> 
    42                              <1>         
    43                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    44                              <1> ;
    45                              <1> ;   FSTCW   mem         ; store Control Word
    46                              <1> ;
    47                              <1> ;       ES:DI is the destination address
    48                              <1> ;
    49                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    50                              <1> gFSTCW:
    51 000004C8 A10000              <1>         mov     ax,word [Control]
    52 000004CB 268905              <1>   es    mov     [di],ax
    53 000004CE E9E5FC              <1>         jmp     restore_segs
    54                              <1> 
    55                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    56                              <1> ;
    57                              <1> ;   FLDCW   mem         ; load Control Word
    58                              <1> ;
    59                              <1> ;       ES:DI is the source address
    60                              <1> ;
    61                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    62                              <1> gFLDCW:
    63 000004D1 268B05              <1>   es    mov     ax,word [di]
    64 000004D4 A30000              <1>         mov     [Control],ax        ;set up new control word
    65 000004D7 F6D0                <1>         not     al                  ;interrupt masks become interrupt enables
    66 000004D9 243F                <1>         and     al,3Fh              ;mask bits which may cause interrupt
    67 000004DB A21100              <1>         mov     [enables],al        ;store interrupt enables
    68                              <1> 
    69 000004DE 88E0                <1>         mov     al,ah               ;extract rounding bits
    70 000004E0 83E00C              <1>         and     ax,0Ch              ; **
    71 000004E3 D1E8                <1>         shr     ax,1                ;get 0, 2, 4 or 6
    72 000004E5 A30E00              <1>         mov     [round],ax          ;store rounding index
    73 000004E8 E9CBFC              <1>         jmp     restore_segs
    74                              <1> 
    75                              <1> 
    76                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    77                              <1> ;
    78                              <1> ;   FSTSW   mem         ; store Status Word (8087, 80287, 80387)
    79                              <1> ;   FSTSW   AX          ; store Status Word to AX (not on 8087)
    80                              <1> ;
    81                              <1> ;       ES:DI is the destination address
    82                              <1> ;
    83                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    84                              <1> FSTSW_ax:
    85 000004EB E80F00              <1>         call    get_status          ;get Status to AX
    86 000004EE 894614              <1>         mov     [v7_ax+bp],ax
    87 000004F1 E9C2FC              <1>         jmp     restore_segs
    88                              <1> gFSTSW:
    89 000004F4 E80600              <1>         call    get_status          ;get Status to AX
    90 000004F7 268905              <1>   es    mov     word [di],ax
    91 000004FA E9B9FC              <1>         jmp     restore_segs
    92                              <1> 
    93                              <1> ;
    94                              <1> ;   Get Status word to AX
    95                              <1> ;
    96                              <1> get_status:		;  proc    near
    97 000004FD A10200              <1>         mov     ax,[Status]
    98 00000500 8A361000            <1>         mov     dh,[tos]            ;get top of stack pointer
    99 00000504 C0E603              <1>         shl     dh,3
   100 00000507 08F4                <1>         or      ah,dh               ;combine TOS with condition codes
   101 00000509 84061100            <1>         test    al,[enables]        ;test for interrupts enabled
   102 0000050D 7402                <1>         jz      GS010
   103                              <1> 
   104 0000050F 0C80                <1>         or      al,Estatus        ;set error summary status
   105                              <1> GS010:
   106 00000511 C3                  <1>         ret
   107                              <1> ;get_status  endp
   108                              <1> 
   109                              <1> 
   110                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   111                              <1> ;
   112                              <1> ;   FLD     ST(i)       push operand onto stack from another register
   113                              <1> ;
   114                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   115                              <1> FLD_i_to_0:
   116 00000512 88CB                <1>         mov     bl,cl               ;source register
   117 00000514 E84701              <1>         call    regptr
   118 00000517 89DE                <1>         mov     si,bx               ;source pointer to si
   119 00000519 E81C01              <1>         call    alloc
   120 0000051C 89DF                <1>         mov     di,bx               ;destination pointer to di
   121                              <1> ;;;        cld
   122                              <1> %if 0
   123                              <1>             REPT   lenAccum/2
   124                              <1>         movsw
   125                              <1>             ENDM
   126                              <1> %else
   127                              <1> 	%rep	lenAccum/2
   128                              <1> 	movsw
   129                              <1> 	%endrep
   129 0000051E A5                  <2>  movsw
   129 0000051F A5                  <2>  movsw
   129 00000520 A5                  <2>  movsw
   129 00000521 A5                  <2>  movsw
   129 00000522 A5                  <2>  movsw
   129 00000523 A5                  <2>  movsw
   130                              <1> %endif
   131 00000524 E98FFC              <1>         jmp     restore_segs
   132                              <1> 
   133                              <1> 
   134                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   135                              <1> ;
   136                              <1> ;   FST     ST(i)       store ST(0) into another stack register
   137                              <1> ;
   138                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   139                              <1> FST_0_to_i:
   140 00000527 E853FE              <1>         call    RRsetup             ;setup SI and DI
   141                              <1> ;;;        cld
   142                              <1> %if 0
   143                              <1>             REPT   lenAccum/2
   144                              <1>         movsw
   145                              <1>             ENDM
   146                              <1> %else
   147                              <1> 	%rep	lenAccum/2
   148                              <1> 	movsw
   149                              <1> 	%endrep
   149 0000052A A5                  <2>  movsw
   149 0000052B A5                  <2>  movsw
   149 0000052C A5                  <2>  movsw
   149 0000052D A5                  <2>  movsw
   149 0000052E A5                  <2>  movsw
   149 0000052F A5                  <2>  movsw
   150                              <1> %endif
   151 00000530 E983FC              <1>         jmp     restore_segs
   152                              <1> 
   153                              <1> FSTP_0_to_i:
   154 00000533 E847FE              <1>         call    RRsetup             ;setup SI and DI
   155                              <1> ;;;        cld
   156 00000536 56                  <1>         push    si
   157                              <1> %if 0
   158                              <1>             REPT   lenAccum/2
   159                              <1>         movsw
   160                              <1>             ENDM
   161                              <1> %else
   162                              <1> 	%rep	lenAccum/2
   163                              <1> 	movsw
   164                              <1> 	%endrep
   164 00000537 A5                  <2>  movsw
   164 00000538 A5                  <2>  movsw
   164 00000539 A5                  <2>  movsw
   164 0000053A A5                  <2>  movsw
   164 0000053B A5                  <2>  movsw
   164 0000053C A5                  <2>  movsw
   165                              <1> %endif
   166                              <1> ; now pop the stack top
   167 0000053D 5B                  <1>         pop     bx
   168 0000053E E964FC              <1>         jmp     pop_stack
   169                              <1> 
   170                              <1> 
   171                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   172                              <1> ;
   173                              <1> ;   FXCH    ST(i)       exchange register with ST(0)
   174                              <1> ;
   175                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   176                              <1> gFXCH:
   177 00000541 E839FE              <1>         call    RRsetup             ;setup SI and DI
   178 00000544 B90600              <1>         mov     cx,lenAccum/2       ;get count of words to exchange
   179                              <1> ;;;        cld                         ;set to work forward
   180 00000547 90                  <1> 	even
   181                              <1> xch000:
   182 00000548 AD                  <1>         lodsw                       ;load AX and increment SI
   183 00000549 8B15                <1>         mov     dx,[di]             ;get DX from DI
   184 0000054B 8954FE              <1>         mov     [si-2],dx           ;remember SI has already been incremented
   185 0000054E AB                  <1>         stosw                       ;store AX and increment DI
   186 0000054F E2F7                <1>         loop    xch000              ; loop back until done
   187                              <1> 
   188 00000551 E962FC              <1>         jmp     restore_segs
   189                              <1> 
   190                              <1> 
   191                              <1> 
   192                              <1> %if BIG
   193                              <1> FP_1:
   194                              <1> ;FP_1    ACCUM   <tag_valid, 0, 0, 8000H, 0, 0, 0>
   195 00000554 0000                <1> 	db	tag_valid, 0
   196 00000556 000000800000000000- <1> 	dw	0, 8000H, 0, 0, 0
   196 0000055F 00                  <1>
   197                              <1> %else
   198                              <1> FP_1:
   199                              <1> ;FP_1    ACCUM   <tag_valid, 0, 0, 8000H, 0>
   200                              <1> 	db	tag_valid, 0
   201                              <1> 	dw	0, 8000H, 0
   202                              <1> %endif
   203                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   204                              <1> ;
   205                              <1> ;   FLD1        load the constant 1.0
   206                              <1> ;
   207                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   208                              <1> gFLD1:
   209                              <1> ;;;     mov     si,OFFSET   FP_1
   210 00000560 BE[5405]            <1>         mov     si, FP_1
   211 00000563 EB64                <1>         jmp     short gFLDconstant
   212                              <1> 
   213                              <1> %if BIG
   214                              <1> FP_L2T:
   215                              <1> ;FP_L2T    ACCUM   <tag_valid, 0, 1, 0D49Ah, 0784Bh, 0CD1Bh, 08AFEh>
   216 00000565 0000                <1> 	db	tag_valid, 0
   217 00000567 01009AD44B781BCDFE- <1> 	dw	1, 0D49Ah, 0784Bh, 0CD1Bh, 08AFEh
   217 00000570 8A                  <1>
   218                              <1> %else
   219                              <1> FP_L2T:
   220                              <1> ;FP_L2T    ACCUM   <tag_valid, 0, 1, 0D49Ah, 0784Ch>
   221                              <1> 	db	tag_valid, 0
   222                              <1> 	dw	1, 0D49Ah, 0784Ch
   223                              <1> %endif
   224                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   225                              <1> ;
   226                              <1> ;   FLDL2T        load the constant  LOG2(10)
   227                              <1> ;
   228                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   229                              <1> gFLDL2T:
   230                              <1> ;;;     mov     si,OFFSET   FP_L2T
   231 00000571 BE[6505]            <1>         mov     si, FP_L2T
   232 00000574 EB53                <1>         jmp     short gFLDconstant
   233                              <1> 
   234                              <1> %if BIG
   235                              <1> FP_L2E:
   236                              <1> ;FP_L2E    ACCUM   <tag_valid, 0, 0, 0B8AAh, 03B29h, 05C17h, 0F0BCh>
   237 00000576 0000                <1> 	db	tag_valid, 0
   238 00000578 0000AAB8293B175CBC- <1> 	dw	0, 0B8AAh, 03B29h, 05C17h, 0F0BCh
   238 00000581 F0                  <1>
   239                              <1> %else
   240                              <1> FP_L2E:
   241                              <1> ;FP_L2E    ACCUM   <tag_valid, 0, 0, 0B8AAh, 03B29h>
   242                              <1> 	db	tag_valid, 0
   243                              <1> 	dw	0, 0B8AAh, 03B29h
   244                              <1> %endif
   245                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   246                              <1> ;
   247                              <1> ;   FLDL2E        load the constant  LOG2(E)
   248                              <1> ;
   249                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   250                              <1> gFLDL2E:
   251                              <1> ;;;     mov     si,OFFSET   FP_L2E
   252 00000582 BE[7605]            <1>         mov     si, FP_L2E
   253 00000585 EB42                <1>         jmp     short gFLDconstant
   254                              <1> 
   255                              <1> %if BIG
   256                              <1> FP_PI:
   257                              <1> ;FP_PI    ACCUM   <tag_valid, 0, 1, 0C90Fh, 0DAA2h, 02168h, 0C235h>
   258 00000587 0000                <1> 	db	tag_valid, 0
   259 00000589 01000FC9A2DA682135- <1> 	dw	1, 0C90Fh, 0DAA2h, 02168h, 0C235h
   259 00000592 C2                  <1>
   260                              <1> %else
   261                              <1> FP_PI:
   262                              <1> ;FP_PI    ACCUM   <tag_valid, 0, 1, 0C90Fh, 0DAA2h>
   263                              <1> 	db	tag_valid, 0
   264                              <1> 	dw	1, 0C90Fh, 0DAA2h
   265                              <1> %endif
   266                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   267                              <1> ;
   268                              <1> ;   FLDPI        load the constant  PI
   269                              <1> ;
   270                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   271                              <1> gFLDPI:
   272 00000593 BE[8705]            <1>         mov     si,  FP_PI
   273 00000596 EB31                <1>         jmp     short gFLDconstant
   274                              <1> 
   275                              <1> %if BIG
   276                              <1> FP_LG2:
   277                              <1> ;FP_LG2    ACCUM   <tag_valid, 0, -2, 09A20h, 09A84h, 0FBCFh, 0F799h>
   278 00000598 0000                <1> 	db	tag_valid, 0
   279 0000059A FEFF209A849ACFFB99- <1> 	dw	-2, 09A20h, 09A84h, 0FBCFh, 0F799h
   279 000005A3 F7                  <1>
   280                              <1> %else
   281                              <1> FP_LG2:
   282                              <1> ;FP_LG2    ACCUM   <tag_valid, 0, -2, 09A20h, 09A85h>
   283                              <1> 	db	tag_valid, 0
   284                              <1> 	dw	-2, 09A20h, 09A85h
   285                              <1> %endif
   286                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   287                              <1> ;
   288                              <1> ;   FLDLG2        load the constant LOG10(2)
   289                              <1> ;
   290                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   291                              <1> gFLDLG2:
   292 000005A4 BE[9805]            <1>         mov     si,  FP_LG2
   293 000005A7 EB20                <1>         jmp     short gFLDconstant
   294                              <1> 
   295                              <1> %if BIG
   296                              <1> FP_LN2:
   297                              <1> ;FP_LN2    ACCUM   <tag_valid, 0, -1, 0B172h, 017F7h, 0D1CFh, 079ACh>
   298 000005A9 0000                <1> 	db	tag_valid, 0
   299 000005AB FFFF72B1F717CFD1AC- <1> 	dw	-1, 0B172h, 017F7h, 0D1CFh, 079ACh
   299 000005B4 79                  <1>
   300                              <1> %else
   301                              <1> FP_LN2:
   302                              <1> ;FP_LN2    ACCUM   <tag_valid, 0, -1, 0B172h, 017F8h>
   303                              <1> 	db	tag_valid, 0
   304                              <1> 	dw	-1, 0B172h, 017F8h
   305                              <1> %endif
   306                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   307                              <1> ;
   308                              <1> ;   FLDLN2        load the constant LN(2)
   309                              <1> ;
   310                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   311                              <1> gFLDLN2:
   312 000005B5 BE[A905]            <1>         mov     si,  FP_LN2
   313 000005B8 EB0F                <1>         jmp     short gFLDconstant
   314                              <1> 
   315                              <1> %if BIG
   316                              <1> FP_Z:
   317                              <1> ;FP_Z    ACCUM   <tag_zero, 0, exp_of_FPzero, 0, 0, 0, 0>
   318 000005BA 0100                <1> 	db	tag_zero, 0
   319 000005BC 018000000000000000- <1> 	dw	exp_of_FPzero, 0, 0, 0, 0
   319 000005C5 00                  <1>
   320                              <1> %else
   321                              <1> FP_Z:
   322                              <1> ;FP_Z    ACCUM   <tag_zero, 0, exp_of_FPzero, 0, 0>
   323                              <1> 	db	tag_zero, 0
   324                              <1> 	dw	exp_of_FPzero, 0, 0
   325                              <1> %endif
   326                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   327                              <1> ;
   328                              <1> ;   FLDZ        load the constant 0.0
   329                              <1> ;
   330                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   331                              <1> gFLDZ:
   332 000005C6 BE[BA05]            <1>         mov     si,  FP_Z
   333                              <1> gFLDconstant:
   334 000005C9 E86C00              <1>         call    alloc           ;allocate space on the stack
   335 000005CC 89DF                <1>         mov     di,bx
   336                              <1> ;;;        cld
   337 000005CE 8CC8                <1>         mov     ax,cs
   338 000005D0 8ED8                <1>         mov     ds,ax
   339                              <1> 		%rep lenAccum/2
   340                              <1>         movsw
   341                              <1> 		%endrep
   341 000005D2 A5                  <2>  movsw
   341 000005D3 A5                  <2>  movsw
   341 000005D4 A5                  <2>  movsw
   341 000005D5 A5                  <2>  movsw
   341 000005D6 A5                  <2>  movsw
   341 000005D7 A5                  <2>  movsw
   342 000005D8 E9DBFB              <1>         jmp     restore_segs
   343                              <1> 
   344                              <1> 
   345                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   346                              <1> ;   Name:  vloadshift
   347                              <1> ;   Desc:  get the mantissa pointed to by BX, and shift right by
   348                              <1> ;          the amount in CX.  Return result in  DX:AX[:BX:CX]
   349                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   350                              <1> vloadshift:		;  proc    near
   351                              <1> %if BIG
   352 000005DB 83F93F              <1>         cmp     cx,63       ;shift of 63 is the max for 64-bit mantissa
   353 000005DE 774E                <1>         ja      vlds100     ;go return zero
   354                              <1> 
   355 000005E0 56                  <1>         push    si          ;counter will be here for 64-bit mantissa
   356                              <1> %else
   357                              <1>         cmp     cx,31       ;shift of 31 is the max for 32-bit mantissa
   358                              <1>         ja      vlds100     ;go return zero
   359                              <1> %endif
   360 000005E1 8B5704              <1>         mov     dx,[bx+mantis]      ;first word of mantissa
   361 000005E4 8B4706              <1>         mov     ax,[bx+mantis+2]    ;second word
   362                              <1> %if BIG
   363 000005E7 8B770A              <1>         mov     si,[bx+mantis+6]    ;fourth word of mantissa
   364 000005EA 8B5F08              <1>         mov     bx,[bx+mantis+4]    ;third word of mantissa
   365                              <1> %endif
   366 000005ED 80F910              <1>         cmp     cl,16               ;compare to 16
   367 000005F0 7210                <1>         jb      vlds020             ;skip 16 bit shifts if below 16
   368                              <1> %if BIG
   369                              <1> vlds010:
   370 000005F2 89DE                <1>         mov     si,bx               ;shift by 16 bits
   371 000005F4 89C3                <1>         mov     bx,ax               ;**
   372                              <1> %endif
   373 000005F6 89D0                <1>         mov     ax,dx               ; **
   374 000005F8 31D2                <1>         xor     dx,dx               ;  **
   375 000005FA 80E910              <1>         sub     cl,16
   376                              <1> %if BIG
   377 000005FD 80F910              <1>         cmp     cl,16               ;compare if another 16-bit shift is needed
   378 00000600 77F0                <1>         ja      vlds010             ;loop back if above zero
   379                              <1> %endif
   380                              <1> vlds020:            ; check for 8 bit shift
   381 00000602 80F908              <1>         cmp     cl,8            
   382 00000605 7217                <1>         jb      vlds040
   383                              <1> %if BIG
   384 00000607 87CE                <1>         xchg    cx,si           ;do a long 8 bit shift
   385 00000609 88E9                <1>         mov     cl,ch
   386 0000060B 88DD                <1>         mov     ch,bl
   387 0000060D 88FB                <1>         mov     bl,bh
   388 0000060F 88C7                <1>         mov     bh,al
   389 00000611 87CE                <1>         xchg    cx,si
   390                              <1> %endif
   391 00000613 88E0                <1>         mov     al,ah           ;do the short portion of an 8-bit shift
   392 00000615 88D4                <1>         mov     ah,dl
   393 00000617 88F2                <1>         mov     dl,dh
   394 00000619 30F6                <1>         xor     dh,dh
   395 0000061B 80E908              <1>         sub     cl,8
   396                              <1> vlds040:
   397 0000061E E30A                <1>         jcxz    vlds090         ;may have been reduced this far
   398                              <1>         even
   399                              <1> vlds050:
   400 00000620 D1EA                <1>         shr     dx,1            ;short right shift of 1 bit
   401 00000622 D1D8                <1>         rcr     ax,1
   402                              <1> %if BIG
   403 00000624 D1DB                <1>         rcr     bx,1            ;long extension, right shift 1 bit
   404 00000626 D1DE                <1>         rcr     si,1
   405                              <1> %endif
   406 00000628 E2F6                <1>         loop    vlds050
   407                              <1> vlds090:
   408                              <1> %if BIG
   409 0000062A 89F1                <1>         mov     cx,si           ;result goes back in DX:AX:BX:CX
   410 0000062C 5E                  <1>         pop     si              ;restore saved register
   411                              <1> %endif
   412                              <1> vlds099:
   413 0000062D C3                  <1>         ret
   414                              <1> ; shift was so big, zero mantissa is the result
   415                              <1> vlds100:
   416 0000062E 31D2                <1>         xor     dx,dx
   417 00000630 31C0                <1>         xor     ax,ax
   418                              <1> %if BIG
   419 00000632 31DB                <1>         xor     bx,bx
   420 00000634 31C9                <1>         xor     cx,cx
   421                              <1> %endif
   422 00000636 EBF5                <1>         jmp     vlds099
   423                              <1> 
   424                              <1> ;vloadshift  endp
   425                              <1> 
   426                              <1> 
   427                              <1> 
   428                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   429                              <1> ; allocate FP stack element
   430                              <1> ;
   431                              <1> ;   return with [bx] pointing at stack top
   432                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   433                              <1> 	even
   434                              <1> alloc:		;   proc    near
   435 00000638 8A1E1000            <1>         mov     bl,[tos]        ;get top of stack
   436 0000063C FECB                <1>         dec     bl
   437 0000063E 83E307              <1>         and     bx,7            ;mask to 3 bits
   438 00000641 881E1000            <1>         mov     [tos],bl
   439 00000645 D1E3                <1>         shl     bx,1            ;index words
   440 00000647 2E8B9F[0602]        <1>   cs    mov     bx, [fp0tab+bx]  ; get accumulator array pointer
   441 0000064C 803F03              <1>         cmp     byte [bx+tag], tag_empty
   442 0000064F 7501                <1>         jne     alloc9
   443 00000651 C3                  <1>         ret
   444                              <1> alloc9:
   445 00000652 800E030002          <1>         or      byte [codes],C1        ;flag overflow
   446 00000657 684108              <1>         push    errStkOverflow+Sflag+Iexcept
   447 0000065A E89415              <1>         call    exception
   448 0000065D C3                  <1>         ret
   449                              <1> 
   450                              <1> ;alloc   endp
   451                              <1> 
   452                              <1> 
   453                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   454                              <1> ; regptr -- get pointer to ST(i), and check for validity
   455                              <1> ;  enter with reg in low 3 bits of bx
   456                              <1> ;  return with pointer in [bx]
   457                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   458                              <1>         even
   459                              <1> regptr:		;	  proc    near
   460 0000065E 021E1000            <1>         add     bl,[tos]        ;get index to actual register
   461 00000662 83E307              <1>         and     bx,7            ;mask to 3 bits
   462 00000665 D1E3                <1>         shl     bx,1            ;index words
   463 00000667 2E8B9F[0602]        <1>   cs    mov     bx, [fp0tab+bx]  ; get offset into accumulator array
   464 0000066C C3                  <1>         ret
   465                              <1> ;regptr  endp
   466                              <1> 
   467                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   468                              <1> ;
   469                              <1> ; load IEEE 4-byte real to accumulator
   470                              <1> ;       es:di   points to value to load
   471                              <1> ;       si      points to accumulator to receive value
   472                              <1> ; uses: ax & dx
   473                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   474                              <1> load_R32:	;	    proc    near
   475 0000066D 268B5502            <1>   es    mov     dx, word [di+2]     ;get exponent
   476 00000671 31C0                <1>         xor     ax,ax
   477 00000673 D1E2                <1>         shl     dx,1            ; sign goes to carry
   478 00000675 D0D0                <1>         rcl     al,1            ; sign goes to AL
   479 00000677 884401              <1>         mov     [si+sign], al
   480 0000067A 88F0                <1>         mov     al,dh           ; ax is biased exponent
   481 0000067C 09C0                <1>         or      ax,ax
   482 0000067E 742B                <1>         jz      lr3201
   483 00000680 3CFF                <1>         cmp     al,255          ; test for max exponent
   484 00000682 7479                <1>         je      lr3211
   485 00000684 C60400              <1>         mov     byte [si+tag], tag_valid
   486                              <1> 
   487 00000687 83E87F              <1>         sub     ax,127          ; get correct exponent
   488 0000068A 894402              <1>         mov     [si+expon], ax
   489 0000068D F9                  <1>         stc
   490 0000068E D0DA                <1>         rcr     dl,1            ; put fractional part on mantissa
   491 00000690 268B05              <1>   es    mov     ax, word [di]
   492 00000693 88D6                <1>         mov     dh,dl
   493 00000695 88E2                <1>         mov     dl,ah
   494 00000697 895404              <1>         mov     [si+mantis], dx
   495 0000069A 88C4                <1>         mov     ah,al
   496 0000069C 30C0                <1>         xor     al,al
   497 0000069E 894406              <1>         mov     word [si+mantis+2], ax
   498                              <1> %if  BIG
   499                              <1> lr3200:
   500 000006A1 31C0                <1>         xor     ax,ax
   501 000006A3 894408              <1>         mov     [si+mantis+4], ax           ; zero out low words
   502 000006A6 89440A              <1>         mov     [si+mantis+6], ax
   503                              <1> %endif
   504 000006A9 EB71                <1>         jmp     lr3299
   505                              <1> 
   506                              <1> ; biased exponent was 0
   507                              <1> lr3201:
   508 000006AB 08D0                <1>         or      al,dl
   509 000006AD 260B05              <1>   es    or      ax,word [di]
   510 000006B0 7516                <1>         jnz     lr3202           ; not a real zero
   511                              <1> ; got real zero
   512 000006B2 C60401              <1>         mov     byte [si+tag], tag_zero
   513 000006B5 C744020180          <1>         mov     word [si+expon], exp_of_FPzero
   514                              <1> lr32015:
   515 000006BA 894404              <1>         mov     [si+mantis], ax
   516 000006BD 894406              <1>         mov     [si+mantis+2], ax
   517                              <1> %if  BIG
   518 000006C0 894408              <1>         mov     [si+mantis+4], ax
   519 000006C3 89440A              <1>         mov     [si+mantis+6], ax
   520                              <1> %endif
   521 000006C6 EB54                <1>         jmp     lr3299
   522                              <1> 
   523                              <1> ; not a real zero -- actually a denormal
   524                              <1> lr3202:
   525 000006C8 6A02                <1>         push    Dexcept
   526 000006CA E82415              <1>         call    exception
   527                              <1> 
   528 000006CD 268B05              <1>   es    mov     ax,word [di]     ; get second word
   529 000006D0 D1E0                <1>         shl     ax,1
   530 000006D2 80D200              <1>         adc     dl,0                ;move bit into dl
   531                              <1> lr3203:
   532 000006D5 FECE                <1>         dec     dh              ; count shifts
   533 000006D7 D1E0                <1>         shl     ax,1            ; try to normalize
   534 000006D9 D0D2                <1>         rcl     dl,1
   535 000006DB 73F8                <1>         jnc     lr3203
   536                              <1> 
   537 000006DD D0DA                <1>         rcr     dl,1
   538 000006DF D1D8                <1>         rcr     ax,1            ; bit has been put back
   539 000006E1 86D4                <1>         xchg    dl,ah
   540 000006E3 86D0                <1>         xchg    dl,al
   541 000006E5 894404              <1>         mov     [si+mantis], ax
   542 000006E8 86D4                <1>         xchg    dl,ah
   543 000006EA 30C0                <1>         xor     al,al
   544 000006EC 894406              <1>         mov     [si+mantis+2], ax
   545 000006EF 88F0                <1>         mov     al,dh
   546 000006F1 98                  <1>         cbw
   547 000006F2 83E87F              <1>         sub     ax,127          ; get correct exponent
   548 000006F5 894402              <1>         mov     [si+expon], ax
   549 000006F8 C60400              <1>         mov     byte [si+tag], tag_valid           
   550                              <1> %if BIG
   551 000006FB EBA4                <1>         jmp     lr3200
   552                              <1> %else
   553                              <1>         jmp     lr3299
   554                              <1> %endif
   555                              <1> 
   556                              <1>         
   557                              <1> ; biased exponent was 255 -- possible infinity
   558                              <1> lr3211:
   559 000006FD 31C0                <1>         xor     ax,ax
   560 000006FF 260A15              <1>   es    or      dl, byte [di]
   561 00000702 260A5501            <1>   es    or      dl, byte [di+1]
   562 00000706 750A                <1>         jnz     lr3215              ; if not zero in packed for, NaN
   563 00000708 C60402              <1>         mov     byte [si+tag], tag_infin
   564                              <1> lr3213:
   565 0000070B C74402FF7F          <1>         mov     word [si+expon], exp_of_FPinf
   566 00000710 EBA8                <1>         jmp     lr32015
   567                              <1> 
   568                              <1> lr3215:
   569 00000712 C60406              <1>         mov     byte [si+tag], tag_invalid
   570 00000715 6A01                <1>         push    Iexcept
   571 00000717 E8D714              <1>         call    exception
   572                              <1> 
   573 0000071A EBEF                <1>         jmp     lr3213
   574                              <1> 
   575                              <1> lr3299:
   576 0000071C C3                  <1>         ret
   577                              <1> ;load_R32    endp
   578                              <1> 
   579                              <1> ; end em187b.asm
   520                                  %include "em187c.asm"
     1                              <1> ; em187c.asm
     2                              <1> 
     3                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     4                              <1> ;
     5                              <1> ; load 2-byte integer to accumulator
     6                              <1> ;       es:di   points to value to load
     7                              <1> ;       si      points to accumulator to receive value
     8                              <1> ;
     9                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    10                              <1> load_I16:		;    proc    near
    11 0000071D 268B05              <1>   es    mov     ax,word [di]            ;get 16 bit word
    12 00000720 31DB                <1>         xor     bx,bx
    13 00000722 BF0F00              <1>         mov     di,15                   ;initial exponent
    14 00000725 EB11                <1>         jmp     short L3200
    15                              <1> ;load_I16    endp
    16                              <1> 
    17                              <1> 
    18                              <1> LDindef:
    19 00000727 6A01                <1>         push    Iexcept
    20 00000729 E8C514              <1>         call    exception
    21 0000072C EB2C                <1>         jmp     short L3204
    22                              <1> 
    23                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    24                              <1> ;
    25                              <1> ; load 4-byte integer to accumulator
    26                              <1> ;       es:di   points to value to load
    27                              <1> ;       si      points to accumulator to receive value
    28                              <1> ;
    29                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    30                              <1> load_I32:		;    proc    near
    31 0000072E 268B1D              <1>   es    mov     bx,[di]          ;get low order
    32 00000731 268B4502            <1>   es    mov     ax,[di+2]
    33 00000735 BF1F00              <1>         mov     di,31               ;initial exponent
    34                              <1> L3200:
    35                              <1> %if BIG
    36 00000738 31C9                <1>         xor     cx,cx               ;if 64 bit mantissas,
    37 0000073A 31D2                <1>         xor     dx,dx               ;  zero out the low order
    38                              <1> %endif
    39 0000073C C6440100            <1>         mov     byte [si+sign],0
    40 00000740 09C0                <1>         or      ax,ax           ;test sign of integer
    41 00000742 7D16                <1>         jge     L3204
    42                              <1> ; is negative, must negate
    43 00000744 FE4401              <1>         inc     byte [si+sign]       ;indicate negative value
    44 00000747 F7D0                <1>         not     ax
    45                              <1> %if BIG
    46 00000749 31ED                <1>         xor     bp,bp           ;get a zero
    47 0000074B F7D3                <1>         not     bx
    48 0000074D F7D1                <1>         not     cx
    49 0000074F F7DA                <1>         neg     dx
    50 00000751 F5                  <1>         cmc
    51 00000752 11E9                <1>         adc     cx,bp
    52 00000754 11EB                <1>         adc     bx,bp
    53 00000756 11E8                <1>         adc     ax,bp
    54                              <1> %else
    55                              <1>         neg     bx
    56                              <1>         cmc
    57                              <1>         adc     ax,0
    58                              <1> %endif
    59 00000758 78CD                <1>         js      LDindef
    60                              <1> L3204:
    61                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    62                              <1> ;
    63                              <1> ;   Normalize the value in AX:BX:[CX:DX], 
    64                              <1> ;   adjusting the exponent in di
    65                              <1> ;
    66                              <1> ;   Tag, exponent, and mantissa are stored at DS:SI if normal number
    67                              <1> ;   Tag and sign stored, too, if result is zero
    68                              <1> ;
    69                              <1> ;   BP is destroyed
    70                              <1> ;
    71                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    72                              <1> normalize_and_exit:
    73 0000075A 89C5                <1>         mov     bp,ax               ;test for zero result first
    74 0000075C 09DD                <1>         or      bp,bx               ;
    75                              <1> %if BIG
    76 0000075E 09CD                <1>         or      bp,cx
    77 00000760 09D5                <1>         or      bp,dx
    78                              <1> %endif
    79 00000762 7446                <1>         jz      NM060               ;result of FADD is zero
    80 00000764 C60400              <1>         mov     byte [si+tag], tag_valid
    81                              <1> NM055:
    82 00000767 09C0                <1>         or      ax,ax               ;test for hi zero
    83 00000769 750A                <1>         jnz     short NM056
    84 0000076B 93                  <1>         xchg    bx,ax
    85                              <1> %if BIG
    86 0000076C 87CB                <1>         xchg    cx,bx
    87 0000076E 87D1                <1>         xchg    dx,cx
    88                              <1> %endif
    89 00000770 83EF10              <1>         sub     di,16               ;decrease exponent
    90 00000773 EBF2                <1>         jmp     NM055
    91                              <1> NM056:
    92 00000775 08E4                <1>         or      ah,ah               ;test for hi zero byte
    93 00000777 7511                <1>         jnz     short   NM057
    94 00000779 86C4                <1>         xchg    al,ah
    95 0000077B 86F8                <1>         xchg    bh,al
    96 0000077D 86DF                <1>         xchg    bl,bh
    97                              <1> %if BIG
    98 0000077F 86EB                <1>         xchg    ch,bl
    99 00000781 86CD                <1>         xchg    cl,ch
   100 00000783 86F1                <1>         xchg    dh,cl
   101 00000785 86D6                <1>         xchg    dl,dh
   102                              <1> %endif
   103 00000787 83EF08              <1>         sub     di,8                ;adjust exponent
   104                              <1> NM057:
   105 0000078A F6C480              <1>         test    ah,80H              ;test for normalized bit
   106 0000078D 750B                <1>         jnz     NM058
   107                              <1> %if BIG
   108 0000078F D1E2                <1>         shl     dx,1                ;normalize a bit at a time
   109 00000791 D1D1                <1>         rcl     cx,1
   110 00000793 D1D3                <1>         rcl     bx,1
   111                              <1> %else
   112                              <1>         shl     bx,1
   113                              <1> %endif
   114 00000795 D1D0                <1>         rcl     ax,1
   115 00000797 4F                  <1>         dec     di                  ;decrease exponent
   116 00000798 EBF0                <1>         jmp     NM057
   117                              <1> 
   118                              <1> NM058:  ; non-zero result
   119 0000079A 897C02              <1>         mov     [si+expon],di       ;store new exponent
   120 0000079D 894404              <1>         mov     [si+mantis],ax
   121 000007A0 895C06              <1>         mov     [si+mantis+2],bx
   122                              <1> %if BIG
   123 000007A3 894C08              <1>         mov     [si+mantis+4],cx
   124 000007A6 89540A              <1>         mov     [si+mantis+6],dx
   125                              <1> %endif
   126 000007A9 C3                  <1>         ret
   127                              <1> 
   128                              <1> 
   129                              <1> NM060:  ; zero result
   130 000007AA C60401              <1>         mov     byte [si+tag], tag_zero      ;result was zero
   131 000007AD 884401              <1>         mov     [si+sign],al            ;all regs are zero
   132 000007B0 BF0180              <1>         mov     di,exp_of_FPzero        ;zero has funny exponent
   133 000007B3 EBE5                <1>         jmp     NM058
   134                              <1> 
   135                              <1> ;load_I32    endp
   136                              <1> 
   137                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   138                              <1> ;
   139                              <1> ;   FILD    qword ptr QJ        load 64-bit integer
   140                              <1> ;
   141                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   142                              <1> FLDi64:
   143 000007B5 E880FE              <1>         call    alloc                   ;get new ST
   144 000007B8 89DE                <1>         mov     si,bx                   ;SI will receive value
   145 000007BA 68[B601]            <1>         push    restore_segs     ; call to load_I64 returns to r_s
   146                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   147                              <1> ;
   148                              <1> ; load 8-byte integer to accumulator
   149                              <1> ;       es:di   points to value to load
   150                              <1> ;       si      points to accumulator to receive value
   151                              <1> ;
   152                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   153                              <1> load_I64:		;    proc    near
   154 000007BD 268B15              <1>   es    mov     dx,[di]      ;get lowest order
   155 000007C0 268B4D02            <1>   es    mov     cx,[di+2]
   156 000007C4 268B5D04            <1>   es    mov     bx,[di+4]
   157 000007C8 268B4506            <1>   es    mov     ax,[di+6]
   158 000007CC BF3F00              <1>         mov     di,63           ;initial exponent
   159                              <1> 
   160 000007CF C60400              <1>         mov     byte [si+tag], tag_valid
   161 000007D2 C6440100            <1>         mov     byte [si+sign],0
   162 000007D6 09C0                <1>         or      ax,ax           ;test sign of integer
   163 000007D8 7D1B                <1>         jge     L6404
   164                              <1> ; is negative, must negate
   165 000007DA FE4401              <1>         inc     byte [si+sign]       ;indicate negative value
   166 000007DD 31ED                <1>         xor     bp,bp           ;get a zero
   167 000007DF F7D0                <1>         not     ax
   168 000007E1 F7D3                <1>         not     bx
   169 000007E3 F7D1                <1>         not     cx
   170 000007E5 F7DA                <1>         neg     dx
   171 000007E7 F5                  <1>         cmc
   172 000007E8 11E9                <1>         adc     cx,bp
   173 000007EA 11EB                <1>         adc     bx,bp
   174 000007EC 11E8                <1>         adc     ax,bp
   175 000007EE 7905                <1>         jns     L6404
   176                              <1> ; loading integer indefinite
   177 000007F0 6A01                <1>         push    Iexcept
   178 000007F2 E8FC13              <1>         call    exception
   179                              <1> L6404:
   180 000007F5 89C5                <1>         mov     bp,ax               ;test for zero result first
   181 000007F7 09DD                <1>         or      bp,bx               ;
   182 000007F9 09CD                <1>         or      bp,cx
   183 000007FB 09D5                <1>         or      bp,dx
   184 000007FD 7443                <1>         jz      L6460               ;result is zero
   185                              <1> L6455:
   186 000007FF 09C0                <1>         or      ax,ax               ;test for hi zero
   187 00000801 750A                <1>         jnz     short   L6456
   188 00000803 93                  <1>         xchg    bx,ax
   189 00000804 87CB                <1>         xchg    cx,bx
   190 00000806 87D1                <1>         xchg    dx,cx
   191 00000808 83EF10              <1>         sub     di,16               ;decrease exponent
   192 0000080B EBF2                <1>         jmp     L6455
   193                              <1> L6456:
   194 0000080D 08E4                <1>         or      ah,ah               ;test for hi zero byte
   195 0000080F 7511                <1>         jnz     short   L6457
   196 00000811 86C4                <1>         xchg    al,ah
   197 00000813 86F8                <1>         xchg    bh,al
   198 00000815 86DF                <1>         xchg    bl,bh
   199 00000817 86EB                <1>         xchg    ch,bl
   200 00000819 86CD                <1>         xchg    cl,ch
   201 0000081B 86F1                <1>         xchg    dh,cl
   202 0000081D 86D6                <1>         xchg    dl,dh
   203 0000081F 83EF08              <1>         sub     di,8                ;adjust exponent
   204                              <1> L6457:
   205 00000822 F6C480              <1>         test    ah,80H              ;test for normalized bit
   206 00000825 750B                <1>         jnz     L6458
   207 00000827 D1E2                <1>         shl     dx,1                ;normalize a bit at a time
   208 00000829 D1D1                <1>         rcl     cx,1
   209 0000082B D1D3                <1>         rcl     bx,1
   210 0000082D D1D0                <1>         rcl     ax,1
   211 0000082F 4F                  <1>         dec     di                  ;decrease exponent
   212 00000830 EBF0                <1>         jmp     L6457
   213                              <1> 
   214                              <1> L6458:  ; non-zero result
   215 00000832 897C02              <1>         mov     [si+expon],di       ;store new exponent
   216 00000835 894404              <1>         mov     [si+mantis],ax
   217 00000838 895C06              <1>         mov     [si+mantis+2],bx
   218                              <1> %if BIG
   219 0000083B 894C08              <1>         mov     [si+mantis+4],cx
   220 0000083E 89540A              <1>         mov     [si+mantis+6],dx
   221                              <1> %endif
   222 00000841 C3                  <1>         ret
   223                              <1> 
   224                              <1> 
   225                              <1> L6460:  ; zero result
   226 00000842 C60401              <1>         mov     byte [si+tag], tag_zero      ;result was zero
   227 00000845 884401              <1>         mov     [si+sign],al            ;all regs are zero
   228 00000848 BF0180              <1>         mov     di,exp_of_FPzero        ;zero has funny exponent
   229 0000084B EBE5                <1>         jmp     L6458
   230                              <1> 
   231                              <1> ;load_I64    endp
   232                              <1> 
   233                              <1> 
   234                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   235                              <1> ;   Store a REAL 32-bit value
   236                              <1> ;
   237                              <1> ;       ES:DI is the destination address
   238                              <1> ;       SI is the source address
   239                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   240                              <1> store_R32:		;   proc    near
   241 0000084D 803C01              <1>         cmp     byte [si+tag], tag_zero  ;test for problem tags
   242 00000850 7338                <1>         jae     str3270             ;jump if not tag_valid
   243 00000852 8B4402              <1>         mov     ax,[si+expon]       ;get exponent
   244 00000855 8B5C04              <1>         mov     bx,[si+mantis]      ;get high order mantissa
   245 00000858 8B4C06              <1>         mov     cx,[si+mantis+2]    ;get lower order mantissa
   246 0000085B 81C18000            <1>         add     cx,0080H            ;round to nearest for now
   247 0000085F 83D300              <1>         adc     bx,0                ;continue
   248 00000862 7221                <1>         jc      str3250             ;jump if carry
   249                              <1> str3210:
   250 00000864 83E881              <1>         sub     ax,-127             ;bias the exponent
   251 00000867 7E37                <1>         jle     str3279             ;go store +0.0
   252 00000869 3DFF00              <1>         cmp     ax,255              ;check for overflow
   253 0000086C 7342                <1>         jae     str3285             ;overflow
   254 0000086E 88C6                <1>         mov     dh,al               ;exponent to DH
   255 00000870 88FA                <1>         mov     dl,bh               ;hi-mantissa to DL
   256 00000872 D0E2                <1>         shl     dl,1                ;hide hi-bit
   257 00000874 0A5401              <1>         or      dl,[si+sign]        ;get sign in low order
   258 00000877 D1CA                <1>         ror     dx,1                ;get high word of result
   259 00000879 26895502            <1>   es    mov     [di+2],dx        ;store it
   260 0000087D 88D9                <1>         mov     cl,bl               ;form low word
   261 0000087F 86CD                <1>         xchg    cl,ch               ;swap bytes
   262 00000881 26890D              <1>   es    mov     [di],cx          ;store low word of result
   263                              <1> str3299:
   264 00000884 C3                  <1>         ret
   265                              <1> ; 
   266                              <1> ; carry occurred on round to nearest; fix the exponent and result
   267                              <1> str3250:
   268 00000885 D1DB                <1>         rcr     bx,1                ;put hi-bit back
   269 00000887 40                  <1>         inc     ax                  ;increment the exponent
   270 00000888 EBDA                <1>         jmp     str3210             ;CX is zero
   271                              <1> str3270:
   272 0000088A 771D                <1>         ja      str3280             ;jump if not tag_zero
   273                              <1> str3275:
   274                              <1> ; store signed zero
   275 0000088C 31C0                <1>         xor     ax,ax
   276                              <1> str3276:
   277 0000088E 8A5C01              <1>         mov     bl,[si+sign]        ;get the sign
   278 00000891 D0EB                <1>         shr     bl,1
   279 00000893 D1D8                <1>         rcr     ax,1                ;move sign to hi-bit
   280                              <1> str3277:
   281 00000895 26894502            <1>   es    mov     [di+2],ax        ;
   282 00000899 31C0                <1>         xor     ax,ax               ;zap it out
   283 0000089B 268905              <1>   es    mov     [di],ax          ;store low zero
   284 0000089E EBE4                <1>         jmp     str3299
   285                              <1> 
   286                              <1> ; store absolute zero
   287                              <1> str3279:
   288 000008A0 6A10                <1>         push    Uexcept             ;underflow
   289 000008A2 E84C13              <1>         call    exception
   290                              <1> 
   291 000008A5 31C0                <1>         xor     ax,ax               ;zap hi-word
   292 000008A7 EBEC                <1>         jmp     str3277
   293                              <1> 
   294                              <1> ; tag is not zero
   295                              <1> str3280:
   296 000008A9 803C02              <1>         cmp     byte [si+tag], tag_infin ;test for infinity
   297 000008AC 7407                <1>         je      str3286
   298 000008AE 770A                <1>         ja      str3290
   299                              <1> ; store signed infinity
   300                              <1> str3285:
   301 000008B0 6A08                <1>         push    Oexcept             ;overflow
   302 000008B2 E83C13              <1>         call    exception
   303                              <1> str3286:
   304 000008B5 B800FF              <1>         mov     ax,0FF00h           ;following code will store sign
   305 000008B8 EBD4                <1>         jmp     str3276             ;go put on sign
   306                              <1> 
   307                              <1> ; store indefinite
   308                              <1> str3290:
   309 000008BA B8C0FF              <1>         mov     ax,0FFC0h           ;get indefinite code
   310 000008BD 6A01                <1>         push    Iexcept             ;invalid operation
   311 000008BF E82F13              <1>         call    exception
   312 000008C2 EBD1                <1>         jmp     str3277             ;go store it
   313                              <1> ;store_R32   endp
   314                              <1> 
   315                              <1> 
   316                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   317                              <1> ;
   318                              <1> ;   FCHS        change the sign of ST
   319                              <1> ;
   320                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   321                              <1> gFCHS:
   322 000008C4 30DB                <1>         xor     bl,bl               ;get ST pointer
   323 000008C6 E895FD              <1>         call    regptr              ; in BX
   324 000008C9 80770101            <1>         xor     byte [bx+sign],1         ;invert the sign
   325 000008CD E9E6F8              <1>         jmp     restore_segs
   326                              <1> 
   327                              <1> 
   328                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   329                              <1> ;
   330                              <1> ;   FABS        absolute value of ST
   331                              <1> ;
   332                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   333                              <1> gFABS:
   334 000008D0 30DB                <1>         xor     bl,bl               ;get ST pointer
   335 000008D2 E889FD              <1>         call    regptr              ; in BX
   336 000008D5 C6470100            <1>         mov     byte [bx+sign],0         ;clear the sign
   337 000008D9 E9DAF8              <1>         jmp     restore_segs
   338                              <1> 
   339                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   340                              <1> ;
   341                              <1> ;   FADD    mem         add memory to ST
   342                              <1> ;
   343                              <1> ;       ES:DI is pointer to memory location
   344                              <1> ;
   345                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   346                              <1> genFADD:
   347 000008DC BE2C00              <1>         mov     si,Areg      ;load first into the Areg
   348 000008DF BB0600              <1>         mov     bx,FMbits           ;get format mask
   349 000008E2 20EB                <1>         and     bl,ch
   350 000008E4 2EFF97[3603]        <1>   cs    call    [vecFLD+bx]          ;get the input argument
   351 000008E9 30DB                <1>         xor     bl,bl
   352 000008EB E870FD              <1>         call    regptr              ;get ST pointer in BX
   353 000008EE 89DF                <1>         mov     di,bx               ;DI is destination, SI is source
   354                              <1> ;  call to  do_add  returns to  restore_segs
   355 000008F0 68[B601]            <1>         push    restore_segs
   356 000008F3 E9A9FA              <1>         JMP     do_add
   357                              <1> 
   358                              <1> 
   359                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   360                              <1> ;
   361                              <1> ;   FSUB    mem         ST := ST - mem
   362                              <1> ;
   363                              <1> ;       ES:DI is pointer to memory location
   364                              <1> ;
   365                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   366                              <1> genFSUB:
   367 000008F6 BE2C00              <1>         mov     si,Areg      ;load first into the Areg
   368 000008F9 BB0600              <1>         mov     bx,FMbits           ;get format mask
   369 000008FC 20EB                <1>         and     bl,ch
   370 000008FE 2EFF97[3603]        <1>   cs    call    [vecFLD+bx]          ;get the input argument
   371 00000903 30DB                <1>         xor     bl,bl
   372 00000905 E856FD              <1>         call    regptr              ;get ST pointer in BX
   373 00000908 89DF                <1>         mov     di,bx               ;DI is destination, SI is source
   374 0000090A 80740101            <1>         xor     byte [si+sign],01h       ;invert the sign
   375                              <1> ;  call to  do_add  returns to  restore_segs
   376 0000090E 68[B601]            <1>         push    restore_segs
   377 00000911 E98BFA              <1>         JMP     do_add
   378                              <1> 
   379                              <1> 
   380                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   381                              <1> ;
   382                              <1> ;   FSUBR   mem         ST := mem - ST
   383                              <1> ;
   384                              <1> ;       ES:DI is pointer to memory location
   385                              <1> ;
   386                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   387                              <1> genFSUBR:
   388 00000914 BE2C00              <1>         mov     si,Areg      ;load first into the Areg
   389 00000917 BB0600              <1>         mov     bx,FMbits           ;get format mask
   390 0000091A 20EB                <1>         and     bl,ch
   391 0000091C 2EFF97[3603]        <1>   cs    call    [vecFLD+bx]          ;get the input argument
   392 00000921 30DB                <1>         xor     bl,bl
   393 00000923 E838FD              <1>         call    regptr              ;get ST pointer in BX
   394 00000926 89DF                <1>         mov     di,bx               ;DI is destination, SI is source
   395 00000928 80750101            <1>         xor     byte [di+sign],01h       ;invert the sign
   396                              <1> 
   397                              <1> ;  call to  do_add  returns to  restore_segs
   398 0000092C 68[B601]            <1>         push    restore_segs
   399 0000092F E96DFA              <1>         JMP     do_add
   400                              <1> 
   401                              <1> 
   402                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   403                              <1> ;
   404                              <1> ;   FDECSTP         decrement the stack pointer
   405                              <1> ;
   406                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   407                              <1> gFDECSTP:
   408 00000932 FE0E1000            <1>         dec     byte [tos]
   409 00000936 8026100007          <1>         and     byte [tos],7           ;mask to 3 bits
   410 0000093B E978F8              <1>         jmp     restore_segs
   411                              <1> 
   412                              <1> 
   413                              <1> 
   414                              <1> 
   415                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   416                              <1> ;
   417                              <1> ;   FINCSTP         increment the stack pointer
   418                              <1> ;
   419                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   420                              <1> gFINCSTP:
   421 0000093E FE061000            <1>         inc     byte [tos]
   422 00000942 8026100007          <1>         and     byte [tos],7           ;mask to 3 bits
   423 00000947 E96CF8              <1>         jmp     restore_segs
   424                              <1> 
   425                              <1> 
   426                              <1> 
   427                              <1>         even
   428                              <1> %if BIG
   429                              <1> ptanCon:
   430                              <1> ;	ACCUM   <tag_valid, 0, 4, 087c0H, 0, 0, 0>
   431 0000094A 0000                <1> 	db	tag_valid, 0
   432 0000094C 0400C0870000000000- <1> 	dw	4, 087c0H, 0, 0, 0
   432 00000955 00                  <1>
   433                              <1> ;       ACCUM   <tag_valid, 1, 3, 0f000H, 0, 0, 0>
   434 00000956 0001                <1> 	db	tag_valid, 1
   435 00000958 030000F00000000000- <1> 	dw	3, 0f000H, 0, 0, 0
   435 00000961 00                  <1>
   436                              <1> ;       ACCUM   <tag_valid, 0, 3, 0d000H, 0, 0, 0>
   437 00000962 0000                <1> 	db	tag_valid, 0
   438 00000964 030000D00000000000- <1> 	dw	3, 0d000H, 0, 0, 0
   438 0000096D 00                  <1>
   439                              <1> ;       ACCUM   <tag_valid, 1, 3, 0b000H, 0, 0, 0>
   440 0000096E 0001                <1> 	db	tag_valid, 1
   441 00000970 030000B00000000000- <1> 	dw	3, 0b000H, 0, 0, 0
   441 00000979 00                  <1>
   442                              <1> ;       ACCUM   <tag_valid, 0, 3, 09000H, 0, 0, 0>
   443 0000097A 0000                <1> 	db	tag_valid, 0
   444 0000097C 030000900000000000- <1> 	dw	3, 09000H, 0, 0, 0
   444 00000985 00                  <1>
   445                              <1> ;       ACCUM   <tag_valid, 1, 2, 0e000H, 0, 0, 0>
   446 00000986 0001                <1> 	db	tag_valid, 1
   447 00000988 020000E00000000000- <1> 	dw	2, 0e000H, 0, 0, 0
   447 00000991 00                  <1>
   448                              <1> ;       ACCUM   <tag_valid, 0, 2, 0a000H, 0, 0, 0>
   449 00000992 0000                <1> 	db	tag_valid, 0
   450 00000994 020000A00000000000- <1> 	dw	2, 0a000H, 0, 0, 0
   450 0000099D 00                  <1>
   451                              <1> ;       ACCUM   <tag_valid, 1, 1, 0c000H, 0, 0, 0>
   452 0000099E 0001                <1> 	db	tag_valid, 1
   453 000009A0 010000C00000000000- <1> 	dw	1, 0c000H, 0, 0, 0
   453 000009A9 00                  <1>
   454                              <1> ;       ACCUM   <tag_valid, 0, 0, 08000H, 0, 0, 0>
   455 000009AA 0000                <1> 	db	tag_valid, 0
   456 000009AC 000000800000000000- <1> 	dw	0, 08000H, 0, 0, 0
   456 000009B5 00                  <1>
   457                              <1> %else
   458                              <1> ptanCon:
   459                              <1> ;	ACCUM   <tag_valid, 0, 3, 08f20H, 0>
   460                              <1> 	db	tag_valid, 0
   461                              <1> 	dw	3, 08f20H, 0
   462                              <1> ;       ACCUM   <tag_valid, 1, 2, 0e000H, 0>
   463                              <1> 	db	tag_valid, 1
   464                              <1> 	dw	2, 0e000H, 0
   465                              <1> ;       ACCUM   <tag_valid, 0, 2, 0a000H, 0>
   466                              <1> 	db	tag_valid, 0
   467                              <1> 	dw	2, 0a000H, 0
   468                              <1> ;       ACCUM   <tag_valid, 1, 1, 0c000H, 0>
   469                              <1> 	db	tag_valid, 1
   470                              <1> 	dw	1, 0c000H, 0
   471                              <1> ;       ACCUM   <tag_valid, 0, 0, 08000H, 0>
   472                              <1> 	db	tag_valid, 0
   473                              <1> 	dw	0, 08000H, 0
   474                              <1> %endif
   475                              <1> ptanConLen equ $-ptanCon
   476                              <1> %if (ptanConLen > lenCreg)
   477                              <1> 	%error not enough constant space in Creg
   478                              <1> %endif
   479                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   480                              <1> ;
   481                              <1> ;   FPTAN           8087 partial tangent
   482                              <1> ;
   483                              <1> ;       use the continued fraction approximation:
   484                              <1> ;
   485                              <1> ;       abs(x) <= pi/4
   486                              <1> ;
   487                              <1> ;   tan(x)/x = 1/1-xx/3-xx/5-xx/7-xx/9-...
   488                              <1> ;       where xx = x*x
   489                              <1> ;
   490                              <1> ;   Enter with X on the top of the stack.  Leave it there
   491                              <1> ;   and compute the denominator 1-xx/3-xx/5-... and push it
   492                              <1> ;   on the stack.  A following FDIV instruction will yield
   493                              <1> ;   the tangent.
   494                              <1> ;
   495                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   496                              <1> gFPTAN:
   497 000009B6 B93600              <1>         mov     cx,ptanConLen/2         ;number of words to move
   498 000009B9 BE[4A09]            <1>         mov     si,ptanCon       ;start of constant list
   499 000009BC E83B10              <1>         call    moveconsts              ;address constants from DS
   500                              <1> 
   501 000009BF 30DB                <1>         xor     bl,bl                   ;get ST pointer
   502 000009C1 E89AFC              <1>         call    regptr                  ;  in BX
   503 000009C4 803F01              <1>         cmp     byte [bx+tag], tag_zero
   504 000009C7 774E                <1>         ja      PT100                   ;error
   505                              <1> %if BIG
   506 000009C9 837F02E0            <1>         cmp     word [bx+expon], -32
   507                              <1> %else
   508                              <1>         cmp     word [bx+expon], -16
   509                              <1> %endif
   510 000009CD 7C45                <1>         jl      PT070                   ;value is very small
   511                              <1> 
   512 000009CF 89DE                <1>         mov     si,bx                   ;set for multiplication
   513 000009D1 89DF                <1>         mov     di,bx                   ; **
   514 000009D3 E862FC              <1>         call    alloc                   ;get new stack location
   515 000009D6 891E1800            <1>         mov     [trptr2],bx               ;save XX ptr
   516 000009DA E89306              <1>         call    do_mul                  ;SI is ptr to  XX
   517 000009DD 89F7                <1>         mov     di,si                   ;DI->XX
   518 000009DF 8B361600            <1>         mov     si,[trptr]                ;get constant pointer
   519 000009E3 C6061B0008          <1>         mov     byte [trctr],ptanConLen/lenAccum - 1   ;count thru constants
   520 000009E8 EB09                <1>         jmp     PT030
   521                              <1> PT020:
   522 000009EA 89F3                <1>         mov     bx,si                   ;sum to Areg
   523 000009EC E8B0F9              <1>         call    do_add                  ;SI->denom
   524 000009EF 8B3E1800            <1>         mov     di,[trptr2]               ;DI->XX
   525                              <1> PT030:
   526 000009F3 BB2C00              <1>         mov     bx,Areg          ;
   527 000009F6 E85408              <1>         call    do_div                  ;SI->XX/denom (Areg)
   528 000009F9 8B3E1600            <1>         mov     di,[trptr]
   529 000009FD 83C70C              <1>         add     di,lenAccum             ;point at next constant
   530 00000A00 893E1600            <1>         mov     [trptr],di
   531 00000A04 FE0E1B00            <1>         dec     byte [trctr]
   532 00000A08 75E0                <1>         jnz     PT020
   533                              <1> 
   534 00000A0A 8B1E1800            <1>         mov     bx,[trptr2]               ;sum to ST
   535 00000A0E E88EF9              <1>         call    do_add                  ;DI->denom
   536                              <1> PT099:
   537 00000A11 E9A2F7              <1>         jmp     restore_segs
   538                              <1> 
   539                              <1> PT070:      ; exponent is so very small
   540 00000A14 E949FB              <1>         jmp     gFLD1                   ;
   541                              <1> 
   542                              <1> PT100:      ; top of stack is not valid
   543 00000A17 E81EFC              <1>         call    alloc
   544 00000A1A C60706              <1>         mov     byte [bx+tag], tag_invalid
   545                              <1> 
   546 00000A1D 6A01                <1>         push    Iexcept
   547 00000A1F E8CF11              <1>         call    exception
   548 00000A22 EBED                <1>         jmp     PT099
   549                              <1> 
   550                              <1> 
   551                              <1> 	even
   552                              <1> %if BIG
   553                              <1> f2xm1Con:
   554                              <1> ;	ACCUM	<tag_valid, 1, 6, 0cfbfH, 0828eH, 0879aH, 0eed4H>
   555 00000A24 0001                <1> 	db	tag_valid, 1
   556 00000A26 0600BFCF8E829A87D4- <1> 	dw	6, 0cfbfH, 0828eH, 0879aH, 0eed4H
   556 00000A2F EE                  <1>
   557                              <1> ;	ACCUM	<tag_valid, 0, 12, 0a3e8H, 0660eH, 063d3H, 01526H>
   558 00000A30 0000                <1> 	db	tag_valid, 0
   559 00000A32 0C00E8A30E66D36326- <1> 	dw	12, 0a3e8H, 0660eH, 063d3H, 01526H
   559 00000A3B 15                  <1>
   560                              <1> ;	ACCUM	<tag_valid, 1, 17, 0a292H, 08a64H, 0d703H, 074a4H>
   561 00000A3C 0001                <1> 	db	tag_valid, 1
   562 00000A3E 110092A2648A03D7A4- <1> 	dw	17, 0a292H, 08a64H, 0d703H, 074a4H
   562 00000A47 74                  <1>
   563                              <1> ;	ACCUM	<tag_valid, 0, 21, 0dbe2H, 02ee9H, 08949H, 0c206H>
   564 00000A48 0000                <1> 	db	tag_valid, 0
   565 00000A4A 1500E2DBE92E498906- <1> 	dw	21, 0dbe2H, 02ee9H, 08949H, 0c206H
   565 00000A53 C2                  <1>
   566                              <1> ;	ACCUM	<tag_valid, 1, 25, 0ce32H, 03827H, 0285dH, 05fdcH>
   567 00000A54 0001                <1> 	db	tag_valid, 1
   568 00000A56 190032CE27385D28DC- <1> 	dw	25, 0ce32H, 03827H, 0285dH, 05fdcH
   568 00000A5F 5F                  <1>
   569                              <1> ;	ACCUM	<tag_valid, 0, 29, 08225H, 08eb0H, 0c7e7H, 09b90H>
   570 00000A60 0000                <1> 	db	tag_valid, 0
   571 00000A62 1D002582B08EE7C790- <1> 	dw	29, 08225H, 08eb0H, 0c7e7H, 09b90H
   571 00000A6B 9B                  <1>
   572                              <1> ;	ACCUM	<tag_valid, 1, 31, 0c92cH, 06ff2H, 0ed46H, 050cbH>
   573 00000A6C 0001                <1> 	db	tag_valid, 1
   574 00000A6E 1F002CC9F26F46EDCB- <1> 	dw	31, 0c92cH, 06ff2H, 0ed46H, 050cbH
   574 00000A77 50                  <1>
   575                              <1> ;	ACCUM	<tag_valid, 0, 33, 0911dH, 0b676H, 0b025H, 0cdc2H>
   576 00000A78 0000                <1> 	db	tag_valid, 0
   577 00000A7A 21001D9176B625B0C2- <1> 	dw	33, 0911dH, 0b676H, 0b025H, 0cdc2H
   577 00000A83 CD                  <1>
   578                              <1> 
   579                              <1> ;	ACCUM	<tag_valid, 0, 10, 0c854H, 0ee83H, 05d90H, 0364bH>
   580 00000A84 0000                <1> 	db	tag_valid, 0
   581 00000A86 0A0054C883EE905D4B- <1> 	dw	10, 0c854H, 0ee83H, 05d90H, 0364bH
   581 00000A8F 36                  <1>
   582                              <1> ;	ACCUM	<tag_valid, 0, 18, 0fe16H, 06f19H, 03deeH, 0d4d4H>
   583 00000A90 0000                <1> 	db	tag_valid, 0
   584 00000A92 120016FE196FEE3DD4- <1> 	dw	18, 0fe16H, 06f19H, 03deeH, 0d4d4H
   584 00000A9B D4                  <1>
   585                              <1> ;	ACCUM	<tag_valid, 0, 24, 0f7e6H, 00399H, 0de4bH, 07174H>
   586 00000A9C 0000                <1> 	db	tag_valid, 0
   587 00000A9E 1800E6F799034BDE74- <1> 	dw	24, 0f7e6H, 00399H, 0de4bH, 07174H
   587 00000AA7 71                  <1>
   588                              <1> 
   589                              <1> %else
   590                              <1> f2xm1Con:
   591                              <1> ;	ACCUM   <tag_valid, 0, 6, 0aed5H, 0c231H>
   592                              <1> 	db	tag_valid, 0
   593                              <1> 	dw	6, 0aed5H, 0c231H
   594                              <1> ;	ACCUM   <tag_valid, 0, 9, 09a7eH, 039aaH>
   595                              <1> 	db	tag_valid, 0
   596                              <1> 	dw	9, 09a7eH, 039aaH
   597                              <1> ;	ACCUM   <tag_valid, 0, -5, 08df4H, 0dff9H>
   598                              <1> 	db	tag_valid, 0
   599                              <1> 	dw	-5, 08df4H, 0dff9H
   600                              <1> ;	ACCUM   <tag_valid, 0, 3, 09f46H, 0063aH>
   601                              <1> 	db	tag_valid, 0
   602                              <1> 	dw	3, 09f46H, 0063aH
   603                              <1> %endif
   604                              <1> f2xm1ConLen equ $-f2xm1Con
   605                              <1> %if (f2xm1ConLen > lenCreg)
   606                              <1>     %error not enough constant space in Creg
   607                              <1> %endif
   608                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   609                              <1> ;
   610                              <1> ;   F2XM1	2**X - 1
   611                              <1> ;
   612                              <1> ;	-1 < X < 1  --  for the 187/387
   613                              <1> ;
   614                              <1> ;	Enter with X on the stack top.  Compute 2**X-1, replacing
   615                              <1> ;	stack top with output.
   616                              <1> ;
   617                              <1> ;    Method:
   618                              <1> ;	To compute  exp(x),  take the Gaussian continued fraction:
   619                              <1> ;	 x 
   620                              <1> ;	e  =  1/1 - x/1 + x/2 - x/3 + x/2 - x/5 + x/2 - x/7 + x/2 -+ ...
   621                              <1> ;
   622                              <1> ;	and truncate at the ninth term.  Rearrange to:
   623                              <1> ;
   624                              <1> ;			    2 	    3    4
   625                              <1> ;	1680 + 840 x + 180 x  + 20 x  + x
   626                              <1> ;       -----------------------------------
   627                              <1> ;			    2 	    3    4
   628                              <1> ;	1680 - 840 x + 180 x  - 20 x  + x
   629                              <1> ;
   630                              <1> ;	which becomes:
   631                              <1> ;
   632                              <1> ;	1 + 2x / (b3 * x**2 - x + b4 -  b2 / (x**2 + b1) )
   633                              <1> ;
   634                              <1> ;	where b1..b4 are constants.  Finally substitute x = y * ln 2
   635                              <1> ;	and derive the constants C1..C4.  Compute as above, omitting the
   636                              <1> ;	" 1 + ".
   637                              <1> ;
   638                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   639                              <1> FX100:
   640 00000AA8 6A01                <1>         push    Iexcept
   641 00000AAA E84411              <1>         call    exception
   642 00000AAD E99400              <1>         jmp     FX099
   643                              <1> 
   644                              <1> gF2XM1:
   645 00000AB0 B94200              <1>         mov     cx,f2xm1ConLen/2        ;number of words to move
   646 00000AB3 BE[240A]            <1>         mov     si,f2xm1Con      ;start of constant list
   647 00000AB6 E8410F              <1>         call    moveconsts              ;address constants from DS
   648                              <1> 
   649 00000AB9 30DB                <1>         xor     bl,bl                   ;get ST pointer
   650 00000ABB E8A0FB              <1>         call    regptr                  ;  in BX
   651 00000ABE 803F01              <1>         cmp     byte [bx+tag], tag_zero
   652 00000AC1 77E5                <1>         ja      FX100			;error
   653                              <1> 
   654 00000AC3 891E1800            <1> 	mov	[trptr2],bx		;save ST pointer
   655                              <1> 
   656                              <1> %if BIG
   657                              <1> ; 64-bit mantissa version
   658 00000AC7 89DE                <1> 	mov	si,bx			;SI = X ptr
   659 00000AC9 BB2C00              <1> 	mov	bx,Areg
   660 00000ACC C6061B0008          <1> 	mov	byte [trctr],8			;count 8 coefficients
   661                              <1> ; DI has trptr
   662 00000AD1 EB0B                <1> 	jmp	short FX020
   663                              <1> 
   664                              <1> FX010:
   665 00000AD3 89F3                <1> 	mov	bx,si			;point to destination
   666 00000AD5 8B3E1800            <1> 	mov	di,[trptr2]		;get X pointer
   667 00000AD9 E89405              <1> 	call	do_mul			; * X
   668 00000ADC 89F3                <1> 	mov	bx,si			; set to add another Coeff
   669                              <1> FX020:
   670 00000ADE 8B3E1600            <1> 	mov	di,[trptr]		; get next trptr
   671 00000AE2 E8BAF8              <1> 	call	do_add
   672 00000AE5 830616000C          <1> 	add	word [trptr],lenAccum		;bump the coeff ptr
   673 00000AEA FE0E1B00            <1> 	dec	byte [trctr]
   674 00000AEE 75E3                <1> 	jnz	FX010
   675                              <1> 
   676                              <1> ; now compute X*X to the Breg
   677 00000AF0 8B361800            <1> 	mov	si,[trptr2]		;get ST pointer
   678 00000AF4 89F7                <1> 	mov	di,si			;copy it
   679 00000AF6 BB3800              <1> 	mov	bx,Breg
   680 00000AF9 E87405              <1> 	call	do_mul			;Breg is X*X
   681 00000AFC BBBC00              <1> 	mov	bx,Creg + lenAccum*2	;place to put it
   682 00000AFF C6061B0003          <1> 	mov	byte [trctr],3			;count 3 coefficients
   683 00000B04 EB0A                <1> 	jmp	short FX040
   684                              <1> 
   685                              <1> FX030:
   686 00000B06 89F3                <1> 	mov	bx,si			;point to destination
   687 00000B08 BF3800              <1> 	mov	di,Breg		;get X pointer
   688 00000B0B E86205              <1> 	call	do_mul			; * X
   689 00000B0E 89F3                <1> 	mov	bx,si			; set to add another Coeff
   690                              <1> FX040:
   691 00000B10 8B3E1600            <1> 	mov	di,[trptr]		; get next trptr
   692 00000B14 E888F8              <1> 	call	do_add
   693 00000B17 830616000C          <1> 	add	word [trptr],lenAccum		;bump the coeff ptr
   694 00000B1C FE0E1B00            <1> 	dec	byte [trctr]
   695 00000B20 75E4                <1> 	jnz	FX030
   696                              <1> 
   697 00000B22 8B3E1800            <1> 	mov	di,[trptr2]		;get stack top
   698 00000B26 89FB                <1> 	mov	bx,di			;result there
   699 00000B28 E84505              <1> 	call	do_mul			;ST = X * num
   700 00000B2B 89F3                <1> 	mov	bx,si
   701 00000B2D BFA400              <1> 	mov	di,Creg		;get first coeff ptr
   702 00000B30 C6450100            <1> 	mov	byte [di+sign],0		;set positive
   703 00000B34 E83905              <1> 	call	do_mul			; ST = coeff * X * num
   704 00000B37 89F7                <1> 	mov	di,si
   705 00000B39 BE2C00              <1> 	mov	si,Areg		;denominator ptr
   706 00000B3C 89FB                <1> 	mov	bx,di			;put result in stack top
   707 00000B3E E80C07              <1> 	call	do_div
   708 00000B41 FF4402              <1> 	inc	word [si+expon]		;double it
   709                              <1> %else
   710                              <1> ; 32-bit mantissa version
   711                              <1> 	mov	si,bx			;set to get X*X
   712                              <1> 	mov	di,bx			; **
   713                              <1> 	mov	bx,Areg		;put X*X in Areg
   714                              <1> 	call	do_mul			;SI points at Areg
   715                              <1> 	mov	di,[trptr]		;get Creg ptr
   716                              <1> 	mov	bx,di			;result to Creg
   717                              <1> 	call	do_add			;C1 + X*X in Creg
   718                              <1> 	mov	di,si			;Creg ptr to DI
   719                              <1> 	add	di,lenAccum		;C2 ptr to DI
   720                              <1> 	mov	bx,di
   721                              <1> 	call	do_div			;C2 = C2/(x*x + C1)
   722                              <1> 	push	si			;save C2 ptr
   723                              <1> 	add	si,lenAccum		;get c3 pointer
   724                              <1> 	mov	di,Areg		;get X*X pointer
   725                              <1> 	mov	bx,si			;result to C3
   726                              <1> 	call	do_mul			;C3 = C3 * X*X
   727                              <1> 	mov	di,si			;
   728                              <1> 	add	di,lenAccum		;get C4 pointer in DI
   729                              <1> 	mov	bx,di			;result to C4
   730                              <1> 	call	do_add
   731                              <1> 	pop	di			;restore C2 pointer
   732                              <1> 	push	si			;save C4 pointer
   733                              <1> 	mov	si,[trptr2]		;get ST pointer
   734                              <1> 	mov	bx,di			;C2 gets sum
   735                              <1> 	call	do_add			;C2 = X + C2/()
   736                              <1> 	xor	byte [si+sign],01		;negate it
   737                              <1> 	pop	di			;get C4 pointer
   738                              <1> 	mov	bx,di
   739                              <1> 	call	do_add			;result to C4
   740                              <1> 	mov	di,[trptr2]		;get ST pointer again
   741                              <1> 	mov	bx,di
   742                              <1> 	call	do_div			;get half of result
   743                              <1> 	inc	word [si+expon]		;get result
   744                              <1> %endif
   745                              <1> FX099:
   746 00000B44 E96FF6              <1> 	jmp	restore_segs		;and exit
   747                              <1> 
   748                              <1> 
   749                              <1> 
   750 00000B47 90                  <1> 	even
   751                              <1> %if BIG
   752                              <1> fl2xCon1:
   753 00000B48 0001                <1> 	db	tag_valid, 1
   754 00000B4A 010004B533F3DEF984- <1> 	dw	1, 0b504H, 0f333H, 0f9deH, 06484H;-sqrt(0.5)
   754 00000B53 64                  <1>
   755 00000B54 0000                <1> 	db	tag_valid, 0
   756 00000B56 04007680F06B104078- <1> 	dw	4, 08076H, 06bf0H, 04010H, 0a778H	;c23
   756 00000B5F A7                  <1>
   757 00000B60 0000                <1> 	db	tag_valid, 0
   758 00000B62 0400B28C3776A4E4A8- <1> 	dw	4, 08cb2H, 07637H, 0e4a4H, 086a8H	;c21
   758 00000B6B 86                  <1>
   759 00000B6C 0000                <1> 	db	tag_valid, 0
   760 00000B6E 0400819BFAE07F6825- <1> 	dw	4, 09b81H, 0e0faH, 0687fH, 0f325H	;c19
   760 00000B77 F3                  <1>
   761 00000B78 0000                <1> 	db	tag_valid, 0
   762 00000B7A 0400CDADDB64F8A11A- <1> 	dw	4, 0adcdH, 064dbH, 0a1f8H, 06a1aH	;c17
   762 00000B83 6A                  <1>
   763 00000B84 0000                <1> 	db	tag_valid, 0
   764 00000B86 0400F9C4B4D87FA6B7- <1> 	dw	4, 0c4f9H, 0d8b4H, 0a67fH, 0efb7H	;c15
   764 00000B8F EF                  <1>
   765 00000B90 0000                <1> 	db	tag_valid, 0
   766 00000B92 040047E346ABBB98E7- <1> 	dw	4, 0e347H, 0ab46H, 098bbH, 000e7H	;c13
   766 00000B9B 00                  <1>
   767 00000B9C 0000                <1> 	db	tag_valid, 0
   768 00000B9E 03004D864C4211A043- <1> 	dw	3, 0864dH, 0424cH, 0a011H, 06943H	;c11
   768 00000BA7 69                  <1>
   769 00000BA8 0000                <1> 	db	tag_valid, 0
   770 00000BAA 030025A4EB8915E0C4- <1> 	dw	3, 0a425H, 089ebH, 0e015H, 047c4H	;c9
   770 00000BB3 47                  <1>
   771 00000BB4 0000                <1> 	db	tag_valid, 0
   772 00000BB6 03000BD353B1F6D6FB- <1> 	dw	3, 0d30bH, 0b153H, 0d6f6H, 0c9fbH	;c7
   772 00000BBF C9                  <1>
   773 00000BC0 0000                <1> 	db	tag_valid, 0
   774 00000BC2 0200BB938762DF7CCA- <1> 	dw	2, 093bbH, 06287H, 07cdfH, 0f3caH	;c5
   774 00000BCB F3                  <1>
   775 00000BCC 0000                <1> 	db	tag_valid, 0
   776 00000BCE 020038F6E14E1FD0A5- <1> 	dw	2, 0f638H, 04ee1H, 0d01fH, 0eba5H	;c3
   776 00000BD7 EB                  <1>
   777 00000BD8 0000                <1> 	db	tag_valid, 0
   778 00000BDA 0000AAB8293B175CBC- <1> 	dw	0, 0b8aaH, 03b29H, 05c17H, 0f0bcH	;c1
   778 00000BE3 F0                  <1>
   779 00000BE4 0000                <1> 	db	tag_valid, 0
   780 00000BE6 010000800000000000- <1> 	dw	1, 08000H, 0H, 0H, 0H		; 1/2
   780 00000BEF 00                  <1>
   781                              <1> 
   782                              <1> fl2xCon1Len equ $-fl2xCon1
   783                              <1> %if (fl2xCon1Len > lenCreg)
   784                              <1>     %error not enough constant space in Creg
   785                              <1> %endif
   786                              <1> 
   787                              <1> fl2xCon2:
   788 00000BF0 0000                <1> 	db	tag_valid, 0
   789 00000BF2 0400F9C4B4D87FA6B7- <1> 	dw	4, 0c4f9H, 0d8b4H, 0a67fH, 0efb7H	;c15
   789 00000BFB EF                  <1>
   790 00000BFC 0001                <1> 	db	tag_valid, 1
   791 00000BFE 04000BD353B1F6D6FB- <1> 	dw	4, 0d30bH, 0b153H, 0d6f6H, 0c9fbH	;m14
   791 00000C07 C9                  <1>
   792 00000C08 0000                <1> 	db	tag_valid, 0
   793 00000C0A 040047E346ABBB98E7- <1> 	dw	4, 0e347H, 0ab46H, 098bbH, 000e7H	;c13
   793 00000C13 00                  <1>
   794 00000C14 0001                <1> 	db	tag_valid, 1
   795 00000C16 040038F6E14E1FD0A5- <1> 	dw	4, 0f638H, 04ee1H, 0d01fH, 0eba5H	;m12
   795 00000C1F EB                  <1>
   796 00000C20 0000                <1> 	db	tag_valid, 0
   797 00000C22 03004D864C4211A043- <1> 	dw	3, 0864dH, 0424cH, 0a011H, 06943H	;c11
   797 00000C2B 69                  <1>
   798 00000C2C 0001                <1> 	db	tag_valid, 1
   799 00000C2E 0300BB938762DF7CCA- <1> 	dw	3, 093bbH, 06287H, 07cdfH, 0f3caH	;m10
   799 00000C37 F3                  <1>
   800 00000C38 0000                <1> 	db	tag_valid, 0
   801 00000C3A 030025A4EB8915E0C4- <1> 	dw	3, 0a425H, 089ebH, 0e015H, 047c4H	;c9
   801 00000C43 47                  <1>
   802 00000C44 0001                <1> 	db	tag_valid, 1
   803 00000C46 0300AAB8293B175CBC- <1> 	dw	3, 0b8aaH, 03b29H, 05c17H, 0f0bcH	;m8
   803 00000C4F F0                  <1>
   804 00000C50 0000                <1> 	db	tag_valid, 0
   805 00000C52 03000BD353B1F6D6FB- <1> 	dw	3, 0d30bH, 0b153H, 0d6f6H, 0c9fbH	;c7
   805 00000C5B C9                  <1>
   806 00000C5C 0001                <1> 	db	tag_valid, 1
   807 00000C5E 030038F6E14E1FD0A5- <1> 	dw	3, 0f638H, 04ee1H, 0d01fH, 0eba5H	;m6
   807 00000C67 EB                  <1>
   808 00000C68 0000                <1> 	db	tag_valid, 0
   809 00000C6A 0200BB938762DF7CCA- <1> 	dw	2, 093bbH, 06287H, 07cdfH, 0f3caH	;c5
   809 00000C73 F3                  <1>
   810 00000C74 0001                <1> 	db	tag_valid, 1
   811 00000C76 0200AAB8293B175CBC- <1> 	dw	2, 0b8aaH, 03b29H, 05c17H, 0f0bcH	;m4
   811 00000C7F F0                  <1>
   812 00000C80 0000                <1> 	db	tag_valid, 0
   813 00000C82 020038F6E14E1FD0A5- <1> 	dw	2, 0f638H, 04ee1H, 0d01fH, 0eba5H	;c3
   813 00000C8B EB                  <1>
   814 00000C8C 0001                <1> 	db	tag_valid, 1
   815 00000C8E 0100AAB8293B175CBC- <1> 	dw	1, 0b8aaH, 03b29H, 05c17H, 0f0bcH	;m2
   815 00000C97 F0                  <1>
   816 00000C98 0000                <1> 	db	tag_valid, 0
   817 00000C9A 0000AAB8293B175CBC- <1> 	dw	0, 0b8aaH, 03b29H, 05c17H, 0f0bcH	;c1
   817 00000CA3 F0                  <1>
   818                              <1> fl2xCon2Len equ $-fl2xCon2
   819                              <1> %if (fl2xCon2Len > lenCreg)
   820                              <1>     %error not enough constant space in Creg
   821                              <1> %endif
   822                              <1> 
   823                              <1> %else
   824                              <1> fl2xCon1:
   825                              <1> 	db	tag_valid, 1
   826                              <1> 	dw	1, 0b504H, 0f334H	; -sqrt(0.5)
   827                              <1> 	db	tag_valid, 1
   828                              <1> 	dw	0, 0b2e3H, 03d74H
   829                              <1> 	db	tag_valid, 1
   830                              <1> 	dw	0, 0c9a1H, 058dcH
   831                              <1> 	db	tag_valid, 0
   832                              <1> 	dw	3, 09f05H, 0d27cH
   833                              <1> 	db	tag_valid, 0
   834                              <1> 	dw	0, 0e10eH, 08d9dH
   835                              <1> 	db	tag_valid, 0
   836                              <1> 	dw	1, 08000H, 00000H	; 1/2
   837                              <1> fl2xCon1Len equ $-fl2xCon1
   838                              <1> %if (fl2xCon1Len > lenCreg)
   839                              <1>     %error not enough constant space in Creg
   840                              <1> %endif
   841                              <1> 
   842                              <1> fl2xCon2:
   843                              <1> 	db	tag_valid, 1
   844                              <1> 	dw	2, 0b8aaH, 03b29H
   845                              <1> 	db	tag_valid, 0
   846                              <1> 	dw	2, 0f638H, 04ee2H
   847                              <1> 	db	tag_valid, 1
   848                              <1> 	dw	1, 0b8aaH, 03b29H
   849                              <1> 	db	tag_valid, 0
   850                              <1> 	dw	0, 0b8aaH, 03b29H
   851                              <1> fl2xCon2Len equ $-fl2xCon2
   852                              <1> %if (fl2xCon2Len > lenCreg)
   853                              <1>     %error not enough constant space in Creg
   854                              <1> %endif
   855                              <1> %endif
   856                              <1> 
   857                              <1> 
   858                              <1> 
   859                              <1> ;
   860                              <1> ;   exceptions for FYL2X
   861                              <1> ;
   862 00000CA4 7414                <1> FY200:	je	FY250		;test for zero
   863 00000CA6 B301                <1> FY210:	mov	bl,1		;tag is infinity, invalid, empty, etc.
   864 00000CA8 E8B3F9              <1> 	call	regptr
   865 00000CAB C60706              <1> 	mov	byte [bx+tag], tag_invalid
   866                              <1> FY240:
   867 00000CAE 6A01                <1>         push    Iexcept
   868                              <1> %if BIG
   869                              <1> FYexception:
   870                              <1> %endif
   871 00000CB0 E83E0F              <1>         call    exception
   872 00000CB3 8B1E1800            <1> 	mov	bx,[trptr2]
   873 00000CB7 E94201              <1> 	jmp	FY999
   874                              <1> 
   875                              <1> FY250:	 ;tag is zero
   876 00000CBA B301                <1> 	mov	bl,1		;result is - infinity
   877 00000CBC E89FF9              <1> 	call	regptr
   878 00000CBF C60702              <1> 	mov	byte [bx+tag], tag_infin
   879 00000CC2 C6470101            <1> 	mov	byte [bx+sign],01	;minus
   880 00000CC6 C74702FF7F          <1> 	mov	word [bx+expon], exp_of_FPinf	;set exponent
   881 00000CCB 31C0                <1> 	xor	ax,ax
   882 00000CCD 894704              <1> 	mov	[bx+mantis],ax
   883 00000CD0 894706              <1> 	mov	[bx+mantis+2],ax
   884                              <1> %if BIG
   885 00000CD3 894708              <1> 	mov	[bx+mantis+4],ax
   886 00000CD6 89470A              <1> 	mov	[bx+mantis+6],ax
   887                              <1> %endif
   888 00000CD9 EBD3                <1> 	jmp	FY240
   889                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   890                              <1> ;
   891                              <1> ;    FYL2X	Y times LOG2(X)
   892                              <1> ;
   893                              <1> ;	Y multiplier is in ST(1)
   894                              <1> ;	X argument is at stack top, ST
   895                              <1> ;
   896                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   897                              <1> gFYL2X:
   898 00000CDB 31DB                <1> 	xor	bx,bx		;get ST pointer
   899 00000CDD E87EF9              <1> 	call	regptr		; in BX
   900 00000CE0 891E1800            <1> 	mov	[trptr2],bx	;save stack top pointer
   901 00000CE4 803F01              <1> 	cmp	byte [bx+tag], tag_zero	;test for valid tag
   902 00000CE7 73BB                <1> 	jae	FY200
   903 00000CE9 807F0100            <1> 	cmp	byte [bx+sign],0	;test for +
   904 00000CED 75B7                <1> 	jne	FY210
   905                              <1> 
   906 00000CEF 8B4702              <1> 	mov	ax,[bx+expon]	;get X exponent
   907 00000CF2 40                  <1> 	inc	ax		;test against 0 or 1
   908 00000CF3 D1E8                <1> 	shr	ax,1
   909 00000CF5 7565                <1> 	jnz	FY100		;not zero or 1, do long computation
   910                              <1> ; exponent is zero or 1, further test needed
   911 00000CF7 BE2C00              <1> 	mov	si,Areg	;get -1 in Areg
   912 00000CFA C60400              <1> 	mov	byte [si+tag], tag_valid	;tag and sign to zero
   913 00000CFD C6440101            <1> 	mov	byte [si+sign],01	; minus
   914 00000D01 C744040080          <1> 	mov	word [si+mantis],8000h	;
   915 00000D06 31C0                <1> 	xor	ax,ax
   916 00000D08 894402              <1> 	mov	[si+expon],ax
   917 00000D0B 894406              <1> 	mov	[si+mantis+2],ax
   918                              <1> %if BIG
   919 00000D0E 894408              <1> 	mov	[si+mantis+4],ax
   920 00000D11 89440A              <1> 	mov	[si+mantis+6],ax
   921                              <1> %endif
   922 00000D14 89DF                <1> 	mov	di,bx		; ST is arg
   923 00000D16 89F3                <1> 	mov	bx,si		;result to Areg
   924 00000D18 E884F6              <1> 	call	do_add		;Areg = X - 1.0
   925 00000D1B 8B1E1800            <1> 	mov	bx,[trptr2]	;restore ST pointer
   926                              <1> %if BIG
   927 00000D1F 837C02FB            <1> 	cmp	word [si+expon],-5	;test exponent
   928                              <1> %else
   929                              <1> 	cmp	word [si+expon],-8	;test exponent
   930                              <1> %endif
   931 00000D23 7F37                <1> 	jg	FY100		;larger values go thru long computation
   932                              <1> ; have Areg is X-1, very near zero
   933 00000D25 BE[F00B]            <1> 	mov	si,fl2xCon2	;get second set of constants
   934 00000D28 B95A00              <1> 	mov	cx,fl2xCon2Len/2	;words to move
   935 00000D2B E8CC0C              <1> 	call	moveconsts	;put constants in data segment
   936                              <1> 
   937 00000D2E 8B1E1800            <1> 	mov	bx,[trptr2]	;accumulate in ST
   938 00000D32 8B361600            <1> 	mov	si,[trptr]
   939 00000D36 C6061B000F          <1> 	mov	byte [trctr],fl2xCon2Len/lenAccum	;count 4/15 multiplies
   940 00000D3B EB10                <1> 	jmp	short FY030
   941                              <1> 
   942                              <1> FY020:
   943 00000D3D 830616000C          <1> 	add	word [trptr],lenAccum	;bump to next constant
   944 00000D42 8B3E1600            <1> 	mov	di,[trptr]	;set to add next constant
   945 00000D46 89F3                <1> 	mov	bx,si		;accumulate same place
   946 00000D48 E854F6              <1> 	call	do_add		;add another constant
   947 00000D4B 89F3                <1> 	mov	bx,si		;
   948                              <1> FY030:
   949 00000D4D BF2C00              <1> 	mov	di,Areg	;X-1 is here
   950 00000D50 E81D03              <1> 	call	do_mul		;multiply
   951 00000D53 FE0E1B00            <1> 	dec	byte [trctr]		;count thru constants
   952 00000D57 75E4                <1> 	jnz	FY020
   953 00000D59 E99200              <1> 	jmp	FY150		;multiply ST by ST(1)
   954                              <1> 
   955                              <1> 
   956                              <1> FY100:
   957 00000D5C BE[480B]            <1> 	mov	si,fl2xCon1	;get source constants
   958 00000D5F B95400              <1> 	mov	cx,fl2xCon1Len/2	;get words to move
   959 00000D62 E8950C              <1> 	call	moveconsts	;move to data segment
   960 00000D65 8D7F02              <1> 	lea	di,[bx+expon]	;get address of integer exponent
   961 00000D68 BE3800              <1> 	mov	si,Breg	;put it in the Breg
   962 00000D6B E8AFF9              <1> 	call	load_I16	;load the integer
   963 00000D6E 8B361800            <1> 	mov	si,[trptr2]	;get X pointer
   964 00000D72 C74402FFFF          <1> 	mov	word [si+expon],-1	; X in range [0.5 ... 1.0)
   965 00000D77 8B3E1600            <1> 	mov	di,[trptr]	;get constant pointer
   966 00000D7B BB2C00              <1> 	mov	bx,Areg	;put sum in Areg
   967 00000D7E E81EF6              <1> 	call	do_add		;do the add
   968 00000D81 8B361800            <1> 	mov	si,[trptr2]	;get X pointer
   969 00000D85 8B3E1600            <1> 	mov	di,[trptr]	;get constant pointer
   970 00000D89 C6450100            <1> 	mov	byte [di+sign],0	;make constant +
   971 00000D8D 89F3                <1> 	mov	bx,si		;result to stack top
   972 00000D8F E80DF6              <1> 	call	do_add		;get denominator
   973 00000D92 BF2C00              <1> 	mov	di,Areg	;get numerator pointer
   974 00000D95 89F3                <1> 	mov	bx,si		;form Z in stack top
   975 00000D97 E8B304              <1> 	call	do_div		;ST = Z
   976 00000D9A 89F7                <1> 	mov	di,si		;set to get Z**2
   977 00000D9C BB2C00              <1> 	mov	bx,Areg	;Z**2 will be in Areg
   978 00000D9F E8CE02              <1> 	call	do_mul		;Areg = Z**2
   979 00000DA2 830616000C          <1> 	add	word [trptr],lenAccum	;bump to C4 or C23
   980                              <1> %if BIG
   981 00000DA7 C6061B000B          <1> 	mov	byte [trctr],fl2xCon1Len/lenAccum-3	;count 11 terms
   982 00000DAC 8B3E1600            <1> 	mov	di,[trptr]	;get constant pointer
   983 00000DB0 89FB                <1> 	mov	bx,di		;accumulate in Const area
   984                              <1> FY120:
   985 00000DB2 E8BB02              <1> 	call	do_mul		; * Z*Z
   986 00000DB5 830616000C          <1> 	add	word [trptr],lenAccum	;bump to next constant
   987 00000DBA 8B3E1600            <1> 	mov	di,[trptr]	;
   988 00000DBE 89F3                <1> 	mov	bx,si		;accumulate in const area
   989 00000DC0 E8DCF5              <1> 	call	do_add		; add on constant
   990 00000DC3 89F3                <1> 	mov	bx,si
   991 00000DC5 BF2C00              <1> 	mov	di,Areg
   992 00000DC8 FE0E1B00            <1> 	dec	byte [trctr]		;count terms
   993 00000DCC 75E4                <1> 	jnz	FY120
   994                              <1> 
   995 00000DCE 8B1E1800            <1> 	mov	bx,[trptr2]	;form 2*Z*(c1...) in ST
   996 00000DD2 FF4702              <1> 	inc	word [bx+expon]
   997                              <1> %else
   998                              <1> 	mov	di,[trptr]	;
   999                              <1> 	mov	bx,di		;accumulate in Const area
  1000                              <1> 	call	do_add		;
  1001                              <1> 	add	word [trptr],lenAccum	;bump to C3
  1002                              <1> 	mov	di,[trptr]
  1003                              <1> 	mov	bx,si		;accumulate at C4 position
  1004                              <1> 	call	do_div
  1005                              <1> 	add	word [trptr],lenAccum	;bump to C2
  1006                              <1> 	push	si		;save C3/...
  1007                              <1> 	mov	si,Areg	;get Z**2 ptr
  1008                              <1> 	mov	di,[trptr]	;get C2 pointer
  1009                              <1> 	mov	bx,si		;accumulate in Areg
  1010                              <1> 	call	do_mul		;Areg = C2 * Z**2
  1011                              <1> 	pop	di
  1012                              <1> 	mov	bx,si		;Add in C3 stuff
  1013                              <1> 	call	do_add		;Areg = C2*Z**2 ...
  1014                              <1> 	add	word [trptr],lenAccum	;bump to C1
  1015                              <1> 	mov	di,[trptr]	;get C1 pointer
  1016                              <1> 	mov	bx,si		;result to Areg
  1017                              <1> 	call	do_add		;add it on
  1018                              <1> 	mov	bx,[trptr2]	;form Z*(c1...) in ST
  1019                              <1> %endif
  1020 00000DD5 89DF                <1> 	mov	di,bx		;
  1021 00000DD7 E89602              <1> 	call	do_mul		;got part of it in ST
  1022 00000DDA 89F3                <1> 	mov	bx,si		;
  1023 00000DDC 8B3E1600            <1> 	mov	di,[trptr]	;get pointer to 1/2
  1024 00000DE0 83C70C              <1> 	add	di,lenAccum	; **
  1025 00000DE3 E8B9F5              <1> 	call	do_add		;got LOG2(x) in ST
  1026 00000DE6 BF3800              <1> 	mov	di,Breg	;get extracted exponent
  1027 00000DE9 89F3                <1> 	mov	bx,si		;result to stack top
  1028 00000DEB E8B1F5              <1> 	call	do_add
  1029                              <1> 
  1030                              <1> FY150:
  1031 00000DEE B301                <1> 	mov	bl,1		;get ST(1) pointer
  1032 00000DF0 E86BF8              <1> 	call	regptr		; in BX
  1033 00000DF3 89DF                <1> 	mov	di,bx		;set for product
  1034 00000DF5 E87802              <1> 	call	do_mul		;do the product
  1035 00000DF8 8B1E1800            <1> 	mov	bx,[trptr2]	;set to pop the stack
  1036                              <1> FY999:
  1037 00000DFC E9A6F3              <1> 	jmp	pop_stack	; go do the pop
  1038                              <1> 
  1039                              <1> 
  1040                              <1> 
  1041                              <1> 
  1042                              <1> 
  1043                              <1> ; end em187c.asm
   521                                  %include "em187e.asm"
     1                              <1> ; em187e.asm
     2                              <1> 
     3                              <1> 
     4                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     5                              <1> ;
     6                              <1> ; load IEEE 8-byte real to accumulator
     7                              <1> ;       es:di   points to value to load
     8                              <1> ;       si      points to accumulator to receive value
     9                              <1> ; uses: ax & dx
    10                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    11                              <1> load_R64:	;	    proc    near
    12 00000DFF 268B5506            <1>   es    mov     dx, word [di+6]     ;get exponent
    13 00000E03 31C0                <1>         xor     ax,ax
    14 00000E05 D1E2                <1>         shl     dx,1            ; sign goes to carry
    15 00000E07 D0D0                <1>         rcl     al,1            ; sign goes to AL
    16 00000E09 884401              <1>         mov     byte [si+sign], al
    17 00000E0C C1EA05              <1>         shr     dx,5            ;dx is biased exponent
    18 00000E0F 09D2                <1>         or      dx,dx           ; test for zero
    19 00000E11 7446                <1>         jz      lr6401
    20 00000E13 81FAFF07            <1>         cmp     dx,2047         ; test for max exponent
    21 00000E17 7467                <1>         je      lr6411
    22 00000E19 C60400              <1>         mov     byte [si+tag], tag_valid
    23                              <1> 
    24 00000E1C 81EAFF03            <1>         sub     dx,1023         ; get correct exponent
    25 00000E20 895402              <1>         mov     word [si+expon],dx   ;set the exponent
    26 00000E23 268A5506            <1>   es    mov     dl,[di+6]    ;get hi-part of mantissa
    27 00000E27 268B4504            <1>   es    mov     ax,[di+4]    ;get second 16 bits
    28 00000E2B 268B5D02            <1>   es    mov     bx,[di+2]    ;get third 16 bits
    29                              <1> %if BIG
    30 00000E2F 268B3D              <1>   es    mov     di,[di]      ;get lowest order 16 bits
    31 00000E32 31ED                <1>         xor     bp,bp           ;zap lo-bit receiver
    32                              <1> %endif
    33 00000E34 B90400              <1>         mov     cx,4            ;count 4 shifts
    34                              <1> lr6493:
    35 00000E37 D1EA                <1>         shr     dx,1            ;shift into carry
    36 00000E39 D1D8                <1>         rcr     ax,1            ;shift into ax
    37 00000E3B D1DB                <1>         rcr     bx,1            ;shift into bx
    38                              <1> %if BIG
    39 00000E3D D1DF                <1>         rcr     di,1            ;shift into di
    40 00000E3F D1DD                <1>         rcr     bp,1            ;shift into bp
    41                              <1> %endif
    42 00000E41 E2F4                <1>         loop    lr6493
    43                              <1> ; have mantissa in AX:BX[:DI:BP]
    44 00000E43 F9                  <1>         stc
    45 00000E44 D1D8                <1>         rcr     ax,1            ;shift into ax
    46 00000E46 D1DB                <1>         rcr     bx,1            ;shift into bx
    47                              <1> %if BIG
    48 00000E48 D1DF                <1>         rcr     di,1            ;shift into di
    49 00000E4A D1DD                <1>         rcr     bp,1            ;shift into bp
    50 00000E4C 896C0A              <1>         mov     [si+mantis+6],bp
    51                              <1> lr6495:
    52 00000E4F 897C08              <1>         mov     [si+mantis+4],di
    53 00000E52 895C06              <1>         mov     [si+mantis+2],bx    ; **
    54 00000E55 894404              <1>         mov     [si+mantis],ax  ;set the internal form
    55                              <1> %else
    56                              <1> lr6495:
    57                              <1>         mov     [si+mantis+2],bx    ; **
    58                              <1>         mov     [si+mantis],ax  ;set the internal form
    59                              <1> %endif
    60                              <1> 
    61                              <1> lr6499:
    62 00000E58 C3                  <1>         ret
    63                              <1> 
    64                              <1> 
    65                              <1> ; biased exponent was 0
    66                              <1> lr6401:
    67 00000E59 268A4506            <1>   es    mov     al,[di+6]            ;get highest mantissa
    68 00000E5D 260B4504            <1>   es    or      ax,[di+4]
    69 00000E61 260B4502            <1>   es    or      ax,[di+2]            ;test for real zero
    70 00000E65 260B05              <1>   es    or      ax,[di]
    71 00000E68 7540                <1>         jnz     lr6402           ; not a real zero
    72                              <1> ; got real zero
    73 00000E6A C60401              <1>         mov     byte [si+tag], tag_zero
    74 00000E6D C744020180          <1>         mov     word [si+expon], exp_of_FPzero
    75                              <1> lr64015:
    76 00000E72 894404              <1>         mov     [si+mantis], ax
    77 00000E75 894406              <1>         mov     [si+mantis+2], ax
    78                              <1> %if  BIG
    79 00000E78 894408              <1>         mov     [si+mantis+4], ax
    80 00000E7B 89440A              <1>         mov     [si+mantis+6], ax
    81                              <1> %endif
    82 00000E7E EBD8                <1>         jmp     lr6499
    83                              <1> 
    84                              <1> ; biased exponent was 2047 -- possible infinity
    85                              <1> lr6411:
    86 00000E80 31C0                <1>         xor     ax,ax
    87 00000E82 268A5507            <1>   es    mov     dl, [di+7]
    88 00000E86 83E20F              <1>         and     dx,000Fh            ;check for zero mantissa
    89 00000E89 260B5504            <1>   es    or      dx,[di+4]
    90 00000E8D 260B5502            <1>   es    or      dx,[di+2]
    91 00000E91 260B15              <1>   es    or      dx,[di]
    92 00000E94 750A                <1>         jnz     lr6415              ; if not zero in packed form, NaN
    93 00000E96 C60402              <1>         mov     byte [si+tag], tag_infin
    94                              <1> lr6413:
    95 00000E99 C74402FF7F          <1>         mov     word [si+expon], exp_of_FPinf
    96 00000E9E EBD2                <1>         jmp     lr64015
    97                              <1> 
    98                              <1> lr6415:
    99 00000EA0 6A01                <1>         push    Iexcept             ;Invalid operation
   100 00000EA2 E84C0D              <1>         call    exception           ;   exception
   101 00000EA5 C60406              <1>         mov     byte [si+tag], tag_invalid
   102 00000EA8 EBEF                <1>         jmp     lr6413
   103                              <1> 
   104                              <1> 
   105                              <1> ; not a real zero -- actually a denormal
   106                              <1> lr6402:
   107 00000EAA 6A02                <1>         push    Dexcept             ;Denormalized operand
   108 00000EAC E8420D              <1>         call    exception           ;  exception
   109                              <1> 
   110 00000EAF 268B4505            <1>   es    mov     ax,[di+5]            ;AH gets 4 highest bits of mantissa
   111 00000EB3 268B5D03            <1>   es    mov     bx,[di+3]
   112 00000EB7 268A35              <1>   es    mov     dh,[di]
   113 00000EBA 268B7D01            <1>   es    mov     di,[di+1]            ;destroy ES:DI as pointer
   114 00000EBE B90400              <1>         mov     cx,4                ;shift by 4, trying to normalize
   115                              <1> lr6405:
   116                              <1> %if BIG
   117 00000EC1 D0E6                <1>         shl     dh,1
   118 00000EC3 D1D7                <1>         rcl     di,1
   119                              <1> %else
   120                              <1>         shl     di,1
   121                              <1> %endif
   122 00000EC5 D1D3                <1>         rcl     bx,1
   123 00000EC7 D1D0                <1>         rcl     ax,1
   124 00000EC9 E2F6                <1>         loop    lr6405              ;now it may be normalized
   125                              <1> ; dl is zero at this point, shift until fraction is normalized
   126                              <1> lr6406:
   127 00000ECB F6C480              <1>         test    ah,80h              ;test the hi-bit
   128 00000ECE 750C                <1>         jnz     lr6407              ;jump when normalized
   129                              <1> %if BIG
   130 00000ED0 D0E6                <1>         shl     dh,1
   131 00000ED2 D1D7                <1>         rcl     di,1
   132                              <1> %else
   133                              <1>         shl     di,1
   134                              <1> %endif
   135 00000ED4 D1D3                <1>         rcl     bx,1
   136 00000ED6 D1D0                <1>         rcl     ax,1
   137 00000ED8 FEC2                <1>         inc     dl                  ;count the shifts needed
   138 00000EDA EBEF                <1>         jmp     lr6406              ;loop back
   139                              <1> lr6407:
   140                              <1> %if BIG
   141 00000EDC 89D5                <1>         mov     bp,dx               ;save away dx
   142                              <1> %endif
   143 00000EDE 30F6                <1>         xor     dh,dh               ;clear hi part of dh
   144 00000EE0 81C2FF03            <1>         add     dx,1023             ;bias the exponent
   145 00000EE4 F7DA                <1>         neg     dx                  ;really is negative
   146 00000EE6 895402              <1>         mov     word [si+expon],dx       ;set exponent
   147                              <1> %if BIG
   148 00000EE9 896C0A              <1>         mov     [si+mantis+6],bp    ;set highest part of mantissa
   149                              <1> %endif
   150 00000EEC E960FF              <1>         jmp     lr6495
   151                              <1> ;load_R64    endp
   152                              <1> 
   153                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   154                              <1> ;
   155                              <1> ;   Store 64-bit real at ES:DI
   156                              <1> ;   SI points at accumulator to store
   157                              <1> ;
   158                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   159                              <1> store_R64:	;	   proc    near
   160 00000EEF 803C01              <1>         cmp     byte [si+tag], tag_zero
   161 00000EF2 735D                <1>         jae     sr64100                 ;go check on funny tag
   162 00000EF4 8B6C02              <1>         mov     bp,word [si+expon]           ;get exponent
   163                              <1> 
   164 00000EF7 8B4404              <1>         mov     ax,[si+mantis]
   165 00000EFA 8B5C06              <1>         mov     bx,[si+mantis+2]        ;get entire mantissa
   166 00000EFD 8A5401              <1>         mov     dl,byte [si+sign]            ;sign to DL
   167                              <1> %if BIG
   168 00000F00 8A740B              <1>         mov     dh,byte [si+mantis+7]
   169 00000F03 8B7408              <1>         mov     si,[si+mantis+4]        ;mantissa in AX:BX[:SI:DX]
   170 00000F06 80C604              <1>         add     dh,04h                  ;round mantissa
   171 00000F09 83D600              <1>         adc     si,0
   172 00000F0C 83D300              <1>         adc     bx,0
   173 00000F0F 83D000              <1>         adc     ax,0
   174 00000F12 7209                <1>         jc      sr64030
   175                              <1> %else
   176                              <1>         xor     dh,dh
   177                              <1>         xor     si,si                   ;zero this word 
   178                              <1> %endif
   179                              <1> 
   180                              <1> ; discard the hidden bit
   181                              <1> %if BIG
   182 00000F14 D0E6                <1>         shl     dh,1
   183 00000F16 D1D6                <1>         rcl     si,1
   184 00000F18 D1D3                <1>         rcl     bx,1
   185                              <1> %else
   186                              <1>         shl     bx,1
   187                              <1> %endif
   188 00000F1A D1D0                <1>         rcl     ax,1
   189 00000F1C F8                  <1>         clc
   190                              <1> sr64030:
   191 00000F1D 83D500              <1>         adc     bp,0                    ;possible increment of exponent
   192                              <1> 
   193 00000F20 81ED01FC            <1>         sub     bp,-1023                ;bias the exponent
   194 00000F24 7E49                <1>         jle     sr64190                 ;return zero on underflow
   195 00000F26 81FDFF07            <1>         cmp     bp,2047                 ;test for maximum exponent
   196 00000F2A 7353                <1>         jae     sr64210                 ;return infinity if overflow
   197                              <1> 
   198                              <1> ;now move 4 bits into the result
   199 00000F2C B90400              <1>         mov     cx,4
   200                              <1> sr64060:
   201                              <1> %if BIG
   202 00000F2F D0E6                <1>         shl     dh,1
   203 00000F31 D1D6                <1>         rcl     si,1
   204 00000F33 D1D3                <1>         rcl     bx,1
   205                              <1> %else
   206                              <1>         shl     bx,1
   207                              <1> %endif
   208 00000F35 D1D0                <1>         rcl     ax,1
   209 00000F37 D1D5                <1>         rcl     bp,1
   210 00000F39 E2F4                <1>         loop    sr64060
   211                              <1> 
   212 00000F3B 30F6                <1>         xor     dh,dh                   ;clear part of fraction
   213 00000F3D D1CA                <1>         ror     dx,1                    ;sign bit to hi position in DX
   214 00000F3F 09EA                <1>         or      dx,bp                   ;form final hi-word
   215 00000F41 268935              <1>   es    mov     [di],si              ;store low order
   216 00000F44 26895D02            <1>   es    mov     [di+2],bx
   217 00000F48 26894504            <1>   es    mov     [di+4],ax
   218 00000F4C 26895506            <1>   es    mov     [di+6],dx            ;store sign & exponent
   219                              <1> sr64099:
   220 00000F50 C3                  <1>         ret
   221                              <1> 
   222                              <1> 
   223                              <1> ; skip to here on not (tag_valid)
   224                              <1> sr64100:
   225 00000F51 7725                <1>         ja      sr64200                 ;further tag checking is needed
   226                              <1> 
   227                              <1> ; store a real zero, signed if you please
   228                              <1> sr64110:
   229 00000F53 31C0                <1>         xor     ax,ax                   ;get a zero
   230                              <1> sr64120:
   231 00000F55 8A5C01              <1>         mov     bl,byte [si+sign]            ;get sign
   232 00000F58 D0EB                <1>         shr     bl,1                    ;sign to carry
   233 00000F5A D1D8                <1>         rcr     ax,1                    ;sign to hi-bit of word
   234                              <1> sr64150:
   235 00000F5C 26894506            <1>   es    mov     [di+6],ax            ;store hi-word
   236 00000F60 31DB                <1>         xor     bx,bx                   ;zap again for good measure
   237 00000F62 26895D04            <1>   es    mov     [di+4],bx            ;store second word
   238 00000F66 26895D02            <1>   es    mov     [di+2],bx
   239 00000F6A 26891D              <1>   es    mov     [di],bx
   240 00000F6D EBE1                <1>         jmp     sr64099                 ;go exit from one point
   241                              <1> 
   242                              <1> ; store plus zero
   243                              <1> sr64190:
   244 00000F6F 6A10                <1>         push    Uexcept                 ;underflow
   245 00000F71 E87D0C              <1>         call    exception
   246                              <1> 
   247 00000F74 31C0                <1>         xor     ax,ax                   ;get +0.0
   248 00000F76 EBE4                <1>         jmp     sr64150
   249                              <1> 
   250                              <1> ; tag is neither (tag_valid) nor (tag_zero)
   251                              <1> sr64200:
   252 00000F78 803C02              <1>         cmp     byte [si+tag], tag_infin     ;test for infinity
   253 00000F7B 7407                <1>         je      sr64220
   254 00000F7D EB0A                <1>         jmp     short sr64250           ;return indefinite
   255                              <1> ; return signed infinity
   256                              <1> sr64210:
   257 00000F7F 6A08                <1>         push    Oexcept                 ;overflow 
   258 00000F81 E86D0C              <1>         call    exception
   259                              <1> sr64220:
   260 00000F84 B8E0FF              <1>         mov     ax,7FF0h << 1          ;following code will put in sign
   261 00000F87 EBCC                <1>         jmp     sr64120
   262                              <1> ; return signed indefinite
   263                              <1> sr64250:
   264 00000F89 6A01                <1>         push    Iexcept                 ;invalid operation
   265 00000F8B E8630C              <1>         call    exception
   266                              <1> 
   267 00000F8E B8F8FF              <1>         mov     ax,0FFF8h               ;following code will store value
   268 00000F91 EBC9                <1>         jmp     sr64150
   269                              <1> 
   270                              <1> ;store_R64   endp
   271                              <1> 
   272                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   273                              <1> ;
   274                              <1> ;   Store 16-bit integer at ES:DI
   275                              <1> ;   SI points at accumulator to store
   276                              <1> ;
   277                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   278                              <1> store_I16:	;	   proc    near
   279 00000F93 803C01              <1>         cmp     byte [si+tag], tag_zero
   280 00000F96 7321                <1>         jae     s16100              ;go do further checking
   281 00000F98 8B4402              <1>         mov     ax,word [si+expon]       ;get exponent
   282 00000F9B 83F80F              <1>         cmp     ax,15
   283 00000F9E 7D23                <1>         jge     s16150              ;go store indefinite
   284 00000FA0 B93F00              <1>         mov     cx,63               ;get shift count
   285 00000FA3 29C1                <1>         sub     cx,ax               ; shift to lowest order
   286 00000FA5 89F3                <1>         mov     bx,si               ;get argument
   287 00000FA7 E85906              <1>         call    vloadsh64           ;get AX:BX:CX:DX
   288 00000FAA E80906              <1>         call    round_mag           ;
   289 00000FAD 807C0100            <1>         cmp     byte [si+sign],0         ;check for plus
   290 00000FB1 7402                <1>         je      s16050              ; **
   291 00000FB3 F7DA                <1>         neg     dx                  ;negate result
   292                              <1> s16050:
   293 00000FB5 268915              <1>   es    mov     [di],dx          ;store low order
   294 00000FB8 C3                  <1>         ret
   295                              <1> 
   296                              <1> ; tag is not (tag_valid), check for other tags
   297                              <1> s16100:
   298 00000FB9 7404                <1>         je      s16120              ;tag zero
   299 00000FBB 6A01                <1>         push    Iexcept             ;
   300 00000FBD EB06                <1>         jmp     short s16160        ;invalid, empty, or indefinite
   301                              <1> ; tag is (tag_zero)
   302                              <1> s16120:
   303 00000FBF 31D2                <1>         xor     dx,dx               ; **
   304 00000FC1 EBF2                <1>         jmp     s16050              ;store and exit
   305                              <1> 
   306                              <1> ; exponent is too big
   307                              <1> s16150:
   308 00000FC3 6A08                <1>         push    Oexcept             ;overflow
   309                              <1> s16160:
   310 00000FC5 E8290C              <1>         call    exception
   311 00000FC8 BA0080              <1>         mov     dx,08000h           ;indefinite result
   312 00000FCB EBE8                <1>         jmp     s16050
   313                              <1> 
   314                              <1> ;store_I16   endp
   315                              <1> 
   316                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   317                              <1> ;
   318                              <1> ;   Store 32-bit integer at ES:DI
   319                              <1> ;   SI points at accumulator to store
   320                              <1> ;
   321                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   322                              <1> store_I32:	;	   proc    near
   323 00000FCD 803C01              <1>         cmp     byte [si+tag], tag_zero
   324 00000FD0 732B                <1>         jae     s32100              ;go do further checking
   325 00000FD2 8B4402              <1>         mov     ax,word [si+expon]       ;get exponent
   326 00000FD5 83F81F              <1>         cmp     ax,31
   327 00000FD8 7D2F                <1>         jge     s32150              ;go store indefinite
   328 00000FDA B93F00              <1>         mov     cx,63               ;get shift count
   329 00000FDD 29C1                <1>         sub     cx,ax               ; shift to lowest order
   330 00000FDF 89F3                <1>         mov     bx,si               ;get argument
   331 00000FE1 E81F06              <1>         call    vloadsh64           ;get AX:BX:CX:DX
   332 00000FE4 E8CF05              <1>         call    round_mag           ;
   333                              <1> 
   334 00000FE7 807C0100            <1>         cmp     byte [si+sign],0         ;check for plus
   335 00000FEB 7408                <1>         je      s32050              ; **
   336 00000FED F7D1                <1>         not     cx                  ;is negative, negate the result
   337 00000FEF F7DA                <1>         neg     dx
   338 00000FF1 F5                  <1>         cmc
   339 00000FF2 83D100              <1>         adc     cx,0
   340                              <1> s32050:
   341 00000FF5 268915              <1>   es    mov     [di],dx          ;store low order
   342 00000FF8 26894D02            <1>   es    mov     [di+2],cx        ;store high order
   343 00000FFC C3                  <1>         ret
   344                              <1> 
   345                              <1> ; tag is not (tag_valid), check for other tags
   346                              <1> s32100:
   347 00000FFD 7404                <1>         je      s32120              ;tag zero
   348 00000FFF 6A01                <1>         push    Iexcept             ;invalid operation
   349 00001001 EB08                <1>         jmp     short s32160              ;invalid, empty, or indefinite
   350                              <1> ; tag is (tag_zero)
   351                              <1> s32120:
   352 00001003 31C9                <1>         xor     cx,cx               ;get zero result
   353 00001005 31D2                <1>         xor     dx,dx               ; **
   354 00001007 EBEC                <1>         jmp     s32050              ;store and exit
   355                              <1> s32150:
   356 00001009 6A08                <1>         push    Oexcept             ;overflow
   357                              <1> s32160:
   358 0000100B E8E30B              <1>         call    exception
   359 0000100E 31D2                <1>         xor     dx,dx               ;zero low order
   360 00001010 B90080              <1>         mov     cx,8000h           ;indefinite result
   361 00001013 EBE0                <1>         jmp     s32050
   362                              <1> 
   363                              <1> ;store_I32   endp
   364                              <1> 
   365                              <1> 
   366                              <1> 
   367                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   368                              <1> ;
   369                              <1> ;   FMUL    ST,ST(i)        R=0, P=0
   370                              <1> ;   FMUL    ST(i),ST        R=1, P=0
   371                              <1> ;   FMULP   ST(i),ST        R=1, P=1
   372                              <1> ;
   373                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   374                              <1> FMULrr:
   375 00001015 E865F3              <1>         call    RRsetup         ;get source and destination reg. ptrs
   376 00001018 89FB                <1>         mov     bx,di           ;BX is where final result will go
   377                              <1> 
   378 0000101A 68[9901]            <1>         push    test_pop ;fake call
   379 0000101D EB51                <1>         jmp     short do_mul          ;do the register to register MUL
   380                              <1> 
   381                              <1> 
   382                              <1> 
   383                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   384                              <1> ;
   385                              <1> ;   FMUL    mem         MUL memory to ST
   386                              <1> ;
   387                              <1> ;       ES:DI is pointer to memory location
   388                              <1> ;
   389                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   390                              <1> genFMUL:
   391 0000101F BE2C00              <1>         mov     si,Areg      ;load first into the Areg
   392 00001022 BB0600              <1>         mov     bx,FMbits           ;get format mask
   393 00001025 20EB                <1>         and     bl,ch
   394 00001027 2EFF97[3603]        <1>   cs    call    [vecFLD+bx]          ;get the input argument
   395 0000102C 30DB                <1>         xor     bl,bl
   396 0000102E E82DF6              <1>         call    regptr              ;get ST pointer in BX
   397 00001031 89DF                <1>         mov     di,bx               ;DI is destination, SI is source
   398                              <1> ;  call to  do_mul  returns to  restore_segs
   399 00001033 68[B601]            <1>         push    restore_segs
   400 00001036 EB38                <1>         JMP     short do_mul
   401                              <1> 
   402                              <1> 
   403                              <1> 
   404                              <1> 
   405                              <1> ; OR of the tags was not 0, meaning both valid and non-zero
   406                              <1> FM200:  
   407 00001038 80E1FE              <1>         and     cl,0FEh         ;save only hi-part (valid & zero are ok)
   408 0000103B 7516                <1>         jnz     FM210           ;allow zero
   409                              <1> ; one or both of the tags says zero
   410 0000103D 5E                  <1>         pop     si
   411 0000103E C60401              <1>         mov     byte [si+tag], tag_zero  ;tag is tag_zero
   412 00001041 C744020180          <1>         mov     word [si+expon], exp_of_FPzero
   413 00001046 31C9                <1>         xor     cx,cx           ;mantissa is zero
   414 00001048 31ED                <1>         xor     bp,bp           ;ditto
   415                              <1> %if BIG
   416 0000104A 894C0A              <1>         mov     [si+mantis+6],cx
   417 0000104D 894C08              <1>         mov     [si+mantis+4],cx
   418                              <1> %endif
   419 00001050 E9B800              <1>         jmp     FM085           ;go store mantissa
   420                              <1> 
   421                              <1> 
   422                              <1> 
   423                              <1> 
   424                              <1> ; error in tags, invalidate result
   425                              <1> FM210:
   426 00001053 5E                  <1>         pop     si                  ; clean up the stack for now
   427 00001054 C60406              <1>         mov     byte [si+tag], tag_invalid
   428 00001057 6A01                <1>         push    Iexcept             ;signal exception
   429 00001059 E8950B              <1>         call    exception
   430 0000105C E9B200              <1>         jmp     FM090
   431                              <1> 
   432                              <1> ; overflow occurred in adding the exponents
   433                              <1> FM220:
   434 0000105F 5E                  <1>         pop     si                  ; clean up the stack for now
   435 00001060 C60402              <1>         mov     byte [si+tag], tag_infin
   436 00001063 C74402FF7F          <1>         mov     word [si+expon], exp_of_FPinf
   437 00001068 6A08                <1>         push    Oexcept             ;signal exception
   438 0000106A E8840B              <1>         call    exception
   439 0000106D E9A100              <1>         jmp     FM090
   440                              <1> 
   441                              <1> 
   442                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   443                              <1> ;
   444                              <1> ;   Multiply register - register
   445                              <1> ;       SI and DI point to operands
   446                              <1> ;       BX is place to put result, may be same as SI or DI
   447                              <1> ;
   448                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   449                              <1> do_mul:		;	      proc    near
   450 00001070 53                  <1>         push    bx              ;save place to which to move result
   451 00001071 8A04                <1>         mov     al,byte [si+tag]     ;get source tag
   452 00001073 8A25                <1>         mov     ah,byte [di+tag]     ;get dest tag
   453 00001075 88C1                <1>         mov     cl,al           ;copy tag
   454 00001077 08E1                <1>         or      cl,ah           ;or tags together
   455 00001079 75BD                <1>         jnz     FM200           ;if not both valid, something needs checking
   456                              <1> ; both tags are valid
   457 0000107B 8A4401              <1>         mov     al,byte [si+sign]    ;exclusive or the signs
   458 0000107E 324501              <1>         xor     al,byte [di+sign]    ; **
   459 00001081 884701              <1>         mov     byte [bx+sign],al    ;
   460                              <1> 
   461 00001084 8B4402              <1>         mov     ax,word [si+expon]   ;add the exponents
   462 00001087 F9                  <1>         stc                     ; plus bias of 1
   463 00001088 134502              <1>         adc     ax,word [di+expon]   ;
   464 0000108B 70D2                <1>         jo      FM220           ;infintiy result
   465 0000108D 894702              <1>         mov     word [bx+expon],ax   ;store result exponent
   466                              <1> 
   467                              <1> %if BIG
   468 00001090 8D740A              <1>         lea     si,[si+mantis+6]    ;final mantissa address
   469 00001093 8D5D0A              <1>         lea     bx,[di+mantis+6]    ; **
   470 00001096 89361400            <1>         mov     word [mptr],si         ;save starting pointer value
   471 0000109A FD                  <1>         std
   472 0000109B 31C0                <1>         xor     ax,ax           ;get zero
   473 0000109D B90800              <1>         mov     cx,8
   474 000010A0 BF2A00              <1>         mov     di,mtemp+14  ;get final word in temporary
   475 000010A3 8CDA                <1>         mov     dx,ds           ;set up ES register
   476 000010A5 8EC2                <1>         mov     es,dx           ; **
   477 000010A7 F3AB                <1>     rep     stosw               ;clear the temporary
   478 000010A9 89DF                <1>         mov     di,bx           ;
   479 000010AB BB2200              <1>         mov     bx,mtemp+6   ;get address of mantissa temporary
   480 000010AE 31ED                <1>         xor     bp,bp           ;clear carry word
   481 000010B0 C6061A0004          <1>         mov     byte [ctr],4           ;loop 4 times
   482 000010B5 90                  <1>         even
   483                              <1> FM030:
   484 000010B6 83C308              <1>         add     bx,8            ;point at lowest order word
   485 000010B9 B90400              <1>         mov     cx,4            ;loop 4 times
   486                              <1>         even
   487                              <1> FM040:
   488 000010BC AD                  <1>         lodsw                   ;get multiplicand
   489 000010BD F725                <1>         mul     word [di]   ;form product
   490 000010BF 0107                <1>         add     [bx],ax         ;add in low order
   491 000010C1 4B                  <1>         dec     bx              ;don't disturb carry
   492 000010C2 4B                  <1>         dec     bx              ; **
   493 000010C3 11EA                <1>         adc     dx,bp           ;carry from this add is possible
   494 000010C5 D1DD                <1>         rcr     bp,1            ;save carry, get previous carry
   495 000010C7 D1C5                <1>         rol     bp,1            ;to low bit
   496 000010C9 0117                <1>         add     [bx],dx         ;
   497 000010CB 83D500              <1>         adc     bp,0            ;get carry to next stage
   498 000010CE E2EC                <1>         loop    FM040           ;loop back
   499                              <1> 
   500                              <1> ; the carry out of this stage (in BP) is always 0
   501                              <1> 
   502 000010D0 8B361400            <1>         mov     si,word [mptr]         ;get multiplicand start pointer
   503 000010D4 4B                  <1>         dec     bx
   504 000010D5 4B                  <1>         dec     bx
   505 000010D6 4F                  <1>         dec     di
   506 000010D7 4F                  <1>         dec     di
   507 000010D8 FE0E1A00            <1>         dec     byte [ctr]
   508 000010DC 75D8                <1>         jnz     FM030
   509                              <1> 
   510 000010DE 5E                  <1>         pop     si              ;get place to store mantissa
   511 000010DF 8B0E1C00            <1>         mov     cx,[mtemp]      ;get mantissa
   512 000010E3 8B2E1E00            <1>             mov     bp,word [mtemp+2]
   513 000010E7 8B162000            <1>         mov     dx,word [mtemp+4]
   514 000010EB A12200              <1>         mov     ax,word [mtemp+6]
   515 000010EE F6C580              <1>         test    ch,80H          ;is it normalized?
   516 000010F1 750F                <1>         jnz     FM060
   517                              <1> 
   518 000010F3 FF4C02              <1>         dec     word [si+expon]      ;must shift by 1 to normalize
   519 000010F6 D1262400            <1>         shl     word [mtemp+8],1       ;get low order bit to carry
   520 000010FA D1D0                <1>         rcl     ax,1            ;do the normalization
   521 000010FC D1D2                <1>         rcl     dx,1            ;
   522 000010FE D1D5                <1>         rcl     bp,1
   523 00001100 D1D1                <1>         rcl     cx,1            ;last of normalization
   524                              <1> FM060:
   525 00001102 89440A              <1>         mov     [si+mantis+6],ax    ;store the result
   526 00001105 895408              <1>         mov     [si+mantis+4],dx    ; **
   527                              <1> %else
   528                              <1>         mov     bx,[si+mantis]  ;get hi-word of source
   529                              <1>         mov     ax,[di+mantis]  ;get hi-word of dest
   530                              <1>         mul     bx              ;DX:AX is  H*H
   531                              <1>         mov     cx,dx           ;
   532                              <1>         mov     bp,ax           ;CX:BP is  H*H
   533                              <1>         mov     ax,[di+mantis+2]    ;get second word of dest
   534                              <1>         mul     bx              ;CX:BP
   535                              <1>                                 ;   DX:AX
   536                              <1>         add     bp,dx           ;CX:BP:AX
   537                              <1>         adc     cx,0            ; account for any carry
   538                              <1>         mov     bx,[si+mantis+2]    ;get second part of source
   539                              <1>         mov     si,ax           ;CX:BP:SI
   540                              <1>         mov     ax,[di+mantis]  ;get hi-word of dest
   541                              <1>         mul     bx
   542                              <1>         add     si,ax           ;align properly
   543                              <1>         adc     bp,dx           ; **
   544                              <1>         adc     cx,0            ;
   545                              <1>         mov     ax,[di+mantis+2]    ;get low word of dest
   546                              <1>         mul     bx              ;form low part of product
   547                              <1>         add     dx,si           ;CX:BP:DX is now the result
   548                              <1>         adc     bp,0            ;
   549                              <1>         adc     cx,0            ;CX:BP is the manitssa
   550                              <1>         pop     si              ;pointer to where to put it
   551                              <1>         test    ch,80H          ;test for normalization
   552                              <1>         jnz     FM080           ;go store if normalized
   553                              <1>         dec     word [si+expon]      ;adjust the exponent
   554                              <1>         shl     dx,1            ;get lowest bit
   555                              <1>         rcl     bp,1            ;rotate into low order
   556                              <1>         rcl     cx,1            ;rotate into high order
   557                              <1> %endif
   558                              <1> FM080:
   559 00001108 C60400              <1>         mov     byte [si+tag], tag_valid ;validate the result
   560                              <1> FM085:
   561 0000110B 896C06              <1>         mov     [si+mantis+2],bp    ;store low-part
   562 0000110E 894C04              <1>         mov     [si+mantis],cx      ;store hi-part
   563                              <1> FM090:
   564 00001111 FC                  <1> 	cld
   565 00001112 C3                  <1>         ret
   566                              <1> 
   567                              <1> 
   568                              <1> ;do_mul  endp
   569                              <1> 
   570                              <1> 
   571                              <1> ; end em187e.asm
   522                                  %include "em187f.asm"
     1                              <1> ; em187f.asm
     2                              <1> 
     3                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     4                              <1> ;
     5                              <1> ;   FXAM                examine ST
     6                              <1> ;
     7                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     8                              <1> gFXAM:
     9 00001113 30DB                <1>         xor     bl,bl
    10 00001115 E846F5              <1>         call    regptr              ;get ST pointer in BX
    11 00001118 8A6701              <1>         mov     ah,byte [bx+sign]        ;get sign flag to C1
    12 0000111B D0E4                <1>         shl     ah,1                ; **
    13 0000111D 8A07                <1>         mov     al,byte [bx+tag]         ;get tag value
    14 0000111F 3C00                <1>         cmp     al,tag_valid        ;try valid first
    15 00001121 7420                <1>         je      gfx090
    16 00001123 3C01                <1>         cmp     al,tag_zero         ;try zero next
    17 00001125 7417                <1>         je      gfx080
    18 00001127 3C02                <1>         cmp     al,tag_infin        ;try infinity next
    19 00001129 740E                <1>         je      gfx070
    20 0000112B 3C03                <1>         cmp     al,tag_empty        ;try empty next
    21 0000112D 7405                <1>         je      gfx060
    22                              <1> 
    23 0000112F 80CC01              <1>         or      ah,C0               ;C0 flags invalid (NaN)
    24 00001132 EB12                <1>         jmp     short gfx095
    25                              <1> gfx060:
    26 00001134 80CC41              <1>         or      ah,C3+C0            ;C3+C0 for empty
    27 00001137 EB0D                <1>         jmp     short gfx095
    28                              <1> gfx070:
    29 00001139 80CC05              <1>         or      ah,C2+C0            ;C2+C0 flags infinity
    30 0000113C EB08                <1>         jmp     short gfx095
    31                              <1> gfx080:
    32 0000113E 80CC40              <1>         or      ah,C3               ;C3 flags zero
    33 00001141 EB03                <1>         jmp     short gfx095
    34                              <1> gfx090:
    35 00001143 80CC04              <1>         or      ah,C2               ;C2 flags normal
    36                              <1> gfx095:
    37 00001146 80260300B8          <1>         and     byte [codes],~(C3+C2+C1+C0)    ;clear Status bits
    38 0000114B 08260300            <1>         or      byte [codes],ah            ;set condition code bits
    39 0000114F E964F0              <1>         jmp     restore_segs
    40                              <1> 
    41                              <1> 
    42                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    43                              <1> ;
    44                              <1> ;   FTST                compare ST to 0.0
    45                              <1> ;
    46                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    47                              <1> gFTST:
    48 00001152 30DB                <1>         xor     bl,bl
    49 00001154 E807F5              <1>         call    regptr              ;get ST pointer in BX
    50 00001157 89DE                <1>         mov     si,bx               ;point SI at stack top
    51 00001159 E82702              <1>         call    do_test             ;compare [SI] to 0.0
    52                              <1> 
    53 0000115C 80260300BA          <1>         and     byte [codes],~ (C3+C2+C0)    ;clear Status bits
    54 00001161 08260300            <1>         or      byte [codes],ah            ;set condition code bits
    55 00001165 E94EF0              <1>         jmp     restore_segs
    56                              <1> 
    57                              <1> 
    58                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    59                              <1> ;
    60                              <1> ;   FDIV    mem         ST := ST / mem
    61                              <1> ;
    62                              <1> ;       ES:DI is pointer to memory location
    63                              <1> ;
    64                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    65                              <1> genFDIV:
    66 00001168 BE2C00              <1>         mov     si,Areg      ;load first into the Areg
    67 0000116B BB0600              <1>         mov     bx,FMbits           ;get format mask
    68 0000116E 20EB                <1>         and     bl,ch
    69 00001170 2EFF97[3603]        <1>   cs    call    [vecFLD+bx]          ;get the input argument
    70 00001175 30DB                <1>         xor     bl,bl
    71 00001177 E8E4F4              <1>         call    regptr              ;get ST pointer in BX
    72 0000117A 89DF                <1>         mov     di,bx               ;DI is destination, SI is source
    73                              <1> ;  call to  do_div  returns to  restore_segs
    74 0000117C 68[B601]            <1>         push    restore_segs
    75 0000117F E9CB00              <1>         JMP     do_div
    76                              <1> 
    77                              <1> 
    78                              <1> 
    79                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    80                              <1> ;
    81                              <1> ;   FDIVR   mem         ST := mem / ST
    82                              <1> ;
    83                              <1> ;       ES:DI is pointer to memory location
    84                              <1> ;
    85                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    86                              <1> genFDIVR:
    87 00001182 BE2C00              <1>         mov     si,Areg      ;load first into the Areg
    88 00001185 BB0600              <1>         mov     bx,FMbits           ;get format mask
    89 00001188 20EB                <1>         and     bl,ch
    90 0000118A 2EFF97[3603]        <1>   cs    call    [vecFLD+bx]          ;get the input argument
    91 0000118F 30DB                <1>         xor     bl,bl
    92 00001191 E8CAF4              <1>         call    regptr              ;get ST pointer in BX
    93 00001194 89DF                <1>         mov     di,bx               ;DI is destination, SI is source
    94 00001196 87F7                <1>         xchg    si,di               ;change sense of divide, ST (in BX)
    95                              <1>                                     ; still gets the result
    96                              <1> ;  call to  do_div  returns to  restore_segs
    97 00001198 68[B601]            <1>         push    restore_segs
    98 0000119B E9AF00              <1>         JMP     do_div
    99                              <1> 
   100                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   101                              <1> ;
   102                              <1> ;   FDIV    ST,ST(i)        R=0, P=0
   103                              <1> ;   FDIVR   ST(i),ST        R=1, P=0
   104                              <1> ;   FDIVRP  ST(i),ST        R=1, P=1
   105                              <1> ;
   106                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   107                              <1> FDIVi:
   108 0000119E 88CB                <1>         mov     bl,cl           ;get ST(i) pointer
   109 000011A0 E8BBF4              <1>         call    regptr          ;BX is ST(i) pointer
   110 000011A3 89DE                <1>         mov     si,bx           ;divisor in SI is ST(i)
   111 000011A5 31DB                <1>         xor     bx,bx           ;get ST pointer
   112 000011A7 E8B4F4              <1>         call    regptr          ;BX is ST pointer
   113 000011AA 89DF                <1>         mov     di,bx           ;dividend pointer in DI is ST
   114 000011AC F6C504              <1>         test    ch,Rbit         ;see who gets the result
   115 000011AF 7408                <1>         jz      FDIVi01         ;ST will get result
   116                              <1> ; ST(i) gets the result
   117 000011B1 89F3                <1>         mov     bx,si           ;BX points to destination
   118 000011B3 68[9901]            <1>         push    test_pop
   119 000011B6 E99400              <1>         jmp     do_div
   120                              <1> FDIVi01:    ; ST will get the result, no pop possible
   121 000011B9 68[B601]            <1>         push    restore_segs
   122 000011BC E98E00              <1>         jmp     do_div
   123                              <1> 
   124                              <1> 
   125                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   126                              <1> ;
   127                              <1> ;   FDIVR    ST,ST(i)        R=0, P=0
   128                              <1> ;   FDIV     ST(i),ST        R=1, P=0
   129                              <1> ;   FDIVP    ST(i),ST        R=1, P=1
   130                              <1> ;
   131                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   132                              <1> FDIV0:
   133 000011BF 88CB                <1>         mov     bl,cl           ;get ST(i) pointer
   134 000011C1 E89AF4              <1>         call    regptr          ;BX is ST(i) pointer
   135 000011C4 89DF                <1>         mov     di,bx           ;dividend pointer in DI is ST(i)
   136 000011C6 31DB                <1>         xor     bx,bx           ;get ST pointer
   137 000011C8 E893F4              <1>         call    regptr          ;BX is ST pointer
   138 000011CB 89DE                <1>         mov     si,bx           ;divisor in SI is ST
   139 000011CD F6C504              <1>         test    ch,Rbit         ;see who gets the result
   140 000011D0 7407                <1>         jz      FDIV001         ;ST will get result
   141                              <1> ; ST(i) gets the result
   142 000011D2 89FB                <1>         mov     bx,di           ;BX points to destination
   143 000011D4 68[9901]            <1>         push    test_pop
   144 000011D7 EB74                <1>         jmp     short do_div
   145                              <1> 
   146                              <1> FDIV001:    ; ST will get the result, no pop possible
   147 000011D9 68[B601]            <1>         push    restore_segs
   148 000011DC EB6F                <1>         jmp     short do_div
   149                              <1> 
   150                              <1> 
   151                              <1> 
   152                              <1> ; error in tags, handle in FADD for now
   153                              <1> FD210:
   154 000011DE 5E                  <1>         pop     si                  ; clean up the stack for now
   155 000011DF C60406              <1>         mov     byte [si+tag], tag_invalid
   156 000011E2 6A01                <1>         push    Iexcept             ;signal exception
   157 000011E4 E80A0A              <1>         call    exception
   158 000011E7 E93801              <1>         jmp     FD099
   159                              <1> 
   160                              <1> 
   161                              <1> FD220:
   162 000011EA 5E                  <1>         pop     si              ;get result pointer
   163 000011EB 803D01              <1>         cmp     byte [di+tag], tag_zero
   164 000011EE 7417                <1>         je      FD230           ;jump if zero divided by zero
   165                              <1> ; have  tag_valid  divided by zero
   166 000011F0 6A04                <1>         push    Zexcept         ;zero divide exception
   167 000011F2 E8FC09              <1>         call    exception
   168 000011F5 8A4501              <1>         mov     al,byte [di+sign]    ;get sign of numerator
   169 000011F8 884401              <1>         mov     byte [si+sign],al    ;store it
   170 000011FB C60402              <1>         mov     byte [si+tag], tag_infin ;set infinity
   171                              <1> FD225:
   172 000011FE C74402FF7F          <1>         mov     word [si+expon], exp_of_FPinf
   173 00001203 31C0                <1>         xor     ax,ax           ;get zero
   174 00001205 EB22                <1>         jmp     short FD250           ;clear mantissa
   175                              <1> FD230:
   176 00001207 6A01                <1>         push    Iexcept         ; 0/0 -- invalid operation
   177 00001209 E8E509              <1>         call    exception
   178 0000120C C60406              <1>         mov     byte [si+tag], tag_invalid
   179 0000120F EBED                <1>         jmp     FD225
   180                              <1> 
   181                              <1> 
   182                              <1> ; exception handling for do_div
   183                              <1> FD200:
   184 00001211 F6C6FE              <1>         test    dh,0FEh         ;check for other than zero
   185 00001214 75C8                <1>         jnz     FD210           ;have invalid, infinity, or empty
   186                              <1> ; one or both of the tags is zero
   187 00001216 803C01              <1>         cmp     byte [si+tag], tag_zero
   188 00001219 74CF                <1>         je      FD220           ;divisor is zero
   189                              <1> ;divisor is non-zero, therefore the dividend is zero
   190 0000121B 5E                  <1>         pop     si              ;get result pointer
   191 0000121C C60401              <1>         mov     byte [si+tag], tag_zero
   192 0000121F 31C0                <1>         xor     ax,ax           ;get zap value
   193 00001221 884401              <1>         mov     byte [si+sign],al    ;set to +0.0
   194 00001224 C744020180          <1>         mov     word [si+expon],exp_of_FPzero
   195                              <1> FD250:
   196 00001229 894404              <1>         mov     [si+mantis],ax  ;zero out the mantissa
   197 0000122C 894406              <1>         mov     [si+mantis+2],ax
   198                              <1> %if BIG
   199 0000122F 894408              <1>         mov     [si+mantis+4],ax
   200 00001232 89440A              <1>         mov     [si+mantis+6],ax
   201                              <1> %endif
   202 00001235 E9EA00              <1>         jmp     FD099           ;go exit from the same point
   203                              <1> 
   204                              <1> ; underflow subtracting exponents
   205                              <1> FD205:
   206 00001238 5E                  <1>         pop     si                  ; clean up the stack for now
   207 00001239 C60401              <1>         mov     byte [si+tag], tag_zero
   208 0000123C C6440100            <1>         mov     byte [si+sign], 0
   209 00001240 C744020180          <1>         mov     word [si+expon],exp_of_FPzero
   210                              <1> 
   211 00001245 6A10                <1>         push    Uexcept             ;signal exception
   212 00001247 E8A709              <1>         call    exception
   213 0000124A E9D500              <1>         jmp     FD099
   214                              <1> 
   215                              <1> 
   216                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   217                              <1> ;
   218                              <1> ;   Divide accumulator DI by SI
   219                              <1> ;       SI and DI point to operands
   220                              <1> ;       BX is place to put result, may be same as SI or DI
   221                              <1> ;
   222                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   223                              <1> do_div:		;      proc    near
   224 0000124D 53                  <1>         push    bx              ;save place to which to move result
   225 0000124E 8A34                <1>         mov     dh,byte [si+tag]     ;get source tag
   226 00001250 0A35                <1>         or      dh,byte [di+tag]     ;get dest tag
   227 00001252 75BD                <1>         jnz     FD200           ;if not both valid, something needs checking
   228                              <1> ; both tags are valid
   229 00001254 8A4401              <1>         mov     al,byte [si+sign]    ;exclusive or the signs
   230 00001257 324501              <1>         xor     al,byte [di+sign]    ; **
   231 0000125A 884701              <1>         mov     byte [bx+sign],al    ;
   232                              <1> 
   233 0000125D 8B4502              <1>         mov     ax,word [di+expon]   ;subtract the exponents
   234 00001260 2B4402              <1>         sub     ax,word [si+expon]   ;
   235 00001263 70D3                <1>         jo      FD205           ;signal underflow
   236 00001265 894702              <1>         mov     word [bx+expon],ax   ;store result exponent
   237                              <1> 
   238                              <1> %if BIG
   239 00001268 8B5504              <1>         mov     dx,[di+mantis]      ;move fraction to mtemp for the divide
   240 0000126B 8B4506              <1>         mov     ax,[di+mantis+2]    ;get 2nd part
   241 0000126E 8B5D08              <1>         mov     bx,[di+mantis+4]    ;get third part
   242 00001271 8B4D0A              <1>         mov     cx,[di+mantis+6]    ;get final part
   243                              <1> 
   244 00001274 8B6C06              <1>         mov     bp,[si+mantis+2]    ;get high order part
   245 00001277 89EF                <1>         mov     di,bp               ;copy for test
   246 00001279 0B7C08              <1>         or      di,[si+mantis+4]    ;test for divide by integer
   247 0000127C 0B7C0A              <1>         or      di,[si+mantis+6]    ;
   248 0000127F 8B7C04              <1>         mov     di,[si+mantis]      ;get hi part
   249 00001282 745C                <1>         jz      FD010               ;go do fast divide
   250                              <1> 
   251                              <1> ;not so lucky, must do the entire mess
   252                              <1> ;  DX:AX:BX:CX / DI:BP:mem:mem
   253 00001284 C6061A0040          <1>         mov     byte [ctr],64              ;count 64 bits
   254 00001289 EB0A                <1>         jmp     short FD004         ;save a shift
   255                              <1> FD003:
   256 0000128B D1E1                <1>         shl     cx,1                ;the long rotate
   257 0000128D D1D3                <1>         rcl     bx,1
   258 0000128F D1D0                <1>         rcl     ax,1
   259 00001291 D1D2                <1>         rcl     dx,1
   260 00001293 7218                <1>         jc      FD005               ;go do the subtract
   261                              <1> FD004:
   262 00001295 39FA                <1>         cmp     dx,di
   263 00001297 7714                <1>         ja      FD005
   264 00001299 721D                <1>         jb      FD007               ;no subtract, but CF=1
   265 0000129B 39E8                <1>         cmp     ax,bp
   266 0000129D 770E                <1>         ja      FD005
   267 0000129F 7217                <1>         jb      FD007
   268 000012A1 3B5C08              <1>         cmp     bx,[si+mantis+4]
   269 000012A4 7707                <1>         ja      FD005
   270 000012A6 7210                <1>         jb      FD007
   271 000012A8 3B4C0A              <1>         cmp     cx,[si+mantis+6]
   272 000012AB 720B                <1>         jb      FD007
   273                              <1> FD005:
   274 000012AD 2B4C0A              <1>         sub     cx,[si+mantis+6]
   275 000012B0 1B5C08              <1>         sbb     bx,[si+mantis+4]
   276 000012B3 19E8                <1>         sbb     ax,bp
   277 000012B5 19FA                <1>         sbb     dx,di
   278 000012B7 F8                  <1>         clc                             ;needed for bullet proofing
   279                              <1> FD007:
   280 000012B8 F5                  <1>         cmc
   281 000012B9 D1162200            <1>         rcl     word [mtemp+6],1               ;accumulate the result a bit at a time
   282 000012BD D1162000            <1>         rcl     word [mtemp+4],1
   283 000012C1 D1161E00            <1>         rcl     word [mtemp+2],1
   284 000012C5 D1161C00            <1>         rcl     word [mtemp],1
   285 000012C9 FE0E1A00            <1>         dec     byte [ctr]
   286 000012CD 75BC                <1>         jnz     FD003
   287                              <1> 
   288                              <1> ; done with division
   289 000012CF 8B1E1C00            <1>         mov     bx,word [mtemp]                ;load up the resulting fraction
   290 000012D3 8B0E1E00            <1>         mov     cx,word [mtemp+2]              ;in the right place
   291 000012D7 8B2E2000            <1>         mov     bp,word [mtemp+4]
   292 000012DB A12200              <1>         mov     ax,word [mtemp+6]              ;BX:CX:BP:AX
   293 000012DE EB15                <1>         jmp     short FD018             ;go round it
   294                              <1> 
   295                              <1> ; integer division -- the low 3 words of the source are zero
   296                              <1> FD010:
   297                              <1> ;;;        xor     bp,bp               ;get zero at low end of word
   298 000012E0 D1EA                <1>         shr     dx,1                ;make sure DX < DI
   299 000012E2 D1D8                <1>         rcr     ax,1
   300 000012E4 D1DB                <1>         rcr     bx,1
   301 000012E6 D1D9                <1>         rcr     cx,1
   302 000012E8 D1DD                <1>         rcr     bp,1                ;last bit retained in BP
   303                              <1> 
   304 000012EA F7F7                <1>         div     di
   305 000012EC 93                  <1>         xchg    ax,bx               ;high quotient to BX
   306 000012ED F7F7                <1>         div     di
   307 000012EF 91                  <1>         xchg    ax,cx               ;second quotient to CX
   308 000012F0 F7F7                <1>         div     di
   309 000012F2 95                  <1>         xchg    ax,bp               ;third quotient to BP
   310 000012F3 F7F7                <1>         div     di                  ;fourth quotient to AX
   311                              <1> ; round the result
   312                              <1> FD018:
   313 000012F5 D1EF                <1>         shr     di,1                ;divide by 2
   314 000012F7 29D7                <1>         sub     di,dx               ;borrow if dx is greater (set carry)
   315 000012F9 83D000              <1>         adc     ax,0
   316 000012FC 83D500              <1>         adc     bp,0
   317 000012FF 83D100              <1>         adc     cx,0
   318 00001302 83D300              <1>         adc     bx,0                ;set the sign flag
   319 00001305 5E                  <1>         pop     si                  ;get place to store it
   320 00001306 780B                <1>         js      FD020               ;no normalization needed
   321 00001308 FF4C02              <1>         dec     word [si+expon]          ;adjust exponent
   322 0000130B D1E0                <1>         shl     ax,1
   323 0000130D D1D5                <1>         rcl     bp,1
   324 0000130F D1D1                <1>         rcl     cx,1
   325 00001311 D1D3                <1>         rcl     bx,1
   326                              <1> FD020:
   327 00001313 895C04              <1>         mov     [si+mantis],bx
   328 00001316 894C06              <1>         mov     [si+mantis+2],cx
   329 00001319 896C08              <1>         mov     [si+mantis+4],bp
   330 0000131C 89440A              <1>         mov     [si+mantis+6],ax
   331                              <1> 
   332                              <1> %else
   333                              <1> ; implement Knuth algorithm for (A+b)/(C+d)
   334                              <1>         mov     cx,[si+mantis]      ;get C in CX
   335                              <1>         mov     ax,[si+mantis+2]    ;get d in AX
   336                              <1>         mov     si,[di+mantis]      ;get A in SI
   337                              <1>         mov     bx,[di+mantis+2]    ;get b in BX
   338                              <1>         or      ax,ax               ;test d
   339                              <1>         jz      FD010               ;skip correction if d==0
   340                              <1>         mul     si                  ;DX:AX is  A*d
   341                              <1>         cmp     dx,cx               ;see if overflow occurs
   342                              <1>         jb      FD005               ;no it doesn't
   343                              <1> ; got overflow problem
   344                              <1>         sub     dx,cx               ;guarantee no overflow
   345                              <1>         div     cx                  ;okay
   346                              <1> 
   347                              <1>         sub     bx,ax               ;BX is b-A*d/C
   348                              <1>         sbb     si,1                ;correct A if borrow needed
   349                              <1>         jmp     short FD010         ;rejoin main line code
   350                              <1> 
   351                              <1> FD005:
   352                              <1>         div     cx                  ;AX is A*d/C and DX is lower order
   353                              <1> 
   354                              <1>         sub     bx,ax               ;BX is b-A*d/C
   355                              <1>         sbb     si,0                ;correct A if borrow needed
   356                              <1> 
   357                              <1> FD010:
   358                              <1>         mov     dx,si               ;DX is now A
   359                              <1>         xor     si,si
   360                              <1> 
   361                              <1>         mov     ax,bx               ;AX is now B
   362                              <1>         shr     dx,1                ;make sure DX is < CX
   363                              <1>         rcr     ax,1                ;shift again
   364                              <1>         rcr     si,1                ;shift third part
   365                              <1>         div     cx                  ;AX is quotient, DX is remainder
   366                              <1>         xchg    ax,si               ;SI is hi-part of result
   367                              <1>         div     cx                  ;AX is lo-part of result
   368                              <1>         shr     cx,1                ;divide by 2
   369                              <1>         sub     cx,dx               ;borrow if dx is greater (carry set)
   370                              <1>         adc     ax,0                ;round the result
   371                              <1>         adc     si,0                ; sets/clears the Sign flag
   372                              <1> 
   373                              <1>         mov     dx,si               ;DX:AX is result
   374                              <1>         pop     si                  ;get pointer of where to put it
   375                              <1> 
   376                              <1>         js      FD060               ;go store it if already normalized
   377                              <1>         dec     word [si+expon]          ;adjust exponent
   378                              <1>         shl     ax,1                ;normalize
   379                              <1>         rcl     dx,1                ;
   380                              <1> FD060:
   381                              <1>         mov     [si+mantis],dx      ;store hi-part
   382                              <1>         mov     [si+mantis+2],ax    ;store lo-part
   383                              <1> %endif
   384 0000131F C60400              <1>         mov     byte [si+tag], tag_valid ;say destination is valid
   385                              <1> FD099:
   386 00001322 C3                  <1>         ret                     ;return to caller
   387                              <1> ;do_div  endp
   388                              <1> 
   389                              <1> 
   390                              <1> 
   391                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   392                              <1> ;
   393                              <1> ; Name:  do_compare
   394                              <1> ;
   395                              <1> ;   compare [DI] to [SI]
   396                              <1> ;   returns result of comparison in AH
   397                              <1> ;
   398                              <1> ;   AH bit settings:
   399                              <1> ;           7  6  5  4  3  2  1  0
   400                              <1> ;              Z           P     C  --  80186 flag register
   401                              <1> ;             C3          C2 C1 C0  --  80187 condition codes
   402                              <1> ;
   403                              <1> ;       [DI] = [SI]     returns  C3                 JE
   404                              <1> ;       [DI] > [SI]     returns all flags clear     JA
   405                              <1> ;       [DI] < [SI]     returns  C0                 JB
   406                              <1> ;   [DI] not comparable to [SI] returns  C3+C2+C0
   407                              <1> ;
   408                              <1> ;   uses:  AX, DX, SI, DI   (may be trashed)
   409                              <1> ;   preserves BX, CX
   410                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   411                              <1> do_compare:	;	  proc    near
   412 00001323 8A05                <1>         mov     al,byte [di+tag]         ;get destination tag
   413 00001325 0A04                <1>         or      al,byte [si+tag]         ;get source tag
   414 00001327 7541                <1>         jnz     DC100               ;tags are not both valid
   415                              <1> ; tags are valid, check signs of operands
   416 00001329 8A4401              <1>         mov     al,byte [si+sign]        ;get sign of source
   417 0000132C 3A4501              <1>         cmp     al,byte [di+sign]        ; if sS > sD,  D > S; if sS < sD,  D < S
   418 0000132F 7534                <1>         jne     DC080               ;done if not equal
   419                              <1> ; signs are the same, swap source and destination if negative
   420 00001331 08C0                <1>         or      al,al
   421 00001333 7402                <1>         jz      DC010               ;both signs are positive
   422 00001335 87F7                <1>         xchg    si,di               ;for negative, magnitude 
   423                              <1>                                     ; comparison is reversed
   424                              <1> DC010:
   425 00001337 8B4502              <1>         mov     ax,word [di+expon]       ;get destination exponent
   426 0000133A 8B5402              <1>         mov     dx,word [si+expon]       ;get source exponent
   427 0000133D 80F480              <1>         xor     ah,80h              ;bias for unsigned comparison
   428 00001340 80F680              <1>         xor     dh,80h              ; **
   429 00001343 39D0                <1>         cmp     ax,dx               ;unsigned comparison
   430 00001345 751E                <1>         jne     DC080               ;if eD > eS,  D > S; and vice versa
   431                              <1> 
   432                              <1> ; exponents are the same, compare mantissas
   433 00001347 8B4504              <1>         mov     ax,[di+mantis]      ;get high order mantissa
   434 0000134A 3B4404              <1>         cmp     ax,[si+mantis]      ;unsigned comparison
   435 0000134D 7516                <1>         jne     DC080
   436                              <1> 
   437 0000134F 8B4506              <1>         mov     ax,[di+mantis+2]      ;get high order mantissa
   438 00001352 3B4406              <1>         cmp     ax,[si+mantis+2]    ;unsigned comparison
   439                              <1> %if BIG
   440 00001355 750E                <1>         jne     DC080
   441                              <1> 
   442 00001357 8B4508              <1>         mov     ax,[di+mantis+4]    ;get high order mantissa
   443 0000135A 3B4408              <1>         cmp     ax,[si+mantis+4]    ;unsigned comparison
   444 0000135D 7506                <1>         jne     DC080
   445                              <1> 
   446 0000135F 8B450A              <1>         mov     ax,[di+mantis+6]    ;get high order mantissa
   447 00001362 3B440A              <1>         cmp     ax,[si+mantis+6]    ;unsigned comparison
   448                              <1> %endif
   449                              <1> 
   450                              <1> DC080:
   451 00001365 9F                  <1>         lahf                        ;get flags to AH
   452 00001366 80E441              <1>         and     ah,C3+C0            ;mask to Zero and Carry
   453                              <1> DC099:
   454 00001369 C3                  <1>         ret
   455                              <1> ;
   456                              <1> ; tags are not both zero; i.e., not both (tag_valid)
   457                              <1> ;
   458 0000136A A8FE                <1> DC100:  test    al,0FEh             ;test for tag_zero as only exception
   459 0000136C 7511                <1>         jnz     DC150               ;not comparable
   460 0000136E 803C01              <1>         cmp     byte [si+tag], tag_zero  ;test source for tag_zero
   461 00001371 7504                <1>         jne     DC110
   462                              <1> ; source is tag zero
   463 00001373 89FE                <1>         mov     si,di               ;FTST  [SI]
   464 00001375 EB0C                <1>         JMP     short do_test       ;do_test will do the return
   465                              <1> 
   466                              <1> DC110:      ; SI is tag_valid, DI must be tag_zero
   467 00001377 E80900              <1>         call    do_test             ;FTST  [SI]
   468 0000137A 80F401              <1>         xor     ah,C0               ;invert comparison bit
   469 0000137D EBEA                <1>         jmp     DC099
   470                              <1>     
   471                              <1> ; one of the operands is infinity, or NaN, or empty
   472                              <1> DC150:
   473 0000137F B445                <1>         mov     ah,C3+C2+C0
   474 00001381 EBE6                <1>         jmp     DC099
   475                              <1> 
   476                              <1> ;do_compare  endp
   477                              <1> 
   478                              <1> 
   479                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   480                              <1> ;
   481                              <1> ;   do_test     compare [SI] to 0.0
   482                              <1> ;
   483                              <1> ;   uses:  AX
   484                              <1> ;   preserves all other registers
   485                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   486                              <1> do_test:	;	 proc    near
   487 00001383 803C01              <1>         cmp     byte [si+tag], tag_zero
   488 00001386 740B                <1>         je      DT090
   489 00001388 770E                <1>         ja      DT070
   490                              <1> ; tag_valid
   491 0000138A 31C0                <1>         xor     ax,ax
   492 0000138C 3A4401              <1>         cmp     al,byte [si+sign]    ;know AL=0, it is (tag_valid)
   493 0000138F 7202                <1>         jb      DT090           ; if 0 < sS,  S < 0.0
   494                              <1> ;;;;      mov     ah,al           ;clear all the flags, S > 0.0
   495 00001391 EB04                <1>         jmp     short DT099
   496                              <1> DT090:
   497 00001393 9F                  <1>         lahf                    ;get flags to AH
   498 00001394 80E441              <1>         and     ah,C3+C0        ;mask to required flags
   499                              <1> DT099:
   500 00001397 C3                  <1>         ret                     ;and return to caller
   501                              <1> 
   502                              <1> ; tag is infinity, NaN, or empty
   503                              <1> DT070:
   504 00001398 B445                <1>         mov     ah,C3+C2+C0
   505 0000139A EBFB                <1>         jmp     DT099
   506                              <1> 
   507                              <1> ;do_test endp
   508                              <1> 
   509                              <1> 
   510                              <1> 
   511                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   512                              <1> ;
   513                              <1> ;   FCOM    mem         ST : mem
   514                              <1> ;
   515                              <1> ;       ES:DI is pointer to memory location
   516                              <1> ;
   517                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   518                              <1> genFCOM:
   519 0000139C BE2C00              <1>         mov     si,Areg      ;load first into the Areg
   520 0000139F BB0600              <1>         mov     bx,FMbits           ;get format mask
   521 000013A2 20EB                <1>         and     bl,ch
   522 000013A4 2EFF97[3603]        <1>   cs    call    [vecFLD+bx]          ;get the input argument
   523 000013A9 30DB                <1>         xor     bl,bl
   524 000013AB E8B0F2              <1>         call    regptr              ;get ST pointer in BX
   525 000013AE 89DF                <1>         mov     di,bx               ;DI is destination, SI is source
   526 000013B0 E870FF              <1>         call    do_compare          ;return condition codes in AH
   527                              <1> 
   528 000013B3 80260300BA          <1>         and     byte [codes],~ (C3+C2+C0)    ;clear Status bits
   529 000013B8 08260300            <1>         or      byte [codes],ah            ;set condition code bits
   530 000013BC E9F7ED              <1>         jmp     restore_segs
   531                              <1> 
   532                              <1> 
   533                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   534                              <1> ;
   535                              <1> ;   FCOMP   mem         ST : mem
   536                              <1> ;
   537                              <1> ;       ES:DI is pointer to memory location
   538                              <1> ;
   539                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   540                              <1> genFCOMP:
   541 000013BF BE2C00              <1>         mov     si,Areg      ;load first into the Areg
   542 000013C2 BB0600              <1>         mov     bx,FMbits           ;get format mask
   543 000013C5 20EB                <1>         and     bl,ch
   544 000013C7 2EFF97[3603]        <1>   cs    call    [vecFLD+bx]          ;get the input argument
   545 000013CC 30DB                <1>         xor     bl,bl
   546 000013CE E88DF2              <1>         call    regptr              ;get ST pointer in BX
   547 000013D1 89DF                <1>         mov     di,bx               ;DI is destination, SI is source
   548                              <1> ; tos pointer is in BX
   549 000013D3 E84DFF              <1>         call    do_compare          ;return condition codes in AH
   550                              <1> 
   551 000013D6 80260300BA          <1>         and     byte [codes],~ (C3+C2+C0)    ;clear Status bits
   552 000013DB 08260300            <1>         or      byte [codes],ah            ;set condition code bits
   553 000013DF E9C3ED              <1>         jmp     pop_stack           ;BX is set
   554                              <1> 
   555                              <1> 
   556                              <1> 
   557                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   558                              <1> ;
   559                              <1> ;   FCOM    ST,ST(i)        R=0, P=0
   560                              <1> ;
   561                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   562                              <1> FCOMrr:
   563 000013E2 E898EF              <1>         call    RRsetup         ;get source and destination reg. ptrs
   564                              <1> 
   565 000013E5 E83BFF              <1>         call    do_compare      ;do the comparison
   566                              <1> 
   567 000013E8 80260300BA          <1>         and     byte [codes],~ (C3+C2+C0)    ;clear Status bits
   568 000013ED 08260300            <1>         or      byte [codes],ah            ;set condition code bits
   569                              <1> ; and exit
   570 000013F1 E9C2ED              <1>         jmp     restore_segs
   571                              <1> 
   572                              <1> 
   573                              <1> 
   574                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   575                              <1> ;
   576                              <1> ;   FCOMP   ST,ST(i)        R=0, P=0
   577                              <1> ;   FCOMPP  ST,ST(1)        R=1, P=1        watch out for R-bit
   578                              <1> ;
   579                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   580                              <1> FCOMPrr:
   581 000013F4 88CB                <1>         mov     bl,cl           ;get source register
   582 000013F6 E865F2              <1>         call    regptr          ;get pointer to source
   583 000013F9 89DE                <1>         mov     si,bx           ;source ptr to SI
   584 000013FB 31DB                <1>         xor     bx,bx           ;get ST(0)
   585 000013FD E85EF2              <1>         call    regptr          ;get pointer to destination
   586 00001400 89DF                <1>         mov     di,bx           ;dest. ptr to DI
   587                              <1> ; tos pointer is in BX
   588 00001402 E81EFF              <1>         call    do_compare          ;return condition codes in AH
   589 00001405 80260300BA          <1>         and     byte [codes],~ (C3+C2+C0)    ;clear Status bits
   590 0000140A 08260300            <1>         or      byte [codes],ah            ;set condition code bits
   591                              <1> 
   592                              <1> ; pop the tos
   593 0000140E 803F03              <1>         cmp     byte [bx+tag], tag_empty ;test for empty register
   594 00001411 740F                <1>         je      under2
   595                              <1> pop002:
   596 00001413 C60703              <1>         mov     byte [bx+tag], tag_empty     ;tag it empty
   597 00001416 FE061000            <1>         inc     byte [tos]                 ;pop the stack
   598 0000141A 8026100007          <1>         and     byte [tos],7               ; **
   599                              <1> 
   600                              <1> ; and exit
   601 0000141F E977ED              <1>         jmp     test_pop        ;test for second pop
   602                              <1> 
   603                              <1> 
   604                              <1> ; signal stack underflow
   605                              <1> under2:
   606 00001422 80260300FD          <1>         and     byte [codes],~ C1                ;indicate underflow
   607 00001427 684110              <1>         push    errStkUnderflow+Sflag+Iexcept
   608 0000142A E8C407              <1>         call    exception
   609 0000142D EBE4                <1>         jmp     short pop002
   610                              <1> 
   611                              <1> 
   612                              <1> ; end em187f.asm
   523                                  %include "em187g.asm"
     1                              <1> ; em187g.asm
     2                              <1> 
     3                              <1> ;
     4                              <1> ; handle Indefinite input to FBLD
     5                              <1> ;
     6                              <1> BL190:
     7 0000142F 6A01                <1>         push    Iexcept                 ;invalid operation
     8 00001431 E8BD07              <1>         call    exception               ;   exception
     9 00001434 C60406              <1>         mov     byte [si+tag], tag_invalid   ;flag as invalid input
    10 00001437 2401                <1>         and     al,01h                  ;mask to low bit
    11 00001439 884401              <1>         mov     byte [si+sign],al            ;store the sign as put in
    12 0000143C E977ED              <1>         jmp     restore_segs
    13                              <1> 
    14                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    15                              <1> ;
    16                              <1> ;   FBLD    mem         load Tbyte BCD number
    17                              <1> ;
    18                              <1> ;       enter with ES:DI pointing at memory operand
    19                              <1> ;
    20                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    21                              <1> gFBLD:
    22 0000143F E8F6F1              <1>         call    alloc                   ;get new ST pointer in BX
    23 00001442 89DE                <1>         mov     si,bx                   ;destination pointer to SI
    24 00001444 83C709              <1>         add     di,9                    ;point at highest order byte
    25 00001447 268A05              <1>   es    mov     al,[di]                 ;get sign byte
    26 0000144A D0E0                <1>         shl     al,1                    ;sign to carry flag
    27 0000144C D0D0                <1>         rcl     al,1                    ;sign to low byte
    28 0000144E 3C01                <1>         cmp     al,1                    ;test for indefinite
    29 00001450 77DD                <1>         ja      BL190                   ;sign is valid only if 0 or 1
    30 00001452 884401              <1>         mov     byte [si+sign],al            ;store sign
    31 00001455 C60400              <1>         mov     byte [si+tag], tag_valid     ;store tag
    32 00001458 C6061A0009          <1>         mov     byte [ctr],9                   ;count 9 bytes
    33 0000145D 31C0                <1>         xor     ax,ax                   ;clear the result
    34 0000145F 31ED                <1>         xor     bp,bp                   ;
    35 00001461 31DB                <1>         xor     bx,bx
    36 00001463 31C9                <1>         xor     cx,cx
    37 00001465 31D2                <1>         xor     dx,dx
    38                              <1> BL010:
    39 00001467 4F                  <1>         dec     di                      ;get two digits
    40 00001468 268A05              <1>   es    mov     al,[di]              ; **
    41 0000146B 08C0                <1>         or      al,al                   ;check for both zero
    42 0000146D 750F                <1>         jnz     BL030                   ;one is above zero
    43 0000146F FE0E1A00            <1>         dec     byte [ctr]                     ;count thru 9 bytes
    44 00001473 75F2                <1>         jne     BL010                   ;loop back
    45 00001475 7445                <1>         je      BL040                   ;all digits are zero
    46                              <1> 
    47                              <1> BL020:
    48 00001477 E84D00              <1>         call    times10                 ;result * 10
    49 0000147A 4F                  <1>         dec     di                      ;get next digit
    50 0000147B 268A05              <1>   es    mov     al,[di]              ; **
    51                              <1> BL030:
    52 0000147E C0E804              <1>         shr     al,4                    ;use high digit
    53 00001481 01C2                <1>         add     dx,ax                   ;add it to the result
    54 00001483 83D100              <1>         adc     cx,0                    ; **
    55 00001486 83D300              <1>         adc     bx,0                    ;  **
    56 00001489 83D500              <1>         adc     bp,0                    ;   **
    57                              <1> 
    58 0000148C E83800              <1>         call    times10                 ;result * 10
    59 0000148F 268A05              <1>   es    mov     al,[di]              ;get low digit
    60 00001492 240F                <1>         and     al,0Fh                  ; **
    61 00001494 01C2                <1>         add     dx,ax                   ;add it to the result
    62 00001496 83D100              <1>         adc     cx,0                    ;
    63 00001499 83D300              <1>         adc     bx,0
    64 0000149C 83D500              <1>         adc     bp,0
    65                              <1> 
    66 0000149F FE0E1A00            <1>         dec     byte [ctr]                     ;count thru the bytes
    67 000014A3 75D2                <1>         jne     BL020                   ;loop if some remain
    68                              <1> 
    69 000014A5 89E8                <1>         mov     ax,bp                   ;prepare to normalize
    70 000014A7 BF3F00              <1>         mov     di,63                   ;exponent
    71                              <1> %if BIG
    72 000014AA 68[B601]            <1>         push    restore_segs     ;simulate call
    73 000014AD E9AAF2              <1>         jmp     normalize_and_exit      ;will return
    74                              <1> %else
    75                              <1> 
    76                              <1> BL055:
    77                              <1>         or      ax,ax               ;test for hi zero
    78                              <1>         jnz     short BL056
    79                              <1>         xchg    bx,ax
    80                              <1>         xchg    cx,bx
    81                              <1>         xchg    dx,cx
    82                              <1>         sub     di,16               ;decrease exponent
    83                              <1>         jmp     BL055
    84                              <1> BL056:
    85                              <1>         or      ah,ah               ;test for hi zero byte
    86                              <1>         jnz     short   BL057
    87                              <1>         xchg    al,ah
    88                              <1>         xchg    bh,al
    89                              <1>         xchg    bl,bh
    90                              <1>         xchg    ch,bl
    91                              <1>         xchg    cl,ch
    92                              <1> ;;;        xchg    dh,cl
    93                              <1> ;;;        xchg    dl,dh
    94                              <1>         sub     di,8                ;adjust exponent
    95                              <1> BL057:
    96                              <1>         test    ah,80H              ;test for normalized bit
    97                              <1>         jnz     BL058
    98                              <1> 
    99                              <1> ;;;        shl     dx,1                ;normalize a bit at a time
   100                              <1> ;;;        rcl     cx,1
   101                              <1>            shl     ch,1
   102                              <1> 
   103                              <1>         rcl     bx,1
   104                              <1>         rcl     ax,1
   105                              <1>         dec     di                  ;decrease exponent
   106                              <1>         jmp     BL057
   107                              <1> %endif
   108                              <1> 
   109                              <1> BL058:  ; non-zero result
   110 000014B0 897C02              <1>         mov     word [si+expon],di       ;store new exponent
   111 000014B3 894404              <1>         mov     [si+mantis],ax
   112 000014B6 895C06              <1>         mov     [si+mantis+2],bx
   113 000014B9 E9FAEC              <1>         jmp     restore_segs
   114                              <1> 
   115                              <1> 
   116                              <1> BL040:  ; zero result
   117 000014BC C60401              <1>         mov     byte [si+tag], tag_zero      ;result was zero
   118 000014BF 884401              <1>         mov     byte [si+sign],al            ;all regs are zero
   119 000014C2 BF0180              <1>         mov     di,exp_of_FPzero        ;zero has funny exponent
   120 000014C5 EBE9                <1>         jmp     BL058
   121                              <1> 
   122                              <1> 
   123                              <1> ; internal subroutine to multiply BP:BX:CX:DX by 10
   124                              <1> 
   125                              <1> times10:	;	 proc    near
   126 000014C7 89161C00            <1>         mov     word [mtemp],dx
   127 000014CB 890E1E00            <1>         mov     word [mtemp+2],cx
   128 000014CF 891E2000            <1>         mov     word [mtemp+4],bx
   129 000014D3 892E2200            <1>         mov     word [mtemp+6],bp
   130                              <1> 
   131 000014D7 D1E2                <1>         shl     dx,1                    ;times 2 to begin
   132 000014D9 D1D1                <1>         rcl     cx,1
   133 000014DB D1D3                <1>         rcl     bx,1
   134 000014DD D1D5                <1>         rcl     bp,1
   135                              <1> 
   136 000014DF D1E2                <1>         shl     dx,1                    ;times 4 to begin
   137 000014E1 D1D1                <1>         rcl     cx,1
   138 000014E3 D1D3                <1>         rcl     bx,1
   139 000014E5 D1D5                <1>         rcl     bp,1
   140                              <1> 
   141 000014E7 03161C00            <1>         add     dx,word [mtemp]                ;times 5
   142 000014EB 130E1E00            <1>         adc     cx,word [mtemp+2]
   143 000014EF 131E2000            <1>         adc     bx,word [mtemp+4]
   144 000014F3 132E2200            <1>         adc     bp,word [mtemp+6]
   145                              <1> 
   146 000014F7 D1E2                <1>         shl     dx,1                    ;times 10
   147 000014F9 D1D1                <1>         rcl     cx,1
   148 000014FB D1D3                <1>         rcl     bx,1
   149 000014FD D1D5                <1>         rcl     bp,1
   150 000014FF C3                  <1>         ret                             ;done
   151                              <1> ;times10 endp
   152                              <1> 
   153                              <1> 
   154                              <1> 
   155                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   156                              <1> ;
   157                              <1> ;   FBSTP   mem         store Tbyte BCD number
   158                              <1> ;
   159                              <1> ;       enter with ES:DI pointing at memory destination
   160                              <1> ;
   161                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   162                              <1> gFBSTP:
   163 00001500 1E                  <1>         push    ds                  ;save DS
   164                              <1> 
   165 00001501 30DB                <1>         xor     bl,bl               ;ST(0) needed
   166 00001503 E858F1              <1>         call    regptr              ;get BX pointing to stact top
   167 00001506 53                  <1>         push    bx                  ;save pointer for later pop
   168                              <1> 
   169 00001507 8A7701              <1>         mov     dh,byte [bx+sign]        ;get sign of operand
   170 0000150A D0EE                <1>         shr     dh,1                ;sign to carry
   171 0000150C D0DE                <1>         rcr     dh,1                ;sign to hi-bit
   172 0000150E 52                  <1>         push    dx                  ;save sign byte in DH
   173                              <1> 
   174 0000150F 8A07                <1>         mov     al,byte [bx+tag]         ;get tag
   175 00001511 3C01                <1>         cmp     al,tag_zero         ;test for special tag
   176 00001513 7611                <1>         jbe     BS010               ;if okay
   177                              <1> ; tag is funny, store indefinite
   178                              <1> BS005:
   179 00001515 6A01                <1>         push    Iexcept             ;invalid operation
   180 00001517 EB02                <1>         jmp     short BS008
   181                              <1> BS006:
   182 00001519 6A09                <1>         push    Iexcept+Oexcept     ;overflow & invalid
   183                              <1> BS008:
   184 0000151B E8D306              <1>         call    exception
   185 0000151E 26C74508FFFF        <1>   es    mov     word [di+8],0FFFFh   ;store indefinite
   186 00001524 EB76                <1>         jmp     short BS090         ;go do the proper pops
   187                              <1> 
   188                              <1> BS010:      ;tag was valid
   189 00001526 B93F00              <1>         mov     cx,63               ;get max. shift
   190 00001529 2B4F02              <1>         sub     cx,word [bx+expon]       ;subtract exponent
   191 0000152C 7EEB                <1>         jle     BS006               ;signal invalid and overflow
   192                              <1> 
   193 0000152E 89DE                <1>         mov     si,bx               ;point SI at input, for 'round_mag'
   194 00001530 E8D000              <1>         call    vloadsh64           ;load 64 bits, extend if necessary
   195 00001533 E88000              <1>         call    round_mag           ;round as specified
   196                              <1> 
   197 00001536 06                  <1>         push    es
   198 00001537 1F                  <1>         pop     ds                      
   199                              <1> 
   200 00001538 89D5                <1>         mov     bp,dx           ;move low order word to BP
   201 0000153A 31D2                <1>         XOR     DX,DX           ;DX = 0
   202 0000153C BE1027              <1>         MOV     si,10000        ;WILL USE THIS CONSTANT QUITE A LOT
   203                              <1> 
   204                              <1> ; START WITH 63 MAGNITUDE BITS
   205 0000153F F7F6                <1>         DIV     si              ;AX = Q4, DX = R4
   206                              <1> ; AX MUST BE ZERO AT THIS POINT
   207 00001541 93                  <1>         XCHG    AX,BX           ;AX = 3, BX = Q4
   208 00001542 F7F6                <1>         DIV     si              ;DX = R3
   209 00001544 91                  <1>         XCHG    AX,CX           ;AX = 2, CX = Q3
   210 00001545 F7F6                <1>         DIV     si              ;DX = R2
   211 00001547 95                  <1>         XCHG    AX,BP           ;AX = 1, BP = Q2
   212 00001548 F7F6                <1>         DIV     si              ;DX = R1, AX = Q1
   213                              <1> ;;;        MOV     ds:[di],DX       ;SAVE LOWEST 4 DIGITS IN BINARY
   214 0000154A 8915                <1>         MOV     [di],DX       ;SAVE LOWEST 4 DIGITS IN BINARY
   215                              <1> 
   216                              <1> ;CONTINUE WITH 50 MAGNITUDE BITS
   217 0000154C 89DA                <1>         MOV     DX,BX           ;DX = 2 BITS OR LESS
   218 0000154E 91                  <1>         XCHG    AX,CX           ;CX = 1
   219 0000154F F7F6                <1>         DIV     si              ;DX = R3
   220 00001551 95                  <1>         XCHG    AX,BP           ;BP = Q3
   221 00001552 F7F6                <1>         DIV     si              ;DX = R2
   222 00001554 91                  <1>         XCHG    AX,CX           ;CX = Q2
   223 00001555 F7F6                <1>         DIV     si              ;DX = R1, AX = Q1
   224                              <1> ;;;        MOV     ds:[di]+2,DX     ;SAVE SECOND SET OF 4 DIGITS IN BINARY
   225 00001557 895502              <1>         MOV     [di+2],DX     ;SAVE SECOND SET OF 4 DIGITS IN BINARY
   226                              <1> 
   227                              <1> ;CONTINUE WITH 37 MAGNITUDE BITS
   228 0000155A 89EA                <1>         MOV     DX,BP           ;DX = 5 BITS OR LESS
   229 0000155C 91                  <1>         XCHG    AX,CX           ;CX = 1
   230 0000155D F7F6                <1>         DIV     si              ;DX = R2
   231 0000155F 91                  <1>         XCHG    AX,CX           ;CX = Q2
   232 00001560 F7F6                <1>         DIV     si              ;DX = R1, AX = Q1
   233 00001562 895504              <1>         MOV     [di+4],DX     ;SAVE THIRD SET OF 4 DIGITS IN BINARY
   234                              <1> 
   235                              <1> ;CONTINUE WITH 23 MAGNITUDE BITS
   236 00001565 89CA                <1>         MOV     DX,CX           ;DX = 7 BITS OR LESS
   237 00001567 F7F6                <1>         DIV     si              ;DX = R1
   238 00001569 895506              <1>         MOV     [di+6],DX     ;SAVE 4TH SET OF 4 DIGITS IN BINARY
   239                              <1> 
   240                              <1> ;QUOTIENT IN AX IS 10 BITS OR LESS
   241 0000156C 83F863              <1>         cmp     ax,99           ;must be .le. 99.
   242 0000156F 77A8                <1>         ja      BS006           ;error if above 99
   243                              <1> 
   244 00001571 8D7506              <1>         LEA     SI,[di+6]      ;POINT AT FOURTH WORD AS SOURCE
   245 00001574 8D7D09              <1>         LEA     DI,[di+9]      ;POINT AT HIGHEST BYTE (SIGN BYTE)
   246 00001577 FD                  <1>         STD                     ;SET TO GO FROM HIGH TO LOW
   247 00001578 B90500              <1>         MOV     CX,5            ;SET FOR 5 WORDS        
   248 0000157B BD6400              <1>         MOV     BP,100          ;DIVISOR OF 100
   249 0000157E B30A                <1>         MOV     BL,10           ;DIVISOR OF 10
   250 00001580 EB01                <1>         JMP     SHORT EMFBSTP11 ;ENTER LOOP AFTER LOAD
   251                              <1> 
   252                              <1> EMFBSTP10:
   253 00001582 AD                  <1>         LODSW                   ;GET 4 DIGITS IN BINARY
   254                              <1> EMFBSTP11:
   255 00001583 31D2                <1>         XOR     DX,DX           ;DX = 0 FOR DIVIDE
   256 00001585 F7F5                <1>         DIV     BP              ;DX IS LOW TWO DIGITS, AX IS HI DIGITS
   257                              <1> 
   258 00001587 F6F3                <1>         DIV     BL              ;AH IS LOWEST DIGIT, AL IS HIGH DIGIT
   259 00001589 C0E004              <1>         SHL     AL,4
   260 0000158C 08E0                <1>         OR      AL,AH           ;AL IS TWO DIGITS
   261 0000158E AA                  <1>         STOSB                   ;STORE DIGIT PAIR
   262                              <1> 
   263 0000158F 89D0                <1>         MOV     AX,DX           ;GET 2 LOWER DIGITS TO AX
   264 00001591 F6F3                <1>         DIV     BL              ;AH IS LOWEST DIGIT, AL IS HIGH DIGIT
   265 00001593 C0E004              <1>         SHL     AL,4
   266 00001596 08E0                <1>         OR      AL,AH           ;AL IS TWO DIGITS
   267 00001598 AA                  <1>         STOSB                   ;STORE DIGIT PAIR
   268 00001599 E2E7                <1>         LOOP    EMFBSTP10       ;LOOP BACK
   269                              <1>         
   270 0000159B 47                  <1>         INC     di              ;RESTORE di
   271                              <1> 
   272                              <1> ; ADD SIGN TO RESULT
   273                              <1> BS090:
   274 0000159C 5A                  <1>         POP     DX              ;GET SAVED SIGN
   275 0000159D 087509              <1>         OR      [di+9],DH       ;SET SIGN BYTE
   276                              <1> 
   277 000015A0 5B                  <1>         pop     bx                  ;restore the tos pointer
   278 000015A1 1F                  <1>         pop     ds                  ;restore DS pointer
   279 000015A2 E900EC              <1>         jmp     pop_stack           ;BX is set
   280                              <1> 
   281                              <1> 
   282 000015A5 90                  <1>         even
   283 000015A6 [C515][C515][F115]- <1> rnd_vec dw  nearest,nearest,  chop,up,  up,chop,  chop,chop
   283 000015AC [DA15][DA15][F115]- <1>
   283 000015B2 [F115][F115]        <1>
   284                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   285                              <1> ;   Name:  round_mag
   286                              <1> ;   Desc:  round the magnitude in AX:BX:CX:DX according to
   287                              <1> ;          the current rounding mode, and the Sign pointed at by
   288                              <1> ;          SI.
   289                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   290                              <1> round_mag:	;	   proc    near
   291 000015B6 53                  <1>         push    bx
   292 000015B7 8B1E0E00            <1>         mov     bx,word [round]        ;get rounding control (0,2,4,6)
   293 000015BB 025C01              <1>         add     bl,byte [si+sign]    ;get dispatch 0..7
   294 000015BE D0E3                <1>         shl     bl,1            ; ** 0,2,4,6,..,14
   295 000015C0 2EFFA7[A615]        <1>   cs    jmp     [rnd_vec+bx]     ;dispatch to proper rounding mode
   296                              <1> 
   297                              <1> ; round magnitude to nearest or even
   298                              <1> nearest:
   299 000015C5 F606130080          <1>         test    byte [guard],80h       ;see if guard bit is set
   300 000015CA 7425                <1>         jz      chop            ;do nothing if not set
   301                              <1> ; guard bit is set
   302 000015CC F6061200FF          <1>         test    byte [sticky],0FFh     ;see if sticky bit is set
   303 000015D1 750F                <1>         jnz     RM020           ;must increment if guard and sticky both set
   304                              <1> ; sticky is not set, round to even
   305 000015D3 F6C201              <1>         test    dl,01           ;see if low bit is set
   306 000015D6 750A                <1>         jnz     RM020           ;must increment to even if odd
   307 000015D8 7417                <1>         jz      chop            ;must leave even if already there
   308                              <1> 
   309                              <1> ; round magnitude toward  + infinity
   310                              <1> up:         ;increment magnitude if guard or sticky set
   311 000015DA 8B1E1200            <1>         mov     bx,word [guard_sticky] ;get guard and sticky bits
   312 000015DE 08FB                <1>         or      bl,bh           ;see if either set
   313 000015E0 740F                <1>         jz      chop            ;done if neither set
   314                              <1> ; must increment the magnitude
   315 000015E2 83C201              <1> RM020:  add     dx,1            ;must use ADD, not INC, to set carry flag
   316 000015E5 83D100              <1>         adc     cx,0
   317 000015E8 5B                  <1>         pop     bx
   318 000015E9 83D300              <1>         adc     bx,0
   319 000015EC 83D000              <1>         adc     ax,0
   320 000015EF EB01                <1>         jmp     short RM099     ;and exit
   321                              <1> 
   322                              <1> ; chop means do nothing to the magnitude
   323                              <1> chop:
   324 000015F1 5B                  <1>         pop     bx              ;restore register
   325                              <1> RM099:
   326 000015F2 C3                  <1>         ret                     ;and return
   327                              <1> ;round_mag   endp
   328                              <1> 
   329                              <1> 
   330                              <1> 
   331                              <1> 
   332                              <1> ; shift was so big (>64), zero mantissa is the result
   333                              <1> vl64100:
   334 000015F3 31C0                <1>         xor     ax,ax
   335 000015F5 31DB                <1>         xor     bx,bx
   336 000015F7 31C9                <1>         xor     cx,cx
   337 000015F9 31D2                <1>         xor     dx,dx
   338 000015FB C7061200FF00        <1>         mov     word [guard_sticky],00FFh  ;guard of zero, sticky set
   339 00001601 EB7A                <1>         jmp     vl64099
   340                              <1> 
   341                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   342                              <1> ;   Name:  vloadsh64
   343                              <1> ;   Desc:  get the mantissa pointed to by BX, and shift right by
   344                              <1> ;          the amount in CX.  If 32 bit mantissa, extend to 64 bits.
   345                              <1> ;       Return result in  AX:BX:CX:DX
   346                              <1> ;       Compute the 'guard' and 'sticky' bits, also
   347                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   348                              <1> vloadsh64:	;	  proc    near
   349 00001603 83F940              <1>         cmp     cx,64       ;shift of 63 is the max for 64-bit mantissa
   350 00001606 77EB                <1>         ja      vl64100     ;go return zero
   351                              <1> 
   352 00001608 56                  <1>         push    si          ;counter will be here for 64-bit mantissa
   353 00001609 57                  <1>         push    di          ;save register DI
   354                              <1> 
   355                              <1> %if BIG
   356                              <1> %else
   357                              <1>         cmp     cx,32       ;test for brief load
   358                              <1>         jb      vl64005
   359                              <1>         sub     cx,32       ;reduce by 32
   360                              <1>         xor     ax,ax
   361                              <1>         xor     di,di
   362                              <1>         mov     si,[bx+mantis]      ;get first word
   363                              <1>         mov     dx,[bx+mantis+2]    ;get the second
   364                              <1>         jmp     short vl64007
   365                              <1>         
   366                              <1> vl64005:
   367                              <1> %endif
   368                              <1> 
   369 0000160A 8B4704              <1>         mov     ax,[bx+mantis]      ;first word of mantissa
   370 0000160D 8B7F06              <1>         mov     di,[bx+mantis+2]    ;second word
   371                              <1> %if BIG
   372 00001610 8B7708              <1>         mov     si,[bx+mantis+4]    ;third word of mantissa
   373 00001613 8B570A              <1>         mov     dx,[bx+mantis+6]    ;fourth word of mantissa
   374                              <1> %else
   375                              <1>         xor     si,si               ;third word of mantissa
   376                              <1>         xor     dx,dx               ;fourth word of mantissa
   377                              <1> 
   378                              <1> vl64007:
   379                              <1> %endif
   380                              <1> 
   381 00001616 31DB                <1>         xor     bx,bx               ;BH is guard bit, BL is sticky bit
   382 00001618 80F910              <1>         cmp     cl,16               ;compare to 16
   383 0000161B 721A                <1>         jb      vl64020             ;skip 16 bit shifts if below 16
   384                              <1> vl64010:
   385 0000161D 08FB                <1>         or      bl,bh               ;guard into sticky
   386 0000161F D0E6                <1>         shl     dh,1                ;isolate new guard bit in carry
   387 00001621 D0DF                <1>         rcr     bh,1                ;guard bit to BH
   388 00001623 08F2                <1>         or      dl,dh               ;sticky in DL
   389 00001625 08D3                <1>         or      bl,dl               ;new sticky in BL
   390 00001627 89F2                <1>         mov     dx,si               ;shift by 16 bits
   391 00001629 89FE                <1>         mov     si,di               ;**
   392 0000162B 89C7                <1>         mov     di,ax               ; **
   393 0000162D 31C0                <1>         xor     ax,ax               ;  **
   394 0000162F 80E910              <1>         sub     cl,16
   395 00001632 80F910              <1>         cmp     cl,16               ;compare if another 16-bit shift is needed
   396 00001635 77E6                <1>         ja      vl64010             ;loop back if above zero
   397                              <1> vl64020:            ; check for 8 bit shift
   398 00001637 80F908              <1>         cmp     cl,8            
   399 0000163A 7223                <1>         jb      vl64040
   400                              <1> 
   401 0000163C 08FB                <1>         or      bl,bh           ;guard into sticky
   402 0000163E D0E2                <1>         shl     dl,1            ;isolate new guard bit in carry
   403 00001640 D0DF                <1>         rcr     bh,1            ;guard bit to BH
   404 00001642 08D3                <1>         or      bl,dl           ;new sticky in BL
   405                              <1> 
   406 00001644 87CE                <1>         xchg    cx,si           ;do a long 8 bit shift
   407 00001646 88F2                <1>         mov     dl,dh
   408 00001648 88CE                <1>         mov     dh,cl
   409 0000164A 87DF                <1>         xchg    bx,di           ;BX has 2 halves
   410 0000164C 88E9                <1>         mov     cl,ch
   411 0000164E 88DD                <1>         mov     ch,bl
   412 00001650 88FB                <1>         mov     bl,bh           ;do the short portion of an 8-bit shift
   413 00001652 88C7                <1>         mov     bh,al
   414 00001654 88E0                <1>         mov     al,ah
   415 00001656 30E4                <1>         xor     ah,ah
   416 00001658 87CE                <1>         xchg    cx,si           ;restore the exchanged registers
   417 0000165A 87DF                <1>         xchg    bx,di
   418                              <1> 
   419 0000165C 80E908              <1>         sub     cl,8
   420                              <1> vl64040:
   421 0000165F E30F                <1>         jcxz    vl64090         ;may have been reduced this far
   422 00001661 90                  <1>         even
   423                              <1> vl64050:
   424 00001662 08FB                <1>         or      bl,bh           ;guard into sticky
   425 00001664 D1E8                <1>         shr     ax,1            ;short right shift of 1 bit
   426 00001666 D1DF                <1>         rcr     di,1
   427 00001668 D1DE                <1>         rcr     si,1            ;long extension, right shift 1 bit
   428 0000166A D1DA                <1>         rcr     dx,1
   429 0000166C D0DF                <1>         rcr     bh,1            ;new guard bit
   430 0000166E E2F2                <1>         loop    vl64050
   431                              <1> vl64090:
   432 00001670 80E780              <1>         and     bh,80h          ;isolate the real guard bit
   433 00001673 891E1200            <1>         mov     word [guard_sticky],bx ;set guard and sticky bits
   434 00001677 89F1                <1>         mov     cx,si           ;result goes back in AX:BX:CX:DX
   435 00001679 89FB                <1>         mov     bx,di           ; **
   436 0000167B 5F                  <1>         pop     di              ;restore saved register
   437 0000167C 5E                  <1>         pop     si              ;restore saved register
   438                              <1> vl64099:
   439 0000167D C3                  <1>         ret
   440                              <1> 
   441                              <1> ;vloadsh64  endp
   442                              <1> 
   443                              <1> 
   444                              <1> 
   445                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   446                              <1> ;
   447                              <1> ;   FXTRACT             ST is operand
   448                              <1> ;
   449                              <1> ;       exponent replaces ST and significand is pushed,
   450                              <1> ;       with exponent of true 0
   451                              <1> ;
   452                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   453                              <1> gFXTRACT:
   454 0000167E 30DB                <1>         xor     bl,bl               ;get tos ptr
   455 00001680 E8DBEF              <1>         call    regptr              ;ST pointer to BX
   456 00001683 89DE                <1>         mov     si,bx               ;tos ptr to SI
   457 00001685 E8B0EF              <1>         call    alloc               ;get new ST pointer
   458                              <1> 
   459 00001688 8B04                <1>         mov     ax,[si]             ;move tag and sign
   460 0000168A 8907                <1>         mov     [bx],ax
   461 0000168C C747020000          <1>         mov     word [bx+expon],0        ;zero is final exponent
   462                              <1> 
   463 00001691 8B4404              <1>         mov     ax,[si+mantis]      ;move mantissa
   464 00001694 894704              <1>         mov     [bx+mantis],ax
   465 00001697 8B4406              <1>         mov     ax,[si+mantis+2]
   466 0000169A 894706              <1>         mov     [bx+mantis+2],ax
   467                              <1> %if BIG
   468 0000169D 8B4408              <1>         mov     ax,[si+mantis+4]
   469 000016A0 894708              <1>         mov     [bx+mantis+4],ax
   470 000016A3 8B440A              <1>         mov     ax,[si+mantis+6]
   471 000016A6 89470A              <1>         mov     [bx+mantis+6],ax
   472                              <1> %endif
   473 000016A9 8D7C02              <1>         lea     di,[si+expon]       ; ES:DI points at integer to load
   474 000016AC 1E                  <1>         push    ds                  ; SI points at accumulator to receive
   475 000016AD 07                  <1>         pop     es                  ;     the resulting value
   476 000016AE E86CF0              <1>         call    load_I16            ;
   477 000016B1 E902EB              <1>         jmp     restore_segs
   478                              <1> 
   479                              <1> 
   480                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   481                              <1> ;
   482                              <1> ;   FSCALE          ST(1) is chopped to an integer
   483                              <1> ;                   and added to the exponent of ST(0)
   484                              <1> ;
   485                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   486                              <1> gFSCALE:
   487 000016B4 B301                <1>         mov     bl,1                ;get ST(1)
   488 000016B6 E8A5EF              <1>         call    regptr              ; pointer in BX
   489 000016B9 89DE                <1>         mov     si,bx               ;save pointer in SI
   490                              <1> %if BIG
   491 000016BB B93F00              <1>         mov     cx,63               ;truncate to integer
   492                              <1> %else
   493                              <1>         mov     cx,31               ;truncate to integer
   494                              <1> %endif
   495 000016BE 2B4F02              <1>         sub     cx,word [bx+expon]       ;form number to shift by
   496 000016C1 E817EF              <1>         call    vloadshift          ;get the magnitude
   497                              <1> %if  BIG
   498 000016C4 89C8                <1>         mov     ax,cx               ;magnitude to ax
   499                              <1> %endif
   500 000016C6 F6440101            <1>         test    byte [si+sign],01h       ;test sign of ST(1)
   501 000016CA 7402                <1>         jz      FSC10
   502 000016CC F7D8                <1>         neg     ax                  ;value is negative
   503                              <1> FSC10:
   504 000016CE 30DB                <1>         xor     bl,bl
   505 000016D0 E88BEF              <1>         call    regptr              ;get ST(0) pointer in BX
   506 000016D3 014702              <1>         add     word [bx+expon],ax       ;modify exponent
   507                              <1> 
   508 000016D6 E9DDEA              <1>         jmp     restore_segs
   509                              <1> 
   510                              <1> 
   511                              <1> 
   512                              <1> 
   513                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   514                              <1> ;
   515                              <1> ;   FSTP        QWORD PTR mem
   516                              <1> ;
   517                              <1> ;       ES:DI points at 64 bit integer
   518                              <1> ;
   519                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   520                              <1> FSTPi64:
   521 000016D9 30DB                <1>         xor     bl,bl               ;get ST(0) pointer in BX
   522 000016DB E880EF              <1>         call    regptr              ; **
   523 000016DE 89DE                <1>         mov     si,bx               ;save pointer in SI
   524 000016E0 803F01              <1>         cmp     byte [bx+tag], tag_zero  ;check the tag
   525 000016E3 773E                <1>         ja      STI64160            ;problem tag, store indefinite
   526                              <1> 
   527 000016E5 B93F00              <1>         mov     cx,63               ;get max shift
   528 000016E8 2B4F02              <1>         sub     cx,word [bx+expon]       ;get shift count
   529 000016EB 7E32                <1>         jle     STI64150            ;shift is negative or zero, overflow occurs
   530                              <1> 
   531 000016ED E813FF              <1>         call    vloadsh64           ;get 64 bit mantissa, shifted
   532                              <1> 
   533 000016F0 E8C3FE              <1>         call    round_mag           ;round magnitude according to RC bits
   534                              <1> 
   535 000016F3 807C0100            <1>         cmp     byte [si+sign],0         ;test for minus
   536 000016F7 7412                <1>         je      STI64050
   537                              <1> ; must negate it
   538 000016F9 F7D0                <1>         not     ax
   539 000016FB F7D3                <1>         not     bx
   540 000016FD F7D1                <1>         not     cx
   541 000016FF F7DA                <1>         neg     dx
   542 00001701 F5                  <1>         cmc
   543 00001702 83D100              <1>         adc     cx,0
   544 00001705 83D300              <1>         adc     bx,0
   545 00001708 83D000              <1>         adc     ax,0
   546                              <1> ; ready to store result
   547                              <1> STI64050:
   548 0000170B 26894506            <1>   es    mov     [di+6],ax            ;store high order
   549 0000170F 26895D04            <1>   es    mov     [di+4],bx            ;store lower order
   550 00001713 26894D02            <1>   es    mov     [di+2],cx            ;store third part
   551 00001717 268915              <1>   es    mov     [di],dx              ;store lowest order part
   552                              <1> STI64090:
   553                              <1> ; pop the tos
   554 0000171A 89F3                <1>         mov     bx,si                   ;set BX for pop
   555 0000171C E986EA              <1>         jmp     pop_stack               ; go do pop
   556                              <1> 
   557                              <1> 
   558                              <1> STI64150:   ; exponent too big
   559 0000171F 6A08                <1>         push    Oexcept                 ;overflow
   560 00001721 EB07                <1>         jmp     short STI64170
   561                              <1> 
   562                              <1> STI64160:   ; tag is infin, empty or invalid
   563 00001723 803F02              <1>         cmp     byte [bx+tag], tag_infin     ;test for infinity
   564 00001726 74F7                <1>         je      STI64150                ;signal overflow
   565                              <1> 
   566 00001728 6A01                <1>         push    Iexcept                 ;invalid operation
   567                              <1> 
   568                              <1> STI64170:   ;general problem exit, signal exception & store indefinite
   569 0000172A E8C404              <1>         call    exception
   570 0000172D 26C745060080        <1>   es    mov     word [di+6],8000h         ;integer indefinite
   571 00001733 31C0                <1>         xor     ax,ax
   572 00001735 26894504            <1>   es    mov     [di+4],ax
   573 00001739 26894502            <1>   es    mov     [di+2],ax
   574 0000173D 268905              <1>   es    mov     [di],ax
   575 00001740 EBD8                <1>         jmp     STI64090                ;go pop and exit
   576                              <1> 
   577                              <1> 
   578                              <1> 
   579                              <1> ; end em187g.asm
   524                                  %include "em187h.asm"
     1                              <1> ; em187h.asm
     2                              <1> 
     3                              <1> 
     4                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     5                              <1> ;
     6                              <1> ;   FLD     tmpReal         load 10-byte real
     7                              <1> ;
     8                              <1> ;       ES:DI points at memory location
     9                              <1> ;
    10                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    11                              <1> FLDtmp:
    12 00001742 E8F3EE              <1>         call    alloc               ;get ST pointer in BX
    13 00001745 268B4508            <1>   es    mov     ax,[di+8]        ;get sign and exponent
    14 00001749 31D2                <1>         xor     dx,dx               ;clear DX
    15 0000174B D1E0                <1>         shl     ax,1                ;sign to carry
    16 0000174D D0D2                <1>         rcl     dl,1                ;sign to DL
    17 0000174F 885701              <1>         mov     byte [bx+sign],dl        ;store sign
    18 00001752 C60700              <1>         mov     byte [bx+tag], tag_valid ;set up valid tag
    19                              <1> 
    20 00001755 D1E8                <1>         shr     ax,1                ;biased exponent to AX
    21 00001757 3DFF7F              <1>         cmp     ax,7FFFh            ;check for infinity
    22 0000175A 7428                <1>         je      LT100               ;it may be
    23 0000175C 09C0                <1>         or      ax,ax               ;test for 0
    24 0000175E 744B                <1>         jz      LT150               ;may be a DeNormal or zero
    25 00001760 2DFF3F              <1>         sub     ax,3FFFh            ;get true exponent
    26                              <1> LT010:
    27 00001763 894702              <1>         mov     word [bx+expon],ax
    28 00001766 268B4506            <1>   es    mov     ax,[di+6]        ;get high mantissa
    29 0000176A 894704              <1>         mov     [bx+mantis],ax
    30 0000176D 268B4504            <1>   es    mov     ax,[di+4]        ;get second mantissa
    31 00001771 894706              <1>         mov     [bx+mantis+2],ax
    32                              <1> %if BIG
    33 00001774 268B4502            <1>   es    mov     ax,[di+2]        ;get third mantissa
    34 00001778 894708              <1>         mov     [bx+mantis+4],ax
    35 0000177B 268B05              <1>   es    mov     ax,[di]          ;get lowest mantissa
    36 0000177E 89470A              <1>         mov     [bx+mantis+6],ax
    37                              <1> %endif
    38                              <1> LT099:
    39 00001781 E932EA              <1>         jmp     restore_segs
    40                              <1> 
    41                              <1> LT100:      ;check for possible infinity
    42 00001784 26817D060080        <1>   es    cmp     word [di+6],8000h     ;check for infinity
    43 0000178A 7512                <1>         jne     LT120
    44 0000178C 268B5504            <1>   es    mov     dx,[di+4]        ;rest must be zero
    45 00001790 260B5502            <1>   es    or      dx,[di+2]        ;
    46 00001794 260B15              <1>   es    or      dx,[di]
    47 00001797 7505                <1>         jnz     LT120
    48 00001799 C60702              <1>         mov     byte [bx+tag], tag_infin
    49                              <1> ;       mov     ax,exp_of_FPinf
    50 0000179C EBC5                <1>         jmp     LT010               ;copy rest of mantissa
    51 0000179E C60706              <1> LT120:  mov     byte [bx+tag], tag_invalid
    52 000017A1 6A01                <1>         push    Iexcept             ;invalid operation
    53 000017A3 E84B04              <1>         call    exception
    54 000017A6 B8FF7F              <1>         mov     ax,exp_of_FPinf
    55 000017A9 EBB8                <1>         jmp     LT010               ;copy rest of mantissa        
    56                              <1> 
    57                              <1> LT150:      ;possible zero or denormal
    58 000017AB 268B5506            <1>   es    mov     dx,[di+6]        ;get high part of mantissa
    59 000017AF 260B5504            <1>   es    or      dx,[di+4]        ;rest must be zero
    60 000017B3 260B5502            <1>   es    or      dx,[di+2]        ;
    61 000017B7 260B15              <1>   es    or      dx,[di]
    62 000017BA B80180              <1>         mov     ax,exp_of_FPzero    ;get exponent of zero
    63 000017BD C60701              <1>         mov     byte [bx+tag], tag_zero
    64 000017C0 74A1                <1>         jz      LT010
    65                              <1> 
    66 000017C2 6A02                <1>         push    Dexcept             ;we don't try to normalize it
    67 000017C4 E82A04              <1>         call    exception
    68 000017C7 EBD5                <1>         jmp     LT120
    69                              <1> 
    70                              <1> 
    71                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    72                              <1> ;
    73                              <1> ;   FSTP    tmpReal         store 10-byte real
    74                              <1> ;
    75                              <1> ;       ES:DI points at memory location
    76                              <1> ;
    77                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    78                              <1> FSTPtmp:
    79 000017C9 30DB                <1>         xor     bl,bl               ;get ST(0) pointer to BX
    80 000017CB E890EE              <1>         call    regptr              ; **
    81 000017CE 8A5701              <1>         mov     dl,byte [bx+sign]        ;get sign
    82 000017D1 D0CA                <1>         ror     dl,1                ;sign to hi bit of DL
    83 000017D3 803F01              <1>         cmp     byte [bx+tag], tag_zero  ;
    84 000017D6 7342                <1>         jae     STP100              ;may be zero or problem
    85 000017D8 8B4702              <1>         mov     ax,word [bx+expon]       ;get exponent
    86 000017DB 2D01C0              <1>         sub     ax,-16383           ;bias it
    87 000017DE 7C29                <1>         jl      STP095              ;too small
    88 000017E0 3DFF7F              <1>         cmp     ax,7FFFh            ;check for too big
    89 000017E3 732B                <1>         jae     STP097              ;too big
    90 000017E5 08D4                <1>         or      ah,dl               ;sign bit to AH
    91 000017E7 26894508            <1>   es    mov     [di+8],ax        ;store sign and exponent
    92                              <1> 
    93 000017EB 8B4704              <1>         mov     ax,[bx+mantis]
    94 000017EE 26894506            <1>   es    mov     [di+6],ax        ;store mantissa
    95 000017F2 8B4706              <1>         mov     ax,[bx+mantis+2]
    96 000017F5 26894504            <1>   es    mov     [di+4],ax
    97                              <1> %if BIG
    98 000017F9 8B4708              <1>         mov     ax,[bx+mantis+4]
    99 000017FC 26894502            <1>   es    mov     [di+2],ax
   100 00001800 8B470A              <1>         mov     ax,[bx+mantis+6]
   101 00001803 268905              <1>   es    mov     [di],ax
   102                              <1> %else
   103                              <1>         xor     ax,ax
   104                              <1>   es    mov     [di+2],ax
   105                              <1>   es    mov     [di],ax
   106                              <1> %endif
   107                              <1> STP090:
   108 00001806 E99CE9              <1>         jmp     pop_stack           ;BX is set ok
   109                              <1> 
   110                              <1> STP095:
   111 00001809 6A10                <1>         push    Uexcept             ;underflow
   112 0000180B E8E303              <1>         call    exception           ;
   113 0000180E EB0C                <1>         jmp     short STP105        ;store zero
   114                              <1> STP097:
   115 00001810 6A08                <1>         push    Oexcept             ;overflow
   116 00001812 E8DC03              <1>         call    exception
   117 00001815 B8FF7F              <1>         mov     ax,7FFFh            ;get largest exponent
   118 00001818 EB25                <1>         jmp     short STP160
   119                              <1> 
   120                              <1> 
   121                              <1> ; tag is .ge. tag_zero
   122                              <1> STP100:
   123 0000181A 771B                <1>         ja      STP150                  ;jump if problem
   124                              <1> ; tag is zero
   125                              <1> STP105:
   126 0000181C 31C0                <1>         xor     ax,ax
   127 0000181E 88D4                <1>         mov     ah,dl                   ;sign it
   128 00001820 26894508            <1>   es    mov     [di+8],ax            ;store signed zero
   129 00001824 30E4                <1>         xor     ah,ah
   130 00001826 26894506            <1>   es    mov     [di+6],ax
   131                              <1> STP130:
   132 0000182A 26894504            <1>   es    mov     [di+4],ax
   133 0000182E 26894502            <1>   es    mov     [di+2],ax
   134 00001832 268905              <1>   es    mov     [di],ax
   135 00001835 EBCF                <1>         jmp     STP090
   136                              <1> STP150:
   137 00001837 B8FF7F              <1>         mov     ax,7FFFH                ;get biased infinity exponent
   138 0000183A 803F02              <1>         cmp     byte [bx+tag], tag_infin     ;check for infinity
   139 0000183D 7510                <1>         jne     STP180
   140                              <1> STP160:
   141 0000183F 08D4                <1>         or      ah,dl                   ;sign the infinity
   142 00001841 26894508            <1>   es    mov     [di+8],ax            ;store sign and exponent
   143 00001845 26C745060080        <1>   es    mov     word [di+6],8000h         ;mantissa of infinity
   144                              <1> STP175:
   145 0000184B 31C0                <1>         xor     ax,ax
   146 0000184D EBDB                <1>         jmp     STP130                  ;store rest of mantissa
   147                              <1> STP180:
   148 0000184F 6A01                <1>         push    Iexcept                 ;tag is empty, or invalid
   149 00001851 E89D03              <1>         call    exception
   150 00001854 26C74508FFFF        <1>   es    mov     word [di+8],0FFFFh        ;store indefinite
   151 0000185A 26C7450600C0        <1>   es    mov     word [di+6],0C000h        ; **
   152 00001860 EBE9                <1>         jmp     STP175
   153                              <1> 
   154                              <1>         even
   155                              <1> %if BIG
   156                              <1> rndCon:
   157                              <1> ;	ACCUM   <tag_valid, 0, 0, 3FFFh, 0FFFFh, 0FFFFh, 0FFFFh>
   158 00001862 0000                <1> 	db	tag_valid, 0
   159 00001864 0000FF3FFFFFFFFFFF- <1> 	dw	0, 3FFFh, 0FFFFh, 0FFFFh, 0FFFFh
   159 0000186D FF                  <1>
   160                              <1> %else
   161                              <1> rndCon:
   162                              <1> ;	ACCUM   <tag_valid, 0, 0, 3FFFh, 0FFFFh>
   163                              <1> 	db	tag_valid, 0
   164                              <1> 	dw	0, 3FFFh, 0FFFFh
   165                              <1> %endif
   166                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   167                              <1> ;
   168                              <1> ;   FRNDINT             round ST to integer according
   169                              <1> ;                       to rounding control
   170                              <1> ;
   171                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   172                              <1> gFRNDINT:
   173 0000186E 30DB                <1>         xor     bl,bl                   ;get pointer to ST in BX
   174 00001870 E8EBED              <1>         call    regptr                  ; **
   175 00001873 803F01              <1>         cmp     byte [bx+tag], tag_zero      ;test the tag
   176 00001876 7431                <1>         je      RND100
   177 00001878 7732                <1>         ja      RND120
   178                              <1> 
   179                              <1> %if BIG
   180 0000187A B93F00              <1>         mov     cx,63               ;get max exponent
   181                              <1> %else
   182                              <1>         mov     cx,31               ;get max exponent
   183                              <1> %endif
   184 0000187D 2B4F02              <1>         sub     cx,word [bx+expon]       ;form shift count
   185 00001880 7E27                <1>         jle     RND100              ;already an integer
   186                              <1> %if BIG
   187                              <1> %else
   188                              <1>         add     cx,32               ;increase shift count
   189                              <1> %endif
   190 00001882 89DE                <1>         mov     si,bx               ;SI is destination pointer
   191 00001884 E87CFD              <1>         call    vloadsh64           ;integerize & compute guard & sticky
   192 00001887 E82CFD              <1>         call    round_mag           ;round magnitude
   193                              <1> %if BIG
   194 0000188A BF3F00              <1>         mov     di,63               ;get max exponent
   195                              <1> %else
   196                              <1>         mov     di,31               ;get smaller exponent
   197                              <1>         mov     ax,cx               ;shift by 32 bits
   198                              <1>         mov     bx,dx               ; **
   199                              <1> %endif
   200 0000188D 68[B601]            <1>         push    restore_segs
   201 00001890 E9C7EE              <1>         jmp     normalize_and_exit
   202                              <1> 
   203                              <1> 
   204                              <1> 
   205                              <1> ;
   206                              <1> ; exponent is small, return zero
   207                              <1> RND050:
   208 00001893 31C0                <1>         xor     ax,ax                   ;get zero
   209 00001895 C60701              <1>         mov     byte [bx+tag], tag_zero      ;set new tag
   210 00001898 C747020180          <1>         mov     word [bx+expon],exp_of_FPzero    ;set special exponent
   211 0000189D 894704              <1>         mov     [bx+mantis],ax          ;set mantissa
   212 000018A0 894706              <1>         mov     [bx+mantis+2],ax        ; **
   213                              <1> %if BIG
   214 000018A3 894708              <1>         mov     [bx+mantis+4],ax        ;  **
   215 000018A6 89470A              <1>         mov     [bx+mantis+6],ax        ;   **
   216                              <1> %endif
   217                              <1> RND100:
   218 000018A9 E90AE9              <1>         jmp     restore_segs        ;major exit point
   219                              <1> 
   220                              <1> 
   221                              <1> ; tag is infinity or above
   222                              <1> RND120:
   223 000018AC 803F02              <1>         cmp     byte [bx+tag],tag_infin      ;test for infinity
   224 000018AF 74F8                <1>         je      RND100
   225                              <1> 
   226 000018B1 6A01                <1>         push    Iexcept                 ;invalid operation
   227 000018B3 E83B03              <1>         call    exception
   228 000018B6 EBF1                <1>         jmp     RND100
   229                              <1> 
   230                              <1> 
   231                              <1> 
   232                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   233                              <1> ;
   234                              <1> ;   FSQRT           square root of stack top
   235                              <1> ;
   236                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   237                              <1> gFSQRT:
   238 000018B8 30DB                <1>         xor     bl,bl           ;get ST(0) pointer in BX
   239 000018BA E8A1ED              <1>         call    regptr          ; **
   240 000018BD 803F01              <1>         cmp     byte [bx+tag], tag_zero  ;test for unusual tags
   241 000018C0 736A                <1>         jae      SQ100           ;skip if okay
   242                              <1> ; tag is valid
   243 000018C2 807F0100            <1>         cmp     byte [bx+sign],0
   244 000018C6 7573                <1>         jne     SQ110           ;SQRT of neg. is indefinite        
   245                              <1> 
   246 000018C8 8B4702              <1>         mov     ax,word [bx+expon]   ;get exponent of argument
   247 000018CB 8B5704              <1>         mov     dx,[bx+mantis]  ;get high order mantissa
   248 000018CE D1C2                <1>         rol     dx,1            ;rotate mantissa
   249 000018D0 D1F8                <1>         sar     ax,1            ;divide exponent by 2, odd bit to carry
   250 000018D2 D1DA                <1>         rcr     dx,1            ;odd bit to high DX
   251 000018D4 D1DA                <1>         rcr     dx,1            ;normal 1 bit to high DX
   252 000018D6 A32E00              <1>         mov     [Areg+expon],ax   ;Areg is initial guess
   253 000018D9 89163000            <1>         mov     [Areg+mantis],dx  ; **
   254 000018DD 31C0                <1>         xor     ax,ax
   255 000018DF A32C00              <1>         mov     word [Areg],ax ;clear sign and tag (+, valid)
   256 000018E2 A33200              <1>         mov     [Areg+mantis+2],ax
   257                              <1> %if BIG
   258 000018E5 A33400              <1>         mov     [Areg+mantis+4],ax
   259 000018E8 A33600              <1>         mov     [Areg+mantis+6],ax
   260                              <1> %endif
   261                              <1> 
   262 000018EB 891E1600            <1>         mov     word [trptr],bx         ;save ST pointer
   263 000018EF BE2C00              <1>         mov     si,Areg
   264                              <1> %if BIG
   265 000018F2 C6061B0003          <1>         mov     byte [trctr],3           ;iterate 4 times with 64-bit mantissa
   266                              <1> %else
   267                              <1>         mov     byte [trctr],2           ;iterate 3 times with 32-bit mantissa
   268                              <1> %endif
   269                              <1> SQ040:
   270 000018F7 8B3E1600            <1>         mov     di,word [trptr]
   271 000018FB BB3800              <1>         mov     bx,Breg
   272 000018FE E84CF9              <1>         call    do_div          ;arg/guess --> temp
   273                              <1> 
   274 00001901 BF2C00              <1>         mov     di,Areg  ;
   275 00001904 89FB                <1>         mov     bx,di
   276 00001906 E896EA              <1>         call    do_add          ; Areg is new guess * 2
   277                              <1> ; SI points at Areg
   278 00001909 FF4C02              <1>         dec     word [si+expon]      ;divide by 2
   279 0000190C FE0E1B00            <1>         dec     byte [trctr]
   280 00001910 75E5                <1>         jnz     SQ040
   281                              <1> 
   282                              <1> ; last iteration has ST as final destination
   283 00001912 8B3E1600            <1>         mov     di,word [trptr]
   284 00001916 BB3800              <1>         mov     bx,Breg
   285 00001919 E831F9              <1>         call    do_div          ;arg/guess --> temp
   286                              <1> 
   287 0000191C BF2C00              <1>         mov     di,Areg  ;
   288 0000191F 8B1E1600            <1>         mov     bx,word [trptr]         ;ST is final destination
   289 00001923 E879EA              <1>         call    do_add          ; Areg is new guess * 2
   290                              <1> ; SI points at ST
   291 00001926 FF4C02              <1>         dec     word [si+expon]      ;divide by 2
   292                              <1> 
   293                              <1> SQ099:
   294 00001929 E98AE8              <1>         jmp     restore_segs
   295                              <1> 
   296                              <1> SQ100:
   297 0000192C 74FB                <1>         je      SQ099               ;+/- 0.0  -->  +/- 0.0
   298 0000192E 803F02              <1>         cmp     byte [bx+tag], tag_infin ;check for an infinity
   299 00001931 7508                <1>         jne     SQ110
   300 00001933 807F0100            <1>         cmp     byte [bx+sign],0
   301 00001937 7502                <1>         jne     SQ110                   ;-inf --> indefinite
   302 00001939 EBEE                <1>         jmp     SQ099                   ;+inf --> +inf
   303                              <1> SQ110:
   304 0000193B C60706              <1>         mov     byte [bx+tag], tag_invalid ;
   305 0000193E 680102              <1>         push    errSqrt+Iexcept
   306 00001941 E8AD02              <1>         call    exception
   307 00001944 EBE3                <1>         jmp     SQ099
   308                              <1> 
   309                              <1> 
   310                              <1> 
   311                              <1> 
   312                              <1> ;
   313                              <1> ; handle FPREM errors here
   314                              <1> ;
   315                              <1> FR200:      ;divisor is zero or otherwise bad
   316 00001946 6A04                <1>         push    Zexcept
   317 00001948 E8A602              <1>         call    exception
   318                              <1> FR300:      ;dividend is infin, empty, or invalid
   319 0000194B 6A01                <1>         push    Iexcept
   320 0000194D E8A102              <1>         call    exception
   321 00001950 C60406              <1>         mov     byte [si+tag], tag_invalid
   322                              <1> FR085:
   323 00001953 80260300B8          <1>         and     byte [codes], ~(C3+C2+C1+C0) ;clear condition codes
   324 00001958 E95BE8              <1>         jmp     restore_segs
   325                              <1> 
   326                              <1> 
   327                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   328                              <1> ;
   329                              <1> ;   FPREM           remainder of ST / ST(1)
   330                              <1> ;
   331                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   332                              <1> gFPREM:
   333 0000195B 30DB                <1>         xor     bl,bl               ;get ST(0) pointer
   334 0000195D E8FEEC              <1>         call    regptr              ; in BX
   335 00001960 89DE                <1>         mov     si,bx               ;save ST pointer in SI
   336                              <1> 
   337 00001962 B301                <1>         mov     bl, 1               ;get ST(1) pointer
   338 00001964 E8F7EC              <1>         call    regptr              ; in BX
   339 00001967 89DF                <1>         mov     di,bx               ;save ST(1) pointer in DI
   340                              <1> 
   341 00001969 803D01              <1>         cmp     byte [di+tag], tag_zero  ;test tag of divisor
   342 0000196C 73D8                <1>         jae     FR200               ; divisor is bad
   343 0000196E 803C01              <1>         cmp     byte [si+tag], tag_zero  ;test tag of dividend
   344 00001971 77D8                <1>         ja      FR300               ; dividend is funny
   345                              <1> ; both tags are valid
   346 00001973 C6061A0000          <1>         mov     byte [ctr],0               ;zero the divide counter
   347 00001978 8B4C02              <1>         mov     cx,word [si+expon]       ;get exponent of dividend
   348 0000197B 8B4502              <1>         mov     ax,word [di+expon]       ;get exponent of divisor
   349 0000197E 29C1                <1>         sub     cx,ax               ;get difference E.dividend - E.divisor
   350 00001980 7CD1                <1>         jl      FR085               ;dividend exponent is less than divisor
   351 00001982 894402              <1>         mov     word [si+expon],ax       ;dividend exponent is updated
   352                              <1> 
   353 00001985 8B4404              <1>         mov     ax,[si+mantis]      ;get dividend in AX:BX[:BP:SI]
   354 00001988 8B5C06              <1>         mov     bx,[si+mantis+2]
   355                              <1> %if BIG
   356 0000198B 8B6C08              <1>         mov     bp,[si+mantis+4]    ; **
   357 0000198E 56                  <1>         push    si                  ;save SI
   358 0000198F 8B740A              <1>         mov     si,[si+mantis+6]
   359                              <1> %endif
   360 00001992 8B5504              <1>         mov     dx,[di+mantis]      ;get divisor in DX:mem[:mem:mem]
   361 00001995 41                  <1>         inc     cx
   362 00001996 EB0E                <1>         jmp     short FR004         ;go do the compare
   363                              <1> 
   364                              <1> FR003:
   365 00001998 D0261A00            <1>         shl     byte [ctr],1               ;shift the counter
   366                              <1> %if BIG
   367 0000199C D1E6                <1>         shl     si,1                ;left shift of the dividend
   368 0000199E D1D5                <1>         rcl     bp,1                ; **
   369 000019A0 D1D3                <1>         rcl     bx,1                ;
   370                              <1> %else
   371                              <1>         shl     bx,1                ; start of short shift
   372                              <1> %endif
   373 000019A2 D1D0                <1>         rcl     ax,1                ;final shift of dividend
   374 000019A4 7219                <1>         jc      FR005               ;dividend is considered greater if CF=1
   375                              <1> FR004:
   376 000019A6 39D0                <1>         cmp     ax,dx               ;compare dividend to divisor
   377 000019A8 7715                <1>         ja      FR005
   378 000019AA 7222                <1>         jb      FR007
   379 000019AC 3B5D06              <1>         cmp     bx,[di+mantis+2]    ;compare
   380                              <1> %if BIG
   381 000019AF 770E                <1>         ja      FR005
   382 000019B1 721B                <1>         jb      FR007
   383 000019B3 3B6D08              <1>         cmp     bp,[di+mantis+4]    ;compare
   384 000019B6 7707                <1>         ja      FR005
   385 000019B8 7214                <1>         jb      FR007
   386 000019BA 3B750A              <1>         cmp     si,[di+mantis+6]    ;compare
   387                              <1> %endif
   388 000019BD 720F                <1>         jb      FR007
   389                              <1> FR005:
   390                              <1> %if BIG
   391 000019BF 2B750A              <1>         sub     si,[di+mantis+6]    ;subtract
   392 000019C2 1B6D08              <1>         sbb     bp,[di+mantis+4]
   393 000019C5 1B5D06              <1>         sbb     bx,[di+mantis+2]
   394                              <1> %else
   395                              <1>         sub     bx,[di+mantis+2]
   396                              <1> %endif
   397 000019C8 19D0                <1>         sbb     ax,dx               ;finish the subtract
   398 000019CA FE061A00            <1>         inc     byte [ctr]                 ;count the subtraction
   399                              <1> FR007:
   400 000019CE E2C8                <1>         loop    FR003
   401                              <1> 
   402                              <1> %if BIG
   403 000019D0 89F2                <1>         mov     dx,si
   404 000019D2 5E                  <1>         pop     si                  ;restore saved destination pointer
   405                              <1> %endif
   406 000019D3 8A0E1A00            <1>         mov     cl,byte [ctr]              ;get quotient bits
   407                              <1> ;;;        cmp     byte [si+sign],0
   408                              <1> ;;;        je      FR050
   409                              <1> ;;;        neg     cl
   410                              <1> FR050:
   411 000019D7 80E107              <1>         and     cl,7                ;mask to 3 bits
   412 000019DA D0E9                <1>         shr     cl,1                ;1's bit to carry
   413 000019DC D0D5                <1>         rcl     ch,1                ;1's bit in b0 of CH
   414 000019DE D0C9                <1>         ror     cl,1                ;4's bit in b0 of CL
   415 000019E0 D0E9                <1>         shr     cl,1                ;4's bit in carry, 2's bit in position
   416 000019E2 D0D5                <1>         rcl     ch,1                ;1's bit in b1, 4's bit in b0 of CH
   417 000019E4 08CD                <1>         or      ch,cl               ;CH is flag byte
   418 000019E6 80260300B8          <1>         and     byte [codes], ~(C3+C2+C1+C0) ;clear condition codes
   419 000019EB 082E0300            <1>         or      byte [codes],ch            ;set codes as appropriate
   420                              <1> 
   421                              <1> %if BIG
   422 000019EF 89E9                <1>         mov     cx,bp
   423                              <1> %endif
   424 000019F1 8B7C02              <1>         mov     di,word [si+expon]       ;get saved exponent
   425                              <1> 
   426 000019F4 68[B601]            <1>         push    restore_segs
   427 000019F7 E960ED              <1>         jmp     normalize_and_exit
   428                              <1> 
   429                              <1> 
   430                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;
   431                              <1> ;
   432                              <1> ;   moveconsts -- move constants to data segment
   433                              <1> ;
   434                              <1> ;   Enter with:
   435                              <1> ;       ES already points at data segment
   436                              <1> ;       SI points at code segment offset from which to move
   437                              <1> ;       CX contains the WORD count to move
   438                              <1> ;
   439                              <1> ;   Return with:
   440                              <1> ;       ES and DS intact
   441                              <1> ;       AX, DX, CX, SI, DI are trashed
   442                              <1> ;       'trptr' points at first constant in Creg
   443                              <1> ;
   444                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;
   445                              <1> moveconsts:	;	  proc    near
   446 000019FA BFA400              <1>         mov     di,Creg  ;destination offset
   447 000019FD 893E1600            <1>         mov     word [trptr],di        ;set for return
   448                              <1> 
   449 00001A01 8CC8                <1>         mov     ax,cs           ;source will be code segment
   450 00001A03 8CDA                <1>         mov     dx,ds           ;save DS in DX
   451 00001A05 8ED8                <1>         mov     ds,ax           ;set up DS for source DS:SI
   452 00001A07 F3A5                <1>     rep     movsw
   453 00001A09 8EDA                <1>         mov     ds,dx           ;restore DS
   454                              <1> 
   455 00001A0B C3                  <1>         ret
   456                              <1> ;moveconsts  endp
   457                              <1> 
   458                              <1> 
   459                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   460                              <1> ;
   461                              <1> ;   FSTENV   mem         ; store Environment
   462                              <1> ;
   463                              <1> ;       ES:DI is the destination address
   464                              <1> ;		of a 14 byte storage area
   465                              <1> ;
   466                              <1> ;	         ; 001 110       14 bytes
   467                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   468                              <1> ;*** gFSTENV:
   469 00001A0C A10000              <1> 	mov	ax,[Control]	; get the full Control word
   470 00001A0F AB                  <1> 	stosw
   471                              <1> 
   472 00001A10 A10200              <1> 	mov	ax,[Status]	; get status word with no TOS
   473 00001A13 8A3E1000            <1> 	mov	bh,[tos]	; get TOS bits
   474 00001A17 C0E703              <1> 	shl	bh,3		; shift to position
   475 00001A1A 30E7                <1> 	xor	bh,ah
   476 00001A1C 80E738              <1> 	and	bh,00111000b
   477 00001A1F 30FC                <1> 	xor	ah,bh		; store the TOS bits
   478 00001A21 AB                  <1> 	stosw
   479 00001A22 BBA400              <1> 	mov	bx,fp7+lenAccum		; address FPAC 7+1
   480                              <1> .1:
   481 00001A25 83EB0C              <1> 	sub	bx,lenAccum	; start at fp(7)
   482 00001A28 8A0F                <1> 	mov	cl,[bx+tag]	; get tag word
   483 00001A2A 80E103              <1> 	and	cl,3		; mask to 2 bits (insurance)
   484 00001A2D D1E0                <1> 	shl	ax,1
   485 00001A2F D1E0                <1> 	shl	ax,1		; make room in AX
   486 00001A31 08C8                <1> 	or	al,cl
   487 00001A33 83FB44              <1> 	cmp	bx,fp0		; done with all of them
   488 00001A36 75ED                <1> 	jne	.1
   489 00001A38 AB                  <1> 	stosw			; store the composed tag word
   490                              <1> 
   491 00001A39 BE0400              <1> 	mov	si,save_ip	; DS:SI points at words to save
   492 00001A3C A5                  <1> 	movsw		; store IP
   493 00001A3D A5                  <1> 	movsw		; store CS
   494 00001A3E A5                  <1> 	movsw		; store data offset
   495 00001A3F A5                  <1> 	movsw		; store data SEG
   496                              <1> 
   497 00001A40 E973E7              <1>         jmp     restore_segs
   498                              <1> 
   499                              <1> 
   500                              <1> 
   501                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   502                              <1> ;
   503                              <1> ;   FLDENV   mem         ; store Environment
   504                              <1> ;
   505                              <1> ;       ES:DI is the destination address
   506                              <1> ;		of a 14 byte storage area
   507                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   508                              <1> ;*** gFLDENV:         ; 001 100       14 bytes
   509 00001A43 E970E7              <1>         jmp     restore_segs
   510                              <1> 
   511                              <1>      
   512                              <1> 	
   513                              <1> ; end em187h.asm
   525                                  
   526                                  
   527                                  	even
   528                                  %if BIG
   529                                  patanCon:
   530                                  ;	ACCUM   <tag_valid, 0, -2, 08930H, 0a2f4H, 0f66aH, 0b18aH>	; T1=tan(15deg.)
   531 00001A46 0000                    	db	tag_valid, 0
   532 00001A48 FEFF3089F4A26AF68A-     	dw	-2, 08930H, 0a2f4H, 0f66aH, 0b18aH	; T1=tan(15deg.)
   532 00001A51 B1                 
   533                                  ;	ACCUM   <tag_valid, 0, -1, 0860aH, 091c1H, 06b9bH, 02c23H>	; pi/6
   534 00001A52 0000                    	db	tag_valid, 0
   535 00001A54 FFFF0A86C1919B6B23-     	dw	-1, 0860aH, 091c1H, 06b9bH, 02c23H	; pi/6
   535 00001A5D 2C                 
   536                                  ;	ACCUM   <tag_valid, 0,  0, 0ddb3H, 0d742H, 0c265H, 0539eH>	; sqrt(3)
   537 00001A5E 0000                    	db	tag_valid, 0
   538 00001A60 0000B3DD42D765C29E-     	dw	 0, 0ddb3H, 0d742H, 0c265H, 0539eH	; sqrt(3)
   538 00001A69 53                 
   539                                  ;	ACCUM   <tag_valid, 1,  0, 08000H, 0H, 0H, 0H>			; -1
   540 00001A6A 0001                    	db	tag_valid, 1
   541 00001A6C 000000800000000000-     	dw	 0, 08000H, 0H, 0H, 0H			; -1
   541 00001A75 00                 
   542                                  ;	ACCUM	<tag_valid, 0, -5, 08d3dH, 0cb08H, 0d3dcH, 0b08dH>	; c14
   543 00001A76 0000                    	db	tag_valid, 0
   544 00001A78 FBFF3D8D08CBDCD38D-     	dw	-5, 08d3dH, 0cb08H, 0d3dcH, 0b08dH	; c14
   544 00001A81 B0                 
   545                                  ;	ACCUM	<tag_valid, 0, -5, 097b4H, 025edH, 0097bH, 0425fH>	; c13
   546 00001A82 0000                    	db	tag_valid, 0
   547 00001A84 FBFFB497ED257B095F-     	dw	-5, 097b4H, 025edH, 0097bH, 0425fH	; c13
   547 00001A8D 42                 
   548                                  ;	ACCUM	<tag_valid, 0, -5, 0a3d7H, 00a3dH, 070a3H, 0d70aH>	; c12
   549 00001A8E 0000                    	db	tag_valid, 0
   550 00001A90 FBFFD7A33D0AA3700A-     	dw	-5, 0a3d7H, 00a3dH, 070a3H, 0d70aH	; c12
   550 00001A99 D7                 
   551                                  ;	ACCUM	<tag_valid, 0, -5, 0b216H, 042c8H, 0590bH, 02164H>	; c11
   552 00001A9A 0000                    	db	tag_valid, 0
   553 00001A9C FBFF16B2C8420B5964-     	dw	-5, 0b216H, 042c8H, 0590bH, 02164H	; c11
   553 00001AA5 21                 
   554                                  ;	ACCUM	<tag_valid, 0, -5, 0c30cH, 030c3H, 00c30H, 0c30cH>	; c10
   555 00001AA6 0000                    	db	tag_valid, 0
   556 00001AA8 FBFF0CC3C330300C0C-     	dw	-5, 0c30cH, 030c3H, 00c30H, 0c30cH	; c10
   556 00001AB1 C3                 
   557                                  ;	ACCUM	<tag_valid, 0, -5, 0d794H, 035e5H, 00d79H, 0435eH>	; c09
   558 00001AB2 0000                    	db	tag_valid, 0
   559 00001AB4 FBFF94D7E535790D5E-     	dw	-5, 0d794H, 035e5H, 00d79H, 0435eH	; c09
   559 00001ABD 43                 
   560                                  ;	ACCUM	<tag_valid, 0, -5, 0f0f0H, 0f0f0H, 0f0f0H, 0f0f1H>	; c08
   561 00001ABE 0000                    	db	tag_valid, 0
   562 00001AC0 FBFFF0F0F0F0F0F0F1-     	dw	-5, 0f0f0H, 0f0f0H, 0f0f0H, 0f0f1H	; c08
   562 00001AC9 F0                 
   563                                  ;	ACCUM	<tag_valid, 0, -4, 08888H, 08888H, 08888H, 08889H>	; c07
   564 00001ACA 0000                    	db	tag_valid, 0
   565 00001ACC FCFF88888888888889-     	dw	-4, 08888H, 08888H, 08888H, 08889H	; c07
   565 00001AD5 88                 
   566                                  ;	ACCUM	<tag_valid, 0, -4, 09d89H, 0d89dH, 089d8H, 09d8aH>	; c06
   567 00001AD6 0000                    	db	tag_valid, 0
   568 00001AD8 FCFF899D9DD8D8898A-     	dw	-4, 09d89H, 0d89dH, 089d8H, 09d8aH	; c06
   568 00001AE1 9D                 
   569                                  ;	ACCUM	<tag_valid, 0, -4, 0ba2eH, 08ba2H, 0e8baH, 02e8cH>	; c05
   570 00001AE2 0000                    	db	tag_valid, 0
   571 00001AE4 FCFF2EBAA28BBAE88C-     	dw	-4, 0ba2eH, 08ba2H, 0e8baH, 02e8cH	; c05
   571 00001AED 2E                 
   572                                  ;	ACCUM	<tag_valid, 0, -4, 0e38eH, 038e3H, 08e38H, 0e38eH>	; c04
   573 00001AEE 0000                    	db	tag_valid, 0
   574 00001AF0 FCFF8EE3E338388E8E-     	dw	-4, 0e38eH, 038e3H, 08e38H, 0e38eH	; c04
   574 00001AF9 E3                 
   575                                  ;	ACCUM	<tag_valid, 0, -3, 09249H, 02492H, 04924H, 09249H>	; c03
   576 00001AFA 0000                    	db	tag_valid, 0
   577 00001AFC FDFF49929224244949-     	dw	-3, 09249H, 02492H, 04924H, 09249H	; c03
   577 00001B05 92                 
   578                                  ;	ACCUM	<tag_valid, 0, -3, 0ccccH, 0ccccH, 0ccccH, 0cccdH>	; c02
   579 00001B06 0000                    	db	tag_valid, 0
   580 00001B08 FDFFCCCCCCCCCCCCCD-     	dw	-3, 0ccccH, 0ccccH, 0ccccH, 0cccdH	; c02
   580 00001B11 CC                 
   581                                  ;	ACCUM	<tag_valid, 0, -2, 0aaaaH, 0aaaaH, 0aaaaH, 0aaabH>	; c01
   582 00001B12 0000                    	db	tag_valid, 0
   583 00001B14 FEFFAAAAAAAAAAAAAB-     	dw	-2, 0aaaaH, 0aaaaH, 0aaaaH, 0aaabH	; c01
   583 00001B1D AA                 
   584                                  ;	ACCUM	<tag_valid, 0,  0, 08000H, 0H, 0H, 0H>			; c00
   585 00001B1E 0000                    	db	tag_valid, 0
   586 00001B20 000000800000000000-     	dw	 0, 08000H, 0H, 0H, 0H			; c00
   586 00001B29 00                 
   587                                  %else
   588                                  patanCon:
   589                                  ;       ACCUM   <tag_valid, 0, -2, 08930H, 0a2f5H>	; T1=tan(15deg.)
   590                                  	db	tag_valid, 0
   591                                  	dw	-2, 08930H, 0a2f5H	; T1=tan(15deg.)
   592                                  ;	ACCUM   <tag_valid, 0, -1, 0860aH, 091c1H>	; pi/6
   593                                  	db	tag_valid, 0
   594                                  	dw	-1, 0860aH, 091c1H	; pi/6
   595                                  ;	ACCUM   <tag_valid, 0,  0, 0ddb3H, 0d743H>	; sqrt(3)
   596                                  	db	tag_valid, 0
   597                                  	dw	 0, 0ddb3H, 0d743H	; sqrt(3)
   598                                  ;	ACCUM   <tag_valid, 1,  0, 08000H, 00000H>			; -1
   599                                  	db	tag_valid, 1
   600                                  	dw	 0, 08000H, 00000H			; -1
   601                                  ;;;	ACCUM	<tag_valid, 0, -5, 0f0f0H, 0f0f1H>	; c08
   602                                  ;;;	ACCUM	<tag_valid, 0, -4, 08888H, 08889H>	; c07
   603                                  ;	ACCUM	<tag_valid, 0, -4, 09d89H, 0d89eH>	; c06
   604                                  	db	tag_valid, 0
   605                                  	dw	-4, 09d89H, 0d89eH	; c06
   606                                  ;	ACCUM	<tag_valid, 0, -4, 0ba2eH, 08ba3H>	; c05
   607                                  	db	tag_valid, 0
   608                                  	dw	-4, 0ba2eH, 08ba3H	; c05
   609                                  ;	ACCUM	<tag_valid, 0, -4, 0e38eH, 038e4H>	; c04
   610                                  	db	tag_valid, 0
   611                                  	dw	-4, 0e38eH, 038e4H	; c04
   612                                  ;	ACCUM	<tag_valid, 0, -3, 09249H, 02492H>	; c03
   613                                  	db	tag_valid, 0
   614                                  	dw	-3, 09249H, 02492H	; c03
   615                                  ;	ACCUM	<tag_valid, 0, -3, 0ccccH, 0cccdH>	; c02
   616                                  	db	tag_valid, 0
   617                                  	dw	-3, 0ccccH, 0cccdH	; c02
   618                                  ;	ACCUM	<tag_valid, 0, -2, 0aaaaH, 0aaabH>	; c01
   619                                  	db	tag_valid, 0
   620                                  	dw	-2, 0aaaaH, 0aaabH	; c01
   621                                  ;	ACCUM	<tag_valid, 0,  0, 08000H, 00000H>	; c00
   622                                  	db	tag_valid, 0
   623                                  	dw	 0, 08000H, 00000H	; c00
   624                                  %endif
   625                                  patanConLen 	equ	$-patanCon
   626                                  %if (patanConLen > lenCreg)
   627                                  	%error  not enough constant space in Creg
   628                                  %endif
   629                                  
   630                                  
   631                                  
   632                                  ; ST (X) has problems -- is zero or inf.
   633                                  ;
   634                                  PAT200:
   635                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   636                                  ;
   637                                  ;   FPATAN          8087 partial arctangent
   638                                  ;
   639                                  ;	Compute arctangent (Y / X), where Y is in ST(1) and X is in ST(0).
   640                                  ;
   641                                  ;	Assume  0 <= Y < X < inf.
   642                                  ;
   643                                  ;
   644                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   645                                  gFPATAN:
   646 00001B2A B97200                          mov     cx,patanConLen/2        ;number of words to move
   647                                  ;;;        mov     si,OFFSET patanCon      ;start of constant list
   648 00001B2D BE[461A]                        mov     si,patanCon      ;start of constant list
   649 00001B30 E8C7FE                          call    moveconsts              ;address constants from DS
   650                                  
   651 00001B33 30DB                    	xor	bl,bl			;get pointer to ST
   652 00001B35 E826EB                  	call	regptr			;BX points at X arg
   653 00001B38 89DE                    	mov	si,bx			;SI is divisor
   654 00001B3A B301                    	mov	bl,1			;Y is ST(1)
   655 00001B3C E81FEB                  	call	regptr
   656 00001B3F 89DF                    	mov	di,bx			;DI -> Y, SI -> X
   657 00001B41 E809F7                  	call	do_div			;ST(1) -> Y/X
   658 00001B44 89F3                    	mov	bx,si			;propagate pointer to X arg
   659 00001B46 803C01                  	cmp	byte [si+tag],tag_zero
   660                                  ;	jae	PAT90
   661 00001B49 7203                    	jb	PAT01
   662 00001B4B E98800                  	jmp	PAT90
   663                                  PAT01:
   664                                  ; SI and BX point at X input
   665                                  ;;;	mov	di,offset Creg		;DI is tan(15)
   666 00001B4E BFA400                  	mov	di,Creg			;DI is tan(15)
   667 00001B51 E8CFF7                  	call	do_compare		; compare [DI] : [SI]
   668 00001B54 31F6                    	xor	si,si			;flag Y=0
   669 00001B56 9E                      	sahf				;set flags
   670 00001B57 732C                    	jae	PAT010
   671 00001B59 53                      	push	bx			;save ST(1) pointer
   672 00001B5A 89DE                    	mov	si,bx			;SI -> X
   673                                  ;;;	mov	di,offset Creg + 2 * lenAccum
   674 00001B5C BFBC00                  	mov	di, Creg + 2 * lenAccum
   675                                  ;;;	mov	bx,offset Areg		;destination
   676 00001B5F BB2C00                  	mov	bx, Areg		;destination
   677 00001B62 56                      	push	si
   678 00001B63 57                      	push	di			;save argument pointers
   679 00001B64 E838E8                  	call	do_add			;SI -> X+S3
   680 00001B67 5F                      	pop	di
   681 00001B68 5E                      	pop	si
   682                                  ;;;	mov	bx,offset Breg
   683 00001B69 BB3800                  	mov	bx, Breg
   684 00001B6C E801F5                  	call	do_mul			;SI -> X*S3
   685                                  ;;;	mov	di,offset Creg + 3 * lenAccum	; -1
   686 00001B6F BFC800                  	mov	di, Creg + 3 * lenAccum	; -1
   687 00001B72 89F3                    	mov	bx,si			;Breg is dest
   688 00001B74 E828E8                  	call	do_add
   689 00001B77 89F7                    	mov	di,si			;numerator
   690                                  ;;;	mov	si,offset Areg		;denom.
   691 00001B79 BE2C00                  	mov	si, Areg		;denom.
   692 00001B7C 5B                      	pop	bx			;restore ST(1) pointer
   693 00001B7D E8CDF6                  	call	do_div
   694 00001B80 89F3                    	mov	bx,si
   695                                  ;;;	mov	si,offset Creg + lenAccum	;Y=PI/6
   696 00001B82 BEB000                  	mov	si, Creg + lenAccum	;Y=PI/6
   697                                  PAT010:				; BX is ST(1) pointer
   698 00001B85 89361800                	mov	[trptr2],si		;save pointer to Y param (0 or address)
   699 00001B89 53                      	push	bx			;save ST(1) pointer
   700 00001B8A 89DE                    	mov	si,bx			;set to form X*X
   701 00001B8C 89DF                    	mov	di,bx
   702                                  ;;;	mov	bx,offset Breg		;XX in Breg
   703 00001B8E BB3800                  	mov	bx, Breg		;XX in Breg
   704 00001B91 E8DCF4                  	call	do_mul			;
   705                                  
   706                                  ;;;	mov	si,offset Creg + 4 * lenAccum	;C14/C06 pointer
   707 00001B94 BED400                  	mov	si, Creg + 4 * lenAccum	;C14/C06 pointer
   708 00001B97 89361600                	mov	[trptr],si
   709                                  %if BIG
   710 00001B9B C6061B000E              	mov	byte [trctr],14
   711                                  %else
   712                                  	mov	byte [trctr],6
   713                                  %endif
   714                                  pat020:
   715                                  ;;;	mov	bx,offset Areg		;S in SI
   716 00001BA0 BB2C00                  	mov	bx, Areg		;S in SI
   717                                  ;;;	mov	di,offset Breg		;XX
   718 00001BA3 BF3800                  	mov	di, Breg		;XX
   719 00001BA6 E8C7F4                  	call	do_mul			;SI points at Areg
   720 00001BA9 89F3                    	mov	bx,si
   721 00001BAB 8B3E1600                	mov	di,[trptr]
   722 00001BAF 83C70C                  	add	di,lenAccum
   723 00001BB2 893E1600                	mov	[trptr],di
   724 00001BB6 80740101                	xor	byte [si+sign],1		;change sign of XX*S
   725 00001BBA E8E2E7                  	call	do_add			;SI points at S (Areg)
   726 00001BBD FE0E1B00                	dec	byte [trctr]
   727 00001BC1 75DD                    	jnz	pat020
   728                                  
   729 00001BC3 5B                      	pop	bx			;restore ST(1) pointer
   730 00001BC4 89DF                    	mov	di,bx
   731 00001BC6 E8A7F4                  	call	do_mul
   732 00001BC9 89F3                    	mov	bx,si
   733 00001BCB 8B3E1800                	mov	di,[trptr2]		;get possible Y
   734 00001BCF 09FF                    	or	di,di
   735 00001BD1 7403                    	jz	PAT90
   736 00001BD3 E8C9E7                  	call	do_add			;ST(1) = Y + X*S
   737                                  PAT90:				; BX contains pointer to result
   738 00001BD6 E9C7E5                  	jmp	pop_the_tos		;clear input X from stack top
   739                                  
   740                                  
   741                                  
   742                                  
   743                                  
   744                                  
   745                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   746                                  ; get FPEM_segment -- get data segment pointer to AX and DS
   747                                  ;
   748                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   749                                  ;;;	assume	ds:nothing
   750                                  	global  get_data_segment
   751                                  get_data_segment:	;	proc	near
   752 00001BD9 6A40                    	push	bios_data_seg	; get bios data area pointer
   753 00001BDB 1F                      	pop	ds
   754                                  .out0:
   755 00001BDC A1F000                  	mov	ax,word [FPEM_segment]	; get emulator segment
   756 00001BDF 09C0                    	or	ax,ax		; Allocated yet?
   757 00001BE1 7403                    	jz	.allocate
   758                                  .done:
   759 00001BE3 8ED8                    	mov	ds,ax
   760 00001BE5 C3                      	ret
   761                                  
   762                                  ; Allocate space for the Floating Point Emulator
   763                                  .allocate:
   764                                  %if FPEM_USE_EBDA
   765                                  	mov     ax,[EBDA_paragraph]
   766                                          sub     ax,word EM187_DATA_PARAS
   767                                  	mov     [EBDA_paragraph],ax
   768                                  	mov     [FPEM_segment],ax
   769                                  	shr     ax,6
   770                                  	mov     [memory_size],ax
   771                                  	jmp	.out0
   772                                  %else
   773 00001BE6 B84000                          mov     ax,bios_data_seg
   774 00001BE9 83E819                          sub     ax,word EM187_DATA_PARAS
   775 00001BEC A3F000                  	mov     [FPEM_segment],ax
   776 00001BEF EBF2                    	jmp	.done
   777                                  %endif
   778                                  ;get_data_segment	endp
   779                                  
   780                                  
   781                                  ;;;     assume  ds:EM187_DATA
   782                                  
   783                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   784                                  ;
   785                                  ;   exception -- called from anywhere to signal setting
   786                                  ;               of exception flags.  Test for unmasked exceptions
   787                                  ;               should occur here.
   788                                  ;
   789                                  ;   Calling sequence:
   790                                  ;
   791                                  ;       push    FLAGBITS
   792                                  ;       call    exception
   793                                  ;
   794                                  ;
   795                                  ;   Returns with stack already popped.
   796                                  ;
   797                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   798                                  exception:		;    proc    near
   799 00001BF1 55                              push    bp          ;create standard stack frame
   800 00001BF2 89E5                            mov     bp,sp
   801                                  
   802 00001BF4 50                              push    ax          ;save AX
   803 00001BF5 1E                              push    ds          ;save DS
   804                                  ;;;        mov     ax,seg EM187_DATA   ;get data segment
   805 00001BF6 E8E0FF                  	call	get_data_segment	; to AX and DS
   806                                  ;;;        mov     ds,ax       ;set up DS
   807                                  
   808 00001BF9 8B4604                          mov     ax,[bp+4]   ;get bits to AX
   809 00001BFC 08060200                        or      [flags],al    ;combine to flag word
   810                                  
   811                                  ;;;;;;;;;;;  JMP  EXC010
   812                                  
   813 00001C00 84061100                        test    al,[enables]  ;test for unmasked exceptions
   814 00001C04 7506                            jnz     EXC010      ;there are unmasked exceptions
   815                                  EXC005:
   816 00001C06 1F                              pop     ds          ;restore DS
   817 00001C07 58                              pop     ax          ;restore AX
   818 00001C08 C9                              leave               ;done
   819 00001C09 C20200                          ret     2           ;return, popping the stack
   820                                  
   821                                  
   822                                  ;   handle simple setting of unmasked error flags
   823                                  EXC010:
   824 00001C0C 08E4                            or      ah,ah       ;test for specific hi-bits
   825 00001C0E 7510                            jnz     EXC020      ;specific error flagged
   826                                  
   827 00001C10 D0C0                            rol     al,1
   828 00001C12 D0C0                            rol     al,1        ;discard hi-2 bits
   829 00001C14 B407                            mov     ah,7        ;max error code + 1 to AH
   830                                  EXC011:
   831 00001C16 FECC                            dec     ah          ;count down
   832 00001C18 D0E0                            shl     al,1        ;move bit to carry
   833 00001C1A 73FA                            jnc     EXC011      ;
   834                                  
   835 00001C1C 88E0                            mov     al,ah       ;error code to AL
   836 00001C1E EB08                            jmp     EXC030      ;go call signal routine
   837                                  
   838                                  EXC020:     ;specific high error flag
   839 00001C20 B006                            mov     al,6        ;min error code -1 to AL
   840                                  EXC021:
   841 00001C22 FEC0                            inc     al
   842 00001C24 D0EC                            shr     ah,1        ;flag bit to carry
   843 00001C26 73FA                            jnc     EXC021
   844                                  EXC030:
   845 00001C28 E80200                          call    _FPSIGNAL   ;signal error
   846 00001C2B EBD9                            jmp     EXC005      ;say nothing for now
   847                                  
   848                                  ;;;exception   endp
   849                                  
   850                                  %if ABSLOAD
   851                                  %include  "em187i.asm"
     1                              <1> ; em187i.asm -- signal module
     2                              <1> ;
     3                              <1> ;  Enter with error number in AL
     4                              <1> ;
     5                              <1> _FPSIGNAL:	;	proc	near
     6 00001C2D 53                  <1> 	push	bx
     7                              <1> ;;;	mov	bx,offset err0
     8 00001C2E BB[4A1C]            <1> 	mov	bx, err0
     9 00001C31 E8CD00              <1> 	call	strout
    10 00001C34 88C3                <1> 	mov	bl,al
    11 00001C36 30FF                <1> 	xor	bh,bh
    12 00001C38 D1E3                <1> 	shl	bx,1
    13 00001C3A 2E8B9F[E51C]        <1>   cs	mov	bx,word [FPUerrtab+bx]
    14 00001C3F E8BF00              <1> 	call	strout
    15                              <1> ;;;	mov	bx,offset errNL
    16 00001C42 BB[E21C]            <1> 	mov	bx, errNL
    17 00001C45 E8B900              <1> 	call	strout
    18 00001C48 5B                  <1> 	pop	bx
    19 00001C49 C3                  <1> 	ret
    20                              <1> ;_FPSIGNAL	endp
    21                              <1> 
    22                              <1> ;define the exception bits
    23                              <1> ; Iexcept     equ     1       ;invalid operation
    24                              <1> ; Dexcept     equ     2       ;denormalized operand
    25                              <1> ; Zexcept     equ     4       ;zero divide
    26                              <1> ; Oexcept     equ     8       ;overflow
    27                              <1> ; Uexcept     equ    10h      ;underflow
    28                              <1> ; Pexcept     equ    20h      ;precision
    29                              <1> ; 
    30                              <1> ; Sflag       equ    40h      ;stack flag     (new with 80187)
    31                              <1> ; Estatus     equ    80h      ;error summary status
    32                              <1> 
    33                              <1> ;define the high order error codes
    34                              <1> ; errUnemulated   equ     0100h   ;unemulated operation
    35                              <1> ; errSqrt         equ     0200h   ;error in SQRT
    36                              <1> ;unassigned
    37                              <1> ; errStkOverflow  equ     0800h   ;
    38                              <1> ; errStkUnderflow equ     1000h   ;
    39                              <1> 
    40 00001C4A 0D0A46505520657272- <1> err0	db	CR,LF,"FPU error:  ",0
    40 00001C53 6F723A202000        <1>
    41                              <1> 
    42 00001C59 496E76616C6964204F- <1> err1	db	"Invalid Operation",0
    42 00001C62 7065726174696F6E00  <1>
    43 00001C6B 44656E6F726D616C00  <1> err2	db	"Denormal",0
    44 00001C74 5A65726F2044697669- <1> err3	db	"Zero Divide",0
    44 00001C7D 646500              <1>
    45 00001C80 4F766572666C6F7700  <1> err4	db	"Overflow",0
    46 00001C89 556E646572666C6F77- <1> err5	db	"Underflow",0
    46 00001C92 00                  <1>
    47 00001C93 507265636973696F6E- <1> err6	db	"Precision",0
    47 00001C9C 00                  <1>
    48                              <1> 
    49 00001C9D 556E656D756C617465- <1> err7	db	"Unemulated Instruction",0
    49 00001CA6 6420496E7374727563- <1>
    49 00001CAF 74696F6E00          <1>
    50 00001CB4 53515254206572726F- <1> err8	db	"SQRT error",0
    50 00001CBD 7200                <1>
    51 00001CBF 00                  <1> err9	db	0
    52 00001CC0 537461636B204F7665- <1> errA	db	"Stack Overflow",0
    52 00001CC9 72666C6F7700        <1>
    53 00001CCF 537461636B20556E64- <1> errB	db	"Stack Underflow",0
    53 00001CD8 6572666C6F7700      <1>
    54 00001CDF 00                  <1> errC	db	0
    55 00001CE0 00                  <1> errD	db	0
    56 00001CE1 00                  <1> errE	db	0
    57                              <1> 
    58 00001CE2 0D0A00              <1> errNL	db	CR,LF,0
    59                              <1> 
    60                              <1> FPUerrtab:
    61 00001CE5 [591C][6B1C][741C]- <1> 	dw	err1,err2,err3,err4
    61 00001CEB [801C]              <1>
    62 00001CED [891C][931C][9D1C]- <1> 	dw	err5,err6,err7,err8
    62 00001CF3 [B41C]              <1>
    63 00001CF5 [BF1C][C01C][CF1C]- <1> 	dw	err9,errA,errB,errC
    63 00001CFB [DF1C]              <1>
    64 00001CFD [E01C][E11C]        <1> 	dw	errD,errE
    65                              <1> 
    66                              <1> ; output the string pointed to by BX
    67                              <1> ;
    68                              <1> strout:		;	proc	near
    69 00001D01 50                  <1> 	push	ax
    70                              <1> strout1:
    71 00001D02 2E8A07              <1>   cs	mov	al,byte [bx]
    72 00001D05 08C0                <1> 	or	al,al
    73 00001D07 7406                <1> 	jz	strout9
    74 00001D09 E80500              <1> 	call	charout
    75 00001D0C 43                  <1> 	inc	bx
    76 00001D0D EBF3                <1> 	jmp	strout1
    77                              <1> strout9:
    78 00001D0F 58                  <1> 	pop	ax
    79 00001D10 C3                  <1> 	ret
    80                              <1> ;strout	endp
    81                              <1> ; output the character in AL
    82                              <1> ;
    83                              <1> charout:	;	proc	near
    84 00001D11 50                  <1> 	push	ax
    85 00001D12 53                  <1> 	push	bx
    86                              <1> 
    87 00001D13 BB0700              <1> 	mov	bx,0007h
    88 00001D16 B40E                <1> 	mov	ah,0Eh
    89 00001D18 CD10                <1> 	int	10h
    90                              <1> 
    91 00001D1A 5B                  <1> 	pop	bx
    92 00001D1B 58                  <1> 	pop	ax
    93 00001D1C C3                  <1> 	ret
    94                              <1> ;charout	endp
    95                              <1> 
    96                              <1> ; end em187i.asm
   852                                  %endif
   853                                  
   854                                  %ifdef DEBUG
   855                                  trace       dd      200 dup (0)
   856                                  tracee      label   dword
   857                                  %endif
   858                                  
   859                                  ; number of paragraphs needed by the DATA area
   860 00001D1D 19                      	db	EM187_DATA_PARAS	; easy to see in the listing file
   861                                  
   862                                  ;;;_TEXT   ENDS
   863                                  ;;;        END
