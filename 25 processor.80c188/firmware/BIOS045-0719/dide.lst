     1                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     2                                  ; DIDE.ASM -- Dual [DMA] IDE driver
     3                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     4                                  ;
     5                                  ;   This version is for assembly by  NASM 0.98.39 or later
     6                                  ;
     7                                  ; Copyright (C) 2013 John R. Coffman.  All rights reserved.
     8                                  ; Provided for hobbyist use on the N8VEM SBC-188 board.
     9                                  ;
    10                                  ; This program is free software: you can redistribute it and/or modify
    11                                  ; it under the terms of the GNU General Public License as published by
    12                                  ; the Free Software Foundation, either version 3 of the License, or
    13                                  ; (at your option) any later version.
    14                                  ;
    15                                  ; This program is distributed in the hope that it will be useful,
    16                                  ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    17                                  ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    18                                  ; GNU General Public License for more details.
    19                                  ;
    20                                  ; You should have received a copy of the GNU General Public License
    21                                  ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    22                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    23                                  %include	"config.asm"
     1                              <1> ;/*
     2                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     3                              <1> ; VGA3.CFG
     4                              <1> ;   Copied to CONFIG.ASM for general release.
     5                              <1> ;
     6                              <1> ;       Modify the parameters below to reflect your system
     7                              <1> ;
     8                              <1> ;
     9                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    10                              <1> ;
    11                              <1> ;   Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    12                              <1> ;   Provided for hobbyist use on the N8VEM SBC-188 board.
    13                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    14                              <1> ;
    15                              <1> ; Define the serial terminal that the Video BIOS must emulate
    16                              <1> ; Set one of the following to 1
    17                              <1> ; If you have no idea what to choose, set TTY to 1
    18                              <1> TTY     equ     0       ; hardcopy -- cannot position the cursor
    19                              <1> DUMB    equ     0       ; dumb CRT -- ^H, ^J, ^K, ^L can move the cursor
    20                              <1> ANSI    equ     1       ; very smart, like a VT-100
    21                              <1> WYSE    equ     0       ; very smart Wyse series (30, 50, ...)
    22                              <1> ; others may get added in the future
    23                              <1> ;  ONE OF THE ABOVE must BE SET TO 1!!!!!
    24                              <1> ;
    25                              <1> ; Does the hardware configuration contain the Color Video Display Unit?
    26                              <1> ; Both the 8563 and the 8242 are used.  The default is CVDU=0
    27                              <1> CVDU	equ	0	; system does not have the CVDU
    28                              <1> ;
    29                              <1> ; Does the hardware configuration contain the VGA3 a/n Video card?
    30                              <1> ; The 8563 will be disabled, but the 8242 code is shared with the CVDU
    31                              <1> ; The default is VGA3=0
    32                              <1> VGA3   equ     1       ; system has the VGA3
    33                              <1> ;
    34                              <1> ; Does the hardware configuration contain the front panel card?
    35                              <1> ; The default is FRONT_PANEL=0
    36                              <1> ;
    37                              <1> FRONT_PANEL   equ     1       ; system has the VGA3
    38                              <1> %if 0
    39                              <1> 	*/
    40                              <1> #define VGA3 1
    41                              <1> /*
    42                              <1> %endif
    43                              <1> ;
    44                              <1> ; Boot up keyboard mode:  20h for NumLock on
    45                              <1> ;CVDU_KEYBOARD_STATUS	equ	0	; NumLock OFF
    46                              <1> CVDU_KEYBOARD_STATUS	equ	20h	; NumLock ON
    47                              <1> 
    48                              <1> ; Define the UART startup bit rate - 1200-19200 are most common
    49                              <1> ;UART_RATE	equ	0		; 1200
    50                              <1> ;UART_RATE	equ	1		; 2400
    51                              <1> ;UART_RATE	equ	2		; 4800
    52                              <1> ;UART_RATE	equ	3		; 9600
    53                              <1> ;UART_RATE	equ	4		; 19200
    54                              <1> UART_RATE	equ	5		; 38400
    55                              <1> ;UART_RATE	equ	6		; 57600
    56                              <1> ;UART_RATE	equ	7		; 115200
    57                              <1> 
    58                              <1> ; Does the serial terminal use the DSR/DTR protocol for flow control?
    59                              <1> ;UART_DSR_PROTOCOL	equ		1	; Yes!
    60                              <1> UART_DSR_PROTOCOL       equ             WYSE    ; Wyse always uses it
    61                              <1> 						; but not ANSI
    62                              <1> ; Define the size of the ROM image on the system in Kilobytes
    63                              <1> ; It may be smaller than the actual EPROM in use.
    64                              <1> ; The following sizes are supported:  32, 64, 128, and 256
    65                              <1> %ifndef ROM
    66                              <1> ROM             equ     32              ; 64 is the default
    67                              <1> %endif
    68                              <1> 
    69                              <1> ; Define the number of Wait States at which the ROM operates
    70                              <1> ROM_WS          equ     1               ; 0..3  (1 is the default)
    71                              <1> 
    72                              <1> ; Define the size in Kilobytes of DOS RAM (low SRAM plus EMM allocate RAM)
    73                              <1> ; This is a desired size and will only be present if a 4MEM board is added
    74                              <1> RAM_DOS         equ     640
    75                              <1> 
    76                              <1> ; Define the size of the low SRAM on the system in Kilobytes
    77                              <1> ; the default is 512 kilobytes
    78                              <1> RAM             equ     512             ; (512 is the default)
    79                              <1> 
    80                              <1> ; Define the number of Wait States at which the RAM operates
    81                              <1> RAM_WS          equ     0               ; 0..3  (0 is the default)
    82                              <1> 
    83                              <1> ; Define the number of Wait States for Local Peripheral devices (600-7FF)
    84                              <1> LCL_IO_WS       equ     1               ; 0..3  (1 is the default)
    85                              <1> 
    86                              <1> ; Define the number of Wait States for ECB BUS peripheral devices (4xx)
    87                              <1> BUS_IO_WS       equ     3               ; 0..3  (3 is the default)
    88                              <1> 
    89                              <1> ; Define the time zone in which we build the Relocatable BIOS
    90                              <1> %ifndef TIMEZONE
    91                              <1> %define TIMEZONE "CDT"
    92                              <1> %endif
    93                              <1> 
    94                              <1> ; Has the REDBUG debugger been loaded?
    95                              <1> %ifndef SOFT_DEBUG
    96                              <1> %define SOFT_DEBUG 0
    97                              <1> %endif
    98                              <1> 
    99                              <1> ; Should the BIOS include "Tiny BASIC" in the image?
   100                              <1> %ifndef TBASIC
   101                              <1> TBASIC          equ     1		; default is 1
   102                              <1> %endif
   103                              <1> 
   104                              <1> ; Should the BIOS include the Floating Point Emulator?  The 80188 does
   105                              <1> ; not allow a floating point co-processor, so this is probably a good idea.
   106                              <1> %ifndef FPEM
   107                              <1> FPEM            equ     1               ; default is 1
   108                              <1> %endif
   109                              <1> 
   110                              <1> ; Define the maximum number of EMM (4MEM) boards supported
   111                              <1> EMM_BOARDS      equ     4
   112                              <1> 
   113                              <1> ; Should the Floating Point Emulator use temporary storage in the EBDA
   114                              <1> ; or at locations 0280h..3FFh in low memory?
   115                              <1> %if SOFT_DEBUG
   116                              <1> FPEM_USE_EBDA   equ     FPEM            ; default is 0
   117                              <1> %else
   118                              <1> FPEM_USE_EBDA   equ     0; FPEM            ; default is 0
   119                              <1> %endif
   120                              <1> 
   121                              <1> ; Define the size of the EPROM that is to be installed on the system
   122                              <1> ; It may be larger than the actual ROM image to be generated.
   123                              <1> %ifndef CHIP
   124                              <1> CHIP            equ     64
   125                              <1> %endif
   126                              <1> 
   127                              <1> ; Does the SBC-188 00.4 board have the LS138/LS08 piggyback fix
   128                              <1> ; Set to 1 for the SBC-188 v1.0 and later production boards
   129                              <1> FDC_PIGGYBACK_FIX       equ     0       ; Fix not installed
   130                              <1> ;FDC_PIGGYBACK_FIX       equ     1       ; fix  IS  installed
   131                              <1> 
   132                              <1> ; On SBC-188 rev 00.4 board, there is a published hardware fix (2010-09-18).
   133                              <1> ; If the wiring update is installed, or you have a later board, then
   134                              <1> ; set this to 0.  If you are using the software workaround, then set this
   135                              <1> ; to 1.  The rev 1.0 board has this fix already.
   136                              <1> NEED_TIMER_FIX  equ     0               ; have revised hardware
   137                              <1> ;NEED_TIMER_FIX  equ     1               ; use workaround
   138                              <1> 
   139                              <1> ; Define the UART oscillator speed
   140                              <1> UART_OSC        equ     1843200         ; 1.8432 Mhz is specified
   141                              <1> 
   142                              <1> 
   143                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   144                              <1> ; end of the User configuration
   145                              <1> ;       Do Not modify anything below this point
   146                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   147                              <1> 
   148                              <1> CVDU_8563	equ	CVDU		; separate inits
   149                              <1> CVDU_8242	equ	CVDU|VGA3 	; separate inits
   150                              <1> VGA3_6445       equ     VGA3            ; separate inits
   151                              <1> ; Suppress all UART output in color video Mode 3
   152                              <1> ;UART_MODE3_SUPPRESS	equ	0
   153                              <1> UART_MODE3_SUPPRESS	equ	CVDU_8563 | VGA3_6445
   154                              <1> CVDU_USE_MSDOS_KLUDGE	equ	0; CVDU_8242	; bad, bad MSDOS
   155                              <1> CVDU_USE_KBD_HOOK		equ	CVDU_8242
   156                              <1> 
   157                              <1> ; Define existence of any uart chip
   158                              <1> UART		equ	TTY+DUMB+ANSI+WYSE
   159                              <1> startuplength   equ     128                     ; may be up to 1024
   160                              <1> startseg        equ     0FFFFh - (ROM*64) + 1
   161                              <1> highrom         equ     (ROM*400h)&0FFFFh
   162                              <1> startupseg      equ     0FFFFh - (startuplength>>4) + 1
   163                              <1> bios_data_seg   equ     040h            ; segment of BIOS data area
   164                              <1> 
   165                              <1> 
   166                              <1> %define ARG(n) [bp+2+(n)*2]
   167                              <1> 
   168                              <1> %macro  check   1.nolist
   169                              <1>  %if (%1)
   170                              <1>    %error Check Failure: %1
   171                              <1>  %endif
   172                              <1> %endm
   173                              <1> %macro  range   3.nolist
   174                              <1>  %if (%1)<(%2)
   175                              <1>    %error Out of Range: %1
   176                              <1>  %elif (%1)>(%3)
   177                              <1>    %error Out of Range: %1
   178                              <1>  %endif
   179                              <1> %endm
   180                              <1> _terminal equ UART+CVDU
   181                              <1>  check   RAM_DOS&15
   182                              <1>  check   RAM&(RAM-1)
   183                              <1>  check   ROM&(ROM-1)
   184                              <1>  range   RAM,32,512
   185                              <1>  range   ROM,32,256
   186                              <1>  range   RAM_WS,0,3
   187                              <1>  range   ROM_WS,0,3
   188                              <1>  range   RAM_DOS,RAM,(1024-ROM)
   189                              <1>  range   LCL_IO_WS,0,3
   190                              <1>  range   BUS_IO_WS,0,3
   191                              <1>  range   UART_OSC,500000,16000000
   192                              <1>  range   UART_RATE,0,7
   193                              <1>  range	 UART,0,1
   194                              <1>  range	 _terminal,1,2
   195                              <1> 
   196                              <1> %ifndef SOFT_DEBUG
   197                              <1> %define SOFT_DEBUG 0
   198                              <1> %endif
   199                              <1> 
   200                              <1> %ifndef TRACE
   201                              <1> %define TRACE 0
   202                              <1> %endif
   203                              <1> 
   204                              <1> %ifdef MAKE_OBJECT_FILE
   205                              <1>         segment _DATA WORD PUBLIC CLASS=DATA
   206                              <1>         export _ROMsize
   207                              <1>         export _CHIPsize
   208                              <1> _ROMsize        dw      ROM
   209                              <1> _CHIPsize       dw      CHIP
   210                              <1> %endif
   211                              <1> ; end of the Hardware configuration file
   212                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   213                              <1> ;*/
    24                                  %include	"cpuregs.asm"
     1                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     2                              <1> ; CPUREGS.ASM
     3                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     4                              <1> ;
     5                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
     6                              <1> ;
     7                              <1> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
     8                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
     9                              <1> ;
    10                              <1> ; This program is free software: you can redistribute it and/or modify
    11                              <1> ; it under the terms of the GNU General Public License as published by
    12                              <1> ; the Free Software Foundation, either version 3 of the License, or
    13                              <1> ; (at your option) any later version.
    14                              <1> ;
    15                              <1> ; This program is distributed in the hope that it will be useful,
    16                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    17                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    18                              <1> ; GNU General Public License for more details.
    19                              <1> ;
    20                              <1> ; You should have received a copy of the GNU General Public License
    21                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    22                              <1> ;
    23                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    24                              <1>         cpu     186
    25                              <1> ;
    26                              <1> ;
    27                              <1> ; IBM model byte -- must be less than a 286
    28                              <1> ;
    29                              <1> ;MODEL_BYTE		equ	0FEh	; PC-XT
    30                              <1> ;SUBMODEL_BYTE		equ	0FFh	; not used
    31                              <1> 
    32                              <1> MODEL_BYTE		equ	0FEh	; PC-XT
    33                              <1> SUBMODEL_BYTE		equ	00h	;  "
    34                              <1> 
    35                              <1> 
    36                              <1> ; 80188 peripheral control register block address
    37                              <1> CPU_CSCR	        equ	0FF00h
    38                              <1> 
    39                              <1> ; Compatible Mode registers
    40                              <1> 
    41                              <1> cpu_relocation          equ     CPU_CSCR+0FEh
    42                              <1> 
    43                              <1> ; The memory and peripheral chip select register offsets from 0FF00h
    44                              <1> 
    45                              <1> cpu_umcs                equ     CPU_CSCR+0A0h          ; Upper memory select
    46                              <1> cpu_lmcs                equ     CPU_CSCR+0A2h          ; Lower memory select
    47                              <1> cpu_pacs                equ     CPU_CSCR+0A4h          ; Peripheral select
    48                              <1> cpu_mmcs                equ     CPU_CSCR+0A6h          ; Middle memory base
    49                              <1> cpu_mpcs                equ     CPU_CSCR+0A8h          ; Mid mem. & peripherals
    50                              <1> 
    51                              <1> ; Enhanced Mode registers
    52                              <1> 
    53                              <1> cpu_mdram               equ     CPU_CSCR+0E0h          ; memory partition reg.
    54                              <1> cpu_cdram               equ     CPU_CSCR+0E2h          ; clock prescaler
    55                              <1> cpu_edram               equ     CPU_CSCR+0E4h          ; Enable refresh reg.
    56                              <1> cpu_pdcon               equ     CPU_CSCR+0F0h          ; Power-Save control
    57                              <1> 
    58                              <1> 
    59                              <1> ; On-board internal peripheral equates
    60                              <1> ; Programmable Interrupt Controller
    61                              <1> PIC	        equ	CPU_CSCR+020H
    62                              <1> PIC_EOI	        equ	PIC+2           ; End Of Interrupt
    63                              <1> PIC_POLLR	equ	PIC+4
    64                              <1> PIC_POLLSR	equ	PIC+6
    65                              <1> PIC_IMASK	equ	PIC+8
    66                              <1> PIC_PMREG	equ	PIC+0AH
    67                              <1> PIC_SRVR	equ	PIC+0CH
    68                              <1> PIC_IRQR	equ	PIC+0EH
    69                              <1> PIC_IRQSR	equ	PIC+10H
    70                              <1> PIC_TCR	        equ	PIC+12H
    71                              <1> PIC_DMA0CR	equ	PIC+14H
    72                              <1> PIC_DMA1CR	equ	PIC+16H
    73                              <1> PIC_I0CON	equ	PIC+18H
    74                              <1> PIC_I1CON	equ	PIC+1AH
    75                              <1> PIC_I2CON	equ	PIC+1CH
    76                              <1> PIC_I3CON	equ	PIC+1EH
    77                              <1> 
    78                              <1> EOI_NSPEC       equ     8000h           ; Non-Specific EOI
    79                              <1> 
    80                              <1> ; Interrupt masks (Master Mode)
    81                              <1> ;
    82                              <1> mask_timer_all          equ     0001h
    83                              <1> mask_dma0               equ     0004h
    84                              <1> mask_dma1               equ     0008h
    85                              <1> mask_int0               equ     0010h
    86                              <1> mask_int1               equ     0020h
    87                              <1> mask_int2               equ     0040h
    88                              <1> mask_int3               equ     0080h
    89                              <1> 
    90                              <1> 
    91                              <1> 
    92                              <1> ; Timers
    93                              <1> TIM0	        equ	CPU_CSCR+050H
    94                              <1> TIM1	        equ	CPU_CSCR+058H
    95                              <1> TIM2	        equ	CPU_CSCR+060H
    96                              <1> 
    97                              <1> TCNT	        equ	0	; count register
    98                              <1> CMPA	        equ	2	; max count A
    99                              <1> CMPB	        equ	4	; max count B (not present on TIM2)
   100                              <1> TCON	        equ	6	; mode/control word
   101                              <1> 
   102                              <1> ; Timer control bits:
   103                              <1> tc_EN           equ     8000h   ; Enable bit
   104                              <1> tc_nINH         equ     4000h   ; not Inhibit Enable
   105                              <1> tc_INT          equ     2000h   ; Interrupt Enable
   106                              <1> tc_RIU          equ     1000h   ; Register A/B (0/1) in Use
   107                              <1> tc_MC           equ     0020h   ; Maximum Count reached
   108                              <1> tc_RTG          equ     0010h   ; Retrigger (internal source)
   109                              <1> tc_P            equ     0008h   ; Prescale internal clock (timers 0 & 1 only)
   110                              <1> tc_EXT          equ     0004h   ; External clock
   111                              <1> tc_ALT          equ     0002h   ; Alternate between A & B max count registers
   112                              <1> tc_CONT         equ     0001h   ; Continuous: continue after max count
   113                              <1> 
   114                              <1> 
   115                              <1> 
   116                              <1> 
   117                              <1> ; DMA
   118                              <1> DMA0	        equ	CPU_CSCR+0C0H
   119                              <1> DMA1	        equ	CPU_CSCR+0D0H
   120                              <1> DMASPL	        equ	0	; source pointer low
   121                              <1> DMASPU	        equ	2	; source pointer high
   122                              <1> DMADPL	        equ	4	; destination pointer low
   123                              <1> DMADPU	        equ	6	; destination pointer high
   124                              <1> DMATC	        equ	8	; terminal count
   125                              <1> DMACW	        equ	0AH	; control word
   126                              <1> 
   127                              <1> 
   128                              <1> 
   129                              <1> 
   130                              <1> 
   131                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   132                              <1> ;
   133                              <1> ;       SBC-188 external devices
   134                              <1> ;
   135                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   136                              <1> 
   137                              <1> IO_BASE			equ	0400h
   138                              <1> 
   139                              <1> 
   140                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   141                              <1> ; The UART registers
   142                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   143                              <1> uart_base               equ     IO_BASE+0280h
   144                              <1> uart_rbr                equ     uart_base       ;Rcvr Buffer / read only
   145                              <1> uart_thr                equ     uart_base       ;Transmit Holding / write only
   146                              <1> uart_ier                equ     uart_base+1     ;Interrupt Enable
   147                              <1> uart_iir                equ     uart_base+2     ;Interrupt Ident / read only
   148                              <1> uart_fcr                equ     uart_base+2     ;FIFO Control / write only
   149                              <1> uart_lcr                equ     uart_base+3     ;Line Control
   150                              <1> uart_mcr                equ     uart_base+4     ;Modem Control
   151                              <1> uart_lsr                equ     uart_base+5     ;Line Status
   152                              <1> uart_msr                equ     uart_base+6     ;Modem Status
   153                              <1> uart_sr			equ	uart_base+7	;Scratch
   154                              <1> 
   155                              <1> uart_dll                equ     uart_base       ;Divisor Latch LS Byte
   156                              <1> uart_dlm                equ     uart_base+1     ;Divisor Latch MS Byte
   157                              <1> 
   158                              <1> 
   159                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   160                              <1> ; Floppy controller
   161                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   162                              <1> FDC	        equ	IO_BASE+0200H
   163                              <1> FDC_MSR         equ     FDC
   164                              <1> FDC_DATA        equ     FDC_MSR+1
   165                              <1> FDC_DACK        equ	FDC+10H
   166                              <1> FDC_LDOR	equ	FDC+20H
   167                              <1> FDC_LDCR	equ	FDC+30H
   168                              <1> FDC_TC	        equ	FDC+40H
   169                              <1> FDC_DACK_TC     equ     FDC_DACK | FDC_TC
   170                              <1> 
   171                              <1> 
   172                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   173                              <1> ;DS1302 RTC
   174                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   175                              <1> RTC	equ	IO_BASE+0300H
   176                              <1> 
   177                              <1> 
   178                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   179                              <1> ; PIO 82C55 I/O 
   180                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   181                              <1> PPI	        equ	IO_BASE+0260H
   182                              <1> PIO_A	        equ	PPI+0	; (OUTPUT)
   183                              <1> PIO_B	        equ	PPI+1	; (INPUT)
   184                              <1> PIO_C	        equ	PPI+2	; (CENTRONICS control low nibble)  
   185                              <1> PIO_CTRL	equ	PPI+3	; CONTROL BYTE PIO 82C55
   186                              <1> 
   187                              <1> portA           equ     PPI+0   ;
   188                              <1> portB           equ     PPI+1   ;     LITES uses this for output
   189                              <1> portC           equ     PPI+2   ;
   190                              <1> 
   191                              <1> 
   192                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   193                              <1> ; Dual [DMA] IDE devices
   194                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   195                              <1> DIDE		equ	IO_BASE + 20H	; range 0x20..0x3F
   196                              <1> 
   197                              <1> DIDE0		equ	DIDE		; first interface (master & slave)
   198                              <1> DIDE1		equ	DIDE+10h	; second interface (master & slave)
   199                              <1> 
   200                              <1> 
   201                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   202                              <1> ; Cassette I/O
   203                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   204                              <1> cuart_base	EQU 	IO_BASE+80H	; BASE IO ADDRESS OF CASSETTE UART
   205                              <1> cuart_rbr	equ     cuart_base	;Rcvr Buffer / read only
   206                              <1> cuart_thr	equ     cuart_base	;Transmit Holding / write only
   207                              <1> cuart_ier	equ     cuart_base+1	;Interrupt Enable
   208                              <1> cuart_iir	equ     cuart_base+2	;Interrupt Ident / read only
   209                              <1> cuart_fcr	equ     cuart_base+2	;FIFO Control / write only
   210                              <1> cuart_lcr	equ     cuart_base+3	;Line Control
   211                              <1> cuart_mcr	equ     cuart_base+4	;Modem Control
   212                              <1> cuart_lsr	equ     cuart_base+5	;Line Status
   213                              <1> cuart_msr	equ     cuart_base+6	;Modem Status
   214                              <1> cuart_sr	equ	cuart_base+7	;Scratch
   215                              <1> 
   216                              <1> cuart_dll	equ     cuart_base	;Divisor Latch LS Byte
   217                              <1> cuart_dlm	equ	cuart_base+1	;Divisor Latch MS Byte
   218                              <1> 
   219                              <1> 
   220                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   221                              <1> ;
   222                              <1> ;       4MEM control registers
   223                              <1> ;
   224                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   225                              <1> EMM_addr        equ     1               ; high 6 bits of 20-bit address
   226                              <1> EMM_page        equ     0               ; 4MEM page in [0..254]
   227                              <1> 
   228                              <1> EMM_BASE        equ     IO_BASE + 000h          ; first EMM (4MEM) board
   229                              <1> EMM_unmapped    equ     255             ; unmapped 4MEM page
   230                              <1> 
   231                              <1> EMM0            equ     EMM_BASE        ; first  EMM board
   232                              <1> EMM1            equ     EMM0 + 2        ; second EMM board
   233                              <1> EMM2            equ     EMM1 + 2        ; third  EMM board
   234                              <1> EMM3            equ     EMM2 + 2        ; fourth EMM board
   235                              <1> 
   236                              <1> 
   237                              <1> 
   238                              <1> 
   239                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   240                              <1> ;
   241                              <1> ;	ColorVDU devices
   242                              <1> ;
   243                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   244                              <1> ;
   245                              <1> ;	major select on the Z80 bus
   246                              <1> ;
   247                              <1> devCVDU_8bit	equ	0xE0		; this may change to 0x10
   248                              <1> 
   249                              <1> devCVDUbase 	equ	IO_BASE + devCVDU_8bit
   250                              <1> 
   251                              <1> M8563status	equ	devCVDUbase + 4		; 4 == bitrev(2)
   252                              <1> M8563register	equ	devCVDUbase + 4
   253                              <1> M8563data	equ	devCVDUbase + 12	; 12 == bitrev(3)
   254                              <1> 
   255                              <1> %if CVDU_8563
   256                              <1> I8242status	equ	devCVDUbase + 10	; 10 == bitrev(5)
   257                              <1> I8242command	equ	devCVDUbase + 10
   258                              <1> I8242data	equ	devCVDUbase + 2		; 2 == bitrev(4)
   259                              <1> %endif
   260                              <1> 
   261                              <1> 
   262                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   263                              <1> ;
   264                              <1> ;	VGA3 devices
   265                              <1> ;
   266                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   267                              <1> ;
   268                              <1> ;	major select on the Z80 bus
   269                              <1> ;
   270                              <1> devVGA3_8bit    equ     0xE0                    ; same as CVDU
   271                              <1> 
   272                              <1> devVGA3base       equ     IO_BASE + devVGA3_8bit
   273                              <1> 
   274                              <1> %if VGA3_6445
   275                              <1> I8242status	equ	devVGA3base + 1
   276                              <1> I8242command	equ	devVGA3base + 1
   277                              <1> I8242data	equ	devVGA3base + 0
   278                              <1> %endif
   279                              <1> HD6445addr	equ	devVGA3base + 2		; to address the HD6445 registers
   280                              <1> HD6445reg	equ	devVGA3base + 3		; to r/w a register on the CRTC
   281                              <1> 
   282                              <1> vga3cfg		equ	devVGA3base + 4
   283                              <1> ; the following are probably not used on the SBC-188, except for testing/checking
   284                              <1> vga3adhi	equ	devVGA3base + 5
   285                              <1> vga3adlo	equ	devVGA3base + 6
   286                              <1> vga3data	equ	devVGA3base + 7
   287                              <1> 
   288                              <1> 
   289                              <1> 
   290                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   291                              <1> ;
   292                              <1> ;	Front Panel devices
   293                              <1> ;
   294                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   295                              <1> ;
   296                              <1> ; Front Panel 82C55 I/O 
   297                              <1> FPPPI	        equ	IO_BASE+0A0H
   298                              <1> FPPORTA         equ     FPPPI+0   	;
   299                              <1> FPPORTB         equ     FPPPI+1   	;    
   300                              <1> FPPORTC         equ     FPPPI+2   	;
   301                              <1> FPPIOCONT       equ     FPPPI+3   	;
   302                              <1> 
   303                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   304                              <1> ; debug port -- JRC only
   305                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   306                              <1> portD		equ	IO_BASE + 0FFh		; 0x04FF
   307                              <1> ;portD		equ	portB		     ; older 8255 output on PPI
   308                              <1> 
   309                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   310                              <1> ;
   311                              <1> ; some useful macros:
   312                              <1> ;
   313                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   314                              <1> ;
   315                              <1> 
   316                              <1> %imacro setloc  1.nolist
   317                              <1>  times   (%1-($-$$)) db 0FFh
   318                              <1> %endm
   319                              <1> 
   320                              <1> %imacro db_lo   1
   321                              <1>  db (%1)&255
   322                              <1> %endm
   323                              <1> 
   324                              <1> %imacro cnop    0.nolist
   325                              <1> %if SOFT_DEBUG
   326                              <1>         nop
   327                              <1> %endif
   328                              <1> %endm
   329                              <1> 
   330                              <1> %imacro popm 1-*.nolist
   331                              <1> %rep %0
   332                              <1> %ifidni %1,ALL
   333                              <1>  popa
   334                              <1> %elifidni %1,F
   335                              <1>  popf
   336                              <1> %else
   337                              <1>  pop %1
   338                              <1> %ifidni %1,DS
   339                              <1>  cnop
   340                              <1> %elifidni %1,ES
   341                              <1>  cnop
   342                              <1> %endif
   343                              <1> %endif
   344                              <1> %rotate 1
   345                              <1> %endrep
   346                              <1> %endm
   347                              <1> 
   348                              <1> %imacro pushm 1-*.nolist
   349                              <1> %rep %0
   350                              <1> %rotate -1
   351                              <1> %ifidni %1,ALL
   352                              <1>  pusha
   353                              <1> %elifidni %1,F
   354                              <1>  pushf
   355                              <1> %else
   356                              <1>  push %1
   357                              <1> %endif
   358                              <1> %endrep
   359                              <1> %endm
   360                              <1> 
   361                              <1> ; end CPUREGS.ASM
   362                              <1> 
    25                                  %include	"equates.asm"
     1                              <1> ;========================================================================
     2                              <1> ; EQUATES.ASM -- Lots of Defintions for Relocatable BIOS
     3                              <1> ;========================================================================
     4                              <1> ;   for the N8VEM SBC-188 v.00.4 and 00.5
     5                              <1> ;
     6                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
     7                              <1> ;
     8                              <1> ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
     9                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    10                              <1> ;
    11                              <1> ; This program is free software: you can redistribute it and/or modify
    12                              <1> ; it under the terms of the GNU General Public License as published by
    13                              <1> ; the Free Software Foundation, either version 3 of the License, or
    14                              <1> ; (at your option) any later version.
    15                              <1> ;
    16                              <1> ; This program is distributed in the hope that it will be useful,
    17                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    18                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    19                              <1> ; GNU General Public License for more details.
    20                              <1> ;
    21                              <1> ; You should have received a copy of the GNU General Public License
    22                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    23                              <1> ;
    24                              <1> ;========================================================================
    25                              <1> 
    26                              <1> %if 1
    27                              <1> 	SEGMENT  _TEXT ALIGN=16 PUBLIC CLASS=CODE
    28                              <1>         SEGMENT  CONST ALIGN=2 PUBLIC CLASS=DATA
    29                              <1> 	SEGMENT  _DATA ALIGN=2 PUBLIC CLASS=DATA
    30                              <1>         SEGMENT  CONST2 ALIGN=2 PUBLIC CLASS=DATA
    31                              <1> 	SEGMENT  _BSS  ALIGN=2 PUBLIC CLASS=BSS
    32                              <1> ;;;        SEGMENT  _BASIC ALIGN=16 PUBLIC CLASS=BASIC
    33                              <1> 
    34                              <1> 	GROUP	DGROUP CONST _DATA CONST2 _BSS
    35                              <1> 
    36                              <1>         global  FPEM_segment
    37                              <1> %endif
    38                              <1> 
    39                              <1> %include "ascii.asm"
     1                              <2> ; ascii.asm
     2                              <2> ;
     3                              <2> CTRL            equ     1Fh     ; masks a character to CTRL-x
     4                              <2> 
     5                              <2> NUL     equ     00h
     6                              <2> BEL     equ     (CTRL & 'G')
     7                              <2> BS      equ     08h
     8                              <2> HT      equ     09h
     9                              <2> LF	equ	0Ah
    10                              <2> NL      equ     LF
    11                              <2> CR	equ	0Dh
    12                              <2> XON     equ     (CTRL & 'Q')
    13                              <2> XOFF    equ     (CTRL & 'S')
    14                              <2> DC1     equ     XON
    15                              <2> DC3     equ     XOFF
    16                              <2> ESC     equ	1Bh
    17                              <2> 
    18                              <2> 
    40                              <1> 
    41                              <1> 
    42                              <1> ; POST error codes. Presently one byte but can expand to word.
    43                              <1> ER_BIOS equ	01h		; Bad ROM bios checksum, patch last byte
    44                              <1> ER_RAM	equ	02h		; Bad RAM in main memory, replace
    45                              <1> ER_CRT	equ	04h		; Bad RAM in video card, replace
    46                              <1> ER_FDC	equ	08h		; Bad FDC
    47                              <1> ER_UNK1	equ	10h		; {unassigned}
    48                              <1> ER_MEM	equ	20h		; Bad RAM in vector area, replace
    49                              <1> ER_ROM	equ	40h		; Bad ROM in expansion area, bad checksum
    50                              <1> ER_UNK2	equ	80h		; {unassigned}
    51                              <1> 
    52                              <1> 
    53                              <1> 
    54                              <1> ;; ************************ BIOS Data Segment ******************************
    55                              <1> ;; BIOS data segment - not all will  be used
    56                              <1> ;                struc   BIOS_DATA_AREA  ; at 0040:0000
    57                              <1> %include "bda.inc"
     1                              <2> ;/*======================================================================
     2                              <2> ; bda.inc -- BIOS data area definitions
     3                              <2> ;========================================================================
     4                              <2> ;   for the N8VEM SBC-188
     5                              <2> ;
     6                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
     7                              <2> ;
     8                              <2> ; Copyright (C) 2013 John R. Coffman.  All rights reserved.
     9                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    10                              <2> ;
    11                              <2> ; This program is free software: you can redistribute it and/or modify
    12                              <2> ; it under the terms of the GNU General Public License as published by
    13                              <2> ; the Free Software Foundation, either version 3 of the License, or
    14                              <2> ; (at your option) any later version.
    15                              <2> ;
    16                              <2> ; This program is distributed in the hope that it will be useful,
    17                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    18                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    19                              <2> ; GNU General Public License for more details.
    20                              <2> ;
    21                              <2> ; You should have received a copy of the GNU General Public License
    22                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    23                              <2> ;
    24                              <2> ;========================================================================
    25                              <2> 
    26                              <2> 			;*/ extern				/*
    27                              <2> 	ABSOLUTE  0	;*/ struct BDA {			/*
    28 00000000 <res 00000008>      <2> serial_ports    resw    4	;*/	word	serial_ports[4];	/*
    29 00000008 <res 00000008>      <2> parallel_ports  resw    4	;*/	word	parallel_ports[4];	/*
    30 00000010 <res 00000002>      <2> equipment_flag  resw    1	;*/	EQFL	equipment_flag;		/*
    31                              <2> ;	dw	?		; 40:10 	; Equipment present word
    32                              <2> ;  						;  = (1 iff floppies) *     1.
    33                              <2> ;                                               ;  + (1 iff 187     ) *     2.
    34                              <2> ;  						;  + (#+1 64K sys ram) *    4.
    35                              <2> ;  						;  + (init crt mode ) *    16.
    36                              <2> ;  						;  + (# of floppies ) *    64.
    37                              <2> ;  						;  + (# serial ports) *   512.
    38                              <2> ;  						;  + (1 iff toy port) *  4096.
    39                              <2> ;                                               ;  + (1 iff modem   ) *  8192.
    40                              <2> ;  						;  + (# parallel LPT) * 16384.
    41 00000012 <res 00000001>      <2> mfg_test_flags  resb    1	;*/	byte	mfg_test_flags;	/* 40:12 unused by us
    42 00000013 <res 00000002>      <2> memory_size     resw    1	;*/	word	memory_size;	/* 40:13 kilobytes
    43                              <2> uart_kbd_ctrl_R	equ	$	;*/				/*** JRC: count of ctrl-R's for reboot
    44 00000015 <res 00000001>      <2> IPL_errors      resb    1	;*/	byte	IPL_errors;	/* 40:15 IPL errors<-table/scratchpad
    45 00000016 <res 00000001>      <2> unused_01       resb    1	;*/	byte	unused_01;	/*
    46                              <2> ;;---------------[Keyboard data area]------------;
    47 00000017 <res 00000002>      <2> keyboard_flags_0 resw   1	;*/	word	keyboard_flags_0;  /* 40:17 Shift/Alt/etc. keyboard flags
    48                              <2> keyboard_flags_1 equ	$-1	;     2nd byte	keyboard_flags_1;  
    49 00000019 <res 00000001>      <2> keypad_char	resb	1	;*/	byte	keypad_char;	/* 40:19 Alt-KEYPAD char. goes here
    50 0000001A <res 00000002>      <2> kbd_buffer_head resw    1	;*/	word	kbd_buffer_head;   /* 40:1A --> keyboard buffer head
    51 0000001C <res 00000002>      <2> kbd_buffer_tail resw    1	;*/	word	kbd_buffer_tail;   /* 40:1C --> keyboard buffer tail
    52 0000001E <res 00000020>      <2> kbd_buffer      resw    16	;*/	word	kbd_buffer[16];	/* 40:1E Keyboard Buffer (Scan,Value)
    53                              <2> kbd_buffer_last	equ	$	;*/				/*
    54                              <2> ;;---------------[Diskette data area]------------;
    55 0000003E <res 00000001>      <2> fdc_drv_calib   resb    1	;*/	byte	fdc_drive_calib;   /* 40:3E
    56 0000003F <res 00000001>      <2> fdc_motor_LDOR  resb    1	;*/	byte	fdc_motor_LDOR;	   /* 40:3F Motor, DMA, select control
    57 00000040 <res 00000001>      <2> fdc_motor_ticks resb    1	;*/	byte	fdc_motor_ticks;   /* 40:40 ticks til motor off
    58 00000041 <res 00000001>      <2> fdc_status      resb    1	;*/	byte	fdc_status;	   /* 40:41
    59                              <2> ;				Floppy return code stat byte
    60                              <2> ;				;  1 = bad ic 765 command req.
    61                              <2> ;				;  2 = address mark not found
    62                              <2> ;				;  3 = write to protected disk
    63                              <2> ;				;  4 = sector not found
    64                              <2> ;				;  8 = data late (DMA overrun)
    65                              <2> ;				;  9 = DMA failed 64K page end
    66                              <2> ;				; 16 = bad CRC on floppy read
    67                              <2> ;				; 32 = bad NEC 765 controller
    68                              <2> ;				; 64 = seek operation failed
    69                              <2> ;				;128 = disk drive timed out
    70 00000042 <res 00000007>      <2> fdc_ctrl_status resb    7	;*/	byte	fdc_ctrl_status[7];  /* 40:42 Status bytes from NEC 765
    71                              <2> ;;---------------[Video display area]------------;
    72 00000049 <res 00000001>      <2> video_mode      resb    1	;*/	byte	video_mode;	/* 40:49
    73                              <2> ;			 	; Current CRT mode  (software)
    74                              <2> ;				;  0 = 40 x 25 text (no color)
    75                              <2> ;				;  1 = 40 x 25 text (16 color)
    76                              <2> ;				;  2 = 80 x 25 text (no color)
    77                              <2> ;				;  3 = 80 x 25 text (16 color)
    78                              <2> ;				;  4 = 320 x 200 grafix 4 color
    79                              <2> ;				;  5 = 320 x 200 grafix 0 color
    80                              <2> ;				;  6 = 640 x 200 grafix 0 color
    81                              <2> ;				;  7 = 80 x 25 text (mono card)
    82 0000004A <res 00000002>      <2> video_columns   resw    1	;*/	word video_columns;	/* 40:4A Columns on CRT screen
    83 0000004C <res 00000002>      <2> video_regen_bytes  resw 1	;*/	word video_regen_bytes;	/* 40:4C Bytes in the regen region
    84 0000004E <res 00000002>      <2> video_regen_offset resw 1	;*/	word video_regen_offset;/* 40:4E Byte offset in regen region
    85 00000050 <res 00000010>      <2> video_cursor_pos  resw  8	;*/	word video_cursor_pos[8];  /* 40:50 Cursor pos for up to 8 pages
    86 00000060 <res 00000002>      <2> video_cursor_mode resw  1	;*/	word video_cursor_mode;	/* 40:60 Current cursor mode setting
    87 00000062 <res 00000001>      <2> video_page      resb    1	;*/	byte video_page;	/* 40:62 Current page on display
    88 00000063 <res 00000002>      <2> video_base_seg  resw    1	;*/	word video_base_seg;	/* 40:63 Base address (B000h or B800h)
    89 00000065 <res 00000001>      <2> video_hw_mode   resb    1	;*/	byte video_hw_mode;	/* 40:65 ic 6845 mode reg. (hardware)
    90 00000066 <res 00000001>      <2> video_cga_palette resb  1	;*/	byte video_cga_palette;	/* 40:66 Current CGA palette
    91                              <2> ;;---------------[Used to setup ROM]-------------;
    92 00000067 <res 00000004>      <2> eprom_address   resd    1	;*/	dword eprom_address;	/* 40:67 Eprom base Offset,Segment
    93 0000006B <res 00000001>      <2> spurious_irq    resb    1	;*/	byte spurious_irq;	/* 40:6B Last spurious interrupt IRQ
    94                              <2> ;;---------------[Timer data area]---------------;
    95 0000006C <res 00000004>      <2> timer_ticks     resd    1	;*/	dword timer_ticks;	/* 40:6C Ticks since midnight (lo,hi)
    96 00000070 <res 00000001>      <2> timer_new_day   resb    1	;*/	byte timer_new_day;	/* 40:70 Non-zero if new day
    97                              <2> ;;---------------[System data area]--------------;
    98 00000071 <res 00000001>      <2> break_flag      resb    1	;*/	byte break_flag;	/* 40:71 Sign bit set iff break
    99 00000072 <res 00000002>      <2> warm_boot       resw    1	;*/	word warm_boot;		/* 40:72 Warm boot iff==1234h
   100                              <2> ;;---------------[Hard disk scratchpad]----------;
   101 00000074 <res 00000004>      <2> hdd_scratch     resd    1	;*/	word hdd_scratch[2];	/* 40:74
   102                              <2> ;;---------------[Timout areas/PRT/LPT]----------;
   103 00000078 <res 00000004>      <2> lpt_timeout     resb    4	;*/	byte lpt_timeout[4];	/* 40:78 Ticks for LPT 1-4 timeouts
   104 0000007C <res 00000004>      <2> com_timeout     resb    4	;*/	byte com_timeout[4];	/* 40:7C Ticks for COM 1-4 timeouts
   105                              <2> ;;---obsolete----[Keyboard buf start/end]---jrc--;
   106 00000080 <res 00000002>      <2> kbd_buffer_start resw   1	;*/	word kbd_buffer_start;	/* 40:80 KBD buffer head (PC/AT)
   107 00000082 <res 00000002>      <2> kbd_buffer_end  resw    1	;*/	word kbd_buffer_end;	/* 40:82 KBD buffer tail (PC/AT)
   108                              <2> ;;---------------[EGA stuff]---------------------;
   109 00000084 <res 00000007>      <2> EGA_stuff	resb	7	;*/	byte EGA_stuff[7];	/* 40:84 Unspecified EGA data
   110                              <2> ;;---------------[Floppy/Fixed Media Info]-------------;
   111 0000008B <res 00000001>      <2> fdc_last_rate	resb	1	;*/	byte fdc_last_rate;	/* 40:8B Last floppy step rate/data rate?
   112 0000008C <res 00000004>      <2> fx_misc_unused	resb	4	;*/	byte fx_misc_unused[4];	/* 40:8C Fixed disk miscellaneous ???
   113 00000090 <res 00000002>      <2> fdc_disk_state	resb	2	;*/	byte fdc_disk_state[2];	/* 40:90 Floppy disk state
   114 00000092 <res 00000002>      <2> fdc_op_start	resb	2	;*/	byte fdc_op_start[2];	/* 40:92 Floppy operation start state machine
   115 00000094 <res 00000002>      <2> fdc_cylinder	resb	2	;*/	byte fdc_cylinder[2];	/* 40:94 Floppy present cylinder
   116                              <2> ;;---------------[Additional KBD flags]----------------;
   117 00000096 <res 00000001>      <2> kbd_flag_3	resb	1	;*/	byte kbd_flag_3;	/* 40:96 kbd ???
   118 00000097 <res 00000001>      <2> kbd_flag_2	resb	1	;*/	byte kbd_flag_2;	/* 40:97 kbd ???
   119                              <2> ;;---------------[RTC/timer1 data]---------------------;
   120 00000098 <res 00000004>      <2> user_semaphore	resw	2	;*/	byte *user_semaphore;	/* 40:98 User semaphore in (bit 7)
   121 0000009C <res 00000004>      <2> rtc_count	resd	1	;*/	dword rtc_count;	/* 40:9C RTC tick counter
   122 000000A0 <res 00000001>      <2> rtc_wait_active	resb	1	;*/	byte rtc_wait_active;	/* 40:A0 Busy=01, Posted=80h, 
   123                              <2> ;;---------------[Cassette I/O stuff]------------------;
   124 000000A1 <res 00000001>      <2> last_val	resb	1	;*/	byte last_val;		/* 40:A1 Last byte read value
   125 000000A2 <res 00000002>      <2> crc_reg		resw	1	;*/	word crc_reg;		/* 40:A2 CRC accumulation area
   126                              <2> ;									Post Acknowleged=00;
   127 000000A4 <res 00000001>      <2> EGA_data	resb	1	;*/	byte EGA_data;		/* 40:A4 Various usage
   128 000000A5 <res 00000002>      <2> SDstatus	resb	2	;*/	byte SDstatus[2];	/* 40:A5 Status byte from command
   129 000000A7 <res 00000002>      <2> SDcardtype	resb	2	;*/	byte SDcardtype[2];	/* 40:A7 SDcard type SDSC=2, HC=3, ...
   130                              <2> ;
   131 000000A9 <res 00000004>      <2> fixed_disk_tab	resb	4	;*/	byte fixed_disk_tab[4];	/* dispatch table to fixed disk drivers
   132 000000AD <res 00000001>      <2> wait12_count	resb	1	;*/	byte wait12_count;	/* 40:AD 12usec CX count
   133 000000AE <res 00000001>      <2> lock_count	resb	1	;*/	byte lock_count;	/* 40:AE lock level counter
   134 000000AF <res 00000001>      <2> EMS_start       resb    1	;*/	byte EMS_start;		/* start EMS allocation from here
   135                              <2> fx80		equ	$	;*/	struct EDD_disk fx80;	/* fixed disk parameter area 0
   136 000000B0 <res 00000002>      <2> fx_log_cylinders resw   1	;	word fx_log_cylinders;	 logical number of cylinders
   137 000000B2 <res 00000001>      <2> fx_log_heads    resb    1	;	byte fx_log_heads;	 logical number of heads
   138 000000B3 <res 00000001>      <2> fx_signature	resb	1	;	byte fx_signature;	 A0h signature = translated geom
   139 000000B4 <res 00000001>      <2> fx_phys_sectors	resb    1       ;	byte fx_phys_sectors;	 physical number of sectors per track
   140 000000B5 <res 00000002>      <2> fx_LBA_high     resw    1       ;	word fx_LBA_high;	 high word of LBA28 number of sectors
   141 000000B7 <res 00000001>      <2> fx_reserved7    resb	1	;	byte fx_reserved;	 MBZ
   142 000000B8 <res 00000001>      <2> fx_drive_control resb   1       ;	byte fx_drive_control;	 flag bits for IDE head register
   143 000000B9 <res 00000002>      <2> fx_phys_cylinders resw	1	;	word fx_phys_cylinders;	 physical number of cylinders
   144 000000BB <res 00000001>      <2> fx_phys_heads	resb	1	;	byte fx_phys_heads;	 physical number of heads
   145 000000BC <res 00000002>      <2> fx_LBA_low	resw	1	;	word fx_LBA_low;	 low word of LBA28 number of sectors
   146 000000BE <res 00000001>      <2> fx_log_sectors	resb	1	;	byte fx_log_sectors;	 logical number of sectors per track
   147 000000BF <res 00000001>      <2> fx_checksum	resb	1	;	byte fx_checksum;	 checksum, dunno how to compute
   148 000000C0 <res 00000010>      <2> fx81            resb    16	;*/	struct EDD_disk fx81;	/* fixed disk parameter area 1
   149 000000D0 <res 00000010>      <2> fx82            resb    16	;*/	struct EDD_disk fx82;	/* fixed disk parameter area 2
   150 000000E0 <res 00000010>      <2> fx83            resb    16	;*/	struct EDD_disk fx83;	/* fixed disk parameter area 3
   151                              <2> ;
   152                              <2> ;
   153                              <2> 
   154 000000F0 <res 00000002>      <2> FPEM_segment    resw    1       ;*/	word FPEM_segment;	/* FPEM data segment
   155                              <2> 
   156 000000F2 <res 00000002>      <2> EBDA_paragraph  resw    1       ;*/	word EBDA_paragraph;	/* lowest EBDA paragraph
   157                              <2> 
   158 000000F4 <res 00000002>      <2> dma0_cw         resw    1       ;*/	word dma0_cw;		/* end of dma control word
   159 000000F6 <res 00000002>      <2> dma1_cw         resw    1       ;*/	word dma1_cw;		/*   ditto
   160                              <2> 
   161 000000F8 <res 00000002>      <2> fdc_type	resb	2	;*/	byte fdc_type[2];	/* disk type in low nibble, alternate in hi nib 
   162                              <2> 
   163 000000FA <res 00000004>      <2> debug_static_ptr  resw	2	;*/	void *debug_static_ptr;	/* pointer to debug static area
   164                              <2> 
   165 000000FE <res 00000001>      <2> n_fixed_disks   resb    1       ;*/	byte n_fixed_disks;	/* number of fixed disks
   166                              <2> 
   167 000000FF <res 00000001>      <2> cpu_xtal        resb    1       ;*/	byte cpu_xtal;		/* CPU crystal frequency in Mhz 
   168                              <2> ;								   CPU clock is half of this
   169                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   170                              <2> ;
   171                              <2> ;  System configuration stuff below
   172                              <2> ;	c.f., CONFIG.ASM (ANSI.CFG, CVDU.CFG, etc.), User configuration stuff
   173                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   174                              <2> %if 0				;*/
   175                              <2> #define FIXED_DISK_MAX 4		/*
   176                              <2> %else
   177                              <2> %define FIXED_DISK_MAX 4
   178                              <2> %endif
   179                              <2> %if 0				;*/
   180                              <2> #define PPIDE_driver 1		/*
   181                              <2> %else
   182                              <2> %define PPIDE_driver 1
   183                              <2> %endif
   184                              <2> %if 0				;*/
   185                              <2> #define DIDE_driver 1		/*
   186                              <2> %else
   187                              <2> %define DIDE_driver 1
   188                              <2> %endif
   189                              <2> %if 0				;*/
   190                              <2> #define DSD_driver 1		/*
   191                              <2> %else
   192                              <2> %define DSD_driver 1
   193                              <2> %endif
   194                              <2> 				;*/
    58                              <1> 
    59                              <1> ;  this must be the same in EQUATES.H */
    60                              <1> %if SOFT_DEBUG
    61                              <1> %define NBREAK  8
    62                              <1> %endif
    63                              <1> 
    64                              <1> 
    65                              <1> %if 0
    66                              <1>         segment _TEXT
    67                              <1> ;; *************************************************************************
    68                              <1> 
    69                              <1> 
    70                              <1> 
    71                              <1> 
    72                              <1> ;; ************************ DOS Data Segment *******************************
    73                              <1> ;dosdir	SEGMENT at 50h				; Boot disk directory from IPL
    74                              <1> ;xerox	label	byte				;  0 if Print Screen idle
    75                              <1> ;						;  1 if PrtSc xeroxing screen
    76                              <1> ;						;255 if PrtSc error in xerox
    77                              <1> ;						;  ...non-grafix PrtSc in bios
    78                              <1> ;	db	200h dup(?)			; PC-DOS bootstrap procedure
    79                              <1> ;						;  ...IBMBIO.COM buffers the
    80                              <1> ;						;  ...directory of the boot
    81                              <1> ;						;  ...device here at IPL time
    82                              <1> ;						;  ...when locating the guts
    83                              <1> ;						;  ...of the operating system
    84                              <1> ;						;  ...filename "IBMDOS.COM"
    85                              <1> ;dosdir	ends
    86                              <1> ;; *************************************************************************
    87                              <1> ;; ************************ DOS IPL Segment ********************************
    88                              <1> ;dosseg	SEGMENT at 70h				; "Kernel" of PC-DOS op sys
    89                              <1> ;;IBMBIO.COM file loaded by boot block. Device Drivers/Bootstrap. CONTIGUOUS<---
    90                              <1> ;;IBMDOS.COM operating system nucleus immediately follows IBMBIO.COM and       !
    91                              <1> ;;     doesn`t have to be contiguous.  The IBMDOS operating system nucleus     !
    92                              <1> ;;     binary image is loaded by transient code in IBMBIO binary image	      !
    93                              <1> ;dosseg	ends					;			      !
    94                              <1> ;iplseg	SEGMENT at 0h				; Segment for boot block      !
    95                              <1> ;;The following boot block is loaded with 512 bytes on the first sector of     !
    96                              <1> ;;the bootable device by code resident in the ROM-resident bios.  Control is   !
    97                              <1> ;;then transferred to the first word 0000:7C00 of the disk-resident bootstrap  !
    98                              <1> ;	ORG	07C00h				;  ..offset for boot block    !
    99                              <1> ;boot	db	200h dup(?)			;  ..start disk resident boot--
   100                              <1> ;iplseg	ends
   101                              <1> 
   102                              <1> %endif
    26                                  ; number of NOPs between word reads; 0 for fastest I/O
    27                                  %define	SLOW_IO		8
    28                                  
    29                                          global  DIDE_BIOS_call_13h
    30                                          global  _DIDE_WRITE_SECTOR
    31                                          global  _DIDE_READ_SECTOR
    32                                          global  _DIDE_READ_ID
    33                                          extern  @mulLS
    34                                          extern  microsecond
    35                                  
    36                                  
    37                                  	SEGMENT	_TEXT
    38                                  	
    39                                  
    40                                  
    41                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    42                                  ;  BIOS call entry for DIDE Fixed Disk driver
    43                                  ;       int  13h
    44                                  ;
    45                                  ; The Fixed Disk driver will move the vector from 13h to 40h
    46                                  ; At the moment there is no Fixed Disk Driver
    47                                  ;
    48                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    49                                  DIDE_BIOS_call_13h:          ; Floppy driver entry
    50 00000000 FB                              sti                     ; Enable interrupts
    51 00000001 061E60                          pushm   all,ds,es       ; Standard register save
    52 00000004 89E5                            mov     bp,sp           ; establish stack addressing
    53 00000006 6A40                            push    bios_data_seg
    54 00000008 1F                              popm    ds              ; establish addressability
    55 00000009 FC                              cld
    56                                  
    57                                  	global	DIDE0_entry, DIDE1_entry
    58                                  DIDE0_entry:
    59                                  DIDE1_entry:
    60 0000000A 31DB                            xor     bx,bx           ; zero extend byte
    61 0000000C 88E3                            mov     bl,ah           ; set to index into dispatch table
    62 0000000E 80FC19                          cmp     ah,max/2
    63 00000011 7307                            jae     try_extended
    64 00000013 D1E3                            shl     bx,1            ; index words
    65                                  
    66 00000015 2EFFA7[4400]                cs  jmp     near [dispatch+bx]
    67                                  
    68                                  try_extended:
    69 0000001A 80EB41                          sub     bl,41h          ; start of extended calls
    70 0000001D 80FB0E                          cmp     bl,max41/2
    71 00000020 7307                            jae     undefined
    72 00000022 D1E3                            shl     bx,1            ; index word addresses
    73 00000024 2EFFA7[7600]                cs  jmp     near [dispatch41+bx]
    74                                  
    75                                  
    76                                  ;fn00:           ; Reset Disk System
    77                                  fn01:           ; Get Disk System Status
    78                                  ;fn02:           ; Read Sector
    79                                  ;fn03:           ; Write Sector
    80                                  ;fn04:           ; Verify Sector
    81                                  fn05:           ; Format Track
    82                                  fn06:           ; Format Bad Track (fixed disk) [PC]
    83                                  fn07:           ; Format Drive (fixed disk)     [PC]
    84                                  ;fn08:           ; Get Drive Parameters
    85                                  fn09:           ; Initialize Fixed Disk Characteristics [PC,AT,PS/2]
    86                                  fn0A:           ; Read Sector Long (fixed disk) [PC,AT,PS/2]
    87                                  fn0B:           ; Write Sector Long (fixed disk) [PC,AT,PS/2]
    88                                  fn0C:           ; Seek (fixed disk)
    89                                  fn0D:           ; Reset Fixed Disk System
    90                                  fn0E:           ; Read Sector Buffer (fixed disk) [PC only]
    91                                  fn0F:           ; Write Sector Buffer (fixed disk) [PC only]
    92                                  fn10:           ; Get Drive Status (fixed disk)
    93                                  fn11:           ; Recalibrate Drive (fixed disk)
    94                                  fn12:           ; Controller RAM Diagnostic (fixed disk) [PC/XT]
    95                                  fn13:           ; Controller Drive Diagnostic (fixed disk) [PC/XT]
    96                                  fn14:           ; Controller Internal Diagnostic (fixed disk) [PC,AT,PS/2]
    97                                  ;fn15:           ; Get Disk Type                 [AT]
    98                                  fn16:           ; Get Disk Change Status (floppy)
    99                                  fn17:           ; Set Disk Type (floppy)
   100                                  fn18:           ; Set Media Type for Format (floppy)
   101                                  
   102                                  ;fn41:           ; Check Extensions Present
   103                                  ;fn42:           ; Extended Read
   104                                  ;fn43:           ; Extended Write
   105                                  ;fn44:           ; Extended Verify
   106                                  fn45:           ; Lock/Unlock Drive
   107                                  fn46:           ; Eject Drive
   108                                  ;fn47:           ; Extended Seek
   109                                  ;fn48:           ; Get Drive Parameters
   110                                  fn49:           ; Get Extended Disk Change Status
   111                                  ;fn4E:           ; Set Hardware Configuration
   112                                  
   113                                  undefined:
   114                                  %if SOFT_DEBUG & 0
   115                                          int 0
   116                                  %endif
   117 00000029 B401                            mov     ah,ERR_invalid_command     ; Invalid command
   118 0000002B EB0A                    	jmp	error_exit
   119                                  
   120                                  good_exit:
   121 0000002D 30E4                    	xor	ah,ah			; clear the carry, AH=0
   122                                  exit_sequence:
   123 0000002F 806618FE                        and     byte [bp+offset_FLAGS],~1       ; clear the carry
   124 00000033 08E4                            or      ah,ah
   125 00000035 7404                            jz     exit_pops
   126                                  error_exit:
   127 00000037 804E1801                        or      byte [bp+offset_FLAGS],1        ; set the carry
   128                                  exit_pops:
   129 0000003B 88660F                          mov     [bp+offset_AH],ah          ; set the error code
   130 0000003E 89EC                            mov     sp,bp			; deallocate any variables
   131 00000040 611F07                          popm    ALL,ds,es
   132 00000043 CF                      	iret
   133                                  
   134                                  
   135                                  dispatch:
   136 00000044 [D302]                          dw      fn00    ; Reset Disk System
   137 00000046 [2900]                          dw      fn01    ; 
   138 00000048 [DE02]                          dw      fn02
   139 0000004A [DE02]                          dw      fn03
   140 0000004C [DE02]                          dw      fn04
   141 0000004E [2900]                          dw      fn05
   142 00000050 [2900]                          dw      fn06
   143 00000052 [2900]                          dw      fn07
   144 00000054 [2F03]                          dw      fn08
   145 00000056 [2900]                          dw      fn09
   146 00000058 [2900]                          dw      fn0A
   147 0000005A [2900]                          dw      fn0B
   148 0000005C [2900]                          dw      fn0C
   149 0000005E [2900]                          dw      fn0D
   150 00000060 [2900]                          dw      fn0E
   151 00000062 [2900]                          dw      fn0F
   152 00000064 [2900]                          dw      fn10
   153 00000066 [2900]                          dw      fn11
   154 00000068 [2900]                          dw      fn12
   155 0000006A [2900]                          dw      fn13
   156 0000006C [2900]                          dw      fn14
   157 0000006E [5603]                          dw      fn15
   158 00000070 [2900]                          dw      fn16
   159 00000072 [2900]                          dw      fn17
   160 00000074 [2900]                          dw      fn18
   161                                  max     equ     $-dispatch
   162                                  
   163                                  dispatch41:
   164 00000076 [7A03]                          dw      fn41
   165 00000078 [A103]                          dw      fn42
   166 0000007A [A103]                          dw      fn43
   167 0000007C [A103]                          dw      fn44
   168 0000007E [2900]                          dw      fn45
   169 00000080 [2900]                          dw      fn46
   170 00000082 [A103]                          dw      fn47
   171 00000084 [DE03]                          dw      fn48
   172 00000086 [2900]                          dw      fn49
   173 00000088 [2900]                          dw      undefined       ; 4A
   174 0000008A [2900]                          dw      undefined       ; 4B
   175 0000008C [2900]                          dw      undefined       ; 4C
   176 0000008E [2900]                          dw      undefined       ; 4D
   177 00000090 [5304]                          dw      fn4E
   178                                  max41   equ     $-dispatch41
   179                                  
   180                                  
   181                                  ;some symbolic constants for the ide registers, which makes the
   182                                  ;code more readable than always specifying the address pins
   183                                  
   184                                  ide_data       	equ	0		; r/w
   185                                  ide_data8	equ	ide_data	; 8-bit data transfer
   186                                  ide_err		equ	1		; read
   187                                  ide_feature	equ	1		; write
   188                                  ide_sec_cnt	equ	2
   189                                  ide_sector     	equ	3
   190                                  ide_cyl_lsb	equ	4
   191                                  ide_cyl_msb	equ	5
   192                                  ide_head       	equ	6
   193                                  ide_command	equ	7		; write
   194                                  ide_status     	equ	7		; read
   195                                  ide_data16	equ	8		; 16-bit data transfer
   196                                  ide_dmack	equ	9		; DMA acknowledge
   197                                  ide_control	equ	0Eh		; aux control port
   198                                  ide_astatus	equ	0Fh		; aux status port
   199                                  
   200                                  
   201                                  ; -----------------------------------------------------------------------------	
   202                                  ;  DIDE_READ_ID
   203                                  ; -----------------------------------------------------------------------------	
   204                                  ; Read the 512 byte ID information from the attached drive
   205                                  ;
   206                                  ;  int DIDE_READ_ID(far byte *buffer, byte slave, byte secondary);
   207                                  ;
   208                                  ;
   209                                  ;-----------------------------------------------------------------------------
   210                                  _DIDE_READ_ID:
   211 00000092 55                              push    bp
   212 00000093 89E5                            mov     bp,sp
   213 00000095 575306                          pushm   es,bx,di
   214                                  
   215 00000098 BF2004                  	mov	di,DIDE0
   216 0000009B 807E0A00                	cmp	byte ARG(4),0
   217 0000009F 7403                    	je	.0
   218 000000A1 BF3004                  	mov	di,DIDE1
   219                                  .0:
   220                                  
   221 000000A4 E81101                  	call	ide_wait_not_busy		;make sure drive is ready
   222                                  
   223 000000A7 31C0                            xor     ax,ax
   224 000000A9 31D2                            xor     dx,dx
   225 000000AB 8B4E08                          mov     cx,ARG(3)               ; select Master/Slave
   226 000000AE E88B01                          call    wr_lba                  ; select device
   227                                  
   228                                  ;;;     mov     al,ide_command
   229                                  ;;;     mov     bl,ide_cmd_id
   230                                  ;;;	call	ide_write				;ask the drive to read it
   231                                  
   232 000000B1 B0EC                    	mov	al,ide_cmd_ident
   233 000000B3 8D5507                  	lea	dx,[ide_command+di]
   234 000000B6 EE                      	out	dx,al
   235                                  
   236 000000B7 E81801                  	call	ide_wait_drq			;wait until it's got the data
   237 000000BA 7405                    	jz	.3
   238                                  
   239 000000BC B8FFFF                     	mov	ax,-1
   240 000000BF EB08                    	jmp	.9
   241                                  .3:
   242                                  
   243 000000C1 C45E04                          les     bx,ARG(1)
   244 000000C4 E82101                  	call	read_data				;grab the data
   245                                  
   246 000000C7 31C0                            xor     ax,ax
   247                                  .9:
   248 000000C9 075B5F                          popm    es,bx,di
   249 000000CC C9                              leave
   250 000000CD C3                      	ret
   251                                  
   252                                  
   253                                  	
   254                                  ; -----------------------------------------------------------------------------	
   255                                  ;  IDE_READ_SECTOR
   256                                  ; -----------------------------------------------------------------------------	
   257                                  	;read a sector, specified by the 4 bytes in "lba",
   258                                  	;Return, acc is zero on success, non-zero for an error
   259                                  ;
   260                                  ;  int IDE_READ_SECTOR(far byte *buffer, long lba_sector, byte slave);
   261                                  ;
   262                                  ;
   263                                  ;-----------------------------------------------------------------------------
   264                                  @DIDE_READ_SECTOR:
   265 000000CE 5152500653                      pushm   bx,es,ax,dx,cx
   266 000000D3 E80600                          call    _DIDE_READ_SECTOR
   267 000000D6 5B07585A59                      popm    bx,es,ax,dx,cx
   268 000000DB C3                              ret
   269                                  
   270                                  _DIDE_READ_SECTOR:
   271 000000DC 55                              push    bp
   272 000000DD 89E5                            mov     bp,sp
   273 000000DF 575306                          pushm   es,bx,di
   274                                  
   275 000000E2 8B4E0C                          mov     cx,ARG(5)
   276                                  ; set device code into DI
   277 000000E5 BF2004                  	mov	di,DIDE0
   278 000000E8 F6C102                  	test	cl,2				; check DIDE1
   279 000000EB 7403                    	jz	.0
   280 000000ED BF3004                  	mov	di,DIDE1
   281 000000F0 80E1F0                  .0:	and	cl,0F0h
   282                                  
   283 000000F3 E8C200                  	call	ide_wait_not_busy		;make sure drive is ready
   284                                  
   285 000000F6 8B4608                          mov     ax,ARG(3)
   286 000000F9 8B560A                          mov     dx,ARG(4)
   287 000000FC E83D01                  	call	wr_lba					;tell it which sector we want
   288                                  
   289                                  ;;;     mov     al,ide_command
   290                                  ;;;     mov     bl,ide_cmd_read
   291                                  ;;;	call	ide_write				;ask the drive to read it
   292                                  
   293 000000FF B020                            mov     al,ide_cmd_read
   294 00000101 8D5507                  	lea	dx,[ide_command+di]
   295 00000104 EE                      	out	dx,al
   296                                  
   297 00000105 E8CA00                  	call	ide_wait_drq			;wait until it's got the data
   298                                  ;	lxi		h, SECTOR_BUFFER
   299 00000108 7405                    	jz	.3
   300                                  
   301 0000010A B8FFFF                     	mov	ax,-1
   302 0000010D EB08                    	jmp	.9
   303                                  .3:
   304                                  
   305                                  
   306 0000010F C45E04                          les     bx,ARG(1)
   307 00000112 E8D300                  	call	read_data				;grab the data
   308                                  ;	mvi		a,0
   309 00000115 31C0                            xor     ax,ax
   310                                  .9:
   311 00000117 075B5F                          popm    es,bx,di
   312 0000011A C9                              leave
   313 0000011B C3                      	ret
   314                                  
   315                                  
   316                                  ; -----------------------------------------------------------------------------	
   317                                  ;  IDE_VERIFY_SECTOR
   318                                  ; -----------------------------------------------------------------------------	
   319                                  	;read a sector, specified by the 4 bytes in "lba",
   320                                  	;Return, acc is zero on success, non-zero for an error
   321                                  ;
   322                                  ;  int IDE_VERIFY_SECTOR(long lba_sector, byte slave);
   323                                  ;
   324                                  ;
   325                                  ;-----------------------------------------------------------------------------
   326                                  @DIDE_VERIFY_SECTOR:
   327 0000011C 515250                          pushm   ax,dx,cx
   328 0000011F E80400                          call    _DIDE_VERIFY_SECTOR
   329 00000122 585A59                          popm    ax,dx,cx
   330 00000125 C3                              ret
   331                                  
   332                                  _DIDE_VERIFY_SECTOR:
   333 00000126 55                              push    bp
   334 00000127 89E5                            mov     bp,sp
   335 00000129 575306                          pushm   es,bx,di
   336                                  
   337 0000012C 8B4E08                          mov     cx,ARG(3)
   338                                  ; set device code into DI
   339 0000012F BF2004                  	mov	di,DIDE0
   340 00000132 F6C102                  	test	cl,2				; check DIDE1
   341 00000135 7403                    	jz	.0
   342 00000137 BF3004                  	mov	di,DIDE1
   343 0000013A 80E1F0                  .0:	and	cl,0F0h
   344                                  
   345 0000013D E87800                  	call	ide_wait_not_busy		;make sure drive is ready
   346                                  
   347 00000140 8B4604                          mov     ax,ARG(1)
   348 00000143 8B5606                          mov     dx,ARG(2)
   349 00000146 E8F300                  	call	wr_lba					;tell it which sector we want
   350                                  
   351                                  ;;;     mov     al,ide_command
   352                                  ;;;     mov     bl,ide_cmd_read
   353                                  ;;;	call	ide_write				;ask the drive to read it
   354 00000149 B020                       	mov	al,ide_cmd_read
   355 0000014B 8D5507                  	lea	dx,[ide_command+di]
   356 0000014E EE                      	out	dx,al
   357                                  
   358 0000014F E88000                  	call	ide_wait_drq			;wait until it's got the data
   359                                  ;	lxi		h, SECTOR_BUFFER
   360                                  ;;        les     bx,ARG(1)
   361 00000152 E8B100                  	call	verify_data				;grab the data
   362                                  ;	mvi		a,0
   363 00000155 31C0                            xor     ax,ax
   364                                  
   365 00000157 075B5F                          popm    es,bx,di
   366 0000015A C9                              leave
   367 0000015B C3                      	ret
   368                                  
   369                                  
   370                                  ;-----------------------------------------------------------------------------
   371                                  ;  IDE_WRITE_SECTOR
   372                                  ;-----------------------------------------------------------------------------
   373                                  	;write a sector, specified by the 4 bytes in "lba",
   374                                  	;whatever is in the buffer gets written to the drive!
   375                                  	;Return, acc is zero on success, non-zero for an error
   376                                  ;
   377                                  ;  int IDE_WRITE_SECTOR(far byte *buffer, long lba_sector, byte slave);
   378                                  ;
   379                                  ;
   380                                  ;-----------------------------------------------------------------------------
   381                                  @DIDE_WRITE_SECTOR:
   382 0000015C 5152500653                      pushm   bx,es,ax,dx,cx
   383 00000161 E80600                          call    _DIDE_WRITE_SECTOR
   384 00000164 5B07585A59                      popm    bx,es,ax,dx,cx
   385 00000169 C3                              ret
   386                                  
   387                                  _DIDE_WRITE_SECTOR:
   388 0000016A 55                              push    bp
   389 0000016B 89E5                            mov     bp,sp
   390 0000016D 575306                          pushm   es,bx,di
   391                                  
   392 00000170 8B4E0C                          mov     cx,ARG(5)
   393                                  ; set device code into DI
   394 00000173 BF2004                  	mov	di,DIDE0
   395 00000176 F6C102                  	test	cl,2				; check DIDE1
   396 00000179 7403                    	jz	.0
   397 0000017B BF3004                  	mov	di,DIDE1
   398 0000017E 80E1F0                  .0:	and	cl,0F0h
   399                                  
   400 00000181 E83400                  	call	ide_wait_not_busy	;make sure drive is ready
   401                                  
   402 00000184 8B4608                          mov     ax,ARG(3)
   403 00000187 8B560A                          mov     dx,ARG(4)
   404 0000018A E8AF00                  	call	wr_lba				;tell it which sector we want
   405                                          
   406                                  ;;;	mov     al,ide_command
   407                                  ;;;     mov     bl,ide_cmd_write
   408                                  ;;;	call	ide_write			;tell drive to write a sector
   409 0000018D B030                    	mov	al,ide_cmd_write
   410 0000018F 8D5507                  	lea	dx,[ide_command+di]
   411 00000192 EE                      	out	dx,al
   412                                  
   413 00000193 E83C00                  	call	ide_wait_drq		;wait unit it wants the data
   414                                  ;	lxi		h,SECTOR_BUFFER
   415 00000196 C45E04                          les     bx,ARG(1)
   416 00000199 E88000                  	call	write_data			;give the data to the drive
   417 0000019C E81900                  	call	ide_wait_not_busy	;wait until the write is complete
   418                                  ;	mvi		a,0					;signal success
   419 0000019F 31C0                            xor     ax,ax
   420                                          
   421 000001A1 075B5F                          popm    es,bx,di
   422 000001A4 C9                              leave
   423 000001A5 C3                      	ret
   424                                  
   425                                  
   426                                  ;-----------------------------------------------------------------------------
   427                                  ; Device Control register bits
   428                                  %define  CTRL_ALWAYS    0x08
   429                                  ; bit 3 must always be asserted when written
   430                                  %define  CTRL_RESET     0x04
   431                                  %define  CTRL_nIEN      0x02
   432                                  ; interrupt enable is active when == 0
   433                                  
   434                                  ;--------ide_soft_reset-------------------------------------------------------
   435                                  ;
   436                                  ;     Do a soft reset on the drive
   437                                  ;
   438                                  ;  Call with:
   439                                  ;       DI = device code of controller
   440                                  ;
   441                                  ;  Exit with:
   442                                  ;       AX and DX are destroyed
   443                                  ;
   444                                  ;-------------------------------------------------------------------------------------------	
   445                                  ide_soft_reset:
   446 000001A6 51                              pushm   cx
   447                                  
   448 000001A7 8D550E                  	lea	dx,[ide_control+di]	; get device code of alt. control
   449 000001AA B00E                     	mov	al,CTRL_ALWAYS | CTRL_RESET | CTRL_nIEN
   450 000001AC EE                      	out	dx,al
   451                                  
   452 000001AD B9F401                          mov     cx,500                ; 500usec delay
   453 000001B0 E8(0000)                        call    microsecond
   454                                  
   455 000001B3 B00A                     	mov	al,CTRL_ALWAYS | CTRL_nIEN
   456 000001B5 EE                      	out	dx,al
   457                                  
   458 000001B6 59                              popm    cx
   459 000001B7 C3                      	ret
   460                                  
   461                                  
   462                                  ;------------------------------------------------------------------------------
   463                                  ; IDE INTERNAL SUBROUTINES 
   464                                  ;------------------------------------------------------------------------------
   465                                  
   466                                  
   467                                  
   468                                  ;-----------------------------------------------------------------------------
   469                                  ;  Wait for RDY to be set
   470                                  ;
   471                                  ;  Exit with:
   472                                  ;       AL contains status
   473                                  ;       All other registers preserved
   474                                  ;
   475                                  ;------------------------------------------------------------------------------
   476                                  ide_wait_not_busy:
   477 000001B8 52                              pushm   dx
   478                                  .1:
   479 000001B9 8D5507                  	lea	dx,[ide_status+di]
   480 000001BC EC                      	in	al,dx
   481                                  
   482 000001BD 2480                            and     al,10000000b
   483 000001BF 75F8                            jnz     .1
   484                                  
   485 000001C1 5A                              popm    dx
   486 000001C2 C3                      	ret
   487                                  
   488                                  ;------------------------------------------------------------------------------
   489                                  ;  Wait for Ready from the drive
   490                                  ;
   491                                  ;  Exit with:
   492                                  ;       AL contains status
   493                                  ;       All other registers preserved
   494                                  ;
   495                                  ;------------------------------------------------------------------------------
   496                                  ide_wait_ready:
   497 000001C3 5253                            pushm   bx,dx
   498                                  .1:
   499                                  ;;;        mov     al,ide_status           ; read status
   500                                  ;;;	call	ide_read
   501 000001C5 8D5507                  	lea	dx,[ide_status+di]
   502 000001C8 EC                      	in	al,dx
   503                                  ;;;        mov     al,bl
   504                                  
   505 000001C9 24C0                            and     al,11000000b            ;Mask off busy and ready bits
   506 000001CB 3440                            xor     al,01000000b            ;We want Busy(7) to be 0 and Ready(6) to be 1
   507 000001CD 75F6                            jnz     .1
   508                                  
   509 000001CF 5B5A                            popm    bx,dx
   510 000001D1 C3                      	ret
   511                                  
   512                                  ;------------------------------------------------------------------------------
   513                                  	;Wait for the drive to be ready to transfer data (DRQ = data request)
   514                                  	;Returns the drive's status in Acc
   515                                  ;
   516                                  ;  Exit with:
   517                                  ;       AL contains status
   518                                  ;       All other registers preserved
   519                                  ;------------------------------------------------------------------------------
   520                                  ide_wait_drq:
   521 000001D2 515253                          pushm   bx,dx,cx
   522                                  
   523 000001D5 B9FFFF                  	mov	cx,0FFFFh
   524                                  .1:
   525 000001D8 8D5507                     	lea	dx,[ide_status+di]
   526 000001DB EC                      	in	al,dx
   527                                  
   528 000001DC 2488                            and     al,10001000b		; Mask off Busy(7) and DRQ(3)
   529 000001DE 3408                            xor     al,00001000b		; We want Busy(7) to be 0 and DRQ (3) to be 1
   530                                  
   531                                  ;;        jnz     .1
   532 000001E0 E0F6                    	loopnz	.1
   533                                  
   534 000001E2 08C0                    	or	al,al
   535 000001E4 5B5A59                          popm    bx,dx,cx
   536 000001E7 C3                      	ret
   537                                  
   538                                  
   539                                  
   540                                  ;------------------------------------------------------------------------------
   541                                  	;Read a block of 512 bytes (one sector) from the drive
   542                                  	;and store it in memory @ HL
   543                                  ; Read a sector of 512 bytes into memory at ES:[BX]
   544                                  ;
   545                                  ;  Call with:
   546                                  ;       ES:BX -- pointer to the data block
   547                                  ;
   548                                  ;  Exit with:
   549                                  ;       AX and DX are destroyed; other registers preserved
   550                                  ;
   551                                  ;-----------------------------------------------------------------------------
   552                                  read_data:
   553 000001E8 5153                            pushm   bx,cx
   554                                  
   555 000001EA 8D5508                  	lea	dx,[ide_data16+di]
   556                                  
   557 000001ED 87FB                            xchg    di,bx
   558                                  
   559                                  
   560                                  %if SLOW_IO
   561 000001EF B90001                  	mov     cx,256          ; sector size in words
   562                                  rdblk2:
   563 000001F2 EC                      	in	al,dx
   564 000001F3 AA                      	stosb
   565                                  %rep SLOW_IO/8
   566                                  	nop
   567                                  %endrep
   567 000001F4 90                  <1>  nop
   568 000001F5 EC                      	in	al,dx
   569 000001F6 AA                      	stosb
   570                                  %rep	SLOW_IO
   571                                  	nop
   572                                  %endrep
   572 000001F7 90                  <1>  nop
   572 000001F8 90                  <1>  nop
   572 000001F9 90                  <1>  nop
   572 000001FA 90                  <1>  nop
   572 000001FB 90                  <1>  nop
   572 000001FC 90                  <1>  nop
   572 000001FD 90                  <1>  nop
   572 000001FE 90                  <1>  nop
   573                                  
   574 000001FF E2F1                            loop    rdblk2
   575                                  %else
   576                                  	mov     cx,512          ; sector size in bytes
   577                                  	rep	insb
   578                                  %endif
   579 00000201 87FB                    	xchg	di,bx
   580                                  
   581 00000203 5B59                            popm    bx,cx
   582 00000205 C3                      	ret
   583                                  
   584                                  ;------------------------------------------------------------------------------
   585                                  	;Read a block of 512 bytes (one sector) from the drive
   586                                  ;
   587                                  ;  Call with:
   588                                  ;       Nothing
   589                                  ;
   590                                  ;  Exit with:
   591                                  ;       AX and DX are destroyed; other registers preserved
   592                                  ;
   593                                  ;-----------------------------------------------------------------------------
   594                                  verify_data:
   595 00000206 51                              pushm   cx
   596                                  
   597 00000207 8D5508                  	lea	dx,[ide_data16+di]
   598                                  
   599 0000020A B90001                          mov     cx,256          ; sector size in words
   600                                  
   601                                  verblk2:
   602 0000020D EC                      	in	al,dx
   603                                  %rep	SLOW_IO/8
   604                                  	nop
   605                                  %endrep
   605 0000020E 90                  <1>  nop
   606 0000020F EC                      	in	al,dx
   607                                  %rep	SLOW_IO
   608                                  	nop
   609                                  %endrep
   609 00000210 90                  <1>  nop
   609 00000211 90                  <1>  nop
   609 00000212 90                  <1>  nop
   609 00000213 90                  <1>  nop
   609 00000214 90                  <1>  nop
   609 00000215 90                  <1>  nop
   609 00000216 90                  <1>  nop
   609 00000217 90                  <1>  nop
   610 00000218 E2F3                            loop    verblk2
   611                                  
   612 0000021A 59                              popm    cx
   613 0000021B C3                      	ret
   614                                  
   615                                  ;-----------------------------------------------------------------------------
   616                                  ;Write a block of 512 bytes (at HL) to the drive
   617                                  ; Write a block of 512 bytes (at ES:BX to the drive)
   618                                  ;
   619                                  ;  Call with:
   620                                  ;       ES:BX -- pointer to the data block
   621                                  ;	DI = primary or secondary base device code
   622                                  ;
   623                                  ;  Exit with:
   624                                  ;       AX and DX are destroyed; other registers preserved
   625                                  ;
   626                                  ;-----------------------------------------------------------------------------
   627                                  write_data:
   628 0000021C 1E5651                          pushm   cx,si,ds
   629                                  
   630 0000021F 06                      	push	es
   631 00000220 1F                      	popm	ds
   632                                  
   633 00000221 89DE                            mov     si,bx           ; use SI for the loads
   634 00000223 8D5508                  	lea	dx,[ide_data16+di]
   635                                  
   636                                  %if SLOW_IO
   637 00000226 B90001                          mov     cx,256          ; 256 words
   638                                  wrblk2: 
   639 00000229 AC                      	lodsb	     		; slow loop
   640 0000022A EE                      	out	dx,al
   641                                  %rep	SLOW_IO/8
   642                                  	nop
   643                                  %endrep
   643 0000022B 90                  <1>  nop
   644 0000022C AC                      	lodsb	     		; slow loop
   645 0000022D EE                      	out	dx,al
   646                                  %rep	SLOW_IO
   647                                  	nop
   648                                  %endrep
   648 0000022E 90                  <1>  nop
   648 0000022F 90                  <1>  nop
   648 00000230 90                  <1>  nop
   648 00000231 90                  <1>  nop
   648 00000232 90                  <1>  nop
   648 00000233 90                  <1>  nop
   648 00000234 90                  <1>  nop
   648 00000235 90                  <1>  nop
   649 00000236 E2F1                            loop            wrblk2
   650                                  
   651                                  
   652                                  %else
   653                                  
   654                                  
   655                                          mov     cx,512          ; 512 bytes = 256 words
   656                                  	rep	outsb		; fastest
   657                                  %endif
   658 00000238 595E1F                          popm    cx,si,ds
   659 0000023B C3                      	ret
   660                                  
   661                                  
   662                                  ;-----------------------------------------------------------------------------
   663                                  ; write the logical block address to the drive's registers
   664                                  ;
   665                                  ;  Call with:
   666                                  ;       DX:AX = logical block address
   667                                  ;       CL = Master/Slave selection in bit 4
   668                                  ;
   669                                  ;  Exit with:
   670                                  ;       AX, BX, DX are destroyed
   671                                  ;
   672                                  ;-----------------------------------------------------------------------------
   673                                  wr_lba:
   674 0000023C 50                              push    ax
   675 0000023D 52                              push    dx
   676                                  
   677 0000023E B010                            mov     al,10h          ; Master/Slave mask
   678 00000240 20C8                            and     al,cl           ; mask bit
   679 00000242 88F3                            mov     bl,dh           ; high order
   680 00000244 80E30F                          and     bl,00Fh
   681 00000247 80CBE0                          or      bl,0E0h         ; mark as LBA
   682                                  ;;;        or      bl,al           ; Select Master/Slave
   683                                  ;;;        mov     al,ide_head
   684                                  ;;;	call	ide_write
   685 0000024A 08D8                    	or	al,bl
   686 0000024C 8D5506                  	lea	dx,[ide_head+di]
   687 0000024F EE                      	out	dx,al
   688                                  	
   689 00000250 5B                              pop     bx              ; get DL to BL
   690                                  ;;;        mov     al,ide_cyl_msb
   691                                  ;;;	call	ide_write
   692 00000251 88D8                    	mov	al,bl
   693 00000253 4A                      	dec	dx
   694 00000254 EE                      	out	dx,al
   695                                  
   696 00000255 5B                              pop     bx
   697                                  ;;;        push    bx
   698                                  ;;;        mov     bl,bh
   699                                  ;;;        mov     al,ide_cyl_lsb
   700                                  ;;;	call	ide_write
   701 00000256 88F8                    	mov	al,bh
   702 00000258 4A                      	dec	dx
   703 00000259 EE                      	out	dx,al
   704                                  	
   705                                  ;;;        pop     bx              ; get LSB to BL
   706                                  ;;;        mov     al,ide_sector
   707                                  ;;;	call	ide_write
   708 0000025A 88D8                    	mov	al,bl
   709 0000025C 4A                      	dec	dx
   710 0000025D EE                      	out	dx,al
   711                                  	
   712                                  ;;;        mov     bl,1
   713                                  ;;;        mov     al,ide_sec_cnt
   714                                  ;;;	call	ide_write
   715 0000025E B001                    	mov	al,1
   716 00000260 4A                      	dec	dx
   717 00000261 EE                      	out	dx,al
   718                                  	
   719 00000262 C3                      	ret
   720                                  	
   721                                  ;-------------------------------------------------------------------------------
   722                                  
   723                                  ;-----------------------------------------------------------------------------
   724                                  ; End of DIDE disk driver
   725                                  ;
   726                                  ; Begin SBC-188 BIOS code
   727                                  ;------------------------------------------------------------------------------------	
   728                                  %ifndef STANDALONE
   729                                  	
   730                                  %include "disk.inc"
     1                              <1> ; disk.inc
     2                              <1> 
     3                              <1> 
     4                              <1> ; Standard int 13h stack frame layout is 
     5                              <1> ; created by:   PUSHM  ALL,DS,ES
     6                              <1> ;               MOV    BP,SP
     7                              <1> ;
     8                              <1> offset_DI       equ     0
     9                              <1> offset_SI       equ     offset_DI+2
    10                              <1> offset_BP       equ     offset_SI+2
    11                              <1> offset_SP       equ     offset_BP+2
    12                              <1> offset_BX       equ     offset_SP+2
    13                              <1> offset_DX       equ     offset_BX+2
    14                              <1> offset_CX       equ     offset_DX+2
    15                              <1> offset_AX       equ     offset_CX+2
    16                              <1> offset_DS       equ     offset_AX+2
    17                              <1> offset_ES       equ     offset_DS+2
    18                              <1> offset_IP       equ     offset_ES+2
    19                              <1> offset_CS       equ     offset_IP+2
    20                              <1> offset_FLAGS    equ     offset_CS+2
    21                              <1> 
    22                              <1> ; The byte registers in the stack
    23                              <1> offset_AL       equ     offset_AX
    24                              <1> offset_AH       equ     offset_AX+1
    25                              <1> offset_BL       equ     offset_BX
    26                              <1> offset_BH       equ     offset_BX+1
    27                              <1> offset_CL       equ     offset_CX
    28                              <1> offset_CH       equ     offset_CX+1
    29                              <1> offset_DL       equ     offset_DX
    30                              <1> offset_DH       equ     offset_DX+1
    31                              <1> 
    32                              <1> ; FDC error codes (returned in AH)
    33                              <1> ;
    34                              <1> ERR_no_error            equ     0       ; no error (return Carry clear)
    35                              <1> ;   everything below returns with the Carry set to indicate an error
    36                              <1> ERR_invalid_command     equ     1
    37                              <1> ERR_address_mark_not_found      equ     2
    38                              <1> ERR_write_protect       equ     3
    39                              <1> ERR_sector_not_found    equ     4
    40                              <1> ERR_disk_removed        equ     6
    41                              <1> ERR_dma_overrun         equ     8
    42                              <1> ERR_dma_crossed_64k     equ     9
    43                              <1> ERR_media_type_not_found        equ     12
    44                              <1> ERR_uncorrectable_CRC_error     equ     10h
    45                              <1> ERR_controller_failure  equ     20h
    46                              <1> ERR_seek_failed         equ     40h
    47                              <1> ERR_disk_timeout        equ     80h
    48                              <1> 
    49                              <1> 
    50                              <1> ; Packet call offsets
    51                              <1> ;
    52                              <1> pkt_size        equ     0       ; byte, size of packet (==16)
    53                              <1> pkt_reserved1   equ     1       ; byte, reserved, must be zero
    54                              <1> pkt_blocks      equ     2       ; byte, number of blocks to transfer
    55                              <1>                                 ; max is 127 (7Fh); 0 means no transfer
    56                              <1> pkt_reserved3   equ     3       ; byte; reserved, must be zero
    57                              <1> pkt_address     equ     4       ; dword; segment:offset of transfer
    58                              <1> pkt_LBA         equ     8       ; qword; LBA of transfer
    59                              <1> ; for convenience:
    60                              <1> pkt_LBA0        equ     8       ; word
    61                              <1> pkt_LBA1        equ     10      ; word
    62                              <1> pkt_LBA2        equ     12      ; word          ; MBZ
    63                              <1> pkt_LBA3        equ     14      ; word          ; MBZ
    64                              <1> 
    65                              <1> ; Parameter Packet returns:
    66                              <1> ;
    67                              <1> ;pkt_size       equ     0       ; word
    68                              <1> pkt_info        equ     2       ; word, information bits
    69                              <1>         ; bit   usage
    70                              <1>         ;  0    DMA boundary errors are handled transparently
    71                              <1>         ;  1    Geometry valid (bytes 8-12)
    72                              <1>         ;  2    Removable device (no)
    73                              <1>         ;  3    Supports Write with Verify (no)
    74                              <1>         ;  4    change line support (no)
    75                              <1>         ;  5    removable & lockable (no)
    76                              <1>         ;  6    max. geometry for a removable drive (no)
    77                              <1>         ;  7-15  MBZ
    78                              <1> pkt_phys_cyl    equ     4       ; dword, physical cylinders
    79                              <1> pkt_phys_hds    equ     8       ; dword, physical heads
    80                              <1> pkt_phys_spt    equ     12      ; dword, sectors per track
    81                              <1> pkt_sectors     equ     16      ; qword, total number of sectors
    82                              <1> pkt_bytes       equ     24      ; word, bytes per sector
    83                              <1> pkt_ptr         equ     26      ; dword, EDD configuration paramter pointer
    84                              <1>                                 ; FFFF:FFFF means invalid pointer
    85                              <1> 
    86                              <1> 
    87                              <1> 				
    88                              <1> ;------------------------------------------------------------------
    89                              <1> ;   Specific to the IDE drivers
    90                              <1> ; More symbolic constants... these should not be changed, unless of
    91                              <1> ; course the IDE drive interface changes, perhaps when drives get
    92                              <1> ; to 128G and the PC industry will do yet another kludge.
    93                              <1> 
    94                              <1> ;IDE Command Constants.  These should never change.
    95                              <1> ide_cmd_recal		equ	10H
    96                              <1> ide_cmd_read		equ	20H
    97                              <1> ide_cmd_write		equ	30H
    98                              <1> ide_cmd_init		equ	91H
    99                              <1> ide_cmd_dma_read	equ	0C8h
   100                              <1> ide_cmd_dma_write	equ	0CAh
   101                              <1> ide_cmd_spindown	equ	0E0h
   102                              <1> ide_cmd_spinup		equ	0E1h
   103                              <1> ide_cmd_ident		equ	0ECh
   104                              <1> ide_cmd_set_feature	equ	0EFh
   105                              <1> 
   106                              <1> 
   107                              <1> ; end disk.inc
   108                              <1> 
   109                              <1> 
   731                                  
   732                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   733                                  ; integrity:    Check integrity of fixed disk table
   734                                  ;
   735                                  ;  Call with:
   736                                  ;       DL = device code (80 or 81)
   737                                  ;       DS set to BIOS data area
   738                                  ;
   739                                  ;  Exit with:
   740                                  ;       DS:SI points at the fixed disk table
   741                                  ;	DI = device code
   742                                  ;
   743                                  ;  Error Exit:
   744                                  ;       If the disk table checksum is bad, give immediate error return
   745                                  ;
   746                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   747                                  integrity:
   748 00000263 5150                            pushm   ax,cx
   749                                  %if 0
   750                                          mov     al,7Fh
   751                                          and     al,dl                   ; mask out the high bit
   752                                          cmp     al,[n_fixed_disks]
   753                                  %else
   754                                  	extern	get_IDE_num
   755 00000265 E8(0000)                	call	get_IDE_num		; get number of IDE disks total
   756 00000268 88C4                    	mov	ah,al
   757 0000026A B07F                    	mov	al,7Fh
   758 0000026C 20D0                            and     al,dl                   ; mask out the high bit
   759 0000026E 38E0                    	cmp	al,ah			; compare against max
   760                                  %endif
   761 00000270 7203E9B4FD                      jae     undefined               ; harsh error exit
   762 00000275 BEB000                          mov     si,fx80
   763 00000278 B91000                          mov     cx,fx81-fx80            ; size of fixed disk table
   764 0000027B 84C0                    	test    al,al
   765 0000027D 7406                            jz      .1
   766 0000027F 01CE                    .0:	add     si,cx                   ; point at fx8?
   767 00000281 FEC8                    	dec	al
   768 00000283 75FA                    	jnz	.0
   769                                  .1:
   770 00000285 BF2004                  	mov	di,DIDE0		; first controller device code
   771 00000288 F6440802                	test	byte [fx_drive_control - fx80 + si],2
   772 0000028C 7403                    	jz	.15
   773 0000028E BF3004                  	mov	di,DIDE1		; second controller
   774                                  .15:
   775 00000291 56                              push    si
   776 00000292 B800EE                          mov     ax,0EE00h               ; error code and zero checksum
   777                                  
   778 00000295 0204                    .2:     add     al,[si]                 ; compute checksum
   779 00000297 46                              inc     si
   780 00000298 E2FB                            loop    .2                      ; loop back
   781                                  
   782 0000029A 5E                              pop     si
   783 0000029B 08C0                            or      al,al                   ; test AL for zero
   784 0000029D 7403E995FD                      jnz     error_exit              ; BIOS data area clobbered
   785                                  
   786 000002A2 5859                            popm    ax,cx
   787 000002A4 C3                              ret
   788                                  
   789                                  
   790                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   791                                  ; cv_lba        Convert CHS in CX & DX to LBA address in DX:AX
   792                                  ;
   793                                  ;  Call with:
   794                                  ;       DS:SI points to fixed disk table
   795                                  ;       CX & DX are CHS input parameters
   796                                  ;
   797                                  ;  Exit with:
   798                                  ;       DX:AX is the corresponding LBA address
   799                                  ;       BX and CX are modified
   800                                  ;
   801                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   802                                  cv_lba:
   803 000002A5 89C8                            mov     ax,cx           ; cylinder info to AX
   804 000002A7 C0C002                          rol     al,2            ; position high 2 bits
   805 000002AA 2403                            and     al,3            ; mask 2 bits
   806 000002AC 86C4                            xchg    al,ah           ; AX = cylinder number
   807 000002AE C1EA08                          shr     dx,8            ; heads to DL   DH=0
   808                                  
   809 000002B1 89D3                            mov     bx,dx           ; heads to BX
   810 000002B3 8A5402                          mov     dl,[fx_log_heads - fx80 + si]   ; may be 0, meaning 256
   811 000002B6 FECA                            dec     dl
   812 000002B8 42                              inc     dx              ; recover 256 !!!
   813                                  
   814 000002B9 F7E2                            mul     dx
   815 000002BB 01D8                            add     ax,bx           ; add in the head number
   816 000002BD 83D200                          adc     dx,0            ; **
   817                                  
   818 000002C0 8A5C0E                          mov     bl,[fx_log_sectors - fx80 + si]    ; BH is already 0
   819 000002C3 51                              push    cx
   820 000002C4 E8(0000)                        call    @mulLS          ; DX:AX = DX:AX * BX
   821 000002C7 59                              pop     cx
   822 000002C8 FEC9                            dec     cl              ; sector address is from 1, not 0
   823 000002CA 83E13F                          and     cx,63
   824 000002CD 01C8                            add     ax,cx           ; add in sector number
   825 000002CF 83D200                          adc     dx,0            ; **
   826 000002D2 C3                              ret
   827                                  
   828                                  
   829                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   830                                  ; fn00 -- Reset the Disk Subsystem
   831                                  ;
   832                                  ;  Call with:
   833                                  ;       AH = 0  function code
   834                                  ;
   835                                  ;  Exit with:
   836                                  ;       Nothing
   837                                  ;
   838                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   839                                  fn00:
   840 000002D3 E88DFF                          call    integrity       ; perhaps no subsystem
   841 000002D6 E8CDFE                          call    ide_soft_reset  ; do the dirty
   842 000002D9 B400                            mov     ah,0
   843 000002DB E951FD                          jmp     exit_sequence
   844                                  
   845                                  
   846                                  
   847                                  
   848                                  
   849                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   850                                  ; fn02 -- Disk Read
   851                                  ; fn03 -- Disk Write
   852                                  ; fn04 -- Disk Verify
   853                                  ;
   854                                  ;  Enter with:
   855                                  ;       AH = 2 (read)
   856                                  ;       AH = 3 (write)
   857                                  ;       AH = 4 (verify)
   858                                  ;       AL = number of sectors to transfer
   859                                  ;       CH = low 8 bits of cylinder number
   860                                  ;       CL = sector number & high 2 bits of sector number
   861                                  ;       DH = head number
   862                                  ;       DL = device code
   863                                  ;       ES:BX = buffer to receive/provide the data (except on verify)
   864                                  ;
   865                                  ;  Exit with:
   866                                  ;       AH = success(0) or error code
   867                                  ;       Carry flag set, if error; clear otherwise
   868                                  ;
   869                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   870                                  fn02:
   871                                  fn03:
   872                                  fn04:
   873 000002DE E882FF                          call    integrity       ; set pointer to Fixed Disk Table in SI
   874 000002E1 E8C1FF                          call    cv_lba          ; convert to LBA address in DX:AX
   875 000002E4 8A4C08                          mov     cl,[fx_drive_control - fx80 + si]
   876 000002E7 8A6E0E                          mov     ch,[bp + offset_AL]      ; get sector count
   877 000002EA 8B5E08                          mov     bx,[bp + offset_BX]      ; get transfer address
   878                                  
   879                                  ; Enter here on Read, Write, Verify or
   880                                  ;     extended  Read, Write, Verify, Seek
   881                                  RWV: 
   882 000002ED FEC5                            inc     ch                      ; zero is valid for no transfer
   883 000002EF EB30                            jmp     .6              ; enter loop at the bottom
   884                                  ; the read/write/verify loop
   885                                  .1:
   886 000002F1 F6C140                          test    cl,40h          ; test LBA bit in drive control
   887 000002F4 7431                            jz      .7
   888                                  ; LBA call is okay
   889 000002F6 F6460F04                        test    byte [bp+offset_AH],04h         ; Seek/Verify?
   890 000002FA 7510                            jnz     .4
   891 000002FC F6460F01                        test    byte [bp+offset_AH],01h         ; Write?
   892 00000300 7505                            jnz     .3
   893 00000302 E8C9FD                  .2:     call    @DIDE_READ_SECTOR
   894 00000305 EB08                            jmp     .5
   895 00000307 E852FE                  .3:     call    @DIDE_WRITE_SECTOR
   896 0000030A EB03                            jmp     .5
   897 0000030C E80DFE                  .4:     call    @DIDE_VERIFY_SECTOR
   898                                  
   899                                  .5:
   900 0000030F 83C001                          add     ax,1            ; increment the LBA address
   901 00000312 83D200                          adc     dx,0            ; **
   902 00000315 80C702                          add     bh,2            ; add 512 == 200h to the BX
   903 00000318 7307                            jnc     .6
   904 0000031A 8CC7                            mov     di,es
   905 0000031C 83C710                          add     di,10h
   906 0000031F 8EC7                            mov     es,di           ; update the segment register
   907 00000321 FECD                    .6:     dec     ch
   908 00000323 75CC                            jnz     .1
   909 00000325 EB03                            jmp     .8
   910                                  
   911                                  ; CHS call is required
   912 00000327 E8FFFC                  .7:     call    undefined
   913                                  
   914                                  .8:     
   915 0000032A 30E4                            xor     ah,ah
   916 0000032C E900FD                          jmp     exit_sequence
   917                                  
   918                                  
   919                                  
   920                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   921                                  ; fn08  --  Get Drive Parameters
   922                                  ;
   923                                  ;  Call with:
   924                                  ;       AH = 8  function code
   925                                  ;       DL = drive code (80h, 81h, ...)
   926                                  ;
   927                                  ;  Exit with:
   928                                  ;       CH = maximum cylinder number (low 8 bits)
   929                                  ;       CL = max. sector number; max. cyl in high 2 bits
   930                                  ;       DH = maximum head number
   931                                  ;       DL = number of fixed disks
   932                                  
   933                                  ;       AH = 0  and Carry is clear on success
   934                                  ;       AH = error code; Carry set on error
   935                                  ;
   936                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   937                                  fn08:           ; Get Drive Parameters
   938 0000032F C6460A00                        mov     byte [bp + offset_DL],0         ; say no fixed disks
   939                                  
   940 00000333 E82DFF                          call    integrity       ; bad device code or no fixed disks
   941                                  
   942 00000336 8B04                            mov     ax,[fx_log_cylinders - fx80 + si]
   943 00000338 48                              dec     ax
   944 00000339 C0E406                          shl     ah,6
   945 0000033C 0A640E                          or      ah,[fx_log_sectors - fx80 + si]
   946 0000033F 86C4                            xchg    al,ah
   947 00000341 89460C                          mov     [bp + offset_CX],ax
   948 00000344 8A7402                          mov     dh,[fx_log_heads - fx80 + si]
   949 00000347 FECE                            dec     dh
   950                                  %if 0
   951                                          mov     dl,[n_fixed_disks]      ; return parameter
   952                                  %else
   953 00000349 E8(0000)                	call	get_IDE_num		; get number of IDE disks
   954 0000034C 88C2                    	mov	dl,al
   955                                  %endif
   956 0000034E 89560A                          mov     [bp + offset_DX],dx
   957                                  
   958 00000351 30E4                            xor     ah,ah
   959 00000353 E9D9FC                          jmp     exit_sequence
   960                                  
   961                                  
   962                                          
   963                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   964                                  ; fn15 -- Get Disk Type
   965                                  ;
   966                                  ;  Call With:
   967                                  ;       AH = 15   function code
   968                                  ;       DL = device code (80h or 81h)
   969                                  ;
   970                                  ;  Exit With:
   971                                  ;     If successful, Carry is clear
   972                                  ;       AH = 3  indicating a hard disk
   973                                  ;       CX:DX   number of hard disk sectors
   974                                  ;
   975                                  ;     If unsuccessful, Carry is set
   976                                  ;
   977                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   978                                  fn15:
   979 00000356 E80AFF                          call    integrity       ; sets DS:SI
   980 00000359 8B04                            mov     ax,[fx_log_cylinders - fx80 + si]
   981 0000035B 8A5C02                          mov     bl,[fx_log_heads - fx80 + si]
   982 0000035E 30FF                            xor     bh,bh
   983 00000360 FECB                            dec     bl              ; 00 means 256
   984 00000362 43                              inc     bx              ; do the conversion
   985 00000363 F7E3                            mul     bx              ; cyls * heads
   986 00000365 8A5C0E                          mov     bl,[fx_log_sectors - fx80 + si]
   987 00000368 30FF                            xor     bh,bh
   988 0000036A E8(0000)                        call    @mulLS          ; cyls * heads * sectors
   989 0000036D 89560C                          mov     word [bp+offset_CX],dx  ; high order
   990 00000370 89460A                          mov     word [bp+offset_DX],ax  ; low order word
   991 00000373 C6460F03                        mov     byte [bp+offset_AH],3   ; code for HARD DISK
   992 00000377 E9B3FC                          jmp     good_exit
   993                                  
   994                                  
   995                                  
   996                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   997                                  ; fn41 -- Check Extensions Present
   998                                  ;
   999                                  ;  Call With:
  1000                                  ;       AH = 41h        function code
  1001                                  ;       BX = 55AAh      magic number
  1002                                  ;       DL = drive code (80h or 81h)
  1003                                  ;
  1004                                  ;  Exit With:
  1005                                  ;     carry clear
  1006                                  ;       AH = 21h        version 1.1 support
  1007                                  ;       BX = AA55h      magic number II
  1008                                  ;       CX = 0001b  bit0=packet support; bit2=EDD drive support
  1009                                  ;
  1010                                  ;     carry set
  1011                                  ;       AH = 01h        Invalid Command
  1012                                  ;
  1013                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1014                                  fn41:
  1015 0000037A E8E6FE                          call    integrity       ; test drive number (sets DS:SI)
  1016 0000037D 817E08AA55                      cmp     word [offset_BX + bp],55AAh
  1017 00000382 7403E9A2FC                      jne     undefined
  1018 00000387 F6440840                        test    byte [fx_drive_control - fx80 + si],40h         ; test LBA bit
  1019 0000038B 7503E999FC                      jz      undefined
  1020                                  
  1021 00000390 C6460F21                        mov     byte [offset_AH + bp],21h       ; version 1.1
  1022 00000394 C7460855AA                      mov     word [offset_BX + bp],0AA55h    ; magic number II
  1023 00000399 C7460C0500                      mov     word [offset_CX + bp],00000101b       ; packet calls & EDD i/f
  1024 0000039E E98CFC                          jmp     good_exit
  1025                                  
  1026                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1027                                  ; fn42 -- Extended Read
  1028                                  ; fn43 -- Extended Write
  1029                                  ; fn44 -- Extended Verify
  1030                                  ; fn47 -- Extended Seek (implement as Verify)
  1031                                  ;
  1032                                  ;  Call With:
  1033                                  ;       AH = function code
  1034                                  ;       AL = 0,1 write with no verify; 2 write with verify
  1035                                  ;            not used for Read or Verify
  1036                                  ;       DL = drive number (80h or 81h)
  1037                                  ;       [DS:SI] was disk packet address; will be used in ES:BX
  1038                                  ;
  1039                                  ;  Exit With:
  1040                                  ;       AH = 0 (no error) and Carry Clear
  1041                                  ;       AH = error code and Carry Set
  1042                                  ;     The block count field is updated with the number of blocks
  1043                                  ;     correctly transferred/verified before the error occurred.
  1044                                  ;
  1045                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1046                                  fn42:
  1047                                  fn43:
  1048                                  fn44:
  1049                                  fn47:
  1050 000003A1 E8BFFE                          call    integrity       ; set pointer to Fixed Disk Table in SI
  1051 000003A4 8E4610                          mov     es,[bp + offset_DS]     ; packet pointer
  1052 000003A7 8B5E02                          mov     bx,[bp + offset_SI]     ; **
  1053 000003AA 26803F10                   es   cmp     byte [bx + pkt_size],16 ; check for correct size
  1054 000003AE 7303E976FC                      jb      undefined
  1055                                  
  1056 000003B3 268B470E                   es   mov     ax,[bx + pkt_LBA3]      ; LBA address
  1057 000003B7 260B470C                   es   or      ax,[bx + pkt_LBA2]      ; LBA address
  1058 000003BB 7403E969FC                      jnz     undefined
  1059 000003C0 268B4708                   es   mov     ax,[bx + pkt_LBA0]      ; LBA address
  1060 000003C4 268B570A                   es   mov     dx,[bx + pkt_LBA1]      ; LBA address hi
  1061                                  
  1062 000003C8 B501                            mov     ch,1                    ; assume Seek
  1063 000003CA 807E0F47                        cmp     byte [offset_AH + bp],47h       ; Seek?
  1064 000003CE 7404                            je      .7
  1065 000003D0 268A6F02                   es   mov     ch,[bx + pkt_blocks]    ; sector count
  1066                                  .7:
  1067 000003D4 8A4C08                          mov     cl,[fx_drive_control - fx80 + si]
  1068 000003D7 26C45F04                   es   les     bx,[bx + pkt_address]   ; get transfer address
  1069                                  
  1070 000003DB E90FFF                          jmp     RWV             ; common read/write/verify code
  1071                                  
  1072                                  
  1073                                          
  1074                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1075                                  ; fn48 -- Get Drive Parameters
  1076                                  ;
  1077                                  ;  Call With:
  1078                                  ;       AH = 48h        function code
  1079                                  ;       DL = drive number
  1080                                  ;       DS:SI = pointer to return buffer (26 or 30 bytes)
  1081                                  ;
  1082                                  ;  Exit With:
  1083                                  ;       AH = 0 and carry clear
  1084                                  ;       results in the buffer
  1085                                  ;
  1086                                  ;       AH = error code and carry set
  1087                                  ;
  1088                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1089                                  fn48:
  1090 000003DE E882FE                          call    integrity               ; set DS:SI
  1091 000003E1 8E4610                          mov     es,[bp + offset_DS]     ; packet pointer
  1092 000003E4 8B5E02                          mov     bx,[bp + offset_SI]     ; **
  1093 000003E7 B9FFFF                          mov     cx,0FFFFh               ; CX = -1  (FFFFh)
  1094 000003EA B81A00                          mov     ax,pkt_ptr              ; AX = 26
  1095 000003ED 263907                     es   cmp     [bx + pkt_size],ax      ; check for correct size = 26
  1096 000003F0 7303E934FC                      jb      undefined
  1097 000003F5 83C004                          add     ax,4
  1098 000003F8 263907                     es   cmp     [bx + pkt_size],ax      ; check for correct size = 30
  1099 000003FB 7208                            jb      .1
  1100 000003FD 26894F1A                   es   mov     [bx + pkt_ptr],cx       ; flag invalid pointer
  1101 00000401 26894F1C                   es   mov     [bx + pkt_ptr+2],cx     ; **
  1102                                  .1:
  1103 00000405 268907                     es   mov     [bx + pkt_size],ax      ; set the returned size
  1104                                  
  1105 00000408 41                              inc     cx                      ; CX = 0
  1106 00000409 26C747020300               es   mov     word [bx + pkt_info], 000011b   ; DMA bound/ Geom OK
  1107                                  
  1108 0000040F 8B4409                          mov     ax,[fx_phys_cylinders - fx80 + si]      ; cylinders
  1109 00000412 26894704                   es   mov     [bx + pkt_phys_cyl],ax  
  1110 00000416 26894F06                   es   mov     [bx + pkt_phys_cyl+2],cx
  1111                                  
  1112 0000041A 8A440B                          mov     al,[fx_phys_heads - fx80 + si]          ; heads
  1113 0000041D 88EC                            mov     ah,ch
  1114 0000041F 26894708                   es   mov     [bx + pkt_phys_hds],ax  
  1115 00000423 26894F0A                   es   mov     [bx + pkt_phys_hds+2],cx
  1116                                  
  1117 00000427 8A4404                          mov     al,[fx_phys_sectors - fx80 + si]        ; sectors
  1118 0000042A 2689470C                   es   mov     [bx + pkt_phys_spt],ax  
  1119 0000042E 26894F0E                   es   mov     [bx + pkt_phys_spt+2],cx
  1120                                  
  1121 00000432 8B440C                          mov     ax,[fx_LBA_low - fx80 + si]             ; total LBA sectors
  1122 00000435 26894710                   es   mov     [bx + pkt_sectors],ax                   ; total sectors
  1123 00000439 8B4405                          mov     ax,[fx_LBA_high - fx80 + si]            ; **
  1124 0000043C 26894712                   es   mov     [bx + pkt_sectors+2],ax                 ; **
  1125 00000440 26894F14                   es   mov     [bx + pkt_sectors+4],cx                 ; **
  1126 00000444 26894F16                   es   mov     [bx + pkt_sectors+6],cx                 ; **
  1127 00000448 26C747180002               es   mov     word [bx + pkt_bytes],512               ; sector size
  1128 0000044E B400                            mov     ah,0
  1129 00000450 E9DCFB                          jmp     exit_sequence
  1130                                  
  1131                                  
  1132                                  
  1133                                          
  1134                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1135                                  ; fn4E -- set hardware configuration
  1136                                  ;
  1137                                  ;  Call With:
  1138                                  ;       AH = 4Eh        function code
  1139                                  ;       AL = hardware function sub-code
  1140                                  ;       DL = drive number
  1141                                  ;
  1142                                  ;  Exit With:
  1143                                  ;       AH = 0          carry is clear
  1144                                  ;       AL = 1          other devices affected
  1145                                  ;
  1146                                  ;       AH = error code and carry is set
  1147                                  ;
  1148                                  ;  This operation is a complete No-Op for the DIDE
  1149                                  ;
  1150                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1151                                  fn4E:
  1152 00000453 E80DFE                          call    integrity
  1153 00000456 B80100                          mov     ax,0001h
  1154 00000459 E9D3FB                          jmp     exit_sequence
  1155                                  
  1156                                  
  1157                                  
  1158                                  
  1159                                  %endif  ; STANDALONE
  1160                                  
  1161                                  
