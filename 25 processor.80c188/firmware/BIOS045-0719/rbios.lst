     1                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     2                                  ; RBIOS.ASM -- Relocatable BIOS for the RetroBrew SBC-188 v.00.4 to 00.7
     3                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     4                                  ;
     5                                  ;   This version is for assembly by  NASM 0.98.39 or later
     6                                  ;
     7                                  ; Copyright (C) 2011-2017 John R. Coffman.  All rights reserved.
     8                                  ; Provided for hobbyist use on the RetroBrew SBC-188 board.
     9                                  ;
    10                                  ; This program is free software: you can redistribute it and/or modify
    11                                  ; it under the terms of the GNU General Public License as published by
    12                                  ; the Free Software Foundation, either version 3 of the License, or
    13                                  ; (at your option) any later version.
    14                                  ;
    15                                  ; This program is distributed in the hope that it will be useful,
    16                                  ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    17                                  ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    18                                  ; GNU General Public License for more details.
    19                                  ;
    20                                  ; You should have received a copy of the GNU General Public License
    21                                  ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    22                                  ;
    23                                  ;
    24                                  ; SBC-188 board revisions:
    25                                  ;       00.4    prototype board
    26                                  ;       00.5    00.4 board + memory select mod
    27                                  ;       00.6    00.4 board + timer & SRDY mods
    28                                  ;       00.7    00.4 board + FDC /DACK & TC mod
    29                                  ; ----------------------------------------------------------------
    30                                  ;       1.0     production board
    31                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    32                                  
    33                                  	cpu	186
    34                                  
    35                                  
    36                                  
    37                                  
    38                                  %include	"config.asm"
     1                              <1> ;/*
     2                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     3                              <1> ; VGA3.CFG
     4                              <1> ;   Copied to CONFIG.ASM for general release.
     5                              <1> ;
     6                              <1> ;       Modify the parameters below to reflect your system
     7                              <1> ;
     8                              <1> ;
     9                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    10                              <1> ;
    11                              <1> ;   Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    12                              <1> ;   Provided for hobbyist use on the N8VEM SBC-188 board.
    13                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    14                              <1> ;
    15                              <1> ; Define the serial terminal that the Video BIOS must emulate
    16                              <1> ; Set one of the following to 1
    17                              <1> ; If you have no idea what to choose, set TTY to 1
    18                              <1> TTY     equ     0       ; hardcopy -- cannot position the cursor
    19                              <1> DUMB    equ     0       ; dumb CRT -- ^H, ^J, ^K, ^L can move the cursor
    20                              <1> ANSI    equ     1       ; very smart, like a VT-100
    21                              <1> WYSE    equ     0       ; very smart Wyse series (30, 50, ...)
    22                              <1> ; others may get added in the future
    23                              <1> ;  ONE OF THE ABOVE must BE SET TO 1!!!!!
    24                              <1> ;
    25                              <1> ; Does the hardware configuration contain the Color Video Display Unit?
    26                              <1> ; Both the 8563 and the 8242 are used.  The default is CVDU=0
    27                              <1> CVDU	equ	0	; system does not have the CVDU
    28                              <1> ;
    29                              <1> ; Does the hardware configuration contain the VGA3 a/n Video card?
    30                              <1> ; The 8563 will be disabled, but the 8242 code is shared with the CVDU
    31                              <1> ; The default is VGA3=0
    32                              <1> VGA3   equ     1       ; system has the VGA3
    33                              <1> ;
    34                              <1> ; Does the hardware configuration contain the front panel card?
    35                              <1> ; The default is FRONT_PANEL=0
    36                              <1> ;
    37                              <1> FRONT_PANEL   equ     1       ; system has the VGA3
    38                              <1> %if 0
    39                              <1> 	*/
    40                              <1> #define VGA3 1
    41                              <1> /*
    42                              <1> %endif
    43                              <1> ;
    44                              <1> ; Boot up keyboard mode:  20h for NumLock on
    45                              <1> ;CVDU_KEYBOARD_STATUS	equ	0	; NumLock OFF
    46                              <1> CVDU_KEYBOARD_STATUS	equ	20h	; NumLock ON
    47                              <1> 
    48                              <1> ; Define the UART startup bit rate - 1200-19200 are most common
    49                              <1> ;UART_RATE	equ	0		; 1200
    50                              <1> ;UART_RATE	equ	1		; 2400
    51                              <1> ;UART_RATE	equ	2		; 4800
    52                              <1> ;UART_RATE	equ	3		; 9600
    53                              <1> ;UART_RATE	equ	4		; 19200
    54                              <1> UART_RATE	equ	5		; 38400
    55                              <1> ;UART_RATE	equ	6		; 57600
    56                              <1> ;UART_RATE	equ	7		; 115200
    57                              <1> 
    58                              <1> ; Does the serial terminal use the DSR/DTR protocol for flow control?
    59                              <1> ;UART_DSR_PROTOCOL	equ		1	; Yes!
    60                              <1> UART_DSR_PROTOCOL       equ             WYSE    ; Wyse always uses it
    61                              <1> 						; but not ANSI
    62                              <1> ; Define the size of the ROM image on the system in Kilobytes
    63                              <1> ; It may be smaller than the actual EPROM in use.
    64                              <1> ; The following sizes are supported:  32, 64, 128, and 256
    65                              <1> %ifndef ROM
    66                              <1> ROM             equ     32              ; 64 is the default
    67                              <1> %endif
    68                              <1> 
    69                              <1> ; Define the number of Wait States at which the ROM operates
    70                              <1> ROM_WS          equ     1               ; 0..3  (1 is the default)
    71                              <1> 
    72                              <1> ; Define the size in Kilobytes of DOS RAM (low SRAM plus EMM allocate RAM)
    73                              <1> ; This is a desired size and will only be present if a 4MEM board is added
    74                              <1> RAM_DOS         equ     640
    75                              <1> 
    76                              <1> ; Define the size of the low SRAM on the system in Kilobytes
    77                              <1> ; the default is 512 kilobytes
    78                              <1> RAM             equ     512             ; (512 is the default)
    79                              <1> 
    80                              <1> ; Define the number of Wait States at which the RAM operates
    81                              <1> RAM_WS          equ     0               ; 0..3  (0 is the default)
    82                              <1> 
    83                              <1> ; Define the number of Wait States for Local Peripheral devices (600-7FF)
    84                              <1> LCL_IO_WS       equ     1               ; 0..3  (1 is the default)
    85                              <1> 
    86                              <1> ; Define the number of Wait States for ECB BUS peripheral devices (4xx)
    87                              <1> BUS_IO_WS       equ     3               ; 0..3  (3 is the default)
    88                              <1> 
    89                              <1> ; Define the time zone in which we build the Relocatable BIOS
    90                              <1> %ifndef TIMEZONE
    91                              <1> %define TIMEZONE "CDT"
    92                              <1> %endif
    93                              <1> 
    94                              <1> ; Has the REDBUG debugger been loaded?
    95                              <1> %ifndef SOFT_DEBUG
    96                              <1> %define SOFT_DEBUG 0
    97                              <1> %endif
    98                              <1> 
    99                              <1> ; Should the BIOS include "Tiny BASIC" in the image?
   100                              <1> %ifndef TBASIC
   101                              <1> TBASIC          equ     1		; default is 1
   102                              <1> %endif
   103                              <1> 
   104                              <1> ; Should the BIOS include the Floating Point Emulator?  The 80188 does
   105                              <1> ; not allow a floating point co-processor, so this is probably a good idea.
   106                              <1> %ifndef FPEM
   107                              <1> FPEM            equ     1               ; default is 1
   108                              <1> %endif
   109                              <1> 
   110                              <1> ; Define the maximum number of EMM (4MEM) boards supported
   111                              <1> EMM_BOARDS      equ     4
   112                              <1> 
   113                              <1> ; Should the Floating Point Emulator use temporary storage in the EBDA
   114                              <1> ; or at locations 0280h..3FFh in low memory?
   115                              <1> %if SOFT_DEBUG
   116                              <1> FPEM_USE_EBDA   equ     FPEM            ; default is 0
   117                              <1> %else
   118                              <1> FPEM_USE_EBDA   equ     0; FPEM            ; default is 0
   119                              <1> %endif
   120                              <1> 
   121                              <1> ; Define the size of the EPROM that is to be installed on the system
   122                              <1> ; It may be larger than the actual ROM image to be generated.
   123                              <1> %ifndef CHIP
   124                              <1> CHIP            equ     64
   125                              <1> %endif
   126                              <1> 
   127                              <1> ; Does the SBC-188 00.4 board have the LS138/LS08 piggyback fix
   128                              <1> ; Set to 1 for the SBC-188 v1.0 and later production boards
   129                              <1> FDC_PIGGYBACK_FIX       equ     0       ; Fix not installed
   130                              <1> ;FDC_PIGGYBACK_FIX       equ     1       ; fix  IS  installed
   131                              <1> 
   132                              <1> ; On SBC-188 rev 00.4 board, there is a published hardware fix (2010-09-18).
   133                              <1> ; If the wiring update is installed, or you have a later board, then
   134                              <1> ; set this to 0.  If you are using the software workaround, then set this
   135                              <1> ; to 1.  The rev 1.0 board has this fix already.
   136                              <1> NEED_TIMER_FIX  equ     0               ; have revised hardware
   137                              <1> ;NEED_TIMER_FIX  equ     1               ; use workaround
   138                              <1> 
   139                              <1> ; Define the UART oscillator speed
   140                              <1> UART_OSC        equ     1843200         ; 1.8432 Mhz is specified
   141                              <1> 
   142                              <1> 
   143                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   144                              <1> ; end of the User configuration
   145                              <1> ;       Do Not modify anything below this point
   146                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   147                              <1> 
   148                              <1> CVDU_8563	equ	CVDU		; separate inits
   149                              <1> CVDU_8242	equ	CVDU|VGA3 	; separate inits
   150                              <1> VGA3_6445       equ     VGA3            ; separate inits
   151                              <1> ; Suppress all UART output in color video Mode 3
   152                              <1> ;UART_MODE3_SUPPRESS	equ	0
   153                              <1> UART_MODE3_SUPPRESS	equ	CVDU_8563 | VGA3_6445
   154                              <1> CVDU_USE_MSDOS_KLUDGE	equ	0; CVDU_8242	; bad, bad MSDOS
   155                              <1> CVDU_USE_KBD_HOOK		equ	CVDU_8242
   156                              <1> 
   157                              <1> ; Define existence of any uart chip
   158                              <1> UART		equ	TTY+DUMB+ANSI+WYSE
   159                              <1> startuplength   equ     128                     ; may be up to 1024
   160                              <1> startseg        equ     0FFFFh - (ROM*64) + 1
   161                              <1> highrom         equ     (ROM*400h)&0FFFFh
   162                              <1> startupseg      equ     0FFFFh - (startuplength>>4) + 1
   163                              <1> bios_data_seg   equ     040h            ; segment of BIOS data area
   164                              <1> 
   165                              <1> 
   166                              <1> %define ARG(n) [bp+2+(n)*2]
   167                              <1> 
   168                              <1> %macro  check   1.nolist
   169                              <1>  %if (%1)
   170                              <1>    %error Check Failure: %1
   171                              <1>  %endif
   172                              <1> %endm
   173                              <1> %macro  range   3.nolist
   174                              <1>  %if (%1)<(%2)
   175                              <1>    %error Out of Range: %1
   176                              <1>  %elif (%1)>(%3)
   177                              <1>    %error Out of Range: %1
   178                              <1>  %endif
   179                              <1> %endm
   180                              <1> _terminal equ UART+CVDU
   181                              <1>  check   RAM_DOS&15
   182                              <1>  check   RAM&(RAM-1)
   183                              <1>  check   ROM&(ROM-1)
   184                              <1>  range   RAM,32,512
   185                              <1>  range   ROM,32,256
   186                              <1>  range   RAM_WS,0,3
   187                              <1>  range   ROM_WS,0,3
   188                              <1>  range   RAM_DOS,RAM,(1024-ROM)
   189                              <1>  range   LCL_IO_WS,0,3
   190                              <1>  range   BUS_IO_WS,0,3
   191                              <1>  range   UART_OSC,500000,16000000
   192                              <1>  range   UART_RATE,0,7
   193                              <1>  range	 UART,0,1
   194                              <1>  range	 _terminal,1,2
   195                              <1> 
   196                              <1> %ifndef SOFT_DEBUG
   197                              <1> %define SOFT_DEBUG 0
   198                              <1> %endif
   199                              <1> 
   200                              <1> %ifndef TRACE
   201                              <1> %define TRACE 0
   202                              <1> %endif
   203                              <1> 
   204                              <1> %ifdef MAKE_OBJECT_FILE
   205                              <1>         segment _DATA WORD PUBLIC CLASS=DATA
   206                              <1>         export _ROMsize
   207                              <1>         export _CHIPsize
   208                              <1> _ROMsize        dw      ROM
   209                              <1> _CHIPsize       dw      CHIP
   210                              <1> %endif
   211                              <1> ; end of the Hardware configuration file
   212                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   213                              <1> ;*/
    39                                  %include	"cpuregs.asm"
     1                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     2                              <1> ; CPUREGS.ASM
     3                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     4                              <1> ;
     5                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
     6                              <1> ;
     7                              <1> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
     8                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
     9                              <1> ;
    10                              <1> ; This program is free software: you can redistribute it and/or modify
    11                              <1> ; it under the terms of the GNU General Public License as published by
    12                              <1> ; the Free Software Foundation, either version 3 of the License, or
    13                              <1> ; (at your option) any later version.
    14                              <1> ;
    15                              <1> ; This program is distributed in the hope that it will be useful,
    16                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    17                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    18                              <1> ; GNU General Public License for more details.
    19                              <1> ;
    20                              <1> ; You should have received a copy of the GNU General Public License
    21                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    22                              <1> ;
    23                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    24                              <1>         cpu     186
    25                              <1> ;
    26                              <1> ;
    27                              <1> ; IBM model byte -- must be less than a 286
    28                              <1> ;
    29                              <1> ;MODEL_BYTE		equ	0FEh	; PC-XT
    30                              <1> ;SUBMODEL_BYTE		equ	0FFh	; not used
    31                              <1> 
    32                              <1> MODEL_BYTE		equ	0FEh	; PC-XT
    33                              <1> SUBMODEL_BYTE		equ	00h	;  "
    34                              <1> 
    35                              <1> 
    36                              <1> ; 80188 peripheral control register block address
    37                              <1> CPU_CSCR	        equ	0FF00h
    38                              <1> 
    39                              <1> ; Compatible Mode registers
    40                              <1> 
    41                              <1> cpu_relocation          equ     CPU_CSCR+0FEh
    42                              <1> 
    43                              <1> ; The memory and peripheral chip select register offsets from 0FF00h
    44                              <1> 
    45                              <1> cpu_umcs                equ     CPU_CSCR+0A0h          ; Upper memory select
    46                              <1> cpu_lmcs                equ     CPU_CSCR+0A2h          ; Lower memory select
    47                              <1> cpu_pacs                equ     CPU_CSCR+0A4h          ; Peripheral select
    48                              <1> cpu_mmcs                equ     CPU_CSCR+0A6h          ; Middle memory base
    49                              <1> cpu_mpcs                equ     CPU_CSCR+0A8h          ; Mid mem. & peripherals
    50                              <1> 
    51                              <1> ; Enhanced Mode registers
    52                              <1> 
    53                              <1> cpu_mdram               equ     CPU_CSCR+0E0h          ; memory partition reg.
    54                              <1> cpu_cdram               equ     CPU_CSCR+0E2h          ; clock prescaler
    55                              <1> cpu_edram               equ     CPU_CSCR+0E4h          ; Enable refresh reg.
    56                              <1> cpu_pdcon               equ     CPU_CSCR+0F0h          ; Power-Save control
    57                              <1> 
    58                              <1> 
    59                              <1> ; On-board internal peripheral equates
    60                              <1> ; Programmable Interrupt Controller
    61                              <1> PIC	        equ	CPU_CSCR+020H
    62                              <1> PIC_EOI	        equ	PIC+2           ; End Of Interrupt
    63                              <1> PIC_POLLR	equ	PIC+4
    64                              <1> PIC_POLLSR	equ	PIC+6
    65                              <1> PIC_IMASK	equ	PIC+8
    66                              <1> PIC_PMREG	equ	PIC+0AH
    67                              <1> PIC_SRVR	equ	PIC+0CH
    68                              <1> PIC_IRQR	equ	PIC+0EH
    69                              <1> PIC_IRQSR	equ	PIC+10H
    70                              <1> PIC_TCR	        equ	PIC+12H
    71                              <1> PIC_DMA0CR	equ	PIC+14H
    72                              <1> PIC_DMA1CR	equ	PIC+16H
    73                              <1> PIC_I0CON	equ	PIC+18H
    74                              <1> PIC_I1CON	equ	PIC+1AH
    75                              <1> PIC_I2CON	equ	PIC+1CH
    76                              <1> PIC_I3CON	equ	PIC+1EH
    77                              <1> 
    78                              <1> EOI_NSPEC       equ     8000h           ; Non-Specific EOI
    79                              <1> 
    80                              <1> ; Interrupt masks (Master Mode)
    81                              <1> ;
    82                              <1> mask_timer_all          equ     0001h
    83                              <1> mask_dma0               equ     0004h
    84                              <1> mask_dma1               equ     0008h
    85                              <1> mask_int0               equ     0010h
    86                              <1> mask_int1               equ     0020h
    87                              <1> mask_int2               equ     0040h
    88                              <1> mask_int3               equ     0080h
    89                              <1> 
    90                              <1> 
    91                              <1> 
    92                              <1> ; Timers
    93                              <1> TIM0	        equ	CPU_CSCR+050H
    94                              <1> TIM1	        equ	CPU_CSCR+058H
    95                              <1> TIM2	        equ	CPU_CSCR+060H
    96                              <1> 
    97                              <1> TCNT	        equ	0	; count register
    98                              <1> CMPA	        equ	2	; max count A
    99                              <1> CMPB	        equ	4	; max count B (not present on TIM2)
   100                              <1> TCON	        equ	6	; mode/control word
   101                              <1> 
   102                              <1> ; Timer control bits:
   103                              <1> tc_EN           equ     8000h   ; Enable bit
   104                              <1> tc_nINH         equ     4000h   ; not Inhibit Enable
   105                              <1> tc_INT          equ     2000h   ; Interrupt Enable
   106                              <1> tc_RIU          equ     1000h   ; Register A/B (0/1) in Use
   107                              <1> tc_MC           equ     0020h   ; Maximum Count reached
   108                              <1> tc_RTG          equ     0010h   ; Retrigger (internal source)
   109                              <1> tc_P            equ     0008h   ; Prescale internal clock (timers 0 & 1 only)
   110                              <1> tc_EXT          equ     0004h   ; External clock
   111                              <1> tc_ALT          equ     0002h   ; Alternate between A & B max count registers
   112                              <1> tc_CONT         equ     0001h   ; Continuous: continue after max count
   113                              <1> 
   114                              <1> 
   115                              <1> 
   116                              <1> 
   117                              <1> ; DMA
   118                              <1> DMA0	        equ	CPU_CSCR+0C0H
   119                              <1> DMA1	        equ	CPU_CSCR+0D0H
   120                              <1> DMASPL	        equ	0	; source pointer low
   121                              <1> DMASPU	        equ	2	; source pointer high
   122                              <1> DMADPL	        equ	4	; destination pointer low
   123                              <1> DMADPU	        equ	6	; destination pointer high
   124                              <1> DMATC	        equ	8	; terminal count
   125                              <1> DMACW	        equ	0AH	; control word
   126                              <1> 
   127                              <1> 
   128                              <1> 
   129                              <1> 
   130                              <1> 
   131                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   132                              <1> ;
   133                              <1> ;       SBC-188 external devices
   134                              <1> ;
   135                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   136                              <1> 
   137                              <1> IO_BASE			equ	0400h
   138                              <1> 
   139                              <1> 
   140                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   141                              <1> ; The UART registers
   142                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   143                              <1> uart_base               equ     IO_BASE+0280h
   144                              <1> uart_rbr                equ     uart_base       ;Rcvr Buffer / read only
   145                              <1> uart_thr                equ     uart_base       ;Transmit Holding / write only
   146                              <1> uart_ier                equ     uart_base+1     ;Interrupt Enable
   147                              <1> uart_iir                equ     uart_base+2     ;Interrupt Ident / read only
   148                              <1> uart_fcr                equ     uart_base+2     ;FIFO Control / write only
   149                              <1> uart_lcr                equ     uart_base+3     ;Line Control
   150                              <1> uart_mcr                equ     uart_base+4     ;Modem Control
   151                              <1> uart_lsr                equ     uart_base+5     ;Line Status
   152                              <1> uart_msr                equ     uart_base+6     ;Modem Status
   153                              <1> uart_sr			equ	uart_base+7	;Scratch
   154                              <1> 
   155                              <1> uart_dll                equ     uart_base       ;Divisor Latch LS Byte
   156                              <1> uart_dlm                equ     uart_base+1     ;Divisor Latch MS Byte
   157                              <1> 
   158                              <1> 
   159                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   160                              <1> ; Floppy controller
   161                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   162                              <1> FDC	        equ	IO_BASE+0200H
   163                              <1> FDC_MSR         equ     FDC
   164                              <1> FDC_DATA        equ     FDC_MSR+1
   165                              <1> FDC_DACK        equ	FDC+10H
   166                              <1> FDC_LDOR	equ	FDC+20H
   167                              <1> FDC_LDCR	equ	FDC+30H
   168                              <1> FDC_TC	        equ	FDC+40H
   169                              <1> FDC_DACK_TC     equ     FDC_DACK | FDC_TC
   170                              <1> 
   171                              <1> 
   172                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   173                              <1> ;DS1302 RTC
   174                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   175                              <1> RTC	equ	IO_BASE+0300H
   176                              <1> 
   177                              <1> 
   178                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   179                              <1> ; PIO 82C55 I/O 
   180                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   181                              <1> PPI	        equ	IO_BASE+0260H
   182                              <1> PIO_A	        equ	PPI+0	; (OUTPUT)
   183                              <1> PIO_B	        equ	PPI+1	; (INPUT)
   184                              <1> PIO_C	        equ	PPI+2	; (CENTRONICS control low nibble)  
   185                              <1> PIO_CTRL	equ	PPI+3	; CONTROL BYTE PIO 82C55
   186                              <1> 
   187                              <1> portA           equ     PPI+0   ;
   188                              <1> portB           equ     PPI+1   ;     LITES uses this for output
   189                              <1> portC           equ     PPI+2   ;
   190                              <1> 
   191                              <1> 
   192                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   193                              <1> ; Dual [DMA] IDE devices
   194                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   195                              <1> DIDE		equ	IO_BASE + 20H	; range 0x20..0x3F
   196                              <1> 
   197                              <1> DIDE0		equ	DIDE		; first interface (master & slave)
   198                              <1> DIDE1		equ	DIDE+10h	; second interface (master & slave)
   199                              <1> 
   200                              <1> 
   201                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   202                              <1> ; Cassette I/O
   203                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   204                              <1> cuart_base	EQU 	IO_BASE+80H	; BASE IO ADDRESS OF CASSETTE UART
   205                              <1> cuart_rbr	equ     cuart_base	;Rcvr Buffer / read only
   206                              <1> cuart_thr	equ     cuart_base	;Transmit Holding / write only
   207                              <1> cuart_ier	equ     cuart_base+1	;Interrupt Enable
   208                              <1> cuart_iir	equ     cuart_base+2	;Interrupt Ident / read only
   209                              <1> cuart_fcr	equ     cuart_base+2	;FIFO Control / write only
   210                              <1> cuart_lcr	equ     cuart_base+3	;Line Control
   211                              <1> cuart_mcr	equ     cuart_base+4	;Modem Control
   212                              <1> cuart_lsr	equ     cuart_base+5	;Line Status
   213                              <1> cuart_msr	equ     cuart_base+6	;Modem Status
   214                              <1> cuart_sr	equ	cuart_base+7	;Scratch
   215                              <1> 
   216                              <1> cuart_dll	equ     cuart_base	;Divisor Latch LS Byte
   217                              <1> cuart_dlm	equ	cuart_base+1	;Divisor Latch MS Byte
   218                              <1> 
   219                              <1> 
   220                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   221                              <1> ;
   222                              <1> ;       4MEM control registers
   223                              <1> ;
   224                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   225                              <1> EMM_addr        equ     1               ; high 6 bits of 20-bit address
   226                              <1> EMM_page        equ     0               ; 4MEM page in [0..254]
   227                              <1> 
   228                              <1> EMM_BASE        equ     IO_BASE + 000h          ; first EMM (4MEM) board
   229                              <1> EMM_unmapped    equ     255             ; unmapped 4MEM page
   230                              <1> 
   231                              <1> EMM0            equ     EMM_BASE        ; first  EMM board
   232                              <1> EMM1            equ     EMM0 + 2        ; second EMM board
   233                              <1> EMM2            equ     EMM1 + 2        ; third  EMM board
   234                              <1> EMM3            equ     EMM2 + 2        ; fourth EMM board
   235                              <1> 
   236                              <1> 
   237                              <1> 
   238                              <1> 
   239                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   240                              <1> ;
   241                              <1> ;	ColorVDU devices
   242                              <1> ;
   243                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   244                              <1> ;
   245                              <1> ;	major select on the Z80 bus
   246                              <1> ;
   247                              <1> devCVDU_8bit	equ	0xE0		; this may change to 0x10
   248                              <1> 
   249                              <1> devCVDUbase 	equ	IO_BASE + devCVDU_8bit
   250                              <1> 
   251                              <1> M8563status	equ	devCVDUbase + 4		; 4 == bitrev(2)
   252                              <1> M8563register	equ	devCVDUbase + 4
   253                              <1> M8563data	equ	devCVDUbase + 12	; 12 == bitrev(3)
   254                              <1> 
   255                              <1> %if CVDU_8563
   256                              <1> I8242status	equ	devCVDUbase + 10	; 10 == bitrev(5)
   257                              <1> I8242command	equ	devCVDUbase + 10
   258                              <1> I8242data	equ	devCVDUbase + 2		; 2 == bitrev(4)
   259                              <1> %endif
   260                              <1> 
   261                              <1> 
   262                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   263                              <1> ;
   264                              <1> ;	VGA3 devices
   265                              <1> ;
   266                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   267                              <1> ;
   268                              <1> ;	major select on the Z80 bus
   269                              <1> ;
   270                              <1> devVGA3_8bit    equ     0xE0                    ; same as CVDU
   271                              <1> 
   272                              <1> devVGA3base       equ     IO_BASE + devVGA3_8bit
   273                              <1> 
   274                              <1> %if VGA3_6445
   275                              <1> I8242status	equ	devVGA3base + 1
   276                              <1> I8242command	equ	devVGA3base + 1
   277                              <1> I8242data	equ	devVGA3base + 0
   278                              <1> %endif
   279                              <1> HD6445addr	equ	devVGA3base + 2		; to address the HD6445 registers
   280                              <1> HD6445reg	equ	devVGA3base + 3		; to r/w a register on the CRTC
   281                              <1> 
   282                              <1> vga3cfg		equ	devVGA3base + 4
   283                              <1> ; the following are probably not used on the SBC-188, except for testing/checking
   284                              <1> vga3adhi	equ	devVGA3base + 5
   285                              <1> vga3adlo	equ	devVGA3base + 6
   286                              <1> vga3data	equ	devVGA3base + 7
   287                              <1> 
   288                              <1> 
   289                              <1> 
   290                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   291                              <1> ;
   292                              <1> ;	Front Panel devices
   293                              <1> ;
   294                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   295                              <1> ;
   296                              <1> ; Front Panel 82C55 I/O 
   297                              <1> FPPPI	        equ	IO_BASE+0A0H
   298                              <1> FPPORTA         equ     FPPPI+0   	;
   299                              <1> FPPORTB         equ     FPPPI+1   	;    
   300                              <1> FPPORTC         equ     FPPPI+2   	;
   301                              <1> FPPIOCONT       equ     FPPPI+3   	;
   302                              <1> 
   303                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   304                              <1> ; debug port -- JRC only
   305                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   306                              <1> portD		equ	IO_BASE + 0FFh		; 0x04FF
   307                              <1> ;portD		equ	portB		     ; older 8255 output on PPI
   308                              <1> 
   309                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   310                              <1> ;
   311                              <1> ; some useful macros:
   312                              <1> ;
   313                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   314                              <1> ;
   315                              <1> 
   316                              <1> %imacro setloc  1.nolist
   317                              <1>  times   (%1-($-$$)) db 0FFh
   318                              <1> %endm
   319                              <1> 
   320                              <1> %imacro db_lo   1
   321                              <1>  db (%1)&255
   322                              <1> %endm
   323                              <1> 
   324                              <1> %imacro cnop    0.nolist
   325                              <1> %if SOFT_DEBUG
   326                              <1>         nop
   327                              <1> %endif
   328                              <1> %endm
   329                              <1> 
   330                              <1> %imacro popm 1-*.nolist
   331                              <1> %rep %0
   332                              <1> %ifidni %1,ALL
   333                              <1>  popa
   334                              <1> %elifidni %1,F
   335                              <1>  popf
   336                              <1> %else
   337                              <1>  pop %1
   338                              <1> %ifidni %1,DS
   339                              <1>  cnop
   340                              <1> %elifidni %1,ES
   341                              <1>  cnop
   342                              <1> %endif
   343                              <1> %endif
   344                              <1> %rotate 1
   345                              <1> %endrep
   346                              <1> %endm
   347                              <1> 
   348                              <1> %imacro pushm 1-*.nolist
   349                              <1> %rep %0
   350                              <1> %rotate -1
   351                              <1> %ifidni %1,ALL
   352                              <1>  pusha
   353                              <1> %elifidni %1,F
   354                              <1>  pushf
   355                              <1> %else
   356                              <1>  push %1
   357                              <1> %endif
   358                              <1> %endrep
   359                              <1> %endm
   360                              <1> 
   361                              <1> ; end CPUREGS.ASM
   362                              <1> 
    40                                  %include	"date.asm"
     1                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     2                              <1> ; date.asm
     3                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     4                              <1> ; string 0 is for "startup.asm" inclusion; must be 8 chars exactly
     5                              <1> ; string 1 is for RBIOS.ASM inclusion; should be very readable
     6                              <1> 
     7                              <1> %define DATE_STRING0	"06/18/17"
     8                              <1> %define DATE_STRING1	"18-Jun-2017"
     9                              <1> 
    10                              <1> %define VERSION_MAJOR		3
    11                              <1> %define VERSION_MINOR		0
    12                              <1> %define VERSION_REVISION	45
    13                              <1> %define VERSION_SUFFIX		"-beta"
    14                              <1> %define VERSION_STRING		"3.0-45",VERSION_SUFFIX
    15                              <1> 
    16                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    17                              <1> ; Revision information:
    18                              <1> ;  ver.	2.1 -- table-driven support for all IBM floppy types
    19                              <1> ;	2.2 -- Dual IDE driver; CVDU memory sizing
    20                              <1> ;	2.3 -- font_vga corrects (i grave) (n_tilde)
    21                              <1> ;	    &  Dual SDcard & Minix boot
    22                              <1> ;	2.4 -- Int 15h multiprogramming hooks: fn90, fn91 (never done)
    23                              <1> ;	3.0 -- VGA3 support
    24                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    41                                  %include	"equates.asm"
     1                              <1> ;========================================================================
     2                              <1> ; EQUATES.ASM -- Lots of Defintions for Relocatable BIOS
     3                              <1> ;========================================================================
     4                              <1> ;   for the N8VEM SBC-188 v.00.4 and 00.5
     5                              <1> ;
     6                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
     7                              <1> ;
     8                              <1> ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
     9                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    10                              <1> ;
    11                              <1> ; This program is free software: you can redistribute it and/or modify
    12                              <1> ; it under the terms of the GNU General Public License as published by
    13                              <1> ; the Free Software Foundation, either version 3 of the License, or
    14                              <1> ; (at your option) any later version.
    15                              <1> ;
    16                              <1> ; This program is distributed in the hope that it will be useful,
    17                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    18                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    19                              <1> ; GNU General Public License for more details.
    20                              <1> ;
    21                              <1> ; You should have received a copy of the GNU General Public License
    22                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    23                              <1> ;
    24                              <1> ;========================================================================
    25                              <1> 
    26                              <1> %if 1
    27                              <1> 	SEGMENT  _TEXT ALIGN=16 PUBLIC CLASS=CODE
    28                              <1>         SEGMENT  CONST ALIGN=2 PUBLIC CLASS=DATA
    29                              <1> 	SEGMENT  _DATA ALIGN=2 PUBLIC CLASS=DATA
    30                              <1>         SEGMENT  CONST2 ALIGN=2 PUBLIC CLASS=DATA
    31                              <1> 	SEGMENT  _BSS  ALIGN=2 PUBLIC CLASS=BSS
    32                              <1> ;;;        SEGMENT  _BASIC ALIGN=16 PUBLIC CLASS=BASIC
    33                              <1> 
    34                              <1> 	GROUP	DGROUP CONST _DATA CONST2 _BSS
    35                              <1> 
    36                              <1>         global  FPEM_segment
    37                              <1> %endif
    38                              <1> 
    39                              <1> %include "ascii.asm"
     1                              <2> ; ascii.asm
     2                              <2> ;
     3                              <2> CTRL            equ     1Fh     ; masks a character to CTRL-x
     4                              <2> 
     5                              <2> NUL     equ     00h
     6                              <2> BEL     equ     (CTRL & 'G')
     7                              <2> BS      equ     08h
     8                              <2> HT      equ     09h
     9                              <2> LF	equ	0Ah
    10                              <2> NL      equ     LF
    11                              <2> CR	equ	0Dh
    12                              <2> XON     equ     (CTRL & 'Q')
    13                              <2> XOFF    equ     (CTRL & 'S')
    14                              <2> DC1     equ     XON
    15                              <2> DC3     equ     XOFF
    16                              <2> ESC     equ	1Bh
    17                              <2> 
    18                              <2> 
    40                              <1> 
    41                              <1> 
    42                              <1> ; POST error codes. Presently one byte but can expand to word.
    43                              <1> ER_BIOS equ	01h		; Bad ROM bios checksum, patch last byte
    44                              <1> ER_RAM	equ	02h		; Bad RAM in main memory, replace
    45                              <1> ER_CRT	equ	04h		; Bad RAM in video card, replace
    46                              <1> ER_FDC	equ	08h		; Bad FDC
    47                              <1> ER_UNK1	equ	10h		; {unassigned}
    48                              <1> ER_MEM	equ	20h		; Bad RAM in vector area, replace
    49                              <1> ER_ROM	equ	40h		; Bad ROM in expansion area, bad checksum
    50                              <1> ER_UNK2	equ	80h		; {unassigned}
    51                              <1> 
    52                              <1> 
    53                              <1> 
    54                              <1> ;; ************************ BIOS Data Segment ******************************
    55                              <1> ;; BIOS data segment - not all will  be used
    56                              <1> ;                struc   BIOS_DATA_AREA  ; at 0040:0000
    57                              <1> %include "bda.inc"
     1                              <2> ;/*======================================================================
     2                              <2> ; bda.inc -- BIOS data area definitions
     3                              <2> ;========================================================================
     4                              <2> ;   for the N8VEM SBC-188
     5                              <2> ;
     6                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
     7                              <2> ;
     8                              <2> ; Copyright (C) 2013 John R. Coffman.  All rights reserved.
     9                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    10                              <2> ;
    11                              <2> ; This program is free software: you can redistribute it and/or modify
    12                              <2> ; it under the terms of the GNU General Public License as published by
    13                              <2> ; the Free Software Foundation, either version 3 of the License, or
    14                              <2> ; (at your option) any later version.
    15                              <2> ;
    16                              <2> ; This program is distributed in the hope that it will be useful,
    17                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    18                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    19                              <2> ; GNU General Public License for more details.
    20                              <2> ;
    21                              <2> ; You should have received a copy of the GNU General Public License
    22                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    23                              <2> ;
    24                              <2> ;========================================================================
    25                              <2> 
    26                              <2> 			;*/ extern				/*
    27                              <2> 	ABSOLUTE  0	;*/ struct BDA {			/*
    28 00000000 <res 00000008>      <2> serial_ports    resw    4	;*/	word	serial_ports[4];	/*
    29 00000008 <res 00000008>      <2> parallel_ports  resw    4	;*/	word	parallel_ports[4];	/*
    30 00000010 <res 00000002>      <2> equipment_flag  resw    1	;*/	EQFL	equipment_flag;		/*
    31                              <2> ;	dw	?		; 40:10 	; Equipment present word
    32                              <2> ;  						;  = (1 iff floppies) *     1.
    33                              <2> ;                                               ;  + (1 iff 187     ) *     2.
    34                              <2> ;  						;  + (#+1 64K sys ram) *    4.
    35                              <2> ;  						;  + (init crt mode ) *    16.
    36                              <2> ;  						;  + (# of floppies ) *    64.
    37                              <2> ;  						;  + (# serial ports) *   512.
    38                              <2> ;  						;  + (1 iff toy port) *  4096.
    39                              <2> ;                                               ;  + (1 iff modem   ) *  8192.
    40                              <2> ;  						;  + (# parallel LPT) * 16384.
    41 00000012 <res 00000001>      <2> mfg_test_flags  resb    1	;*/	byte	mfg_test_flags;	/* 40:12 unused by us
    42 00000013 <res 00000002>      <2> memory_size     resw    1	;*/	word	memory_size;	/* 40:13 kilobytes
    43                              <2> uart_kbd_ctrl_R	equ	$	;*/				/*** JRC: count of ctrl-R's for reboot
    44 00000015 <res 00000001>      <2> IPL_errors      resb    1	;*/	byte	IPL_errors;	/* 40:15 IPL errors<-table/scratchpad
    45 00000016 <res 00000001>      <2> unused_01       resb    1	;*/	byte	unused_01;	/*
    46                              <2> ;;---------------[Keyboard data area]------------;
    47 00000017 <res 00000002>      <2> keyboard_flags_0 resw   1	;*/	word	keyboard_flags_0;  /* 40:17 Shift/Alt/etc. keyboard flags
    48                              <2> keyboard_flags_1 equ	$-1	;     2nd byte	keyboard_flags_1;  
    49 00000019 <res 00000001>      <2> keypad_char	resb	1	;*/	byte	keypad_char;	/* 40:19 Alt-KEYPAD char. goes here
    50 0000001A <res 00000002>      <2> kbd_buffer_head resw    1	;*/	word	kbd_buffer_head;   /* 40:1A --> keyboard buffer head
    51 0000001C <res 00000002>      <2> kbd_buffer_tail resw    1	;*/	word	kbd_buffer_tail;   /* 40:1C --> keyboard buffer tail
    52 0000001E <res 00000020>      <2> kbd_buffer      resw    16	;*/	word	kbd_buffer[16];	/* 40:1E Keyboard Buffer (Scan,Value)
    53                              <2> kbd_buffer_last	equ	$	;*/				/*
    54                              <2> ;;---------------[Diskette data area]------------;
    55 0000003E <res 00000001>      <2> fdc_drv_calib   resb    1	;*/	byte	fdc_drive_calib;   /* 40:3E
    56 0000003F <res 00000001>      <2> fdc_motor_LDOR  resb    1	;*/	byte	fdc_motor_LDOR;	   /* 40:3F Motor, DMA, select control
    57 00000040 <res 00000001>      <2> fdc_motor_ticks resb    1	;*/	byte	fdc_motor_ticks;   /* 40:40 ticks til motor off
    58 00000041 <res 00000001>      <2> fdc_status      resb    1	;*/	byte	fdc_status;	   /* 40:41
    59                              <2> ;				Floppy return code stat byte
    60                              <2> ;				;  1 = bad ic 765 command req.
    61                              <2> ;				;  2 = address mark not found
    62                              <2> ;				;  3 = write to protected disk
    63                              <2> ;				;  4 = sector not found
    64                              <2> ;				;  8 = data late (DMA overrun)
    65                              <2> ;				;  9 = DMA failed 64K page end
    66                              <2> ;				; 16 = bad CRC on floppy read
    67                              <2> ;				; 32 = bad NEC 765 controller
    68                              <2> ;				; 64 = seek operation failed
    69                              <2> ;				;128 = disk drive timed out
    70 00000042 <res 00000007>      <2> fdc_ctrl_status resb    7	;*/	byte	fdc_ctrl_status[7];  /* 40:42 Status bytes from NEC 765
    71                              <2> ;;---------------[Video display area]------------;
    72 00000049 <res 00000001>      <2> video_mode      resb    1	;*/	byte	video_mode;	/* 40:49
    73                              <2> ;			 	; Current CRT mode  (software)
    74                              <2> ;				;  0 = 40 x 25 text (no color)
    75                              <2> ;				;  1 = 40 x 25 text (16 color)
    76                              <2> ;				;  2 = 80 x 25 text (no color)
    77                              <2> ;				;  3 = 80 x 25 text (16 color)
    78                              <2> ;				;  4 = 320 x 200 grafix 4 color
    79                              <2> ;				;  5 = 320 x 200 grafix 0 color
    80                              <2> ;				;  6 = 640 x 200 grafix 0 color
    81                              <2> ;				;  7 = 80 x 25 text (mono card)
    82 0000004A <res 00000002>      <2> video_columns   resw    1	;*/	word video_columns;	/* 40:4A Columns on CRT screen
    83 0000004C <res 00000002>      <2> video_regen_bytes  resw 1	;*/	word video_regen_bytes;	/* 40:4C Bytes in the regen region
    84 0000004E <res 00000002>      <2> video_regen_offset resw 1	;*/	word video_regen_offset;/* 40:4E Byte offset in regen region
    85 00000050 <res 00000010>      <2> video_cursor_pos  resw  8	;*/	word video_cursor_pos[8];  /* 40:50 Cursor pos for up to 8 pages
    86 00000060 <res 00000002>      <2> video_cursor_mode resw  1	;*/	word video_cursor_mode;	/* 40:60 Current cursor mode setting
    87 00000062 <res 00000001>      <2> video_page      resb    1	;*/	byte video_page;	/* 40:62 Current page on display
    88 00000063 <res 00000002>      <2> video_base_seg  resw    1	;*/	word video_base_seg;	/* 40:63 Base address (B000h or B800h)
    89 00000065 <res 00000001>      <2> video_hw_mode   resb    1	;*/	byte video_hw_mode;	/* 40:65 ic 6845 mode reg. (hardware)
    90 00000066 <res 00000001>      <2> video_cga_palette resb  1	;*/	byte video_cga_palette;	/* 40:66 Current CGA palette
    91                              <2> ;;---------------[Used to setup ROM]-------------;
    92 00000067 <res 00000004>      <2> eprom_address   resd    1	;*/	dword eprom_address;	/* 40:67 Eprom base Offset,Segment
    93 0000006B <res 00000001>      <2> spurious_irq    resb    1	;*/	byte spurious_irq;	/* 40:6B Last spurious interrupt IRQ
    94                              <2> ;;---------------[Timer data area]---------------;
    95 0000006C <res 00000004>      <2> timer_ticks     resd    1	;*/	dword timer_ticks;	/* 40:6C Ticks since midnight (lo,hi)
    96 00000070 <res 00000001>      <2> timer_new_day   resb    1	;*/	byte timer_new_day;	/* 40:70 Non-zero if new day
    97                              <2> ;;---------------[System data area]--------------;
    98 00000071 <res 00000001>      <2> break_flag      resb    1	;*/	byte break_flag;	/* 40:71 Sign bit set iff break
    99 00000072 <res 00000002>      <2> warm_boot       resw    1	;*/	word warm_boot;		/* 40:72 Warm boot iff==1234h
   100                              <2> ;;---------------[Hard disk scratchpad]----------;
   101 00000074 <res 00000004>      <2> hdd_scratch     resd    1	;*/	word hdd_scratch[2];	/* 40:74
   102                              <2> ;;---------------[Timout areas/PRT/LPT]----------;
   103 00000078 <res 00000004>      <2> lpt_timeout     resb    4	;*/	byte lpt_timeout[4];	/* 40:78 Ticks for LPT 1-4 timeouts
   104 0000007C <res 00000004>      <2> com_timeout     resb    4	;*/	byte com_timeout[4];	/* 40:7C Ticks for COM 1-4 timeouts
   105                              <2> ;;---obsolete----[Keyboard buf start/end]---jrc--;
   106 00000080 <res 00000002>      <2> kbd_buffer_start resw   1	;*/	word kbd_buffer_start;	/* 40:80 KBD buffer head (PC/AT)
   107 00000082 <res 00000002>      <2> kbd_buffer_end  resw    1	;*/	word kbd_buffer_end;	/* 40:82 KBD buffer tail (PC/AT)
   108                              <2> ;;---------------[EGA stuff]---------------------;
   109 00000084 <res 00000007>      <2> EGA_stuff	resb	7	;*/	byte EGA_stuff[7];	/* 40:84 Unspecified EGA data
   110                              <2> ;;---------------[Floppy/Fixed Media Info]-------------;
   111 0000008B <res 00000001>      <2> fdc_last_rate	resb	1	;*/	byte fdc_last_rate;	/* 40:8B Last floppy step rate/data rate?
   112 0000008C <res 00000004>      <2> fx_misc_unused	resb	4	;*/	byte fx_misc_unused[4];	/* 40:8C Fixed disk miscellaneous ???
   113 00000090 <res 00000002>      <2> fdc_disk_state	resb	2	;*/	byte fdc_disk_state[2];	/* 40:90 Floppy disk state
   114 00000092 <res 00000002>      <2> fdc_op_start	resb	2	;*/	byte fdc_op_start[2];	/* 40:92 Floppy operation start state machine
   115 00000094 <res 00000002>      <2> fdc_cylinder	resb	2	;*/	byte fdc_cylinder[2];	/* 40:94 Floppy present cylinder
   116                              <2> ;;---------------[Additional KBD flags]----------------;
   117 00000096 <res 00000001>      <2> kbd_flag_3	resb	1	;*/	byte kbd_flag_3;	/* 40:96 kbd ???
   118 00000097 <res 00000001>      <2> kbd_flag_2	resb	1	;*/	byte kbd_flag_2;	/* 40:97 kbd ???
   119                              <2> ;;---------------[RTC/timer1 data]---------------------;
   120 00000098 <res 00000004>      <2> user_semaphore	resw	2	;*/	byte *user_semaphore;	/* 40:98 User semaphore in (bit 7)
   121 0000009C <res 00000004>      <2> rtc_count	resd	1	;*/	dword rtc_count;	/* 40:9C RTC tick counter
   122 000000A0 <res 00000001>      <2> rtc_wait_active	resb	1	;*/	byte rtc_wait_active;	/* 40:A0 Busy=01, Posted=80h, 
   123                              <2> ;;---------------[Cassette I/O stuff]------------------;
   124 000000A1 <res 00000001>      <2> last_val	resb	1	;*/	byte last_val;		/* 40:A1 Last byte read value
   125 000000A2 <res 00000002>      <2> crc_reg		resw	1	;*/	word crc_reg;		/* 40:A2 CRC accumulation area
   126                              <2> ;									Post Acknowleged=00;
   127 000000A4 <res 00000001>      <2> EGA_data	resb	1	;*/	byte EGA_data;		/* 40:A4 Various usage
   128 000000A5 <res 00000002>      <2> SDstatus	resb	2	;*/	byte SDstatus[2];	/* 40:A5 Status byte from command
   129 000000A7 <res 00000002>      <2> SDcardtype	resb	2	;*/	byte SDcardtype[2];	/* 40:A7 SDcard type SDSC=2, HC=3, ...
   130                              <2> ;
   131 000000A9 <res 00000004>      <2> fixed_disk_tab	resb	4	;*/	byte fixed_disk_tab[4];	/* dispatch table to fixed disk drivers
   132 000000AD <res 00000001>      <2> wait12_count	resb	1	;*/	byte wait12_count;	/* 40:AD 12usec CX count
   133 000000AE <res 00000001>      <2> lock_count	resb	1	;*/	byte lock_count;	/* 40:AE lock level counter
   134 000000AF <res 00000001>      <2> EMS_start       resb    1	;*/	byte EMS_start;		/* start EMS allocation from here
   135                              <2> fx80		equ	$	;*/	struct EDD_disk fx80;	/* fixed disk parameter area 0
   136 000000B0 <res 00000002>      <2> fx_log_cylinders resw   1	;	word fx_log_cylinders;	 logical number of cylinders
   137 000000B2 <res 00000001>      <2> fx_log_heads    resb    1	;	byte fx_log_heads;	 logical number of heads
   138 000000B3 <res 00000001>      <2> fx_signature	resb	1	;	byte fx_signature;	 A0h signature = translated geom
   139 000000B4 <res 00000001>      <2> fx_phys_sectors	resb    1       ;	byte fx_phys_sectors;	 physical number of sectors per track
   140 000000B5 <res 00000002>      <2> fx_LBA_high     resw    1       ;	word fx_LBA_high;	 high word of LBA28 number of sectors
   141 000000B7 <res 00000001>      <2> fx_reserved7    resb	1	;	byte fx_reserved;	 MBZ
   142 000000B8 <res 00000001>      <2> fx_drive_control resb   1       ;	byte fx_drive_control;	 flag bits for IDE head register
   143 000000B9 <res 00000002>      <2> fx_phys_cylinders resw	1	;	word fx_phys_cylinders;	 physical number of cylinders
   144 000000BB <res 00000001>      <2> fx_phys_heads	resb	1	;	byte fx_phys_heads;	 physical number of heads
   145 000000BC <res 00000002>      <2> fx_LBA_low	resw	1	;	word fx_LBA_low;	 low word of LBA28 number of sectors
   146 000000BE <res 00000001>      <2> fx_log_sectors	resb	1	;	byte fx_log_sectors;	 logical number of sectors per track
   147 000000BF <res 00000001>      <2> fx_checksum	resb	1	;	byte fx_checksum;	 checksum, dunno how to compute
   148 000000C0 <res 00000010>      <2> fx81            resb    16	;*/	struct EDD_disk fx81;	/* fixed disk parameter area 1
   149 000000D0 <res 00000010>      <2> fx82            resb    16	;*/	struct EDD_disk fx82;	/* fixed disk parameter area 2
   150 000000E0 <res 00000010>      <2> fx83            resb    16	;*/	struct EDD_disk fx83;	/* fixed disk parameter area 3
   151                              <2> ;
   152                              <2> ;
   153                              <2> 
   154 000000F0 <res 00000002>      <2> FPEM_segment    resw    1       ;*/	word FPEM_segment;	/* FPEM data segment
   155                              <2> 
   156 000000F2 <res 00000002>      <2> EBDA_paragraph  resw    1       ;*/	word EBDA_paragraph;	/* lowest EBDA paragraph
   157                              <2> 
   158 000000F4 <res 00000002>      <2> dma0_cw         resw    1       ;*/	word dma0_cw;		/* end of dma control word
   159 000000F6 <res 00000002>      <2> dma1_cw         resw    1       ;*/	word dma1_cw;		/*   ditto
   160                              <2> 
   161 000000F8 <res 00000002>      <2> fdc_type	resb	2	;*/	byte fdc_type[2];	/* disk type in low nibble, alternate in hi nib 
   162                              <2> 
   163 000000FA <res 00000004>      <2> debug_static_ptr  resw	2	;*/	void *debug_static_ptr;	/* pointer to debug static area
   164                              <2> 
   165 000000FE <res 00000001>      <2> n_fixed_disks   resb    1       ;*/	byte n_fixed_disks;	/* number of fixed disks
   166                              <2> 
   167 000000FF <res 00000001>      <2> cpu_xtal        resb    1       ;*/	byte cpu_xtal;		/* CPU crystal frequency in Mhz 
   168                              <2> ;								   CPU clock is half of this
   169                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   170                              <2> ;
   171                              <2> ;  System configuration stuff below
   172                              <2> ;	c.f., CONFIG.ASM (ANSI.CFG, CVDU.CFG, etc.), User configuration stuff
   173                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   174                              <2> %if 0				;*/
   175                              <2> #define FIXED_DISK_MAX 4		/*
   176                              <2> %else
   177                              <2> %define FIXED_DISK_MAX 4
   178                              <2> %endif
   179                              <2> %if 0				;*/
   180                              <2> #define PPIDE_driver 1		/*
   181                              <2> %else
   182                              <2> %define PPIDE_driver 1
   183                              <2> %endif
   184                              <2> %if 0				;*/
   185                              <2> #define DIDE_driver 1		/*
   186                              <2> %else
   187                              <2> %define DIDE_driver 1
   188                              <2> %endif
   189                              <2> %if 0				;*/
   190                              <2> #define DSD_driver 1		/*
   191                              <2> %else
   192                              <2> %define DSD_driver 1
   193                              <2> %endif
   194                              <2> 				;*/
    58                              <1> 
    59                              <1> ;  this must be the same in EQUATES.H */
    60                              <1> %if SOFT_DEBUG
    61                              <1> %define NBREAK  8
    62                              <1> %endif
    63                              <1> 
    64                              <1> 
    65                              <1> %if 0
    66                              <1>         segment _TEXT
    67                              <1> ;; *************************************************************************
    68                              <1> 
    69                              <1> 
    70                              <1> 
    71                              <1> 
    72                              <1> ;; ************************ DOS Data Segment *******************************
    73                              <1> ;dosdir	SEGMENT at 50h				; Boot disk directory from IPL
    74                              <1> ;xerox	label	byte				;  0 if Print Screen idle
    75                              <1> ;						;  1 if PrtSc xeroxing screen
    76                              <1> ;						;255 if PrtSc error in xerox
    77                              <1> ;						;  ...non-grafix PrtSc in bios
    78                              <1> ;	db	200h dup(?)			; PC-DOS bootstrap procedure
    79                              <1> ;						;  ...IBMBIO.COM buffers the
    80                              <1> ;						;  ...directory of the boot
    81                              <1> ;						;  ...device here at IPL time
    82                              <1> ;						;  ...when locating the guts
    83                              <1> ;						;  ...of the operating system
    84                              <1> ;						;  ...filename "IBMDOS.COM"
    85                              <1> ;dosdir	ends
    86                              <1> ;; *************************************************************************
    87                              <1> ;; ************************ DOS IPL Segment ********************************
    88                              <1> ;dosseg	SEGMENT at 70h				; "Kernel" of PC-DOS op sys
    89                              <1> ;;IBMBIO.COM file loaded by boot block. Device Drivers/Bootstrap. CONTIGUOUS<---
    90                              <1> ;;IBMDOS.COM operating system nucleus immediately follows IBMBIO.COM and       !
    91                              <1> ;;     doesn`t have to be contiguous.  The IBMDOS operating system nucleus     !
    92                              <1> ;;     binary image is loaded by transient code in IBMBIO binary image	      !
    93                              <1> ;dosseg	ends					;			      !
    94                              <1> ;iplseg	SEGMENT at 0h				; Segment for boot block      !
    95                              <1> ;;The following boot block is loaded with 512 bytes on the first sector of     !
    96                              <1> ;;the bootable device by code resident in the ROM-resident bios.  Control is   !
    97                              <1> ;;then transferred to the first word 0000:7C00 of the disk-resident bootstrap  !
    98                              <1> ;	ORG	07C00h				;  ..offset for boot block    !
    99                              <1> ;boot	db	200h dup(?)			;  ..start disk resident boot--
   100                              <1> ;iplseg	ends
   101                              <1> 
   102                              <1> %endif
    42                                  
    43                                  %define	VERSION	VERSION_STRING
    44                                  %define	DATE	DATE_STRING1
    45                                  
    46                                          global  begin_here
    47                                          global  initialization
    48                                          extern  _cprintf
    49                                  %if TRACE
    50                                  	extern	int_trace
    51                                  %endif	; TRACE
    52                                  
    53                                          segment         _TEXT
    54                                  ; startup jumps to this absolute location
    55                                  ..start:
    56                                  begin_here:
    57 00000000 E93303                          jmp     cold_boot
    58                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    59                                  ;  Put the Copyright notice right at the beginning of the ROM.
    60                                  ;  It may be printed second, but it should be at the most obvious
    61                                  ;  location in the ROM image.
    62                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    63                                  ident2:
    64 00000003 0A                              db      NL
    65 00000004 25313261                	db	"%12a"
    66 00000008 436F70797269676874-             db      "Copyright (C) 2010-2017 by The RetroBrew Users' Group.  All rights reserved."
    66 00000011 202843292032303130-
    66 0000001A 2D3230313720627920-
    66 00000023 54686520526574726F-
    66 0000002C 427265772055736572-
    66 00000035 73272047726F75702E-
    66 0000003E 2020416C6C20726967-
    66 00000047 687473207265736572-
    66 00000050 7665642E           
    67 00000054 0A                              db      NL
    68 00000055 50726F766964656420-             db      "Provided for hobbyist use on the RetroBrew SBC-188 board."
    68 0000005E 666F7220686F626279-
    68 00000067 69737420757365206F-
    68 00000070 6E2074686520526574-
    68 00000079 726F42726577205342-
    68 00000082 432D31383820626F61-
    68 0000008B 72642E             
    69 0000008E 2020416C6C20636F64-             db      "  All code may be"
    69 00000097 65206D6179206265   
    70 0000009F 0A                              db      NL
    71 000000A0 7573656420756E6465-             db      "used under the terms of the GNU General Public License, a copy of which"
    71 000000A9 722074686520746572-
    71 000000B2 6D73206F6620746865-
    71 000000BB 20474E552047656E65-
    71 000000C4 72616C205075626C69-
    71 000000CD 63204C6963656E7365-
    71 000000D6 2C206120636F707920-
    71 000000DF 6F66207768696368   
    72 000000E7 0A                              db      NL
    73 000000E8 697320636F6E746169-             db      "is contained in the file COPYING.TXT in the top-level source directory."
    73 000000F1 6E656420696E207468-
    73 000000FA 652066696C6520434F-
    73 00000103 5059494E472E545854-
    73 0000010C 20696E207468652074-
    73 00000115 6F702D6C6576656C20-
    73 0000011E 736F75726365206469-
    73 00000127 726563746F72792E   
    74 0000012F 0A                              db      NL
    75                                  %if SOFT_DEBUG
    76                                          db      NL
    77                                  	db	"%7a"
    78                                          db      "             ***** SOFT BIOS *****"
    79                                          db      NL
    80                                  %endif
    81                                  %ifdef __DATE__
    82                                  %ifdef __TIME__
    83 00000130 0A                              db      NL
    84 00000131 25313461                	db	"%14a"
    85 00000135 546869732042494F53-             db      "This BIOS copy was built at ",__TIME__," ",TIMEZONE
    85 0000013E 20636F707920776173-
    85 00000147 206275696C74206174-
    85 00000150 2031333A30393A3031-
    85 00000159 20434454           
    86 0000015D 206F6E20323031372D-             db      " on ", __DATE__,"."
    86 00000166 30372D30332E       
    87 0000016C 0A                              db      NL
    88                                  %endif
    89                                  %endif
    90 0000016D 00                              db      0
    91                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    92                                  ;  This is the banner which prints out first.
    93                                  ;  The letters are variable width; B is wide; -, and 1 are kerned.
    94                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    95                                  ident1:
    96 0000016E 0A253961                        db      NL,"%9a"
    97 00000172 202020535353202020-             db      "   SSS   BBBBB    CCC           1     888    888",	NL
    97 0000017B 424242424220202020-
    97 00000184 434343202020202020-
    97 0000018D 202020202031202020-
    97 00000196 202038383820202020-
    97 0000019F 3838380A           
    98 000001A3 202053202020532020-             db      "  S   S   B   B  C   C         11    8   8  8   8",	NL
    98 000001AC 204220202042202043-
    98 000001B5 202020432020202020-
    98 000001BE 202020203131202020-
    98 000001C7 203820202038202038-
    98 000001D0 202020380A         
    99 000001D5 202020532020202020-             db      "   S      B   B  C              1    8   8  8   8",	NL
    99 000001DE 204220202042202043-
    99 000001E7 202020202020202020-
    99 000001F0 202020202031202020-
    99 000001F9 203820202038202038-
    99 00000202 202020380A         
   100 00000207 202020205320202020-             db      "    S     BBBB   C      HHHH    1     888    888",	NL
   100 00000210 204242424220202043-
   100 00000219 202020202020484848-
   100 00000222 482020202031202020-
   100 0000022B 202038383820202020-
   100 00000234 3838380A           
   101 00000238 202020202053202020-             db      "     S    B   B  C              1    8   8  8   8             rev. ", VERSION, NL
   101 00000241 204220202042202043-
   101 0000024A 202020202020202020-
   101 00000253 202020202031202020-
   101 0000025C 203820202038202038-
   101 00000265 202020382020202020-
   101 0000026E 202020202020202072-
   101 00000277 65762E20332E302D34-
   101 00000280 352D626574610A     
   102 00000287 202053202020532020-             db      "  S   S   B   B  C   C          1    8   8  8   8             of ", DATE, NL   
   102 00000290 204220202042202043-
   102 00000299 202020432020202020-
   102 000002A2 202020202031202020-
   102 000002AB 203820202038202038-
   102 000002B4 202020382020202020-
   102 000002BD 20202020202020206F-
   102 000002C6 662031382D4A756E2D-
   102 000002CF 323031370A         
   103 000002D4 202020535353202020-             db      "   SSS   BBBBB    CCC         11111   888    888                  ("
   103 000002DD 424242424220202020-
   103 000002E6 434343202020202020-
   103 000002EF 202020313131313120-
   103 000002F8 202038383820202020-
   103 00000301 383838202020202020-
   103 0000030A 202020202020202020-
   103 00000313 20202028           
   104                                  %if ANSI
   105 00000317 414E5349                        db      "ANSI"
   106                                  %elif WYSE
   107                                          db      "Wyse"
   108                                  %elif DUMB
   109                                          db      "dumb"
   110                                  %elif TTY
   111                                          db      "tty"
   112                                  %else
   113                                          db      "???"
   114                                  %endif
   115 0000031B 290A                            db      ")",NL
   116 0000031D 00                              db      0
   117                                  
   118                                  
   119                                  %if FRONT_PANEL
   120 0000031E 014E673E003E6701        	CPUUP	    DB 	001h,04Eh,067h,03Eh,000h,03Eh,067h,001h
   121 00000326 0101677E5B700101        	POSTMSG	    DB 	001h,001h,067h,07Eh,05Bh,070h,001h,001h
   122 0000032E 01011F775B304E01        	BASICMSG    DB 	001h,001h,01Fh,077h,05Bh,030h,04Eh,001h
   123                                  %endif
   124                                  
   125                                  
   126                                  
   127                                  cold_boot:
   128 00000336 FA                              cli                     ; Should be clear already
   129                                  %if 0
   130                                   /* SOFT_DEBUG > 1 */
   131                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   132                                  ; set up for LED lights display on PPI portB
   133                                  ; 6/14/2017 -- now called portD, may equ portB, or separate on 0x4FF
   134                                          mov     dx,PIO_CTRL
   135                                          mov     al,99h          ; Mode 0, portA=input, portC=input, 
   136                                                                  ;         portB=output (lites)
   137                                          out     dx,al
   138                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   139                                  %endif
   140                                  %if SOFT_DEBUG
   141                                          mov     dx,portD
   142                                          mov     al,0A5h         ; A5 to the LITES
   143                                          out     dx,al
   144                                  %endif
   145 00000337 B84000                          mov     ax,bios_data_seg
   146 0000033A 8ED0                            mov     ss,ax
   147 0000033C BC0070                          mov     sp,7000h        ; Stack should be out of the way
   148                                  ; cannot use the stack yet, since memory is not tested
   149 0000033F 368B1E7200                  ss	mov	bx,word [warm_boot]	; check for 1234h == Warm Boot
   150                                  %if SOFT_DEBUG
   151                                  	push	5Ah
   152                                  	call	lites
   153                                  %endif
   154                                  
   155                                  ; Immediately test low memory
   156 00000344 31C0                            xor     ax,ax           ; Segment 0
   157 00000346 BD[4C03]                        mov     bp,.0           ; return address
   158 00000349 E9F403                          jmp     memtest0        ; don't use the stack
   159                                  .0:
   160                                  ; BX was preserved by 'memtest0'
   161                                  
   162                                  %if SOFT_DEBUG
   163                                          jnc     cold_continue
   164                                          mov     dx,portD
   165                                          mov     al,0F1h         ; F1 to the LITES
   166                                          out     dx,al
   167                                  .1:
   168                                          hlt
   169                                          jmp     .1              ; solid halt on error
   170                                  %endif
   171                                  
   172                                  cold_continue:
   173 0000034C FC                              cld                     ; Clear the direction flag
   174 0000034D 31C0                            xor     ax,ax
   175 0000034F 8EC0                            mov     es,ax
   176                                          cnop
   177 00000351 89C7                            mov     di,ax
   178 00000353 B90003                          mov     cx,600h/2       ; clear segments 00h, 040h and 050h
   179 00000356 F3AB                       rep  stosw                   ; clear out BIOS DATA AREA
   180                                  
   181 00000358 36891E7200                 ss	mov	word [warm_boot],bx	; save only warm boot flag
   182                                  
   183                                  %if EMM_BOARDS
   184 0000035D E80605                          call    EMM_init0       ; disable all EMM boards
   185                                  %endif
   186 00000360 E86F03                          call    get_ramsize
   187 00000363 C1E006                          shl     ax,6            ; convert to Segment address
   188                                  %if SOFT_DEBUG
   189                                  	mov	cx,_BSS		; paragraph of _BSS segment
   190                                  ; since the BSS is of length 0000, this is beyond all data
   191                                  
   192                                          mov     bx,cs           ; Code Segment
   193                                          sub     cx,bx           ; Code paragraphs
   194                                          push    cx
   195                                          mov     bx,ax           ; Save HMA in K
   196                                          sub     bx,cx           ; new Code segment
   197                                          mov     es,bx           ; Destination
   198                                          cnop
   199                                          mov     ax,bx           ; Paragraph address to AX
   200                                  
   201                                          push    cs
   202                                          popm     ds              ; Source
   203                                          xor     si,si
   204                                          xor     di,di
   205                                          pop     cx              ; Code length in Paragraphs
   206                                          shl     cx,3            ; Code length in words
   207                                     rep  movsw                   ; move all of it
   208                                          push    es              ; new Code segment
   209                                          push    word SOFT_continue   ; IP
   210                                          retf
   211                                  
   212                                          global  SOFT_continue
   213                                  SOFT_continue:                  ; Continue here in soft memory
   214                                  ;
   215                                  ;  Allocate the DEBUG static area
   216                                  ;
   217                                  	mov	cx,(NBREAK+1)*8 + 15
   218                                  	shr	cx,4		; CX=needed paragraphs
   219                                  	sub	ax,cx		; allocate space
   220                                    ss	mov	[debug_static_ptr+2],ax	 	; setup static area segment
   221                                    ss	mov	word [debug_static_ptr],0	; and offset
   222                                    	shl	cx,4		; word count
   223                                  	pushm	ax,ax		; save segment, twice
   224                                  	popm	es		; set segment to zap
   225                                  	xor	di,di		; start at offset 0
   226                                  	mov	ax,di		; AL=0
   227                                    rep	stosb	    		; Zap memory
   228                                  	popm	ax		; restore AX, EBDA paragraph segment
   229                                  %endif
   230                                  ;
   231                                  ; Save the memory pointers
   232                                  ;
   233 00000366 36A3F200                    ss  mov     [EBDA_paragraph],ax
   234 0000036A C1E806                          shr     ax,6
   235 0000036D 36A31300                    ss  mov     [memory_size],ax
   236                                  
   237 00000371 68[0000]                        push    DGROUP
   238 00000374 1F                              popm    ds              ; This is for the C-programs
   239                                  
   240 00000375 E82602                          call    set_traps	; setup interrupt table
   241 00000378 E82202                  	call	set_interrupt_priority ; set default interrupt priorities
   242                                  
   243 0000037B B80500                  	mov	ax,UART_RATE	; set the default rate
   244                                  	extern	@nvram_get_video
   245 0000037E E8(0000)                	call	@nvram_get_video
   246                                  				; get RAM_serial byte - UART speed
   247                                  				; returned in AL
   248                                  %if SOFT_DEBUG
   249                                  	PUSH	3
   250                                  	CALL	lites
   251                                  %endif
   252                                  	extern	video_init
   253 00000381 E8(0000)                	call	video_init
   254                                  
   255                                  %if SOFT_DEBUG
   256                                  	PUSH	4
   257                                  	CALL	lites
   258                                  %endif
   259                                  	extern	keyboard_init
   260 00000384 E8(0000)                	call	keyboard_init
   261                                  
   262                                  %if SOFT_DEBUG
   263                                  	PUSH	5
   264                                  	CALL	lites
   265                                  %endif
   266 00000387 FB                      	sti                     ; enable interrupts
   267                                  %if FPEM
   268 00000388 9BDBE3                  	finit			; will allocate memory
   269                                  %endif
   270                                  %if SOFT_DEBUG
   271                                  	PUSH	1
   272                                  	CALL	lites
   273                                  %endif
   274                                  
   275                                  
   276                                  %if FRONT_PANEL
   277 0000038B 1E                      	PUSH 	DS
   278 0000038C 0E                           	push    cs
   279 0000038D 1F                              pop     ds              ; Source
   280 0000038E BA[2603]                	mov  dx,POSTMSG		;    	
   281 00000391 B451                        	mov  ah, 0x51       	; ah=0x51 - "Write BUFFER TO FRONT PANEL"
   282 00000393 CD15                        	INT  0x15  		;
   283 00000395 1F                          	pop 	DS
   284                                  %endif
   285                                  
   286                                  
   287                                  
   288                                  
   289                                  
   290 00000396 0E                      	push	cs
   291 00000397 68[6E01]                	push	ident1
   292 0000039A E8(0000)                	call	_cprintf
   293 0000039D 58                      	pop     ax
   294 0000039E 68[0300]                	push	ident2
   295 000003A1 E8(0000)                	call	_cprintf
   296 000003A4 58                      	pop     ax
   297 000003A5 58                      	pop     ax
   298                                  
   299                                  %if SOFT_DEBUG
   300                                  %if SOFT_DEBUG>1
   301                                  	PUSH	2
   302                                  	CALL	lites
   303                                  %endif
   304                                          extern     redbug
   305                                  
   306                                          pushf           ; push the flags
   307                                          push    cs      ; simulate a far call
   308                                          call    redbug  ; call our weak debugger
   309                                     es   mov     cx,[bp+si+4]
   310                                  %if SOFT_DEBUG>1
   311                                  	PUSH	3
   312                                  	CALL	lites
   313                                  %endif
   314                                  
   315                                  %endif
   316                                  
   317                                  HAS_FLOPPY	equ	0000000000000001b
   318                                  HAS_FPU		equ	0000000000000010b
   319                                  HAS_MOUSE	equ	0000000000000100b
   320                                  VIDEO_EGA	equ	0000000000000000b
   321                                  VIDEO_COLOR_40	equ	0000000000010000b
   322                                  VIDEO_COLOR_80	equ	0000000000100000b
   323                                  VIDEO_MONO	equ	0000000000110000b
   324                                  FLOPPIES_1	equ	0000000000000000b
   325                                  FLOPPIES_2	equ	0000000001000000b
   326                                  FLOPPIES_3	equ	0000000010000000b
   327                                  FLOPPIES_4	equ	0000000011000000b
   328                                  SERIAL_0	equ	0000000000000000b
   329                                  SERIAL_1	equ	0000001000000000b
   330                                  SERIAL_2	equ	0000010000000000b
   331                                  SERIAL_3	equ	0000011000000000b
   332                                  SERIAL_4	equ	0000100000000000b
   333                                  SERIAL_5	equ	0000101000000000b
   334                                  SERIAL_6	equ	0000110000000000b
   335                                  SERIAL_7	equ	0000111000000000b
   336                                  PARALLEL_0	equ	0000000000000000b
   337                                  PARALLEL_1	equ	0100000000000000b
   338                                  PARALLEL_2	equ	1000000000000000b
   339                                  PARALLEL_3	equ	1100000000000000b
   340                                  
   341                                  
   342                                  ; setup BIOS data area
   343 000003A6 6A40                    	push	bios_data_seg
   344 000003A8 1F                      	popm	ds
   345 000003A9 C606AE0000              	mov	byte [lock_count],0	; zap the @enable/@disable lock count
   346                                  ; no serial interface -- it is used for the video driver
   347 000003AE B83140                  	mov	ax,PARALLEL_1|SERIAL_0|FLOPPIES_1|VIDEO_MONO|HAS_FLOPPY
   348                                  %if FPEM
   349 000003B1 83C802                          or      ax,HAS_FPU              ; a bit of a lie
   350                                  %endif
   351 000003B4 A31000                  	mov	word [equipment_flag],ax
   352                                  
   353                                  	extern	_cpu_speed
   354 000003B7 E8(0000)                	call	_cpu_speed
   355 000003BA 055802                  	add	ax,600
   356 000003BD B9E204                  	mov	cx,1250
   357 000003C0 31D2                    	xor	dx,dx
   358 000003C2 F7F1                    	div	cx
   359 000003C4 A2FF00                  	mov	byte [cpu_xtal],al	; CPU oscillator frequency
   360                                  
   361                                  %if CVDU_8563
   362                                  	xor	dx,dx
   363                                  	mov	dl,[video_cga_palette]
   364                                  	push	dx			; CVDU memory size
   365                                  %endif
   366 000003C7 FF361300                	push	word [memory_size]
   367                                  
   368 000003CB 68[0000]                	push	DGROUP
   369 000003CE 1F                      	popm	ds			; This is for the C-programs
   370                                  
   371 000003CF 50                      	push	ax
   372                                  	extern	@timer_init
   373 000003D0 E8(0000)                	call	@timer_init
   374 000003D3 58                      	pop	ax
   375                                  
   376 000003D4 1E                      	push	ds
   377 000003D5 A90100                  	test	ax,1
   378 000003D8 7505                    	jnz	.cpu_clock_05
   379 000003DA 68[9801]                	push	msg_cpu_clock_00
   380 000003DD EB03                    	jmp	.print_cpu_clock
   381                                  .cpu_clock_05:
   382 000003DF 68[9501]                	push	msg_cpu_clock_05
   383                                  .print_cpu_clock:
   384 000003E2 D1E8                    	shr	ax,1
   385 000003E4 50                      	push	ax
   386 000003E5 1E                      	push	ds
   387 000003E6 68[4001]                	push	msg_cpu_memory
   388 000003E9 E8(0000)                	call	_cprintf
   389 000003EC 83C40A                  	add	sp,12-2
   390                                  %if 1
   391 000003EF 58                              pop     ax                      ; memory size in K
   392 000003F0 E8B903                          call    POST_memory             ; Power On Self Test
   393                                  %endif
   394                                  %if CVDU_8563
   395                                  	inc	sp
   396                                  	inc	sp			; remove CVDU memory size
   397                                  %endif
   398 000003F3 E81A00                  	call	nvram_init
   399                                  
   400 000003F6 1E                      	push	ds		; DS = DGROUP (CONST)
   401 000003F7 68[E401]                	push	msg_floppy
   402 000003FA E8(0000)                	call	_cprintf
   403 000003FD 83C404                  	add	sp,4
   404                                  
   405                                  	extern	@floppy_init
   406 00000400 E8(0000)                	call	@floppy_init
   407                                  
   408                                  %if FRONT_PANEL
   409 00000403 1E                      	PUSH 	DS
   410 00000404 0E                           	push    cs
   411 00000405 1F                              pop     ds              ; Source
   412 00000406 BA[1E03]                	mov  dx,CPUUP		;    	
   413 00000409 B451                        	mov  ah, 0x51       	; ah=0x51 - "Write BUFFER TO FRONT PANEL"
   414 0000040B CD15                        	INT  0x15  		;
   415 0000040D 1F                          	pop 	DS
   416                                  %endif
   417                                  
   418                                  
   419 0000040E EB62                    	jmp	boot_the_OS
   420                                  
   421                                  
   422                                  ;========================================================================
   423                                  ; nvram_init - check NVRAM checksum, prompt for NVRAM setup, apply NVRAM configuration
   424                                  ;========================================================================
   425                                  nvram_init:
   426                                  	extern	@nvram_check
   427 00000410 E8(0000)                	call	@nvram_check
   428 00000413 09C0                    	or	ax,ax
   429 00000415 740C                    	jz	.ask_setup
   430                                  
   431 00000417 1E                      	push	ds
   432 00000418 68[BA01]                	push	msg_nvram_bad
   433 0000041B E8(0000)                	call	_cprintf
   434 0000041E 83C404                  	add	sp,4
   435 00000421 EB2D                    	jmp	.run_setup
   436                                  
   437                                  .ask_setup:
   438 00000423 1E                      	push	ds
   439 00000424 68[9901]                	push	msg_setup
   440 00000427 E8(0000)                	call	_cprintf
   441 0000042A 83C404                  	add	sp,4
   442                                  
   443 0000042D B400                    	mov	ah,0
   444 0000042F CD1A                    	int	1Ah
   445 00000431 89D3                    	mov	bx,dx
   446 00000433 83C324                  	add	bx,18*2		; wait 2 seconds
   447                                  .wait_setup:
   448 00000436 B401                    	mov	ah,1
   449 00000438 CD16                    	int	16h
   450 0000043A 740A                    	jz	.wait_setup_1
   451 0000043C B400                    	mov	ah,0
   452 0000043E CD16                    	int	16h
   453 00000440 0C20                    	or	al,'s'^'S'
   454 00000442 3C73                    	cmp	al,'s'
   455 00000444 740A                    	je	.run_setup
   456                                  
   457                                  .wait_setup_1:
   458 00000446 B400                    	mov	ah,0
   459 00000448 CD1A                    	int	1Ah
   460 0000044A 39DA                    	cmp	dx,bx
   461 0000044C 72E8                    	jb	.wait_setup
   462 0000044E EB03                    	jmp	.skip_setup
   463                                  
   464                                  .run_setup:
   465                                  	extern	@nvram_setup
   466 00000450 E8(0000)                	call	@nvram_setup
   467                                  
   468                                  .skip_setup:
   469                                  	extern	@nvram_apply
   470 00000453 E8(0000)                	call	@nvram_apply
   471                                  
   472 00000456 E80602                          call    ticktime                ; set the tick clock
   473                                  
   474 00000459 C3                      	ret
   475                                  
   476                                  ;========================================================================
   477                                  ; BIOS_call_18h - Start ROM Basic
   478                                  ; Note:
   479                                  ;	In this BIOS it prints a "no Basic" message and tries to boot the OS
   480                                  ;	or it will run tests if tests are enabled
   481                                  ;========================================================================
   482                                  BIOS_call_18h:
   483 0000045A FB                      	sti
   484                                  %ifdef TESTS
   485                                  	extern	tests
   486                                  	call	tests
   487                                  %else	; TESTS
   488                                  
   489                                  %if TBASIC
   490                                  ;;;        extern  cbasic
   491                                  ;;;        extern  end_cbasic
   492                                  ;;;	jmp	seg cbasic:cbasic
   493 0000045B EA000000F0              	jmp	0F000h:0000h
   494                                  %else
   495                                  	mov	ax,bios_data_seg
   496                                  	mov	ss,ax			; Reset SS
   497                                  	mov	sp,7000h		; and SP
   498                                  	push	DGROUP			; just in case DS is not pointing
   499                                  	popm	ds			; were it should
   500                                  
   501                                  	push	ds
   502                                  	push	msg_no_basic
   503                                  	call	_cprintf
   504                                  	add	sp,4
   505                                  	mov	ah,0			; get any keystroke; jrc 2012/12/02
   506                                  	int	16h
   507                                  	int	19h			; reboot the OS
   508                                  %endif  ; TBASIC
   509                                  
   510                                  %endif	; TESTS
   511                                  .1:
   512 00000460 F4                      	hlt				; we should never get here
   513 00000461 EBFD                    	jmp	.1
   514                                  
   515                                  ;========================================================================
   516                                  ; BIOS_call_19h  - re-Boot the OS
   517                                  ;========================================================================
   518                                  BIOS_call_19h:
   519 00000463 6A40                    	push	bios_data_seg
   520 00000465 1F                      	popm	ds
   521 00000466 C70672003412            	mov	word [warm_boot],1234h	; set warm boot flag
   522 0000046C FA                      	cli				; disable interrupts
   523 0000046D EA0000FFFF              	jmp	0FFFFh:0000h		; go to STARTUP.BIN code
   524                                  
   525                                  
   526                                  
   527                                  
   528                                  ;========================================================================
   529                                  ;========================================================================
   530                                  boot_the_OS:
   531 00000472 B84000                  	mov	ax,bios_data_seg
   532 00000475 8ED0                    	mov	ss,ax			; Reset SS
   533 00000477 BC0070                  	mov	sp,7000h		; and SP
   534 0000047A 68[0000]                	push	DGROUP			; just in case DS is not pointing
   535 0000047D 1F                      	popm	ds			; were it should
   536 0000047E FB                      	sti
   537                                  
   538                                  %if CVDU_8242
   539 0000047F 36800E170020                ss	or	byte [keyboard_flags_0],CVDU_KEYBOARD_STATUS ; NumLock?
   540                                  	extern	I8242UpdateLites_
   541 00000485 E8(0000)                	call	I8242UpdateLites_
   542                                  %endif
   543                                  
   544 00000488 6A41                    	push	'A'
   545 0000048A 1E                      	push	ds
   546 0000048B 68[FD01]                	push	msg_booting
   547 0000048E E8(0000)                	call	_cprintf
   548 00000491 83C406                  	add	sp,6
   549                                  
   550 00000494 B200                    	mov	dl,0
   551 00000496 E82100                  	call	boot_drive
   552                                  
   553 00000499 6A43                    	push	'C'
   554 0000049B 1E                      	push	ds
   555 0000049C 68[FD01]                	push	msg_booting
   556 0000049F E8(0000)                	call	_cprintf
   557 000004A2 83C406                  	add	sp,6
   558                                  %if SOFT_DEBUG>1
   559                                  	int 0
   560                                  %endif
   561 000004A5 B280                    	mov	dl,80h
   562 000004A7 E81000                  	call	boot_drive
   563                                  
   564                                  %if FRONT_PANEL
   565 000004AA 1E                      	PUSH 	DS
   566 000004AB 0E                           	push    cs
   567 000004AC 1F                              pop     ds              ; Source
   568 000004AD BA[2E03]                	mov  dx,BASICMSG		;    	
   569 000004B0 B451                        	mov  ah, 0x51       	; ah=0x51 - "Write BUFFER TO FRONT PANEL"
   570 000004B2 CD15                        	INT  0x15  		;
   571 000004B4 1F                          	pop 	DS
   572                                  %endif
   573                                  
   574                                  
   575 000004B5 CD18                    	int	18h			; failed to boot, start ROM Basic
   576                                  
   577                                  .1:
   578 000004B7 F4                      	hlt				; we should never get here
   579 000004B8 EBFD                    	jmp	.1
   580                                  
   581                                  ;========================================================================
   582                                  ; boot_drive - try to boot from the drive
   583                                  ; Input:
   584                                  ;	DL = drive number (00h = first floppy, 80h = first HDD)
   585                                  ;========================================================================
   586                                  boot_drive:
   587 000004BA BE0300                  	mov	si,3			; make 3 tries before giving up
   588                                  
   589                                  %if SOFT_DEBUG>1
   590                                  	nop
   591                                  	int 0
   592                                  %endif
   593                                  .1:					; loop comes back here
   594 000004BD B400                    	mov	ah,0			; reset the Disk Controller
   595 000004BF CD13                    	int	13h
   596                                  	
   597 000004C1 52                      	push	dx
   598 000004C2 B408                    	mov	ah,8			; get drive parameters
   599 000004C4 CD13                    	int	13h
   600 000004C6 88D0                    	mov	al,dl			; number of drives
   601 000004C8 5A                      	pop	dx
   602 000004C9 7213                    	jc	.fn8_error
   603                                  
   604                                  
   605                                  %if SOFT_DEBUG > 2
   606                                  	nop
   607                                  	int	0
   608                                  
   609                                          mov     ax,0401h                ; verify sector
   610                                  	mov	cx,1			; track 0, sector 1
   611                                  	mov	dh,0			; head 0
   612                                          int     13h
   613                                  
   614                                          nop
   615                                          int     0
   616                                  %endif
   617                                  
   618 000004CB B80102                  	mov	ax,0201h		; read one sector
   619 000004CE B90100                  	mov	cx,1			; track 0, sector 1
   620 000004D1 B600                    	mov	dh,0			; head 0
   621 000004D3 31DB                    	xor	bx,bx
   622 000004D5 8EC3                    	mov	es,bx			; ES = 0
   623 000004D7 BB007C                  	mov	bx,7C00h		; ES:BX = 0000:7C00
   624 000004DA CD13                    	int	13h
   625 000004DC 730F                    	jnc	.read_ok
   626                                  
   627                                  .fn8_error:
   628 000004DE 4E                      	dec	si			; go back and reset the controller
   629 000004DF 75DC                    	jnz	.1			; make several tries
   630                                  
   631 000004E1 50                      	push	ax
   632 000004E2 1E                      	push	ds
   633 000004E3 68[1C02]                	push	msg_boot_err
   634 000004E6 E8(0000)                	call	_cprintf
   635 000004E9 83C406                  	add	sp,4+2
   636 000004EC C3                      	ret
   637                                  
   638                                  .read_ok:
   639 000004ED 52                      	push	dx
   640                                  
   641 000004EE B80480                          mov     ax,8004h                ; NVRAM bits
   642 000004F1 E81304                          call    rtc_get_loc
   643 000004F4 A802                            test    al,2            ; RAM_bits_AA55 flag
   644 000004F6 7538                            jnz     .cpm_bootsec
   645 000004F8 26813EFE7D55AA              es	cmp	word [7C00h+1FEh],0AA55h
   646 000004FF 7415                    	je	.good_signature
   647 00000501 26813EBC7D55AA              es	cmp	word [7C00h+1BCh],0AA55h
   648 00000508 7420                        	je	.minix_bootsec
   649 0000050A 1E                      	push	ds
   650 0000050B 68[3702]                	push	msg_no_boot
   651 0000050E E8(0000)                	call	_cprintf
   652 00000511 83C404                  	add	sp,4		; remove DX also
   653 00000514 5A                      	pop	dx		; **
   654 00000515 C3                      	ret
   655                                  .good_signature:
   656 00000516 26833E007C00                es	cmp	word [7C00h+000h],0
   657 0000051C 751C                    	jne	.good_bootsec
   658 0000051E 1E                      	push	ds
   659 0000051F 68[5102]                	push	msg_no_loader
   660 00000522 E8(0000)                	call	_cprintf
   661 00000525 83C404                  	add	sp,4		; remove DX also
   662 00000528 5A                      	pop	dx		; **
   663 00000529 C3                      	ret
   664                                  
   665                                  .minix_bootsec:
   666 0000052A 1E                      	push	ds		; alternate boot signature
   667 0000052B 68[8702]                	push	msg_alt_disk
   668 0000052E EB04                    	jmp	short .cpmbs2
   669                                  .cpm_bootsec:
   670 00000530 1E                              push    ds
   671 00000531 68[7302]                        push    msg_cpm_disk
   672 00000534 E8(0000)                .cpmbs2:  call    _cprintf
   673 00000537 83C404                  	add	sp,4
   674                                  .good_bootsec:
   675 0000053A 1E                      	push	ds
   676 0000053B 68[6F02]                	push	msg_boot_ok
   677 0000053E E8(0000)                	call	_cprintf
   678 00000541 83C404                  	add	sp,4
   679                                  
   680 00000544 5A                      	pop	dx
   681                                  
   682                                  %if SOFT_DEBUG>1
   683                                  	global	major_debug
   684                                  major_debug:
   685                                  	cmp	dl,0
   686                                  	jne	.999
   687                                  
   688                                  	xor	bx,bx
   689                                  	push	bx
   690                                  	popm	es			; ES = 0
   691                                  	mov	bx,7C00h		; ES:BX = 0000:7C00
   692                                  	int	0
   693                                  
   694                                  	mov	ax,0201h
   695                                  	inc	cl
   696                                  	int	13h
   697                                  
   698                                  	mov	ax,0201h
   699                                  	mov	cl,10h
   700                                  	int	13h
   701                                  
   702                                  	mov	ax,0201h
   703                                  	mov	dh,1
   704                                  	int	13h
   705                                  
   706                                  	mov	ax,0201h
   707                                  	mov	ch,1		; cylinder 1
   708                                  	int	13h
   709                                  
   710                                  	mov	ax,0201h
   711                                  	mov	ch,23h
   712                                  	int	13h
   713                                  
   714                                  	mov	ax,0201h
   715                                  	mov	cx,1
   716                                  	mov	dh,0
   717                                  	int	13h
   718                                  
   719                                  .999:
   720                                  %endif
   721                                  %if SOFT_DEBUG
   722                                  	push	7
   723                                  	call	lites
   724                                  	int 0
   725                                  %endif
   726 00000545 EA007C0000              	jmp	0000:7C00h		; execute the boot sector
   727                                  
   728                                  
   729                                  ;========================================================================
   730                                  ; BIOS_call_14h  - Serial port communication services
   731                                  ;========================================================================
   732                                  BIOS_call_14h:
   733                                  %if TRACE
   734                                  	call	int_trace
   735                                  %endif	; TRACE
   736 0000054A 31C0                    	xor	ax,ax
   737 0000054C CF                      	iret
   738                                  
   739                                  ;========================================================================
   740                                  ; BIOS_call_17h  - Print services
   741                                  ;========================================================================
   742                                  BIOS_call_17h:
   743                                  %if TRACE
   744                                  	call	int_trace
   745                                  %endif	; TRACE
   746 0000054D B400                    	mov	ah,0
   747 0000054F CF                      	iret
   748                                  
   749                                  ;========================================================================
   750                                  
   751                                  interrupt_table:
   752                                  
   753                                  %if SOFT_DEBUG
   754                                  	db	0			; Int 0 - divide by zero
   755                                  	extern	zero_divide
   756                                  	dw	zero_divide
   757                                  
   758                                  	db	1			; Int 1 - single step
   759                                  	extern	single_step
   760                                  	dw	single_step
   761                                  
   762                                  	db	2			; Int 2 - NMI interrupt
   763                                  	extern	nmi_interrupt
   764                                  	dw	nmi_interrupt
   765                                  
   766                                  	db	3			; Int 3 - breakpoint
   767                                  	extern	breakpoint
   768                                  	dw	breakpoint
   769                                  
   770                                  	db	4			; Int 4 - interrupt on overflow (INTO instruction)
   771                                  	extern	INTO_trap
   772                                  	dw	INTO_trap
   773                                  
   774                                  	db	5			; Int 5 - bound check error
   775                                  	extern	bound_trap
   776                                  	dw	bound_trap
   777                                  
   778                                  	db	6			; Int 6 - invalid opcode
   779                                  	extern	undefined_op
   780                                  	dw	undefined_op
   781                                  %endif	; SOFT_DEBUG
   782                                  
   783                                  %if FPEM
   784                                  %if 0
   785                                  	db	7			; ESC opcode / Floating Point
   786                                  	extern	vector7
   787                                  	dw	vector7
   788                                  %endif
   789                                  %else
   790                                  %if SOFT_DEBUG
   791                                  	db	7			; Int 7 - math coprocessor not present
   792                                  	dw	undefined_op
   793                                  %endif	; SOFT_DEBUG
   794                                  %endif
   795                                  
   796 00000550 08                      	db	8			; Timer 0 interrupt
   797                                  	extern	timer0_interrupt
   798 00000551 [0000]                  	dw	timer0_interrupt
   799                                  
   800 00000553 0A                      	db	0Ah			; DMA 0 interrupt
   801                                  	extern	dma0_interrupt
   802 00000554 [0000]                  	dw	dma0_interrupt
   803                                  
   804 00000556 0B                      	db	0Bh			; DMA 1 interrupt
   805 00000557 [8905]                  	dw	end_of_interrupt
   806                                  
   807 00000559 0C                      	db	0Ch			; INT0 - external bus INT
   808                                  %if CVDU_8242 & (1-CVDU_USE_KBD_HOOK)
   809                                  	extern	cvdu_kbd_int
   810                                  	dw	cvdu_kbd_int
   811                                  %else
   812 0000055A [8905]                  	dw	end_of_interrupt
   813                                  %endif
   814                                  
   815 0000055C 0D                      	db	0Dh			; INT1 - UART
   816                                  %if UART
   817                                  	extern	uart_int
   818 0000055D [0000]                  	dw	uart_int
   819                                  %else
   820                                  	dw	end_of_interrupt
   821                                  %endif
   822                                  
   823 0000055F 0F                      	db	0Fh
   824                                  	extern	fdc_interrupt_level
   825 00000560 [0000]                  	dw	fdc_interrupt_level	; INT3 - FDC
   826                                  
   827 00000562 10                      	db	10h			; BIOS - Video display services
   828                                  	extern	BIOS_call_10h
   829 00000563 [0000]                  	dw	BIOS_call_10h
   830                                  
   831 00000565 11                      	db	11h			; BIOS - Return equipment list
   832 00000566 [1907]                  	dw	BIOS_call_11h		; in memory.asm
   833                                  
   834 00000568 12                      	db	12h			; BIOS - Return conventional memory size
   835 00000569 [2307]                  	dw	BIOS_call_12h		; (shared with Timer 1)
   836                                  ;;;	dw	timer1_interrupt	; non INT 12h passed to timer1
   837                                  
   838 0000056B 13                      	db	13h			; BIOS - Disk services
   839                                  %if PPIDE_driver | DIDE_driver | DSD_driver
   840                                  	extern	FIXED_BIOS_call_13h
   841 0000056C [0000]                  	dw	FIXED_BIOS_call_13h     ; (shared with Timer 2, prescaler, NOT USED)
   842                                  
   843 0000056E 40                              db      40h                     ; Floppy Driver
   844                                  %endif
   845                                  	extern	BIOS_call_13h
   846 0000056F [0000]                          dw      BIOS_call_13h
   847                                  
   848 00000571 14                      	db	14h			; BIOS - Serial port communication
   849 00000572 [4A05]                  	dw	BIOS_call_14h
   850                                  
   851 00000574 15                      	db	15h			; BIOS - Miscellaneous system services support routines
   852                                  	extern	BIOS_call_15h
   853 00000575 [0000]                  	dw	BIOS_call_15h
   854                                  
   855 00000577 16                      	db	16h			; BIOS - Keyboard services
   856                                  	extern	BIOS_call_16h
   857 00000578 [0000]                  	dw	BIOS_call_16h
   858                                  
   859 0000057A 17                      	db	17h
   860 0000057B [4D05]                  	dw	BIOS_call_17h		; BIOS - Print services
   861                                  
   862                                  %if TBASIC==0 
   863                                  	db	18h			; BIOS - Start ROM Basic
   864                                  	dw	BIOS_call_18h
   865                                  %endif
   866                                  
   867 0000057D 19                      	db	19h			; BIOS - Boot the OS
   868 0000057E [6304]                  	dw	BIOS_call_19h
   869                                  
   870 00000580 1A                      	db	1Ah			; BIOS - RTC (real time clock) services
   871                                  	extern	BIOS_call_1Ah
   872 00000581 [0000]                  	dw	BIOS_call_1Ah
   873                                  
   874 00000583 1C                      	db	1Ch
   875                                  	extern	BIOS_call_1Ch
   876 00000584 [0000]                  	dw	BIOS_call_1Ch
   877                                  
   878 00000586 70                      	db	70h			; RTC timer tick on IRQ8
   879                                  	extern	rtc_interrupt
   880 00000587 [0000]                  	dw	rtc_interrupt		; 1024 Hz timer
   881                                  
   882                                  num_vectors	equ     (($-interrupt_table)/3)
   883                                  
   884                                  ;========================================================================
   885                                  ; end_of_interrupt - signal end of interrupt to the interrupt controller
   886                                  ;========================================================================
   887                                  end_of_interrupt:
   888 00000589 5250                            pushm   ax,dx
   889 0000058B BA22FF                          mov     dx,PIC_EOI              ; EOI register
   890 0000058E B80080                          mov     ax,EOI_NSPEC            ; non-specific end of interrupt
   891 00000591 EF                              out     dx,ax                   ; signal it
   892 00000592 585A                            popm    ax,dx
   893 00000594 CF                      	iret
   894                                  
   895                                  skip_trap:
   896                                  %if TRACE
   897                                  	call	int_trace
   898                                  %endif	; TRACE
   899 00000595 CF                              iret            ; return from interrupt is a null trap
   900                                  
   901                                  
   902                                  ;========================================================================
   903                                  ;  Interrupt priority re-assignments
   904                                  ;========================================================================
   905                                  MASK		equ	08h	; mask interrupt
   906                                  LTM		equ	10h	; Level Trigger Mode
   907                                  interrupt_priority:
   908 00000596 0E                      	db	6 | MASK	; Timers -- timer_init clears the mask
   909 00000597 02                      	db	2		; DMA0
   910 00000598 0A                      	db	2 | MASK	; DMA1
   911 00000599 0C                      	db	4 | MASK	; INT0 -- external /INT (keyboard)
   912 0000059A 04                      	db	4		; INT1 -- UART
   913 0000059B 0F                      	db	7 | MASK	; INT2
   914 0000059C 1B                      	db	3 | LTM+MASK	; INT3 -- floppy disk
   915                                  lth_int_priority   equ	$-interrupt_priority
   916                                  
   917                                  set_interrupt_priority:
   918                                  %if 0
   919                                  /* for now */
   920                                  	mov	dx,PIC_TCR
   921                                  	mov	si,interrupt_priority
   922                                  	xor	ax,ax		; zap AH
   923                                  	mov	cx,lth_int_priority
   924                                  sip_loop:
   925                                     cs	lodsb			; get priority level
   926                                     	out	dx,ax
   927                                  	add	dx,2		; PIC control regs are even
   928                                  	loop	sip_loop
   929                                  %endif
   930 0000059D C3                      	ret
   931                                  
   932                                  ;========================================================================
   933                                  ; set_traps - setup interrupt table
   934                                  ;========================================================================
   935                                  set_traps:
   936 0000059E 1E                              push    ds
   937                                  
   938 0000059F 8CCA                    	mov	dx,cs
   939 000005A1 B90001                  	mov	cx,0100h	; number of interrupt vectors
   940 000005A4 B300                    	mov	bl,0		; start with int 0
   941 000005A6 B8[9505]                	mov	ax,skip_trap
   942                                  .set_default_loop:
   943 000005A9 E83E00                  	call	set_vector
   944 000005AC FEC3                    	inc	bl
   945 000005AE E2F9                    	loop	.set_default_loop
   946                                  	
   947 000005B0 8EDA                            mov     ds,dx           ; for LODS  CS==DX==DS
   948                                          cnop
   949 000005B2 BE[5005]                        mov     si,interrupt_table	; load address to start
   950 000005B5 B91300                  	mov	cx,num_vectors
   951                                  				; note DX = CS
   952                                  .set_vectors_loop:
   953 000005B8 AC                      	lodsb
   954 000005B9 88C3                    	mov	bl,al
   955 000005BB AD                      	lodsw
   956 000005BC E82B00                  	call	set_vector
   957 000005BF E2F7                    	loop	.set_vectors_loop
   958                                  
   959                                  %if TBASIC
   960 000005C1 B318                    	mov	bl,18h		; int 18h is Tiny Basic
   961 000005C3 31C0                    	xor	ax,ax
   962 000005C5 BA00F0                  	mov	dx,0F000h	; absolute segment load @ 00K
   963 000005C8 E81F00                  	call	set_vector
   964                                  %endif
   965                                  %if FPEM
   966 000005CB B307                    	mov	bl,07h		; vector 7 is FPU emulator
   967 000005CD 31C0                    	xor	ax,ax
   968 000005CF BA80F4                  	mov	dx,0F480h	; absolute segment load @ 18K
   969 000005D2 E81500                  	call	set_vector
   970                                  %endif
   971                                  
   972 000005D5 1F                              popm     ds
   973 000005D6 C3                              ret
   974                                  
   975                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   976                                  ;  get_vector
   977                                  ;       Get an interrupt vector
   978                                  ;
   979                                  ;       Enter with vector number in BL
   980                                  ;       Exit with vector in DX:AX
   981                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   982                                          global  get_vector
   983                                  get_vector:
   984 000005D7 1E53                            pushm   bx,ds		; register saves
   985                                  
   986 000005D9 31C0                            xor     ax,ax           ; zero BX
   987 000005DB 8ED8                            mov     ds,ax           ; set DS=0
   988                                          cnop
   989 000005DD B700                    	mov	bh,0
   990 000005DF C1E302                          shl     bx,2            ; index * 4
   991                                  
   992 000005E2 8B07                            mov     ax,[bx]         ; load the vector
   993 000005E4 8B5702                          mov     dx,[bx+2]       ;
   994                                  
   995 000005E7 5B1F                            popm    bx,ds		; register restores
   996 000005E9 C3                              ret                     ; result in DX:AX
   997                                  
   998                                  
   999                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1000                                  ;  set_vector
  1001                                  ;       Set an interrupt vector
  1002                                  ;
  1003                                  ;       Enter with vector number in BL
  1004                                  ;               vector in DX:AX
  1005                                  ;
  1006                                  ;       All registers preserved
  1007                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1008                                          global  set_vector
  1009                                  set_vector:
  1010 000005EA 1E5351                          pushm   cx,bx,ds	; register saves
  1011                                  
  1012 000005ED 31C9                    	xor	cx,cx
  1013 000005EF 8ED9                            mov     ds,cx           ; set DS=0
  1014                                          cnop
  1015 000005F1 B700                    	mov	bh,0
  1016 000005F3 C1E302                          shl     bx,2            ; index * 4
  1017                                  
  1018 000005F6 8907                            mov     [bx],ax         ; set offset
  1019 000005F8 895702                          mov     [bx+2],dx       ; set segment
  1020                                  
  1021 000005FB 595B1F                          popm    cx,bx,ds	; register restores
  1022 000005FE C3                              ret                     ; return
  1023                                          
  1024                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1025                                  ;  cpu_table_init
  1026                                  ;
  1027                                  ;       call    cpu_table_init
  1028                                  ;       dw      <table>         ; table in the Code segment
  1029                                  ;       <return here>
  1030                                  ;               AX, CX, DX are trashed
  1031                                  ;
  1032                                  ;
  1033                                  ; table:
  1034                                  ;       db_lo   <cpu_register>
  1035                                  ;       dw      <contents>
  1036                                  ;       ...
  1037                                  ;       db      0       ; ends table
  1038                                  ;
  1039                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1040                                          global  cpu_table_init
  1041                                  cpu_table_init:
  1042                                  ; get the table address
  1043 000005FF 89F1                            mov     cx,si           ; save SI
  1044 00000601 5E                              pop     si              ; get the return address
  1045 00000602 2EAD                        cs  lodsw                   ; get the table address
  1046 00000604 56                              push    si              ; save incremented return address
  1047 00000605 51                              push    cx              ; save former SI
  1048                                  
  1049 00000606 89C6                            mov     si,ax           ; CS:SI is table pointer
  1050 00000608 B6FF                            mov     dh,cpu_relocation>>8
  1051                                  .1:
  1052 0000060A 2EAC                        cs  lodsb                   ; get low device code
  1053 0000060C 84C0                            test    al,al
  1054 0000060E 7407                            jz      .9              ; done with table on zero low device code
  1055 00000610 88C2                            mov     dl,al
  1056 00000612 2EAD                        cs  lodsw                   ; get cpu register data
  1057 00000614 EF                              out     dx,ax           ; output a full word
  1058 00000615 EBF3                            jmp     .1
  1059                                  .9:
  1060 00000617 5E                              pop     si              ; restore SI
  1061 00000618 C3                              ret                     ;
  1062                                          
  1063                                  
  1064                                  %if 1
  1065                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1066                                  ;  C-callable:
  1067                                  ;       dword __fastcall divLS(dword dividend, word divisor);
  1068                                  ;
  1069                                  ;       double word  divided by  word
  1070                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1071                                          global  @divLS
  1072                                  @divLS:
  1073                                          ; DX:AX is dividend
  1074                                          ; BX is divisor
  1075 00000619 09D2                            or      dx,dx
  1076 0000061B 7505                            jnz     .3
  1077 0000061D F7F3                            div     bx
  1078 0000061F 31D2                            xor     dx,dx
  1079 00000621 C3                              ret
  1080                                  
  1081 00000622 89C1                    .3:     mov     cx,ax           ; save low dividend in CX
  1082 00000624 89D0                            mov     ax,dx
  1083 00000626 31D2                            xor     dx,dx           ; 0:DX div BX
  1084 00000628 F7F3                            div     bx
  1085 0000062A 91                              xchg    cx,ax           ; CX is high quotient
  1086 0000062B F7F3                            div     bx
  1087 0000062D 89CA                            mov     dx,cx
  1088 0000062F C3                              ret
  1089                                  
  1090                                  %ifndef HAS_FASTCALL
  1091                                          global  _divLS
  1092                                  _divLS: push    bp
  1093                                          mov     bp,sp
  1094                                          mov     ax,ARG(1)
  1095                                          mov     dx,ARG(2)
  1096                                          mov     bx,ARG(3)
  1097                                          call    @divLS
  1098                                          leave
  1099                                          ret
  1100                                  
  1101                                          global  _remLS
  1102                                  _remLS: push    bp
  1103                                          mov     bp,sp
  1104                                          mov     ax,ARG(1)
  1105                                          mov     dx,ARG(2)
  1106                                          mov     bx,ARG(3)
  1107                                          call    @remLS
  1108                                          leave
  1109                                          ret
  1110                                  %endif
  1111                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1112                                  ;  C-callable:
  1113                                  ;       word __fastcall remLS(dword dividend, word divisor);
  1114                                  ;
  1115                                  ;       remainder of:
  1116                                  ;       double word  divided by  word
  1117                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1118                                          global  @remLS
  1119                                  @remLS:
  1120                                          ; DX:AX is dividend
  1121                                          ; BX is divisor
  1122 00000630 09D2                            or      dx,dx
  1123 00000632 740A                            jz      .5
  1124 00000634 89C1                            mov     cx,ax           ; save low dividend in CX
  1125 00000636 89D0                            mov     ax,dx
  1126 00000638 31D2                            xor     dx,dx           ; 0:DX div BX
  1127 0000063A F7F3                            div     bx              ; discard quotient in AX
  1128 0000063C 89C8                            mov     ax,cx           ; restore low dividend
  1129 0000063E F7F3                    .5:     div     bx
  1130 00000640 89D0                            mov     ax,dx           ; remainder to AX
  1131 00000642 C3                              ret
  1132                                  
  1133                                  
  1134                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1135                                  ;  C-callable:
  1136                                  ;       dword __fastcall mulLS(dword factor1, word factor2);
  1137                                  ;
  1138                                  ;       double word  multiplied by  word
  1139                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1140                                  	global	@mulLS
  1141                                  @mulLS:
  1142                                  	; DX:AX is factor1
  1143                                  	; BX is factor2
  1144 00000643 09D2                            or      dx,dx
  1145 00000645 7503                            jnz     .1		; dx != 0
  1146 00000647 F7E3                            mul     bx
  1147 00000649 C3                              ret
  1148 0000064A 89C1                    .1:     mov     cx,ax           ; save low part of factor1 in CX
  1149 0000064C 89D0                            mov     ax,dx
  1150 0000064E F7E3                            mul     bx
  1151 00000650 91                              xchg    cx,ax           ; CX is a product of high part of factor1 and factor2
  1152 00000651 F7E3                            mul	bx
  1153 00000653 01CA                            add     dx,cx
  1154 00000655 C3                              ret
  1155                                  %endif
  1156                                  
  1157                                  
  1158                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1159                                  ;  microsecond
  1160                                  ;       Enter with CX = delay time in microseconds
  1161                                  ;       Exit with CX = 0
  1162                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1163                                          global  @microsecond
  1164                                          global  microsecond
  1165                                  @microsecond:		; C-callable with __fastcall
  1166 00000656 89C1                    	mov	cx,ax
  1167                                  microsecond:
  1168 00000658 E303                            jcxz    .9
  1169 0000065A 90                      .1:     nop		; 4 clocks
  1170 0000065B E2FD                            loop    .1	; 15 clocks	loop is 19 clocks (approx.)
  1171 0000065D C3                      .9:     ret
  1172                                  
  1173                                  ;========================================================================
  1174                                  ; wout - nobody calls it, but unasm defines it as an extenal symbol
  1175                                  ; XXX: Need to recompile unasm and kill it
  1176                                  ;========================================================================
  1177                                  	global	wout
  1178                                  wout:
  1179 0000065E C3                      	ret
  1180                                  
  1181                                  
  1182                                  
  1183                                  %macro  binary  1
  1184                                          mov     ah,%1
  1185                                          shr     ax,4
  1186                                          shr     al,4
  1187                                          aad
  1188                                          mov     %1,al
  1189                                  %endm
  1190                                          
  1191                                  
  1192                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1193                                  ;  ticktime -- set the tick count from the CMOS clock
  1194                                  ;
  1195                                  ;       Preserves all registers
  1196                                  ;
  1197                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1198                                          global  ticktime
  1199                                  ticktime:
  1200 0000065F 60                              pushm   ALL
  1201                                  
  1202 00000660 B402                            mov     ah,2            ; get Time
  1203 00000662 CD1A                            int     1Ah
  1204                                  
  1205                                          binary  dh
  1205 00000664 88F4                <1>  mov ah,%1
  1205 00000666 C1E804              <1>  shr ax,4
  1205 00000669 C0E804              <1>  shr al,4
  1205 0000066C D50A                <1>  aad
  1205 0000066E 88C6                <1>  mov %1,al
  1206                                          binary  cl
  1206 00000670 88CC                <1>  mov ah,%1
  1206 00000672 C1E804              <1>  shr ax,4
  1206 00000675 C0E804              <1>  shr al,4
  1206 00000678 D50A                <1>  aad
  1206 0000067A 88C1                <1>  mov %1,al
  1207                                          binary  ch
  1207 0000067C 88EC                <1>  mov ah,%1
  1207 0000067E C1E804              <1>  shr ax,4
  1207 00000681 C0E804              <1>  shr al,4
  1207 00000684 D50A                <1>  aad
  1207 00000686 88C5                <1>  mov %1,al
  1208                                  ;       mov     al,ch
  1209 00000688 88E5                            mov     ch,ah           ; CH = 0
  1210 0000068A B23C                            mov     dl,60           ; 60 min / hr,  60 sec / min
  1211 0000068C F6E2                            mul     dl
  1212 0000068E 01C8                            add     ax,cx           ; AX = hr*60 + min
  1213 00000690 88F1                            mov     cl,dh           ; CX = sec
  1214 00000692 88EE                            mov     dh,ch           ; DH = 0
  1215 00000694 F7E2                            mul     dx              ;
  1216 00000696 01C8                            add     ax,cx
  1217 00000698 83D200                          adc     dx,0            ; DX:AX = time in seconds
  1218                                  
  1219 0000069B BBFA00                          mov     bx,250
  1220 0000069E 89D1                            mov     cx,dx           ; CX:AX is time in seconds
  1221 000006A0 F7E3                            mul     bx
  1222 000006A2 91                              xchg    ax,cx           ; CX is low result
  1223 000006A3 F6E3                            mul     bl
  1224 000006A5 01D0                            add     ax,dx           ; AX:CX is 250*maxseconds
  1225                                  
  1226 000006A7 C1E302                          shl     bx,2            ; BX = 1000
  1227 000006AA 91                              xchg    ax,cx           ; CX:AX is 250*maxseconds
  1228 000006AB F7E3                            mul     bx              ; DX:AX is partial product
  1229 000006AD 91                              xchg    ax,cx
  1230 000006AE 87D3                            xchg    dx,bx           ; BX:CX is partial product
  1231 000006B0 F7E2                            mul     dx
  1232 000006B2 01D8                            add     ax,bx
  1233 000006B4 83D200                          adc     dx,0            ; DX:AX:CX is product
  1234                                  
  1235 000006B7 BBA335                          mov     bx,54924/4      ; = 13731       (divisor)
  1236 000006BA F7F3                            div     bx
  1237 000006BC 91                              xchg    ax,cx           ; CX is high quotient
  1238 000006BD F7F3                            div     bx              ; CX:AX is quotient, DX is remainder
  1239                                  ; round the result
  1240 000006BF 29D3                            sub     bx,dx           ; if DX > BX/2
  1241 000006C1 39D3                            cmp     bx,dx           ; 
  1242 000006C3 7706                            ja      .3
  1243 000006C5 83C001                          add     ax,1
  1244 000006C8 83D100                          adc     cx,0
  1245                                  .3:
  1246 000006CB 92                              xchg    ax,dx           ; CX:DX is tick count to set
  1247 000006CC B401                            mov     ah,1
  1248 000006CE CD1A                            int     1Ah             ; set tick count
  1249                                  
  1250 000006D0 61                              popm    ALL
  1251 000006D1 C3                              ret
  1252                                  
  1253                                  
  1254                                  
  1255                                  
  1256                                  ;========================================================================
  1257                                  
  1258                                  %include        "memory.asm"
     1                              <1> ;========================================================================
     2                              <1> ; MEMORY.ASM -- Memory management routines
     3                              <1> ;========================================================================
     4                              <1> ;
     5                              <1> ;   This version is for assembly by  NASM
     6                              <1> ;
     7                              <1> ; Copyright (C) 2011   John R. Coffman
     8                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board
     9                              <1> ;
    10                              <1> ; This program is free software: you can redistribute it and/or modify
    11                              <1> ; it under the terms of the GNU General Public License as published by
    12                              <1> ; the Free Software Foundation, either version 3 of the License, or
    13                              <1> ; (at your option) any later version.
    14                              <1> ;
    15                              <1> ; This program is distributed in the hope that it will be useful,
    16                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    17                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    18                              <1> ; GNU General Public License for more details.
    19                              <1> ;
    20                              <1> ; You should have received a copy of the GNU General Public License
    21                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    22                              <1> ;
    23                              <1> ;========================================================================
    24                              <1> 
    25                              <1>         segment         _TEXT
    26                              <1> 
    27                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    28                              <1> ;  get_ramsize
    29                              <1> ;
    30                              <1> ;       Return the number of 1k blocks of RAM in AX
    31                              <1> ;
    32                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    33                              <1> get_ramsize:
    34 000006D2 1E                  <1>         push    ds
    35 000006D3 53                  <1>         push    bx
    36 000006D4 51                  <1>         push    cx
    37 000006D5 31C0                <1>         xor     ax,ax           ; count of 1k intervals
    38 000006D7 89C3                <1>         mov     bx,ax           ; segment address
    39                              <1> .1:
    40 000006D9 8EDB                <1>         mov     ds,bx           ; set pointer
    41                              <1>         cnop
    42 000006DB 8B0E0000            <1>         mov     cx,word [0]     ; save contents
    43 000006DF C70600006CA5        <1>         mov     word [0],0a56ch ; addressing is [DS:0]
    44 000006E5 89DB                <1>         mov     bx,bx
    45 000006E7 89C0                <1>         mov     ax,ax           ; waste time
    46 000006E9 813E00006CA5        <1>         cmp     word [0],0a56ch ; see if it is the same
    47 000006EF 7524                <1>         jne     .9
    48 000006F1 890E0000            <1>         mov     word [0],cx     ; restore
    49 000006F5 8B0EFC03            <1>         mov     cx,word [1020]
    50 000006F9 C706FC03325A        <1>         mov     word [1020],05a32h  ; address [DS:1020]
    51 000006FF 89C0                <1>         mov     ax,ax
    52 00000701 89DB                <1>         mov     bx,bx
    53 00000703 813EFC03325A        <1>         cmp     word [1020],05a32h
    54 00000709 750A                <1>         jne     .9
    55 0000070B 890EFC03            <1>         mov     word [1020],cx  ; restore
    56                              <1> 
    57                              <1> ; Memory test succeeded at the address
    58                              <1> 
    59 0000070F 40                  <1>         inc     ax              ; count 1k
    60 00000710 83C340              <1>         add     bx,1024/16      ; increment segment register by paragraphs
    61 00000713 EBC4                <1>         jmp     .1
    62                              <1> 
    63                              <1> .9:
    64 00000715 59                  <1>         pop     cx
    65 00000716 5B                  <1>         pop     bx
    66 00000717 1F                  <1>         pop     ds
    67 00000718 C3                  <1>         ret
    68                              <1>         
    69                              <1> 
    70                              <1> 
    71                              <1> 
    72                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    73                              <1> ;  BIOS_call_11h
    74                              <1> ;
    75                              <1> ;       Get Equipment Configuration
    76                              <1> ;
    77                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    78                              <1> BIOS_call_11h:          
    79 00000719 FB                  <1>         sti
    80 0000071A 1E                  <1>         push    ds
    81 0000071B 6A40                <1>         push    bios_data_seg
    82 0000071D 1F                  <1>         pop     ds
    83 0000071E A11000              <1>         mov     ax,[equipment_flag]     ; pick it out of the BDA
    84 00000721 1F                  <1>         pop     ds
    85 00000722 CF                  <1>         iret
    86                              <1> 
    87                              <1> 
    88                              <1> 
    89                              <1> 
    90                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    91                              <1> ;  BIOS_call_12h
    92                              <1> ;
    93                              <1> ;       Get Conventional Memory Size
    94                              <1> ;
    95                              <1> ;  N.B.:  This BIOS call shares the interrupt vector with Timer 1.
    96                              <1> ;       Thus we need to see if an "int 12h" called us, otherwise
    97                              <1> ;       we assume this was a Timer 1 interrupt.
    98                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    99                              <1> ; stack
   100                              <1> offset_SI	equ	0
   101                              <1> offset_DS	equ	offset_SI+2
   102                              <1> offset_IP       equ     offset_DS+2
   103                              <1> offset_CS       equ     offset_IP+2
   104                              <1> offset_FLAGS    equ     offset_CS+2
   105                              <1> 
   106                              <1> BIOS_call_12h:
   107 00000723 1E                  <1>         push    ds
   108 00000724 56                  <1>         push    si
   109 00000725 89E6                <1>         mov     si,sp           ; establish stack addressing
   110 00000727 36C57404            <1>    ss   lds     si,[offset_IP+si]
   111                              <1>         cnop
   112 0000072B 817CFECD12          <1>         cmp     word [si-2],12CDh       ; int 12h
   113 00000730 5E                  <1>         pop     si
   114 00000731 7404                <1>         je      .4
   115 00000733 1F                  <1>         popm	ds
   116                              <1> ; since the segment is already correct...
   117                              <1> 	extern	timer1_interrupt
   118 00000734 E9(0000)            <1> 	jmp	timer1_interrupt
   119                              <1> 
   120 00000737 6A40                <1> .4:     push    bios_data_seg
   121 00000739 1F                  <1>         pop     ds
   122 0000073A A11300              <1>         mov     ax,[memory_size]
   123 0000073D 1F                  <1>         pop     ds
   124 0000073E CF                  <1>         iret
   125                              <1> 
   126                              <1> 
   127                              <1> 
   128                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   129                              <1> ;  Memory Test
   130                              <1> ;       Enter with segment to test in AX
   131                              <1> ;
   132                              <1> ;       Return: C=1 if error, (DI==loc)
   133                              <1> ;               C=0 if no error
   134                              <1> ;
   135                              <1> ;       AX, CX, DX, BP, DI, ES are all destroyed
   136                              <1> ;       DS, BX & SI are preserved
   137                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   138                              <1> memtest:
   139 0000073F 5D                  <1>         pop     bp              ; save return address in BP
   140                              <1> memtest0:                       ; entry to test page 0
   141 00000740 FC                  <1>         cld                     ; clear the direction flag
   142 00000741 8EC0                <1>         mov     es,ax           ; set segment
   143 00000743 31FF                <1>         xor     di,di
   144 00000745 B85AA5              <1>         mov     ax,0A55Ah       ; alternating bits in alternating bytes
   145 00000748 B90080              <1>         mov     cx,8000h        ; test 64K (2 x 32K)
   146 0000074B F3AB                <1>         rep stosw               ; 
   147 0000074D B580                <1>         mov     ch,80h          ; 32K count of words
   148 0000074F F3AF                <1>         repe scasw
   149 00000751 754F                <1>         jne     .3
   150                              <1> 
   151 00000753 86C4                <1>         xchg    al,ah           ; second pattern
   152 00000755 B580                <1>         mov     ch,80h          ; 32K count of words
   153 00000757 F3AB                <1>         rep stosw
   154 00000759 B580                <1>         mov     ch,80h          ; 32K count of words
   155 0000075B F3AF                <1>         repe scasw
   156 0000075D 7543                <1>         jne     .3
   157                              <1> %if 1
   158                              <1> seed1   equ     47F8h           ; NOT a random value
   159                              <1>                                 ; Seed values are chosen to have a relatively
   160                              <1>                                 ; prime cycle length, and to never produce a zero
   161                              <1>                                 ; Most random values will produce a zero!!!!
   162                              <1> 
   163 0000075F B8F847              <1>         mov     ax,seed1        ; seed value (critical)
   164                              <1>                                 ; cycle is 111 locations, relative prime to 2**15
   165 00000762 B580                <1>         mov     ch,80h          ; 32K words
   166                              <1> .t1:
   167 00000764 268905              <1>     es  mov     [di],ax         ; store the value
   168 00000767 F7E0                <1>         mul     ax
   169 00000769 47                  <1>         inc     di
   170 0000076A 88E0                <1>         mov     al,ah           ; generate the next bit pattern
   171 0000076C 47                  <1>         inc     di
   172 0000076D 88D4                <1>         mov     ah,dl
   173                              <1> %if 0
   174                              <1> .t102:  or      ax,ax           ; trap a bad seed value
   175                              <1>         jz      .t102
   176                              <1> %endif
   177 0000076F E2F3                <1>         loop    .t1             ; fill memory with the pattern
   178                              <1> 
   179 00000771 B8F847              <1>         mov     ax,seed1
   180 00000774 B580                <1>         mov     ch,80h          ; 32K words
   181                              <1> .t11:
   182 00000776 263B05              <1>     es  cmp     ax,[di]
   183 00000779 8D7D02              <1>         lea     di,[di+2]       ; don't touch the Zero flag
   184 0000077C 7524                <1>         jne     .3
   185 0000077E F7E0                <1>         mul     ax
   186 00000780 88E0                <1>         mov     al,ah
   187 00000782 88D4                <1>         mov     ah,dl
   188 00000784 E2F0                <1>         loop    .t11
   189                              <1> 
   190                              <1> %endif
   191 00000786 B8FFFF              <1>         mov     ax,0FFFFh       ; solid pattern of 1's
   192 00000789 B580                <1>         mov     ch,80h          ; 32K count of words
   193 0000078B F3AB                <1>         rep stosw
   194 0000078D B580                <1>         mov     ch,80h          ; 32K count of words
   195 0000078F F3AF                <1>         repe scasw
   196 00000791 750F                <1>         jne     .3
   197                              <1>         
   198 00000793 31C0                <1>         xor     ax,ax           ; solid pattern of 0's
   199 00000795 B580                <1>         mov     ch,80h          ; 32K count of words
   200 00000797 F3AB                <1>         rep stosw
   201 00000799 B580                <1>         mov     ch,80h          ; 32K count of words
   202 0000079B F3AF                <1>         repe scasw
   203 0000079D 7503                <1>         jne     .3
   204                              <1>         
   205 0000079F F8                  <1>         clc                     ; no error
   206 000007A0 FFE5                <1>         jmp     bp
   207                              <1> 
   208                              <1> .3: ; ERROR in scan string
   209 000007A2 4F                  <1>         dec     di
   210 000007A3 263A25              <1>    es   cmp     ah,[di]
   211 000007A6 7401                <1>         je      .4
   212 000007A8 4F                  <1>         dec     di
   213                              <1> .4:
   214 000007A9 F9                  <1>         stc
   215 000007AA FFE5                <1>         jmp     bp
   216                              <1> 
   217                              <1> 
   218                              <1> 
   219                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   220                              <1> ; POST_memory -- Power On Self Test of Memory
   221                              <1> ;
   222                              <1> ;
   223                              <1> ;  Enter with:
   224                              <1> ;       AX = memory limit in kilobytes
   225                              <1> ;	DS = DGROUP
   226                              <1> ;	SS = bios_data_seg
   227                              <1> ;
   228                              <1> ;  Watch out, "memtest" clobbers segment registers
   229                              <1> ;
   230                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   231                              <1> POST_memory:
   232 000007AC 0660                <1>         pushm   ALL,es	; ,ds
   233 000007AE 36813E72003412      <1>     ss	cmp	word [warm_boot],1234h
   234 000007B5 36C70672007856      <1>     ss 	mov	word [warm_boot],5678h	; non-magic value!!!
   235 000007BC 7507                <1>     	jne	.001
   236 000007BE 1E                  <1> 	push	ds
   237 000007BF 68[5000]            <1> 	push	msg_mem_bypass
   238 000007C2 E99800              <1> 	jmp	.print
   239                              <1> .001:
   240 000007C5 C1E006              <1>         shl     ax,6                    ; memory size in paragraphs
   241 000007C8 89C3                <1>         mov     bx,ax                   ; save in BX
   242                              <1> .1:
   243 000007CA BA0010              <1>         mov     dx,1000h                ; seg. 0000:xxxx has been tested
   244 000007CD 29D3                <1>         sub     bx,dx
   245 000007CF 7432                <1>         jz      .8                      ; done if down to zero
   246 000007D1 39D3                <1>         cmp     bx,dx
   247 000007D3 7302                <1>         jae     .2
   248 000007D5 89D3                <1>         mov     bx,dx
   249                              <1> .2:
   250 000007D7 53                  <1>         push    bx
   251                              <1> 
   252 000007D8 53                  <1>         push    bx
   253 000007D9 1E                  <1>         push    ds		;DGROUP
   254 000007DA 68[0000]            <1>         push    msg_mem_test
   255 000007DD E8(0000)            <1>         call    _cprintf
   256 000007E0 83C406              <1>         add     sp,6 
   257                              <1> 
   258 000007E3 5B                  <1>         pop     bx
   259 000007E4 89D8                <1>         mov     ax,bx                   ; AX is segment tested
   260 000007E6 E856FF              <1>         call    memtest
   261                              <1> 
   262                              <1> %if 0
   263                              <1> ;  induce an error to see printout
   264                              <1>         mov     di,3465h
   265                              <1>         stc
   266                              <1> %endif
   267 000007E9 73DF                <1>         jnc     .1
   268                              <1> ; make an error report
   269                              <1> 
   270 000007EB 89FA                <1>         mov     dx,di           ; copy byte address
   271 000007ED C1EF04              <1>         shr     di,4            ; convert to paragraphs
   272 000007F0 01DF                <1>         add     di,bx           ; DI is total paragraphs
   273 000007F2 83E20F              <1>         and     dx,0Fh          ; single-byte byte address
   274 000007F5 52                  <1>         push    dx
   275 000007F6 57                  <1>         push    di
   276 000007F7 1E                  <1>         push    ds		; DGROUP
   277 000007F8 68[7400]            <1>         push    msg_mem_error
   278 000007FB E8(0000)            <1>         call    _cprintf
   279 000007FE 83C408              <1>         add     sp,8
   280                              <1> 
   281 00000801 EBC7                <1>         jmp     .1
   282                              <1> 
   283                              <1> .8:
   284                              <1> %if SOFT_DEBUG==0
   285                              <1> ; tested down to 1000:0000
   286                              <1> ; now do the test at loc. 0  (watch out for the stack)
   287 00000803 53                  <1>         push    bx                      ; BX is zero
   288 00000804 1E                  <1>         push    ds		; DGROUP
   289 00000805 68[0000]            <1>         push    msg_mem_test
   290 00000808 E8(0000)            <1>         call    _cprintf
   291 0000080B 83C406              <1>         add     sp,6 
   292                              <1> 
   293 0000080E 1E9C                <1>         pushm   f,ds
   294 00000810 FA                  <1>         cli                             ; disable interrupts
   295                              <1> 
   296 00000811 6A00                <1>         push    0
   297 00000813 1F                  <1>         pop     ds                      ; source is 0000:xxxx
   298 00000814 680010              <1>         push    1000h           
   299 00000817 07                  <1>         pop     es                      ; dest. is 1000:xxxx (save area)
   300 00000818 31F6                <1>         xor     si,si
   301 0000081A 31FF                <1>         xor     di,di
   302 0000081C B90080              <1>         mov     cx,8000h                ; 32k words == 64K bytes
   303 0000081F F3A5                <1>         rep movsw
   304                              <1> 
   305 00000821 31C0                <1>         xor     ax,ax
   306 00000823 BD[2908]            <1>         mov     bp,.85
   307 00000826 E917FF              <1>         jmp     memtest0
   308                              <1> .85:
   309                              <1> %if 0
   310                              <1>         stc
   311                              <1>         mov     di,8765h                ; force error reporting
   312                              <1> %endif
   313 00000829 19D2                <1>         sbb     dx,dx                   ; grab the returned carry
   314 0000082B 89FB                <1>         mov     bx,di                   ; save error location
   315                              <1>         
   316 0000082D 680010              <1>         push    1000h                   ; source is 1000:xxxx
   317 00000830 1F                  <1>         pop     ds
   318 00000831 6A00                <1>         push    0
   319 00000833 07                  <1>         pop     es                      ; restore 0000:xxxx
   320 00000834 31F6                <1>         xor     si,si
   321 00000836 31FF                <1>         xor     di,di
   322 00000838 B90080              <1>         mov     cx,8000h                ; 32k words == 64K bytes
   323 0000083B F3A5                <1>         rep movsw
   324                              <1> 
   325 0000083D 1E                  <1>         push    ds
   326 0000083E 07                  <1>         pop     es
   327 0000083F 31C0                <1>         xor     ax,ax
   328 00000841 B580                <1>         mov     ch,80h                  ; re-zero 1000:0000 ...
   329 00000843 F3AB                <1>         rep stosw
   330                              <1> 
   331 00000845 9D1F                <1>         popm    f,ds
   332                              <1> %endif
   333 00000847 D1EA                <1>         shr     dx,1                    ; set the carry
   334 00000849 730E                <1>         jnc     .89
   335                              <1> 
   336                              <1> ; make the page 0 error report
   337 0000084B 53                  <1>         push    bx
   338 0000084C 1E                  <1>         push    ds			; DGROUP
   339 0000084D 68[9200]            <1>         push    msg_mem_error0
   340 00000850 E8(0000)            <1>         call    _cprintf
   341 00000853 83C406              <1>         add     sp,6
   342                              <1> 
   343 00000856 F4                  <1> .88:    hlt
   344 00000857 EBFD                <1>         jmp     .88
   345                              <1> 
   346                              <1> .89:
   347 00000859 1E                  <1>         push    ds			; DGROUP
   348 0000085A 68[2000]            <1>         push    msg_mem_done
   349                              <1> .print:
   350 0000085D E8(0000)            <1>         call    _cprintf
   351 00000860 83C404              <1>         add     sp,4
   352                              <1> .9:
   353 00000863 6107                <1>         popm    ALL,es ; ,ds
   354 00000865 C3                  <1>         ret
   355                              <1> 
   356                              <1> 
   357                              <1>         segment CONST
   358                              <1> msg_mem_test:
   359 00000000 0D2538615465737469- <1>         db      CR,"%8aTesting memory at %7a%04x:0",NUL
   359 00000009 6E67206D656D6F7279- <1>
   359 00000012 206174202537612530- <1>
   359 0000001B 34783A3000          <1>
   360                              <1> msg_mem_done:
   361 00000020 0D253261502E4F2E53- <1>         db      CR,"%2aP.O.S.T. of memory %10aSUCCESSFUL        "
   361 00000029 2E542E206F66206D65- <1>
   361 00000032 6D6F72792025313061- <1>
   361 0000003B 535543434553534655- <1>
   361 00000044 4C2020202020202020  <1>
   362                              <1> msg_mem_double:
   363 0000004D 0A0A00              <1>         db      NL,NL,NUL
   364                              <1> msg_mem_bypass:
   365 00000050 0D253861502E4F2E53- <1> 	db	CR,"%8aP.O.S.T. of memory BYPASSED  ",NL,NL,NUL
   365 00000059 2E542E206F66206D65- <1>
   365 00000062 6D6F72792042595041- <1>
   365 0000006B 5353454420200A0A00  <1>
   366                              <1> msg_mem_error:
   367 00000074 070A253134614D656D- <1>         db      BEL,NL,"%14aMemory error at %04x%x",NL,NUL
   367 0000007D 6F7279206572726F72- <1>
   367 00000086 206174202530347825- <1>
   367 0000008F 780A00              <1>
   368                              <1> msg_mem_error0:
   369 00000092 070A253134614D656D- <1>         db      BEL,NL,"%14aMemory error at 0%04x",NL,NL
   369 0000009B 6F7279206572726F72- <1>
   369 000000A4 206174203025303478- <1>
   369 000000AD 0A0A                <1>
   370 000000AF 2A2A2A2A2A2A2A2A2A- <1>         db      "**************************",NL
   370 000000B8 2A2A2A2A2A2A2A2A2A- <1>
   370 000000C1 2A2A2A2A2A2A2A2A0A  <1>
   371 000000CA 2A2020202020434154- <1>         db      "*     CATASTROPHE!!!     *",NL
   371 000000D3 415354524F50484521- <1>
   371 000000DC 212120202020202A0A  <1>
   372 000000E5 2A2A2A2A2A2A2A2A2A- <1>         db      "**************************",NL,NL
   372 000000EE 2A2A2A2A2A2A2A2A2A- <1>
   372 000000F7 2A2A2A2A2A2A2A2A0A- <1>
   372 00000100 0A                  <1>
   373 00000101 48616C74696E672064- <1>         db      "Halting due to error in segment 0000:xxxx",BEL,NL
   373 0000010A 756520746F20657272- <1>
   373 00000113 6F7220696E20736567- <1>
   373 0000011C 6D656E742030303030- <1>
   373 00000125 3A78787878070A      <1>
   374 0000012C 00                  <1>         db      NUL
   375 0000012D 00                  <1> 	db	0
   376                              <1> 
   377                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   378                              <1> ;
   379                              <1> ;       Expanded Memory (EMM/4MEM) support -- LIM EMS
   380                              <1> ;
   381                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   382                              <1> %if EMM_BOARDS
   383                              <1> ; Define the UMB mask; '1' bit means allocate it
   384                              <1> UMB_MASK_80     equ     ~(0FFFFh<<((RAM_DOS-RAM)/16))   ; segments 8000,9000
   385                              <1>                                                         ; skip A000,B000
   386                              <1> ;;;UMB_MASK_C0     equ     0FFFFh>>(ROM/16)                ; segments C000,D000,...
   387                              <1> UMB_MASK_C0     equ     0FFFFh>>(CHIP/16)                ; segments C000,D000,...
   388                              <1>                                                         ; up to start of ROM
   389                              <1>         
   390                              <1> 
   391                              <1>         segment CONST
   392                              <1> emm_board_list:
   393                              <1> 
   394                              <1> %assign xemm EMM0
   395                              <1> %rep    EMM_BOARDS
   396                              <1>         dw      xemm
   397                              <1> %assign xemm (xemm+EMM1-EMM0)
   398                              <1> %endrep
   398 0000012E 0004                <2>  dw xemm
   398                              <2> %assign xemm (xemm+EMM1-EMM0)
   398 00000130 0204                <2>  dw xemm
   398                              <2> %assign xemm (xemm+EMM1-EMM0)
   398 00000132 0404                <2>  dw xemm
   398                              <2> %assign xemm (xemm+EMM1-EMM0)
   398 00000134 0604                <2>  dw xemm
   398                              <2> %assign xemm (xemm+EMM1-EMM0)
   399 00000136 FFFF                <1>         dw      -1
   400                              <1> 
   401                              <1>         segment _TEXT
   402                              <1> EMM_init0:
   403 00000866 601E                <1>         pushm   ds,all
   404                              <1> ;;        cld           ; already done!
   405 00000868 68[0000]            <1>         push    DGROUP               ; address CONST segment
   406 0000086B 1F                  <1>         popm    ds
   407 0000086C BE[2E01]            <1>         mov     si,emm_board_list
   408                              <1> 
   409                              <1> ; clear all of the paging registers
   410                              <1> ; with no reads, the board(s) remain disabled for now
   411 0000086F AD                  <1> .0:     lodsw           ; get page data reg I/O code
   412 00000870 40                  <1>         inc     ax      ; get address reg I/O code
   413 00000871 7412                <1>         jz      .3
   414 00000873 89C2                <1>         mov     dx,ax
   415 00000875 B94000              <1>         mov     cx,64   ; number of address reg entries
   416                              <1> .1:
   417 00000878 89C8                <1>         mov     ax,cx
   418 0000087A 48                  <1>         dec     ax      ; 
   419 0000087B EE                  <1>         out     dx,al   ; set the address
   420 0000087C 4A                  <1>         dec     dx      ; get page data reg I/O code
   421 0000087D B0FF                <1>         mov     al,EMM_unmapped
   422 0000087F EE                  <1>         out     dx,al
   423 00000880 42                  <1>         inc     dx      ; get address reg I/O code
   424 00000881 E2F5                <1>         loop    .1
   425 00000883 EBEA                <1>         jmp     .0      ; go on to the next board
   426                              <1> 
   427                              <1> ; assign memory above 512K, usually up to the 640K limit
   428                              <1> .3:
   429 00000885 8B16[2E01]          <1>         mov     dx,[emm_board_list]
   430 00000889 BB2000              <1>         mov     bx,RAM/16       ; get size of physical RAM chip
   431                              <1>  check  (RAM-512)
   432                              <1> ;;;        mov     cx,(RAM_DOS - RAM)/16   ; number of pages
   433                              <1> ;;;        jcxz    .5
   434 0000088C B9FF00              <1>         mov     cx,UMB_MASK_80 & 0FFFFh  ; bits to allocate
   435 0000088F BEFF0F              <1>         mov     si,UMB_MASK_C0 & 0FFFFh  ; **
   436                              <1> .4:
   437 00000892 89CF                <1>         mov     di,cx           ; test for done
   438 00000894 09F7                <1>         or      di,si
   439 00000896 741A                <1>         jz      .6
   440                              <1> 
   441 00000898 D1EE                <1>         shr     si,1            ; shift bit into carry
   442 0000089A D1D9                <1>         rcr     cx,1            ; carry is next to allocate
   443 0000089C 7310                <1>         jnc     .5              ; skip allocation if zero
   444                              <1> 
   445 0000089E 42                  <1>         inc     dx
   446 0000089F 88D8                <1>         mov     al,bl           ; page address
   447 000008A1 EE                  <1>         out     dx,al           ; set address
   448 000008A2 4A                  <1>         dec     dx
   449 000008A3 88F8                <1>         mov     al,bh
   450 000008A5 EE                  <1>         out     dx,al
   451 000008A6 90                  <1>         nop
   452 000008A7 EC                  <1>         in      al,dx           ; enable board
   453 000008A8 38C7                <1>         cmp     bh,al
   454 000008AA 750D                <1>         jne     .9
   455                              <1> 
   456 000008AC FEC7                <1>         inc     bh              ; increment page
   457 000008AE FEC3                <1> .5:     inc     bl              ; increment address
   458 000008B0 EBE0                <1>         jmp     .4              ; loop back
   459                              <1> ; all of the Upper Memory Blocks are allocated (no EMS yet)
   460                              <1> .6:
   461 000008B2 6A40                <1>         push    bios_data_seg
   462 000008B4 1F                  <1>         pop     ds
   463 000008B5 883EAF00            <1>         mov     [EMS_start],bh  ; save start page
   464                              <1> .9:
   465 000008B9 1F61                <1>         popm    ds,all
   466 000008BB C3                  <1>         ret
   467                              <1> %endif
   468                              <1> 
  1259                                  %include        "ds1302.asm"
     1                              <1> ;========================================================================
     2                              <1> ; DS1302.ASM -- support on the SBC-188 for the DS1302 chip
     3                              <1> ;========================================================================
     4                              <1> ;
     5                              <1> ;   This version is for assembly by  NASM 2.08
     6                              <1> ;
     7                              <1> ; Copyright (C) 2010   John R. Coffman
     8                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board
     9                              <1> ;
    10                              <1> ; This program is free software: you can redistribute it and/or modify
    11                              <1> ; it under the terms of the GNU General Public License as published by
    12                              <1> ; the Free Software Foundation, either version 3 of the License, or
    13                              <1> ; (at your option) any later version.
    14                              <1> ;
    15                              <1> ; This program is distributed in the hope that it will be useful,
    16                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    17                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    18                              <1> ; GNU General Public License for more details.
    19                              <1> ;
    20                              <1> ; You should have received a copy of the GNU General Public License
    21                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    22                              <1> ;
    23                              <1> ;========================================================================
    24                              <1> 
    25                              <1>         segment         _TEXT
    26                              <1> 
    27                              <1> rtc_data        equ     1               ; Data mask bit
    28                              <1> rtc_wren        equ     2               ; Write enable bit
    29                              <1> rtc_clk         equ     4               ; Clock signal
    30                              <1> rtc_rst         equ     8               ; Reset bit
    31                              <1> 
    32                              <1> 
    33                              <1> ;        global  _rtc_reset
    34                              <1> rtc_reset:
    35 000008BC BA0007              <1>         mov     dx,RTC              ; set the device code
    36 000008BF B008                <1>         mov     al,rtc_rst              ; Reset, enable read
    37 000008C1 EB05                <1>         jmp     rtc_out
    38                              <1> 
    39                              <1> 
    40                              <1> ;        global  _rtc_reset_off
    41                              <1> rtc_reset_off:
    42 000008C3 BA0007              <1>         mov     dx,RTC
    43 000008C6 B000                <1>         mov     al,0                    ; Reset Off, enable read
    44                              <1> rtc_out:
    45 000008C8 EE                  <1>         out     dx,al
    46 000008C9 B91000              <1>         mov     cx,16
    47 000008CC E989FD              <1>         jmp     microsecond             ; delay 16 us
    48                              <1> 
    49                              <1> 
    50                              <1> ;        global  @rtc_write
    51                              <1> @rtc_write:
    52                              <1> rtc_write:
    53 000008CF 53                  <1>         push    bx
    54                              <1> 
    55 000008D0 BA0007              <1>         mov     dx,RTC
    56 000008D3 88C3                <1>         mov     bl,al                   ; save data in BL
    57 000008D5 B408                <1>         mov     ah,8                    ; set loop count
    58                              <1> .1:
    59 000008D7 B002                <1>         mov     al,rtc_wren             ; write enable, reset off, clock off
    60 000008D9 D0EB                <1>         shr     bl,1                    ; data bit to Carry
    61 000008DB 1400                <1>         adc     al,0                    ; data to BIT 0
    62 000008DD E8E8FF              <1>         call    rtc_out                 ; put out the data
    63                              <1> 
    64 000008E0 0C04                <1>         or      al,rtc_clk              ; set the clock bit
    65 000008E2 E8E3FF              <1>         call    rtc_out                 ; put out the data
    66                              <1> 
    67 000008E5 FECC                <1>         dec     ah                      ; count a bit
    68 000008E7 75EE                <1>         jnz     .1
    69                              <1> 
    70                              <1> ; rtc_write ends with the clock high
    71 000008E9 5B                  <1>         pop     bx
    72 000008EA C3                  <1>         ret
    73                              <1> 
    74                              <1> 
    75                              <1> 
    76                              <1> 
    77                              <1> rtc_read:
    78 000008EB 53                  <1>         push    bx
    79                              <1> 
    80 000008EC BA0007              <1>         mov     dx,RTC
    81 000008EF B308                <1>         mov     bl,8                    ; bit count
    82                              <1> .1:
    83 000008F1 B000                <1>         mov     al,0                    ; clock off, reset off, read enable
    84 000008F3 E8D2FF              <1>         call    rtc_out
    85                              <1> ; delay was included in the above output call
    86 000008F6 EC                  <1>         in      al,dx                   ; read a bit
    87 000008F7 D1C8                <1>         ror     ax,1                    ; rotate data into AH left to right
    88                              <1> 
    89 000008F9 B004                <1>         mov     al,rtc_clk              ; set to clock next data bit
    90 000008FB E8CAFF              <1>         call    rtc_out
    91 000008FE FECB                <1>         dec     bl
    92 00000900 75EF                <1>         jnz     .1
    93                              <1> 
    94 00000902 C1E808              <1>         shr     ax,8                    ; return data in AL,  AH=0
    95                              <1> 
    96 00000905 5B                  <1>         pop     bx
    97 00000906 C3                  <1>         ret
    98                              <1> 
    99                              <1> 
   100                              <1> 
   101                              <1> 
   102                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   103                              <1> ;  rtc_get_loc          RTC get location as addressed
   104                              <1> ;       Enter with      AL = address of the location to get
   105                              <1> ;                       AH = Flag RAM/clock  (RAM=!0, clock=0)
   106                              <1> ;       Exit with data in AL
   107                              <1> ;               All other registers are preserved
   108                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   109                              <1>         global  @rtc_get_loc
   110                              <1>         global  rtc_get_loc
   111                              <1> @rtc_get_loc:
   112                              <1> rtc_get_loc:
   113 00000907 52                  <1>         push    dx
   114 00000908 51                  <1>         push    cx              ; 3 register saves
   115 00000909 53                  <1>         push    bx
   116                              <1> 
   117 0000090A 08E4                <1>         or      ah,ah           ; test flag
   118 0000090C 7402                <1>         jz      .1
   119 0000090E B440                <1>         mov     ah,040h         ; RAM flag
   120 00000910 88E7                <1> .1:     mov     bh,ah           ; save flag in BH
   121 00000912 241F                <1>         and     al,31           ; mask address to 5 bits
   122 00000914 00C0                <1>         add     al,al           ; shift left
   123 00000916 08C7                <1>         or      bh,al           ; form command
   124 00000918 80CF81              <1>         or      bh,81h          ; Clock Command / READ bit = 01h
   125                              <1> 
   126 0000091B BA0007              <1>         mov     dx,RTC
   127 0000091E E89BFF              <1>         call    rtc_reset
   128 00000921 E89FFF              <1>         call    rtc_reset_off   ; signal that a command is coming
   129 00000924 88F8                <1>         mov     al,bh
   130 00000926 E8A6FF              <1>         call    rtc_write       ; write out the command
   131 00000929 E8BFFF              <1>         call    rtc_read        ; read the data location
   132 0000092C 50                  <1>         push    ax              ; save the result
   133 0000092D E893FF              <1>         call    rtc_reset_off
   134 00000930 E889FF              <1>         call    rtc_reset       ; and finish up  
   135                              <1> 
   136 00000933 58                  <1>         pop     ax              ; return value
   137                              <1> 
   138 00000934 5B                  <1>         pop     bx
   139 00000935 59                  <1>         pop     cx              ; plus 3 register restores
   140 00000936 5A                  <1>         pop     dx
   141 00000937 C3                  <1>         ret
   142                              <1> 
   143                              <1> 
   144                              <1> 
   145                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   146                              <1> ;  rtc_set_loc          RTC set location as addressed
   147                              <1> ;       Enter with      AL = address of the location to set
   148                              <1> ;                       AH = Flag RAM/clock  (RAM=!0, clock=0)
   149                              <1> ;                       DL = data to write to location
   150                              <1> ;               AX is undefined on return
   151                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   152                              <1>         global  @rtc_set_loc
   153                              <1>         global  rtc_set_loc
   154                              <1> @rtc_set_loc:
   155                              <1> rtc_set_loc:
   156 00000938 52                  <1>         push    dx
   157 00000939 51                  <1>         push    cx              ; 3 register saves
   158 0000093A 53                  <1>         push    bx
   159                              <1> 
   160 0000093B 52                  <1>         push    dx              ; save data
   161                              <1> 
   162 0000093C 08E4                <1>         or      ah,ah           ; test flag
   163 0000093E 7402                <1>         jz      .1
   164 00000940 B440                <1>         mov     ah,040h         ; RAM flag
   165 00000942 88E7                <1> .1:     mov     bh,ah           ; save flag in BH
   166 00000944 241F                <1>         and     al,31           ; mask address to 5 bits
   167 00000946 00C0                <1>         add     al,al           ; shift left
   168 00000948 08C7                <1>         or      bh,al           ; form command
   169 0000094A 80CF80              <1>         or      bh,80h          ; Clock Command / WRITE bit = 00h
   170                              <1> 
   171 0000094D BA0007              <1>         mov     dx,RTC
   172 00000950 E869FF              <1>         call    rtc_reset
   173 00000953 E86DFF              <1>         call    rtc_reset_off   ; signal that a command is coming
   174 00000956 88F8                <1>         mov     al,bh           ; command to AL
   175 00000958 E874FF              <1>         call    rtc_write       ; write out the command
   176 0000095B 58                  <1>         pop     ax              ; get the data value
   177 0000095C E870FF              <1>         call    rtc_write       ; write the data
   178 0000095F E861FF              <1>         call    rtc_reset_off   ; end of command
   179 00000962 E857FF              <1>         call    rtc_reset
   180                              <1> 
   181 00000965 5B                  <1>         pop     bx
   182 00000966 59                  <1>         pop     cx              ; plus 3 register restores
   183 00000967 5A                  <1>         pop     dx
   184 00000968 C3                  <1>         ret
   185                              <1> 
   186                              <1> 
   187                              <1> 
   188                              <1> 
   189                              <1> 
  1260                                  
  1261                                  %if SOFT_DEBUG
  1262                                          global  lites
  1263                                  ; call with:
  1264                                  ;       push    code    ; code in AL
  1265                                  ;       call    lites
  1266                                  ;
  1267                                  lites:  push    bp
  1268                                          mov     bp,sp           ; establish stack frame
  1269                                          pushm   ax,dx
  1270                                          mov     al,[bp+4]
  1271                                          mov     dx,portD
  1272                                          out     dx,al
  1273                                          popm    ax,dx
  1274                                          pop     bp
  1275                                          ret     2               ; remove argument
  1276                                  %endif
  1277                                  
  1278                                  %if 0
  1279                                  ; _FPSIGNAL:
  1280                                  ;   Enter with AL = condensed error code
  1281                                  ;
  1282                                  	global	_FPSIGNAL
  1283                                  _FPSIGNAL:
  1284                                  	xor	ah,ah
  1285                                  	push	ax
  1286                                  	push	DGROUP
  1287                                  	push	msg_fpu_err
  1288                                  	call	_cprintf
  1289                                  	add	sp,6
  1290                                  	ret
  1291                                  %endif
  1292                                  ;;;        align   256		; what's this for???
  1293 00000969 90<rept>                	align	16
  1294                                  
  1295                                  bulk_of_code_end        equ     $
  1296                                  
  1297                                  
  1298                                  
  1299                                          segment CONST
  1300                                  %if SOFT_DEBUG
  1301                                  %else
  1302                                  %if (CVDU_8563 | VGA3_6445)
  1303                                  	global	_Font
  1304 00000138 000080F6                _Font	dw	0, 0F680h		; loaded at absolute location
  1305                                  %endif
  1306                                  %endif
  1307                                  
  1308                                  
  1309                                          global  _bios_data_area_ptr
  1310                                  _bios_data_area_ptr:
  1311 0000013C 00004000                        dw      0000h,bios_data_seg     ; pointer 40:0
  1312                                  
  1313                                  
  1314                                  msg_cpu_memory:
  1315 00000140 253135612564257320-     	db	"%15a%d%s %2aMhz CPU clock, %15a%u%2aK memory installed"
  1315 00000149 2532614D687A204350-
  1315 00000152 5520636C6F636B2C20-
  1315 0000015B 253135612575253261-
  1315 00000164 4B206D656D6F727920-
  1315 0000016D 696E7374616C6C6564 
  1316                                  %if CVDU_8563
  1317                                  	db	", with %15a%d%2aK ColorVDU memory"
  1318                                  %endif
  1319                                  %if VGA3_6445
  1320 00000176 2C2077697468202531-     	db	", with %15a32%2aK VGA3 memory"
  1320 0000017F 356133322532614B20-
  1320 00000188 56474133206D656D6F-
  1320 00000191 7279               
  1321                                  %endif
  1322 00000193 0A00                    	db	NL, 0
  1323                                  msg_cpu_clock_05:
  1324 00000195 2E3500                  	db	".5", 0
  1325                                  msg_cpu_clock_00:
  1326 00000198 00                      	db	0
  1327                                  msg_setup:
  1328 00000199 507265737320277327-     	db	"Press 's' to run NVRAM setup...", NL, 0
  1328 000001A2 20746F2072756E204E-
  1328 000001AB 5652414D2073657475-
  1328 000001B4 702E2E2E0A00       
  1329                                  msg_nvram_bad:
  1330 000001BA 4E5652414D20636865-     	db	"NVRAM checksum is invalid, running setup", NL, 0
  1330 000001C3 636B73756D20697320-
  1330 000001CC 696E76616C69642C20-
  1330 000001D5 72756E6E696E672073-
  1330 000001DE 657475700A00       
  1331                                  msg_floppy:
  1332 000001E4 4E6F7720696E697469-     	db	"Now initializing floppy", NL, 0
  1332 000001ED 616C697A696E672066-
  1332 000001F6 6C6F7070790A00     
  1333                                  %if 0
  1334                                  msg_fpu_err:
  1335                                  	db	NL, "EM187 has signalled error 0x%02x.", NL, 0
  1336                                  %endif
  1337                                  msg_booting:
  1338 000001FD 547279696E6720746F-     	db	"Trying to boot from drive %c: ", 0
  1338 00000206 20626F6F742066726F-
  1338 0000020F 6D2064726976652025-
  1338 00000218 633A2000           
  1339                                  msg_boot_err:
  1340 0000021C 4469736B2072656164-     	db	"Disk read failed  AX=%04x", NL, 0
  1340 00000225 206661696C65642020-
  1340 0000022E 41583D253034780A00 
  1341                                  msg_no_boot:
  1342 00000237 426F6F74207369676E-     	db	"Boot signature not found", NL, 0
  1342 00000240 6174757265206E6F74-
  1342 00000249 20666F756E640A00   
  1343                                  msg_no_loader:
  1344 00000251 4D617374657220626F-     	db	"Master boot loader not found", NL, 0
  1344 0000025A 6F74206C6F61646572-
  1344 00000263 206E6F7420666F756E-
  1344 0000026C 640A00             
  1345                                  msg_boot_ok:
  1346 0000026F 4F4B0A00                	db	"OK", NL, 0
  1347                                  msg_cpm_disk:
  1348 00000273 6E6F207369676E6174-             db      "no signature check ", 0
  1348 0000027C 75726520636865636B-
  1348 00000285 2000               
  1349                                  msg_alt_disk:
  1350 00000287 4D494E495820626F6F-     	db	"MINIX boot signature ",0
  1350 00000290 74207369676E617475-
  1350 00000299 72652000           
  1351                                  %if TBASIC
  1352                                  %else
  1353                                  msg_no_basic:
  1354                                  	db	"No ROM Basic. Please implement one :-)", NL
  1355                                  	db	"Press any key to try again...", NL, 0
  1356                                  %endif
  1357                                  
