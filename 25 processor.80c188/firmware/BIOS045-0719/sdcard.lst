     1                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     2                                  ; SDcard.ASM -- Basic I/O routines for the Dual SDcard add-on board
     3                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     4                                  ;
     5                                  ;   This version is for assembly by  NASM 0.98.39 or later
     6                                  ;
     7                                  ; Copyright (c) 2013 John R. Coffman.  All rights reserved.
     8                                  ; Provided for hobbyist use on the N8VEM SBC-188 board.
     9                                  ;
    10                                  ; This program is free software: you can redistribute it and/or modify
    11                                  ; it under the terms of the GNU General Public License as published by
    12                                  ; the Free Software Foundation, either version 3 of the License, or
    13                                  ; (at your option) any later version.
    14                                  ;
    15                                  ; This program is distributed in the hope that it will be useful,
    16                                  ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    17                                  ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    18                                  ; GNU General Public License for more details.
    19                                  ;
    20                                  ; You should have received a copy of the GNU General Public License
    21                                  ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    22                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    23                                  %include	"config.asm"
     1                              <1> ;/*
     2                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     3                              <1> ; VGA3.CFG
     4                              <1> ;   Copied to CONFIG.ASM for general release.
     5                              <1> ;
     6                              <1> ;       Modify the parameters below to reflect your system
     7                              <1> ;
     8                              <1> ;
     9                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    10                              <1> ;
    11                              <1> ;   Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    12                              <1> ;   Provided for hobbyist use on the N8VEM SBC-188 board.
    13                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    14                              <1> ;
    15                              <1> ; Define the serial terminal that the Video BIOS must emulate
    16                              <1> ; Set one of the following to 1
    17                              <1> ; If you have no idea what to choose, set TTY to 1
    18                              <1> TTY     equ     0       ; hardcopy -- cannot position the cursor
    19                              <1> DUMB    equ     0       ; dumb CRT -- ^H, ^J, ^K, ^L can move the cursor
    20                              <1> ANSI    equ     1       ; very smart, like a VT-100
    21                              <1> WYSE    equ     0       ; very smart Wyse series (30, 50, ...)
    22                              <1> ; others may get added in the future
    23                              <1> ;  ONE OF THE ABOVE must BE SET TO 1!!!!!
    24                              <1> ;
    25                              <1> ; Does the hardware configuration contain the Color Video Display Unit?
    26                              <1> ; Both the 8563 and the 8242 are used.  The default is CVDU=0
    27                              <1> CVDU	equ	0	; system does not have the CVDU
    28                              <1> ;
    29                              <1> ; Does the hardware configuration contain the VGA3 a/n Video card?
    30                              <1> ; The 8563 will be disabled, but the 8242 code is shared with the CVDU
    31                              <1> ; The default is VGA3=0
    32                              <1> VGA3   equ     1       ; system has the VGA3
    33                              <1> ;
    34                              <1> ; Does the hardware configuration contain the front panel card?
    35                              <1> ; The default is FRONT_PANEL=0
    36                              <1> ;
    37                              <1> FRONT_PANEL   equ     1       ; system has the VGA3
    38                              <1> %if 0
    39                              <1> 	*/
    40                              <1> #define VGA3 1
    41                              <1> /*
    42                              <1> %endif
    43                              <1> ;
    44                              <1> ; Boot up keyboard mode:  20h for NumLock on
    45                              <1> ;CVDU_KEYBOARD_STATUS	equ	0	; NumLock OFF
    46                              <1> CVDU_KEYBOARD_STATUS	equ	20h	; NumLock ON
    47                              <1> 
    48                              <1> ; Define the UART startup bit rate - 1200-19200 are most common
    49                              <1> ;UART_RATE	equ	0		; 1200
    50                              <1> ;UART_RATE	equ	1		; 2400
    51                              <1> ;UART_RATE	equ	2		; 4800
    52                              <1> ;UART_RATE	equ	3		; 9600
    53                              <1> ;UART_RATE	equ	4		; 19200
    54                              <1> UART_RATE	equ	5		; 38400
    55                              <1> ;UART_RATE	equ	6		; 57600
    56                              <1> ;UART_RATE	equ	7		; 115200
    57                              <1> 
    58                              <1> ; Does the serial terminal use the DSR/DTR protocol for flow control?
    59                              <1> ;UART_DSR_PROTOCOL	equ		1	; Yes!
    60                              <1> UART_DSR_PROTOCOL       equ             WYSE    ; Wyse always uses it
    61                              <1> 						; but not ANSI
    62                              <1> ; Define the size of the ROM image on the system in Kilobytes
    63                              <1> ; It may be smaller than the actual EPROM in use.
    64                              <1> ; The following sizes are supported:  32, 64, 128, and 256
    65                              <1> %ifndef ROM
    66                              <1> ROM             equ     32              ; 64 is the default
    67                              <1> %endif
    68                              <1> 
    69                              <1> ; Define the number of Wait States at which the ROM operates
    70                              <1> ROM_WS          equ     1               ; 0..3  (1 is the default)
    71                              <1> 
    72                              <1> ; Define the size in Kilobytes of DOS RAM (low SRAM plus EMM allocate RAM)
    73                              <1> ; This is a desired size and will only be present if a 4MEM board is added
    74                              <1> RAM_DOS         equ     640
    75                              <1> 
    76                              <1> ; Define the size of the low SRAM on the system in Kilobytes
    77                              <1> ; the default is 512 kilobytes
    78                              <1> RAM             equ     512             ; (512 is the default)
    79                              <1> 
    80                              <1> ; Define the number of Wait States at which the RAM operates
    81                              <1> RAM_WS          equ     0               ; 0..3  (0 is the default)
    82                              <1> 
    83                              <1> ; Define the number of Wait States for Local Peripheral devices (600-7FF)
    84                              <1> LCL_IO_WS       equ     1               ; 0..3  (1 is the default)
    85                              <1> 
    86                              <1> ; Define the number of Wait States for ECB BUS peripheral devices (4xx)
    87                              <1> BUS_IO_WS       equ     3               ; 0..3  (3 is the default)
    88                              <1> 
    89                              <1> ; Define the time zone in which we build the Relocatable BIOS
    90                              <1> %ifndef TIMEZONE
    91                              <1> %define TIMEZONE "CDT"
    92                              <1> %endif
    93                              <1> 
    94                              <1> ; Has the REDBUG debugger been loaded?
    95                              <1> %ifndef SOFT_DEBUG
    96                              <1> %define SOFT_DEBUG 0
    97                              <1> %endif
    98                              <1> 
    99                              <1> ; Should the BIOS include "Tiny BASIC" in the image?
   100                              <1> %ifndef TBASIC
   101                              <1> TBASIC          equ     1		; default is 1
   102                              <1> %endif
   103                              <1> 
   104                              <1> ; Should the BIOS include the Floating Point Emulator?  The 80188 does
   105                              <1> ; not allow a floating point co-processor, so this is probably a good idea.
   106                              <1> %ifndef FPEM
   107                              <1> FPEM            equ     1               ; default is 1
   108                              <1> %endif
   109                              <1> 
   110                              <1> ; Define the maximum number of EMM (4MEM) boards supported
   111                              <1> EMM_BOARDS      equ     4
   112                              <1> 
   113                              <1> ; Should the Floating Point Emulator use temporary storage in the EBDA
   114                              <1> ; or at locations 0280h..3FFh in low memory?
   115                              <1> %if SOFT_DEBUG
   116                              <1> FPEM_USE_EBDA   equ     FPEM            ; default is 0
   117                              <1> %else
   118                              <1> FPEM_USE_EBDA   equ     0; FPEM            ; default is 0
   119                              <1> %endif
   120                              <1> 
   121                              <1> ; Define the size of the EPROM that is to be installed on the system
   122                              <1> ; It may be larger than the actual ROM image to be generated.
   123                              <1> %ifndef CHIP
   124                              <1> CHIP            equ     64
   125                              <1> %endif
   126                              <1> 
   127                              <1> ; Does the SBC-188 00.4 board have the LS138/LS08 piggyback fix
   128                              <1> ; Set to 1 for the SBC-188 v1.0 and later production boards
   129                              <1> FDC_PIGGYBACK_FIX       equ     0       ; Fix not installed
   130                              <1> ;FDC_PIGGYBACK_FIX       equ     1       ; fix  IS  installed
   131                              <1> 
   132                              <1> ; On SBC-188 rev 00.4 board, there is a published hardware fix (2010-09-18).
   133                              <1> ; If the wiring update is installed, or you have a later board, then
   134                              <1> ; set this to 0.  If you are using the software workaround, then set this
   135                              <1> ; to 1.  The rev 1.0 board has this fix already.
   136                              <1> NEED_TIMER_FIX  equ     0               ; have revised hardware
   137                              <1> ;NEED_TIMER_FIX  equ     1               ; use workaround
   138                              <1> 
   139                              <1> ; Define the UART oscillator speed
   140                              <1> UART_OSC        equ     1843200         ; 1.8432 Mhz is specified
   141                              <1> 
   142                              <1> 
   143                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   144                              <1> ; end of the User configuration
   145                              <1> ;       Do Not modify anything below this point
   146                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   147                              <1> 
   148                              <1> CVDU_8563	equ	CVDU		; separate inits
   149                              <1> CVDU_8242	equ	CVDU|VGA3 	; separate inits
   150                              <1> VGA3_6445       equ     VGA3            ; separate inits
   151                              <1> ; Suppress all UART output in color video Mode 3
   152                              <1> ;UART_MODE3_SUPPRESS	equ	0
   153                              <1> UART_MODE3_SUPPRESS	equ	CVDU_8563 | VGA3_6445
   154                              <1> CVDU_USE_MSDOS_KLUDGE	equ	0; CVDU_8242	; bad, bad MSDOS
   155                              <1> CVDU_USE_KBD_HOOK		equ	CVDU_8242
   156                              <1> 
   157                              <1> ; Define existence of any uart chip
   158                              <1> UART		equ	TTY+DUMB+ANSI+WYSE
   159                              <1> startuplength   equ     128                     ; may be up to 1024
   160                              <1> startseg        equ     0FFFFh - (ROM*64) + 1
   161                              <1> highrom         equ     (ROM*400h)&0FFFFh
   162                              <1> startupseg      equ     0FFFFh - (startuplength>>4) + 1
   163                              <1> bios_data_seg   equ     040h            ; segment of BIOS data area
   164                              <1> 
   165                              <1> 
   166                              <1> %define ARG(n) [bp+2+(n)*2]
   167                              <1> 
   168                              <1> %macro  check   1.nolist
   169                              <1>  %if (%1)
   170                              <1>    %error Check Failure: %1
   171                              <1>  %endif
   172                              <1> %endm
   173                              <1> %macro  range   3.nolist
   174                              <1>  %if (%1)<(%2)
   175                              <1>    %error Out of Range: %1
   176                              <1>  %elif (%1)>(%3)
   177                              <1>    %error Out of Range: %1
   178                              <1>  %endif
   179                              <1> %endm
   180                              <1> _terminal equ UART+CVDU
   181                              <1>  check   RAM_DOS&15
   182                              <1>  check   RAM&(RAM-1)
   183                              <1>  check   ROM&(ROM-1)
   184                              <1>  range   RAM,32,512
   185                              <1>  range   ROM,32,256
   186                              <1>  range   RAM_WS,0,3
   187                              <1>  range   ROM_WS,0,3
   188                              <1>  range   RAM_DOS,RAM,(1024-ROM)
   189                              <1>  range   LCL_IO_WS,0,3
   190                              <1>  range   BUS_IO_WS,0,3
   191                              <1>  range   UART_OSC,500000,16000000
   192                              <1>  range   UART_RATE,0,7
   193                              <1>  range	 UART,0,1
   194                              <1>  range	 _terminal,1,2
   195                              <1> 
   196                              <1> %ifndef SOFT_DEBUG
   197                              <1> %define SOFT_DEBUG 0
   198                              <1> %endif
   199                              <1> 
   200                              <1> %ifndef TRACE
   201                              <1> %define TRACE 0
   202                              <1> %endif
   203                              <1> 
   204                              <1> %ifdef MAKE_OBJECT_FILE
   205                              <1>         segment _DATA WORD PUBLIC CLASS=DATA
   206                              <1>         export _ROMsize
   207                              <1>         export _CHIPsize
   208                              <1> _ROMsize        dw      ROM
   209                              <1> _CHIPsize       dw      CHIP
   210                              <1> %endif
   211                              <1> ; end of the Hardware configuration file
   212                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   213                              <1> ;*/
    24                                  %include	"cpuregs.asm"
     1                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     2                              <1> ; CPUREGS.ASM
     3                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     4                              <1> ;
     5                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
     6                              <1> ;
     7                              <1> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
     8                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
     9                              <1> ;
    10                              <1> ; This program is free software: you can redistribute it and/or modify
    11                              <1> ; it under the terms of the GNU General Public License as published by
    12                              <1> ; the Free Software Foundation, either version 3 of the License, or
    13                              <1> ; (at your option) any later version.
    14                              <1> ;
    15                              <1> ; This program is distributed in the hope that it will be useful,
    16                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    17                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    18                              <1> ; GNU General Public License for more details.
    19                              <1> ;
    20                              <1> ; You should have received a copy of the GNU General Public License
    21                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    22                              <1> ;
    23                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    24                              <1>         cpu     186
    25                              <1> ;
    26                              <1> ;
    27                              <1> ; IBM model byte -- must be less than a 286
    28                              <1> ;
    29                              <1> ;MODEL_BYTE		equ	0FEh	; PC-XT
    30                              <1> ;SUBMODEL_BYTE		equ	0FFh	; not used
    31                              <1> 
    32                              <1> MODEL_BYTE		equ	0FEh	; PC-XT
    33                              <1> SUBMODEL_BYTE		equ	00h	;  "
    34                              <1> 
    35                              <1> 
    36                              <1> ; 80188 peripheral control register block address
    37                              <1> CPU_CSCR	        equ	0FF00h
    38                              <1> 
    39                              <1> ; Compatible Mode registers
    40                              <1> 
    41                              <1> cpu_relocation          equ     CPU_CSCR+0FEh
    42                              <1> 
    43                              <1> ; The memory and peripheral chip select register offsets from 0FF00h
    44                              <1> 
    45                              <1> cpu_umcs                equ     CPU_CSCR+0A0h          ; Upper memory select
    46                              <1> cpu_lmcs                equ     CPU_CSCR+0A2h          ; Lower memory select
    47                              <1> cpu_pacs                equ     CPU_CSCR+0A4h          ; Peripheral select
    48                              <1> cpu_mmcs                equ     CPU_CSCR+0A6h          ; Middle memory base
    49                              <1> cpu_mpcs                equ     CPU_CSCR+0A8h          ; Mid mem. & peripherals
    50                              <1> 
    51                              <1> ; Enhanced Mode registers
    52                              <1> 
    53                              <1> cpu_mdram               equ     CPU_CSCR+0E0h          ; memory partition reg.
    54                              <1> cpu_cdram               equ     CPU_CSCR+0E2h          ; clock prescaler
    55                              <1> cpu_edram               equ     CPU_CSCR+0E4h          ; Enable refresh reg.
    56                              <1> cpu_pdcon               equ     CPU_CSCR+0F0h          ; Power-Save control
    57                              <1> 
    58                              <1> 
    59                              <1> ; On-board internal peripheral equates
    60                              <1> ; Programmable Interrupt Controller
    61                              <1> PIC	        equ	CPU_CSCR+020H
    62                              <1> PIC_EOI	        equ	PIC+2           ; End Of Interrupt
    63                              <1> PIC_POLLR	equ	PIC+4
    64                              <1> PIC_POLLSR	equ	PIC+6
    65                              <1> PIC_IMASK	equ	PIC+8
    66                              <1> PIC_PMREG	equ	PIC+0AH
    67                              <1> PIC_SRVR	equ	PIC+0CH
    68                              <1> PIC_IRQR	equ	PIC+0EH
    69                              <1> PIC_IRQSR	equ	PIC+10H
    70                              <1> PIC_TCR	        equ	PIC+12H
    71                              <1> PIC_DMA0CR	equ	PIC+14H
    72                              <1> PIC_DMA1CR	equ	PIC+16H
    73                              <1> PIC_I0CON	equ	PIC+18H
    74                              <1> PIC_I1CON	equ	PIC+1AH
    75                              <1> PIC_I2CON	equ	PIC+1CH
    76                              <1> PIC_I3CON	equ	PIC+1EH
    77                              <1> 
    78                              <1> EOI_NSPEC       equ     8000h           ; Non-Specific EOI
    79                              <1> 
    80                              <1> ; Interrupt masks (Master Mode)
    81                              <1> ;
    82                              <1> mask_timer_all          equ     0001h
    83                              <1> mask_dma0               equ     0004h
    84                              <1> mask_dma1               equ     0008h
    85                              <1> mask_int0               equ     0010h
    86                              <1> mask_int1               equ     0020h
    87                              <1> mask_int2               equ     0040h
    88                              <1> mask_int3               equ     0080h
    89                              <1> 
    90                              <1> 
    91                              <1> 
    92                              <1> ; Timers
    93                              <1> TIM0	        equ	CPU_CSCR+050H
    94                              <1> TIM1	        equ	CPU_CSCR+058H
    95                              <1> TIM2	        equ	CPU_CSCR+060H
    96                              <1> 
    97                              <1> TCNT	        equ	0	; count register
    98                              <1> CMPA	        equ	2	; max count A
    99                              <1> CMPB	        equ	4	; max count B (not present on TIM2)
   100                              <1> TCON	        equ	6	; mode/control word
   101                              <1> 
   102                              <1> ; Timer control bits:
   103                              <1> tc_EN           equ     8000h   ; Enable bit
   104                              <1> tc_nINH         equ     4000h   ; not Inhibit Enable
   105                              <1> tc_INT          equ     2000h   ; Interrupt Enable
   106                              <1> tc_RIU          equ     1000h   ; Register A/B (0/1) in Use
   107                              <1> tc_MC           equ     0020h   ; Maximum Count reached
   108                              <1> tc_RTG          equ     0010h   ; Retrigger (internal source)
   109                              <1> tc_P            equ     0008h   ; Prescale internal clock (timers 0 & 1 only)
   110                              <1> tc_EXT          equ     0004h   ; External clock
   111                              <1> tc_ALT          equ     0002h   ; Alternate between A & B max count registers
   112                              <1> tc_CONT         equ     0001h   ; Continuous: continue after max count
   113                              <1> 
   114                              <1> 
   115                              <1> 
   116                              <1> 
   117                              <1> ; DMA
   118                              <1> DMA0	        equ	CPU_CSCR+0C0H
   119                              <1> DMA1	        equ	CPU_CSCR+0D0H
   120                              <1> DMASPL	        equ	0	; source pointer low
   121                              <1> DMASPU	        equ	2	; source pointer high
   122                              <1> DMADPL	        equ	4	; destination pointer low
   123                              <1> DMADPU	        equ	6	; destination pointer high
   124                              <1> DMATC	        equ	8	; terminal count
   125                              <1> DMACW	        equ	0AH	; control word
   126                              <1> 
   127                              <1> 
   128                              <1> 
   129                              <1> 
   130                              <1> 
   131                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   132                              <1> ;
   133                              <1> ;       SBC-188 external devices
   134                              <1> ;
   135                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   136                              <1> 
   137                              <1> IO_BASE			equ	0400h
   138                              <1> 
   139                              <1> 
   140                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   141                              <1> ; The UART registers
   142                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   143                              <1> uart_base               equ     IO_BASE+0280h
   144                              <1> uart_rbr                equ     uart_base       ;Rcvr Buffer / read only
   145                              <1> uart_thr                equ     uart_base       ;Transmit Holding / write only
   146                              <1> uart_ier                equ     uart_base+1     ;Interrupt Enable
   147                              <1> uart_iir                equ     uart_base+2     ;Interrupt Ident / read only
   148                              <1> uart_fcr                equ     uart_base+2     ;FIFO Control / write only
   149                              <1> uart_lcr                equ     uart_base+3     ;Line Control
   150                              <1> uart_mcr                equ     uart_base+4     ;Modem Control
   151                              <1> uart_lsr                equ     uart_base+5     ;Line Status
   152                              <1> uart_msr                equ     uart_base+6     ;Modem Status
   153                              <1> uart_sr			equ	uart_base+7	;Scratch
   154                              <1> 
   155                              <1> uart_dll                equ     uart_base       ;Divisor Latch LS Byte
   156                              <1> uart_dlm                equ     uart_base+1     ;Divisor Latch MS Byte
   157                              <1> 
   158                              <1> 
   159                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   160                              <1> ; Floppy controller
   161                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   162                              <1> FDC	        equ	IO_BASE+0200H
   163                              <1> FDC_MSR         equ     FDC
   164                              <1> FDC_DATA        equ     FDC_MSR+1
   165                              <1> FDC_DACK        equ	FDC+10H
   166                              <1> FDC_LDOR	equ	FDC+20H
   167                              <1> FDC_LDCR	equ	FDC+30H
   168                              <1> FDC_TC	        equ	FDC+40H
   169                              <1> FDC_DACK_TC     equ     FDC_DACK | FDC_TC
   170                              <1> 
   171                              <1> 
   172                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   173                              <1> ;DS1302 RTC
   174                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   175                              <1> RTC	equ	IO_BASE+0300H
   176                              <1> 
   177                              <1> 
   178                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   179                              <1> ; PIO 82C55 I/O 
   180                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   181                              <1> PPI	        equ	IO_BASE+0260H
   182                              <1> PIO_A	        equ	PPI+0	; (OUTPUT)
   183                              <1> PIO_B	        equ	PPI+1	; (INPUT)
   184                              <1> PIO_C	        equ	PPI+2	; (CENTRONICS control low nibble)  
   185                              <1> PIO_CTRL	equ	PPI+3	; CONTROL BYTE PIO 82C55
   186                              <1> 
   187                              <1> portA           equ     PPI+0   ;
   188                              <1> portB           equ     PPI+1   ;     LITES uses this for output
   189                              <1> portC           equ     PPI+2   ;
   190                              <1> 
   191                              <1> 
   192                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   193                              <1> ; Dual [DMA] IDE devices
   194                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   195                              <1> DIDE		equ	IO_BASE + 20H	; range 0x20..0x3F
   196                              <1> 
   197                              <1> DIDE0		equ	DIDE		; first interface (master & slave)
   198                              <1> DIDE1		equ	DIDE+10h	; second interface (master & slave)
   199                              <1> 
   200                              <1> 
   201                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   202                              <1> ; Cassette I/O
   203                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   204                              <1> cuart_base	EQU 	IO_BASE+80H	; BASE IO ADDRESS OF CASSETTE UART
   205                              <1> cuart_rbr	equ     cuart_base	;Rcvr Buffer / read only
   206                              <1> cuart_thr	equ     cuart_base	;Transmit Holding / write only
   207                              <1> cuart_ier	equ     cuart_base+1	;Interrupt Enable
   208                              <1> cuart_iir	equ     cuart_base+2	;Interrupt Ident / read only
   209                              <1> cuart_fcr	equ     cuart_base+2	;FIFO Control / write only
   210                              <1> cuart_lcr	equ     cuart_base+3	;Line Control
   211                              <1> cuart_mcr	equ     cuart_base+4	;Modem Control
   212                              <1> cuart_lsr	equ     cuart_base+5	;Line Status
   213                              <1> cuart_msr	equ     cuart_base+6	;Modem Status
   214                              <1> cuart_sr	equ	cuart_base+7	;Scratch
   215                              <1> 
   216                              <1> cuart_dll	equ     cuart_base	;Divisor Latch LS Byte
   217                              <1> cuart_dlm	equ	cuart_base+1	;Divisor Latch MS Byte
   218                              <1> 
   219                              <1> 
   220                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   221                              <1> ;
   222                              <1> ;       4MEM control registers
   223                              <1> ;
   224                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   225                              <1> EMM_addr        equ     1               ; high 6 bits of 20-bit address
   226                              <1> EMM_page        equ     0               ; 4MEM page in [0..254]
   227                              <1> 
   228                              <1> EMM_BASE        equ     IO_BASE + 000h          ; first EMM (4MEM) board
   229                              <1> EMM_unmapped    equ     255             ; unmapped 4MEM page
   230                              <1> 
   231                              <1> EMM0            equ     EMM_BASE        ; first  EMM board
   232                              <1> EMM1            equ     EMM0 + 2        ; second EMM board
   233                              <1> EMM2            equ     EMM1 + 2        ; third  EMM board
   234                              <1> EMM3            equ     EMM2 + 2        ; fourth EMM board
   235                              <1> 
   236                              <1> 
   237                              <1> 
   238                              <1> 
   239                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   240                              <1> ;
   241                              <1> ;	ColorVDU devices
   242                              <1> ;
   243                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   244                              <1> ;
   245                              <1> ;	major select on the Z80 bus
   246                              <1> ;
   247                              <1> devCVDU_8bit	equ	0xE0		; this may change to 0x10
   248                              <1> 
   249                              <1> devCVDUbase 	equ	IO_BASE + devCVDU_8bit
   250                              <1> 
   251                              <1> M8563status	equ	devCVDUbase + 4		; 4 == bitrev(2)
   252                              <1> M8563register	equ	devCVDUbase + 4
   253                              <1> M8563data	equ	devCVDUbase + 12	; 12 == bitrev(3)
   254                              <1> 
   255                              <1> %if CVDU_8563
   256                              <1> I8242status	equ	devCVDUbase + 10	; 10 == bitrev(5)
   257                              <1> I8242command	equ	devCVDUbase + 10
   258                              <1> I8242data	equ	devCVDUbase + 2		; 2 == bitrev(4)
   259                              <1> %endif
   260                              <1> 
   261                              <1> 
   262                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   263                              <1> ;
   264                              <1> ;	VGA3 devices
   265                              <1> ;
   266                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   267                              <1> ;
   268                              <1> ;	major select on the Z80 bus
   269                              <1> ;
   270                              <1> devVGA3_8bit    equ     0xE0                    ; same as CVDU
   271                              <1> 
   272                              <1> devVGA3base       equ     IO_BASE + devVGA3_8bit
   273                              <1> 
   274                              <1> %if VGA3_6445
   275                              <1> I8242status	equ	devVGA3base + 1
   276                              <1> I8242command	equ	devVGA3base + 1
   277                              <1> I8242data	equ	devVGA3base + 0
   278                              <1> %endif
   279                              <1> HD6445addr	equ	devVGA3base + 2		; to address the HD6445 registers
   280                              <1> HD6445reg	equ	devVGA3base + 3		; to r/w a register on the CRTC
   281                              <1> 
   282                              <1> vga3cfg		equ	devVGA3base + 4
   283                              <1> ; the following are probably not used on the SBC-188, except for testing/checking
   284                              <1> vga3adhi	equ	devVGA3base + 5
   285                              <1> vga3adlo	equ	devVGA3base + 6
   286                              <1> vga3data	equ	devVGA3base + 7
   287                              <1> 
   288                              <1> 
   289                              <1> 
   290                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   291                              <1> ;
   292                              <1> ;	Front Panel devices
   293                              <1> ;
   294                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   295                              <1> ;
   296                              <1> ; Front Panel 82C55 I/O 
   297                              <1> FPPPI	        equ	IO_BASE+0A0H
   298                              <1> FPPORTA         equ     FPPPI+0   	;
   299                              <1> FPPORTB         equ     FPPPI+1   	;    
   300                              <1> FPPORTC         equ     FPPPI+2   	;
   301                              <1> FPPIOCONT       equ     FPPPI+3   	;
   302                              <1> 
   303                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   304                              <1> ; debug port -- JRC only
   305                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   306                              <1> portD		equ	IO_BASE + 0FFh		; 0x04FF
   307                              <1> ;portD		equ	portB		     ; older 8255 output on PPI
   308                              <1> 
   309                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   310                              <1> ;
   311                              <1> ; some useful macros:
   312                              <1> ;
   313                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   314                              <1> ;
   315                              <1> 
   316                              <1> %imacro setloc  1.nolist
   317                              <1>  times   (%1-($-$$)) db 0FFh
   318                              <1> %endm
   319                              <1> 
   320                              <1> %imacro db_lo   1
   321                              <1>  db (%1)&255
   322                              <1> %endm
   323                              <1> 
   324                              <1> %imacro cnop    0.nolist
   325                              <1> %if SOFT_DEBUG
   326                              <1>         nop
   327                              <1> %endif
   328                              <1> %endm
   329                              <1> 
   330                              <1> %imacro popm 1-*.nolist
   331                              <1> %rep %0
   332                              <1> %ifidni %1,ALL
   333                              <1>  popa
   334                              <1> %elifidni %1,F
   335                              <1>  popf
   336                              <1> %else
   337                              <1>  pop %1
   338                              <1> %ifidni %1,DS
   339                              <1>  cnop
   340                              <1> %elifidni %1,ES
   341                              <1>  cnop
   342                              <1> %endif
   343                              <1> %endif
   344                              <1> %rotate 1
   345                              <1> %endrep
   346                              <1> %endm
   347                              <1> 
   348                              <1> %imacro pushm 1-*.nolist
   349                              <1> %rep %0
   350                              <1> %rotate -1
   351                              <1> %ifidni %1,ALL
   352                              <1>  pusha
   353                              <1> %elifidni %1,F
   354                              <1>  pushf
   355                              <1> %else
   356                              <1>  push %1
   357                              <1> %endif
   358                              <1> %endrep
   359                              <1> %endm
   360                              <1> 
   361                              <1> ; end CPUREGS.ASM
   362                              <1> 
    25                                  %include	"equates.asm"
     1                              <1> ;========================================================================
     2                              <1> ; EQUATES.ASM -- Lots of Defintions for Relocatable BIOS
     3                              <1> ;========================================================================
     4                              <1> ;   for the N8VEM SBC-188 v.00.4 and 00.5
     5                              <1> ;
     6                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
     7                              <1> ;
     8                              <1> ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
     9                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    10                              <1> ;
    11                              <1> ; This program is free software: you can redistribute it and/or modify
    12                              <1> ; it under the terms of the GNU General Public License as published by
    13                              <1> ; the Free Software Foundation, either version 3 of the License, or
    14                              <1> ; (at your option) any later version.
    15                              <1> ;
    16                              <1> ; This program is distributed in the hope that it will be useful,
    17                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    18                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    19                              <1> ; GNU General Public License for more details.
    20                              <1> ;
    21                              <1> ; You should have received a copy of the GNU General Public License
    22                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    23                              <1> ;
    24                              <1> ;========================================================================
    25                              <1> 
    26                              <1> %if 1
    27                              <1> 	SEGMENT  _TEXT ALIGN=16 PUBLIC CLASS=CODE
    28                              <1>         SEGMENT  CONST ALIGN=2 PUBLIC CLASS=DATA
    29                              <1> 	SEGMENT  _DATA ALIGN=2 PUBLIC CLASS=DATA
    30                              <1>         SEGMENT  CONST2 ALIGN=2 PUBLIC CLASS=DATA
    31                              <1> 	SEGMENT  _BSS  ALIGN=2 PUBLIC CLASS=BSS
    32                              <1> ;;;        SEGMENT  _BASIC ALIGN=16 PUBLIC CLASS=BASIC
    33                              <1> 
    34                              <1> 	GROUP	DGROUP CONST _DATA CONST2 _BSS
    35                              <1> 
    36                              <1>         global  FPEM_segment
    37                              <1> %endif
    38                              <1> 
    39                              <1> %include "ascii.asm"
     1                              <2> ; ascii.asm
     2                              <2> ;
     3                              <2> CTRL            equ     1Fh     ; masks a character to CTRL-x
     4                              <2> 
     5                              <2> NUL     equ     00h
     6                              <2> BEL     equ     (CTRL & 'G')
     7                              <2> BS      equ     08h
     8                              <2> HT      equ     09h
     9                              <2> LF	equ	0Ah
    10                              <2> NL      equ     LF
    11                              <2> CR	equ	0Dh
    12                              <2> XON     equ     (CTRL & 'Q')
    13                              <2> XOFF    equ     (CTRL & 'S')
    14                              <2> DC1     equ     XON
    15                              <2> DC3     equ     XOFF
    16                              <2> ESC     equ	1Bh
    17                              <2> 
    18                              <2> 
    40                              <1> 
    41                              <1> 
    42                              <1> ; POST error codes. Presently one byte but can expand to word.
    43                              <1> ER_BIOS equ	01h		; Bad ROM bios checksum, patch last byte
    44                              <1> ER_RAM	equ	02h		; Bad RAM in main memory, replace
    45                              <1> ER_CRT	equ	04h		; Bad RAM in video card, replace
    46                              <1> ER_FDC	equ	08h		; Bad FDC
    47                              <1> ER_UNK1	equ	10h		; {unassigned}
    48                              <1> ER_MEM	equ	20h		; Bad RAM in vector area, replace
    49                              <1> ER_ROM	equ	40h		; Bad ROM in expansion area, bad checksum
    50                              <1> ER_UNK2	equ	80h		; {unassigned}
    51                              <1> 
    52                              <1> 
    53                              <1> 
    54                              <1> ;; ************************ BIOS Data Segment ******************************
    55                              <1> ;; BIOS data segment - not all will  be used
    56                              <1> ;                struc   BIOS_DATA_AREA  ; at 0040:0000
    57                              <1> %include "bda.inc"
     1                              <2> ;/*======================================================================
     2                              <2> ; bda.inc -- BIOS data area definitions
     3                              <2> ;========================================================================
     4                              <2> ;   for the N8VEM SBC-188
     5                              <2> ;
     6                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
     7                              <2> ;
     8                              <2> ; Copyright (C) 2013 John R. Coffman.  All rights reserved.
     9                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    10                              <2> ;
    11                              <2> ; This program is free software: you can redistribute it and/or modify
    12                              <2> ; it under the terms of the GNU General Public License as published by
    13                              <2> ; the Free Software Foundation, either version 3 of the License, or
    14                              <2> ; (at your option) any later version.
    15                              <2> ;
    16                              <2> ; This program is distributed in the hope that it will be useful,
    17                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    18                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    19                              <2> ; GNU General Public License for more details.
    20                              <2> ;
    21                              <2> ; You should have received a copy of the GNU General Public License
    22                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    23                              <2> ;
    24                              <2> ;========================================================================
    25                              <2> 
    26                              <2> 			;*/ extern				/*
    27                              <2> 	ABSOLUTE  0	;*/ struct BDA {			/*
    28 00000000 <res 00000008>      <2> serial_ports    resw    4	;*/	word	serial_ports[4];	/*
    29 00000008 <res 00000008>      <2> parallel_ports  resw    4	;*/	word	parallel_ports[4];	/*
    30 00000010 <res 00000002>      <2> equipment_flag  resw    1	;*/	EQFL	equipment_flag;		/*
    31                              <2> ;	dw	?		; 40:10 	; Equipment present word
    32                              <2> ;  						;  = (1 iff floppies) *     1.
    33                              <2> ;                                               ;  + (1 iff 187     ) *     2.
    34                              <2> ;  						;  + (#+1 64K sys ram) *    4.
    35                              <2> ;  						;  + (init crt mode ) *    16.
    36                              <2> ;  						;  + (# of floppies ) *    64.
    37                              <2> ;  						;  + (# serial ports) *   512.
    38                              <2> ;  						;  + (1 iff toy port) *  4096.
    39                              <2> ;                                               ;  + (1 iff modem   ) *  8192.
    40                              <2> ;  						;  + (# parallel LPT) * 16384.
    41 00000012 <res 00000001>      <2> mfg_test_flags  resb    1	;*/	byte	mfg_test_flags;	/* 40:12 unused by us
    42 00000013 <res 00000002>      <2> memory_size     resw    1	;*/	word	memory_size;	/* 40:13 kilobytes
    43                              <2> uart_kbd_ctrl_R	equ	$	;*/				/*** JRC: count of ctrl-R's for reboot
    44 00000015 <res 00000001>      <2> IPL_errors      resb    1	;*/	byte	IPL_errors;	/* 40:15 IPL errors<-table/scratchpad
    45 00000016 <res 00000001>      <2> unused_01       resb    1	;*/	byte	unused_01;	/*
    46                              <2> ;;---------------[Keyboard data area]------------;
    47 00000017 <res 00000002>      <2> keyboard_flags_0 resw   1	;*/	word	keyboard_flags_0;  /* 40:17 Shift/Alt/etc. keyboard flags
    48                              <2> keyboard_flags_1 equ	$-1	;     2nd byte	keyboard_flags_1;  
    49 00000019 <res 00000001>      <2> keypad_char	resb	1	;*/	byte	keypad_char;	/* 40:19 Alt-KEYPAD char. goes here
    50 0000001A <res 00000002>      <2> kbd_buffer_head resw    1	;*/	word	kbd_buffer_head;   /* 40:1A --> keyboard buffer head
    51 0000001C <res 00000002>      <2> kbd_buffer_tail resw    1	;*/	word	kbd_buffer_tail;   /* 40:1C --> keyboard buffer tail
    52 0000001E <res 00000020>      <2> kbd_buffer      resw    16	;*/	word	kbd_buffer[16];	/* 40:1E Keyboard Buffer (Scan,Value)
    53                              <2> kbd_buffer_last	equ	$	;*/				/*
    54                              <2> ;;---------------[Diskette data area]------------;
    55 0000003E <res 00000001>      <2> fdc_drv_calib   resb    1	;*/	byte	fdc_drive_calib;   /* 40:3E
    56 0000003F <res 00000001>      <2> fdc_motor_LDOR  resb    1	;*/	byte	fdc_motor_LDOR;	   /* 40:3F Motor, DMA, select control
    57 00000040 <res 00000001>      <2> fdc_motor_ticks resb    1	;*/	byte	fdc_motor_ticks;   /* 40:40 ticks til motor off
    58 00000041 <res 00000001>      <2> fdc_status      resb    1	;*/	byte	fdc_status;	   /* 40:41
    59                              <2> ;				Floppy return code stat byte
    60                              <2> ;				;  1 = bad ic 765 command req.
    61                              <2> ;				;  2 = address mark not found
    62                              <2> ;				;  3 = write to protected disk
    63                              <2> ;				;  4 = sector not found
    64                              <2> ;				;  8 = data late (DMA overrun)
    65                              <2> ;				;  9 = DMA failed 64K page end
    66                              <2> ;				; 16 = bad CRC on floppy read
    67                              <2> ;				; 32 = bad NEC 765 controller
    68                              <2> ;				; 64 = seek operation failed
    69                              <2> ;				;128 = disk drive timed out
    70 00000042 <res 00000007>      <2> fdc_ctrl_status resb    7	;*/	byte	fdc_ctrl_status[7];  /* 40:42 Status bytes from NEC 765
    71                              <2> ;;---------------[Video display area]------------;
    72 00000049 <res 00000001>      <2> video_mode      resb    1	;*/	byte	video_mode;	/* 40:49
    73                              <2> ;			 	; Current CRT mode  (software)
    74                              <2> ;				;  0 = 40 x 25 text (no color)
    75                              <2> ;				;  1 = 40 x 25 text (16 color)
    76                              <2> ;				;  2 = 80 x 25 text (no color)
    77                              <2> ;				;  3 = 80 x 25 text (16 color)
    78                              <2> ;				;  4 = 320 x 200 grafix 4 color
    79                              <2> ;				;  5 = 320 x 200 grafix 0 color
    80                              <2> ;				;  6 = 640 x 200 grafix 0 color
    81                              <2> ;				;  7 = 80 x 25 text (mono card)
    82 0000004A <res 00000002>      <2> video_columns   resw    1	;*/	word video_columns;	/* 40:4A Columns on CRT screen
    83 0000004C <res 00000002>      <2> video_regen_bytes  resw 1	;*/	word video_regen_bytes;	/* 40:4C Bytes in the regen region
    84 0000004E <res 00000002>      <2> video_regen_offset resw 1	;*/	word video_regen_offset;/* 40:4E Byte offset in regen region
    85 00000050 <res 00000010>      <2> video_cursor_pos  resw  8	;*/	word video_cursor_pos[8];  /* 40:50 Cursor pos for up to 8 pages
    86 00000060 <res 00000002>      <2> video_cursor_mode resw  1	;*/	word video_cursor_mode;	/* 40:60 Current cursor mode setting
    87 00000062 <res 00000001>      <2> video_page      resb    1	;*/	byte video_page;	/* 40:62 Current page on display
    88 00000063 <res 00000002>      <2> video_base_seg  resw    1	;*/	word video_base_seg;	/* 40:63 Base address (B000h or B800h)
    89 00000065 <res 00000001>      <2> video_hw_mode   resb    1	;*/	byte video_hw_mode;	/* 40:65 ic 6845 mode reg. (hardware)
    90 00000066 <res 00000001>      <2> video_cga_palette resb  1	;*/	byte video_cga_palette;	/* 40:66 Current CGA palette
    91                              <2> ;;---------------[Used to setup ROM]-------------;
    92 00000067 <res 00000004>      <2> eprom_address   resd    1	;*/	dword eprom_address;	/* 40:67 Eprom base Offset,Segment
    93 0000006B <res 00000001>      <2> spurious_irq    resb    1	;*/	byte spurious_irq;	/* 40:6B Last spurious interrupt IRQ
    94                              <2> ;;---------------[Timer data area]---------------;
    95 0000006C <res 00000004>      <2> timer_ticks     resd    1	;*/	dword timer_ticks;	/* 40:6C Ticks since midnight (lo,hi)
    96 00000070 <res 00000001>      <2> timer_new_day   resb    1	;*/	byte timer_new_day;	/* 40:70 Non-zero if new day
    97                              <2> ;;---------------[System data area]--------------;
    98 00000071 <res 00000001>      <2> break_flag      resb    1	;*/	byte break_flag;	/* 40:71 Sign bit set iff break
    99 00000072 <res 00000002>      <2> warm_boot       resw    1	;*/	word warm_boot;		/* 40:72 Warm boot iff==1234h
   100                              <2> ;;---------------[Hard disk scratchpad]----------;
   101 00000074 <res 00000004>      <2> hdd_scratch     resd    1	;*/	word hdd_scratch[2];	/* 40:74
   102                              <2> ;;---------------[Timout areas/PRT/LPT]----------;
   103 00000078 <res 00000004>      <2> lpt_timeout     resb    4	;*/	byte lpt_timeout[4];	/* 40:78 Ticks for LPT 1-4 timeouts
   104 0000007C <res 00000004>      <2> com_timeout     resb    4	;*/	byte com_timeout[4];	/* 40:7C Ticks for COM 1-4 timeouts
   105                              <2> ;;---obsolete----[Keyboard buf start/end]---jrc--;
   106 00000080 <res 00000002>      <2> kbd_buffer_start resw   1	;*/	word kbd_buffer_start;	/* 40:80 KBD buffer head (PC/AT)
   107 00000082 <res 00000002>      <2> kbd_buffer_end  resw    1	;*/	word kbd_buffer_end;	/* 40:82 KBD buffer tail (PC/AT)
   108                              <2> ;;---------------[EGA stuff]---------------------;
   109 00000084 <res 00000007>      <2> EGA_stuff	resb	7	;*/	byte EGA_stuff[7];	/* 40:84 Unspecified EGA data
   110                              <2> ;;---------------[Floppy/Fixed Media Info]-------------;
   111 0000008B <res 00000001>      <2> fdc_last_rate	resb	1	;*/	byte fdc_last_rate;	/* 40:8B Last floppy step rate/data rate?
   112 0000008C <res 00000004>      <2> fx_misc_unused	resb	4	;*/	byte fx_misc_unused[4];	/* 40:8C Fixed disk miscellaneous ???
   113 00000090 <res 00000002>      <2> fdc_disk_state	resb	2	;*/	byte fdc_disk_state[2];	/* 40:90 Floppy disk state
   114 00000092 <res 00000002>      <2> fdc_op_start	resb	2	;*/	byte fdc_op_start[2];	/* 40:92 Floppy operation start state machine
   115 00000094 <res 00000002>      <2> fdc_cylinder	resb	2	;*/	byte fdc_cylinder[2];	/* 40:94 Floppy present cylinder
   116                              <2> ;;---------------[Additional KBD flags]----------------;
   117 00000096 <res 00000001>      <2> kbd_flag_3	resb	1	;*/	byte kbd_flag_3;	/* 40:96 kbd ???
   118 00000097 <res 00000001>      <2> kbd_flag_2	resb	1	;*/	byte kbd_flag_2;	/* 40:97 kbd ???
   119                              <2> ;;---------------[RTC/timer1 data]---------------------;
   120 00000098 <res 00000004>      <2> user_semaphore	resw	2	;*/	byte *user_semaphore;	/* 40:98 User semaphore in (bit 7)
   121 0000009C <res 00000004>      <2> rtc_count	resd	1	;*/	dword rtc_count;	/* 40:9C RTC tick counter
   122 000000A0 <res 00000001>      <2> rtc_wait_active	resb	1	;*/	byte rtc_wait_active;	/* 40:A0 Busy=01, Posted=80h, 
   123                              <2> ;;---------------[Cassette I/O stuff]------------------;
   124 000000A1 <res 00000001>      <2> last_val	resb	1	;*/	byte last_val;		/* 40:A1 Last byte read value
   125 000000A2 <res 00000002>      <2> crc_reg		resw	1	;*/	word crc_reg;		/* 40:A2 CRC accumulation area
   126                              <2> ;									Post Acknowleged=00;
   127 000000A4 <res 00000001>      <2> EGA_data	resb	1	;*/	byte EGA_data;		/* 40:A4 Various usage
   128 000000A5 <res 00000002>      <2> SDstatus	resb	2	;*/	byte SDstatus[2];	/* 40:A5 Status byte from command
   129 000000A7 <res 00000002>      <2> SDcardtype	resb	2	;*/	byte SDcardtype[2];	/* 40:A7 SDcard type SDSC=2, HC=3, ...
   130                              <2> ;
   131 000000A9 <res 00000004>      <2> fixed_disk_tab	resb	4	;*/	byte fixed_disk_tab[4];	/* dispatch table to fixed disk drivers
   132 000000AD <res 00000001>      <2> wait12_count	resb	1	;*/	byte wait12_count;	/* 40:AD 12usec CX count
   133 000000AE <res 00000001>      <2> lock_count	resb	1	;*/	byte lock_count;	/* 40:AE lock level counter
   134 000000AF <res 00000001>      <2> EMS_start       resb    1	;*/	byte EMS_start;		/* start EMS allocation from here
   135                              <2> fx80		equ	$	;*/	struct EDD_disk fx80;	/* fixed disk parameter area 0
   136 000000B0 <res 00000002>      <2> fx_log_cylinders resw   1	;	word fx_log_cylinders;	 logical number of cylinders
   137 000000B2 <res 00000001>      <2> fx_log_heads    resb    1	;	byte fx_log_heads;	 logical number of heads
   138 000000B3 <res 00000001>      <2> fx_signature	resb	1	;	byte fx_signature;	 A0h signature = translated geom
   139 000000B4 <res 00000001>      <2> fx_phys_sectors	resb    1       ;	byte fx_phys_sectors;	 physical number of sectors per track
   140 000000B5 <res 00000002>      <2> fx_LBA_high     resw    1       ;	word fx_LBA_high;	 high word of LBA28 number of sectors
   141 000000B7 <res 00000001>      <2> fx_reserved7    resb	1	;	byte fx_reserved;	 MBZ
   142 000000B8 <res 00000001>      <2> fx_drive_control resb   1       ;	byte fx_drive_control;	 flag bits for IDE head register
   143 000000B9 <res 00000002>      <2> fx_phys_cylinders resw	1	;	word fx_phys_cylinders;	 physical number of cylinders
   144 000000BB <res 00000001>      <2> fx_phys_heads	resb	1	;	byte fx_phys_heads;	 physical number of heads
   145 000000BC <res 00000002>      <2> fx_LBA_low	resw	1	;	word fx_LBA_low;	 low word of LBA28 number of sectors
   146 000000BE <res 00000001>      <2> fx_log_sectors	resb	1	;	byte fx_log_sectors;	 logical number of sectors per track
   147 000000BF <res 00000001>      <2> fx_checksum	resb	1	;	byte fx_checksum;	 checksum, dunno how to compute
   148 000000C0 <res 00000010>      <2> fx81            resb    16	;*/	struct EDD_disk fx81;	/* fixed disk parameter area 1
   149 000000D0 <res 00000010>      <2> fx82            resb    16	;*/	struct EDD_disk fx82;	/* fixed disk parameter area 2
   150 000000E0 <res 00000010>      <2> fx83            resb    16	;*/	struct EDD_disk fx83;	/* fixed disk parameter area 3
   151                              <2> ;
   152                              <2> ;
   153                              <2> 
   154 000000F0 <res 00000002>      <2> FPEM_segment    resw    1       ;*/	word FPEM_segment;	/* FPEM data segment
   155                              <2> 
   156 000000F2 <res 00000002>      <2> EBDA_paragraph  resw    1       ;*/	word EBDA_paragraph;	/* lowest EBDA paragraph
   157                              <2> 
   158 000000F4 <res 00000002>      <2> dma0_cw         resw    1       ;*/	word dma0_cw;		/* end of dma control word
   159 000000F6 <res 00000002>      <2> dma1_cw         resw    1       ;*/	word dma1_cw;		/*   ditto
   160                              <2> 
   161 000000F8 <res 00000002>      <2> fdc_type	resb	2	;*/	byte fdc_type[2];	/* disk type in low nibble, alternate in hi nib 
   162                              <2> 
   163 000000FA <res 00000004>      <2> debug_static_ptr  resw	2	;*/	void *debug_static_ptr;	/* pointer to debug static area
   164                              <2> 
   165 000000FE <res 00000001>      <2> n_fixed_disks   resb    1       ;*/	byte n_fixed_disks;	/* number of fixed disks
   166                              <2> 
   167 000000FF <res 00000001>      <2> cpu_xtal        resb    1       ;*/	byte cpu_xtal;		/* CPU crystal frequency in Mhz 
   168                              <2> ;								   CPU clock is half of this
   169                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   170                              <2> ;
   171                              <2> ;  System configuration stuff below
   172                              <2> ;	c.f., CONFIG.ASM (ANSI.CFG, CVDU.CFG, etc.), User configuration stuff
   173                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   174                              <2> %if 0				;*/
   175                              <2> #define FIXED_DISK_MAX 4		/*
   176                              <2> %else
   177                              <2> %define FIXED_DISK_MAX 4
   178                              <2> %endif
   179                              <2> %if 0				;*/
   180                              <2> #define PPIDE_driver 1		/*
   181                              <2> %else
   182                              <2> %define PPIDE_driver 1
   183                              <2> %endif
   184                              <2> %if 0				;*/
   185                              <2> #define DIDE_driver 1		/*
   186                              <2> %else
   187                              <2> %define DIDE_driver 1
   188                              <2> %endif
   189                              <2> %if 0				;*/
   190                              <2> #define DSD_driver 1		/*
   191                              <2> %else
   192                              <2> %define DSD_driver 1
   193                              <2> %endif
   194                              <2> 				;*/
    58                              <1> 
    59                              <1> ;  this must be the same in EQUATES.H */
    60                              <1> %if SOFT_DEBUG
    61                              <1> %define NBREAK  8
    62                              <1> %endif
    63                              <1> 
    64                              <1> 
    65                              <1> %if 0
    66                              <1>         segment _TEXT
    67                              <1> ;; *************************************************************************
    68                              <1> 
    69                              <1> 
    70                              <1> 
    71                              <1> 
    72                              <1> ;; ************************ DOS Data Segment *******************************
    73                              <1> ;dosdir	SEGMENT at 50h				; Boot disk directory from IPL
    74                              <1> ;xerox	label	byte				;  0 if Print Screen idle
    75                              <1> ;						;  1 if PrtSc xeroxing screen
    76                              <1> ;						;255 if PrtSc error in xerox
    77                              <1> ;						;  ...non-grafix PrtSc in bios
    78                              <1> ;	db	200h dup(?)			; PC-DOS bootstrap procedure
    79                              <1> ;						;  ...IBMBIO.COM buffers the
    80                              <1> ;						;  ...directory of the boot
    81                              <1> ;						;  ...device here at IPL time
    82                              <1> ;						;  ...when locating the guts
    83                              <1> ;						;  ...of the operating system
    84                              <1> ;						;  ...filename "IBMDOS.COM"
    85                              <1> ;dosdir	ends
    86                              <1> ;; *************************************************************************
    87                              <1> ;; ************************ DOS IPL Segment ********************************
    88                              <1> ;dosseg	SEGMENT at 70h				; "Kernel" of PC-DOS op sys
    89                              <1> ;;IBMBIO.COM file loaded by boot block. Device Drivers/Bootstrap. CONTIGUOUS<---
    90                              <1> ;;IBMDOS.COM operating system nucleus immediately follows IBMBIO.COM and       !
    91                              <1> ;;     doesn`t have to be contiguous.  The IBMDOS operating system nucleus     !
    92                              <1> ;;     binary image is loaded by transient code in IBMBIO binary image	      !
    93                              <1> ;dosseg	ends					;			      !
    94                              <1> ;iplseg	SEGMENT at 0h				; Segment for boot block      !
    95                              <1> ;;The following boot block is loaded with 512 bytes on the first sector of     !
    96                              <1> ;;the bootable device by code resident in the ROM-resident bios.  Control is   !
    97                              <1> ;;then transferred to the first word 0000:7C00 of the disk-resident bootstrap  !
    98                              <1> ;	ORG	07C00h				;  ..offset for boot block    !
    99                              <1> ;boot	db	200h dup(?)			;  ..start disk resident boot--
   100                              <1> ;iplseg	ends
   101                              <1> 
   102                              <1> %endif
    26                                  
    27                                  %define QUICK_VERIFY 1
    28                                  %define DEBUG 0
    29                                  %include	"sdcard.inc"
     1                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     2                              <1> ; SDcard.INC -- include file for Basic I/O routines for the Dual SDcard
     3                              <1> ;		add-on board
     4                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     5                              <1> ;
     6                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
     7                              <1> ;
     8                              <1> ; Copyright (c) 2013 John R. Coffman.  All rights reserved.
     9                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    10                              <1> ;
    11                              <1> ; This program is free software: you can redistribute it and/or modify
    12                              <1> ; it under the terms of the GNU General Public License as published by
    13                              <1> ; the Free Software Foundation, either version 3 of the License, or
    14                              <1> ; (at your option) any later version.
    15                              <1> ;
    16                              <1> ; This program is distributed in the hope that it will be useful,
    17                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    18                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    19                              <1> ; GNU General Public License for more details.
    20                              <1> ;
    21                              <1> ; You should have received a copy of the GNU General Public License
    22                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    23                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    24                              <1> ;
    25                              <1> ;;;	cpu	186
    26                              <1> 
    27                              <1> %define	dev_SDcard	08h		; Dual SD card board device code
    28                              <1> 
    29                              <1> %define Z80	1
    30                              <1> %define SBC188	2
    31                              <1> %define M68K	3
    32                              <1> 
    33                              <1> %define TRUE	1
    34                              <1> %define FALSE	0
    35                              <1> 
    36                              <1> %if 0
    37                              <1> %define CPU	SBC188
    38                              <1> 
    39                              <1> %if	CPU==Z80
    40                              <1> IO_BASE		equ	0
    41                              <1> %elif	CPU==SBC188
    42                              <1> IO_BASE		equ	0400h
    43                              <1> %elif	CPU=M68K
    44                              <1> IO_BASE		equ	0FFFF8000h
    45                              <1> %else
    46                              <1> IO_BASE		equ	0
    47                              <1> %endif
    48                              <1> %endif
    49                              <1> 
    50                              <1> 
    51                              <1> SDoperation	equ	dev_SDcard + IO_BASE
    52                              <1> SDselect	equ	SDoperation + 1
    53                              <1> 
    54                              <1> 
    55                              <1> 
    56                              <1> ; Operation register bits
    57                              <1> CardDetect	equ	20h		; read-only
    58                              <1> WrProt		equ	10h		; read-only
    59                              <1> ChipSelect	equ	04h		; bit 2 (through an inverter)
    60                              <1> Clock		equ	02h		; bit 1
    61                              <1> DataIn		equ	01h
    62                              <1> DataOut		equ	01h		; all Data I/O through bit 0
    63                              <1> 
    64                              <1> ; Select register bits
    65                              <1> Unit		equ	01h		; read/write
    66                              <1> UnitMask	equ	Unit
    67                              <1> 
    68                              <1> WrProt0		equ	04h		; read-only
    69                              <1> WrProt1		equ	08h		; read-only
    70                              <1> 
    71                              <1> CardDetect0	equ	10h		; read/write	(ChangeBit must be set)
    72                              <1> CardDetect1	equ	20h		; read/write	( ditto )
    73                              <1> 
    74                              <1> IntEnable	equ	40h		; write-only	(ChangeBit must be set)
    75                              <1> ChangeBit	equ	80h		; write-only
    76                              <1> Pend0		equ	40h		; read-only
    77                              <1> Pend1		equ	80h		; read-only
    78                              <1> PendMask	equ	Pend0 | Pend1
    79                              <1> 
    80                              <1> CDupdateMask	equ	CardDetect1 | CardDetect0 | UnitMask
    81                              <1> 
    82                              <1> 
    83                              <1> ; Card types:
    84                              <1> SDtypeUnk	equ	0		; unknown card type
    85                              <1> SDtypeMMC	equ	1		; old MMC card
    86                              <1> SDtypeSDSC 	equ	2		; standard card
    87                              <1> SDtypeSDHC	equ	3		; HC card
    88                              <1> 
    89                              <1> 
    90                              <1> %if 1
    91                              <1> ; for the Tiny, Small, or Compact models:
    92                              <1> %define ARG(n) [bp+2+(n)*2]
    93                              <1> %endif
    30                                  
    31                                  ; Do we use CRC's with commands and data transfers?
    32                                  %define USE_CRCs	TRUE
    33                                  
    34                                          global  SDcard_BIOS_call_13h
    35                                          extern  @mulLS
    36                                          extern  microsecond
    37                                  
    38                                  	SEGMENT	_TEXT
    39                                  
    40                                  Zero:
    41                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    42                                  ;  BIOS call entry for Dual SD Card driver
    43                                  ;       int  13h
    44                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    45                                  SDcard_BIOS_call_13h:           ; SDcard driver entry
    46 00000000 FB                              sti                     ; Enable interrupts
    47 00000001 061E60                          pushm   all,ds,es       ; Standard register save
    48 00000004 89E5                            mov     bp,sp           ; establish stack addressing
    49 00000006 6A40                            push    bios_data_seg
    50 00000008 1F                              popm    ds              ; establish addressability
    51 00000009 FC                              cld
    52                                  ; above done in general Fixed disk entry point
    53                                  
    54                                  
    55                                  	global	DSD_entry
    56                                  DSD_entry:
    57                                  %if SOFT_DEBUG & 0
    58                                  	int 5
    59                                  %endif
    60 0000000A 30FF                            xor     bh,bh           ; zero extend byte
    61 0000000C 88E3                            mov     bl,ah           ; set to index into dispatch table
    62 0000000E 80FC19                          cmp     ah,max/2
    63 00000011 7307                            jae     try_extended
    64 00000013 D1E3                            shl     bx,1            ; index words
    65                                  
    66 00000015 2EFFA7[3F00]                cs  jmp     near [dispatch+bx]
    67                                  
    68                                  try_extended:
    69 0000001A 80EB41                          sub     bl,41h          ; start of extended calls
    70 0000001D 80FB0E                          cmp     bl,max41/2
    71 00000020 7307                            jae     undefined
    72 00000022 D1E3                            shl     bx,1            ; index word addresses
    73 00000024 2EFFA7[7100]                cs  jmp     near [dispatch41+bx]
    74                                  
    75                                  
    76                                  ;fn00:           ; Reset Disk System
    77                                  fn01:           ; Get Disk System Status
    78                                  ;fn02:           ; Read Sector
    79                                  ;fn03:           ; Write Sector
    80                                  ;fn04:           ; Verify Sector
    81                                  fn05:           ; Format Track
    82                                  fn06:           ; Format Bad Track (fixed disk) [PC]
    83                                  fn07:           ; Format Drive (fixed disk)     [PC]
    84                                  ;fn08:           ; Get Drive Parameters
    85                                  fn09:           ; Initialize Fixed Disk Characteristics [PC,AT,PS/2]
    86                                  fn0A:           ; Read Sector Long (fixed disk) [PC,AT,PS/2]
    87                                  fn0B:           ; Write Sector Long (fixed disk) [PC,AT,PS/2]
    88                                  fn0C:           ; Seek (fixed disk)
    89                                  fn0D:           ; Reset Fixed Disk System
    90                                  fn0E:           ; Read Sector Buffer (fixed disk) [PC only]
    91                                  fn0F:           ; Write Sector Buffer (fixed disk) [PC only]
    92                                  fn10:           ; Get Drive Status (fixed disk)
    93                                  fn11:           ; Recalibrate Drive (fixed disk)
    94                                  fn12:           ; Controller RAM Diagnostic (fixed disk) [PC/XT]
    95                                  fn13:           ; Controller Drive Diagnostic (fixed disk) [PC/XT]
    96                                  fn14:           ; Controller Internal Diagnostic (fixed disk) [PC,AT,PS/2]
    97                                  ;fn15:           ; Get Disk Type                 [AT]
    98                                  fn16:           ; Get Disk Change Status (floppy)
    99                                  fn17:           ; Set Disk Type (floppy)
   100                                  fn18:           ; Set Media Type for Format (floppy)
   101                                  
   102                                  ;fn41:           ; Check Extensions Present
   103                                  ;fn42:           ; Extended Read
   104                                  ;fn43:           ; Extended Write
   105                                  ;fn44:           ; Extended Verify
   106                                  fn45:           ; Lock/Unlock Drive
   107                                  fn46:           ; Eject Drive
   108                                  ;fn47:           ; Extended Seek
   109                                  ;fn48:           ; Get Drive Parameters
   110                                  fn49:           ; Get Extended Disk Change Status
   111                                  ;fn4E:           ; Set Hardware Configuration
   112                                  
   113                                  undefined:
   114                                  %if SOFT_DEBUG & 0
   115                                          int 5
   116                                  %endif
   117 00000029 B401                            mov     ah,ERR_invalid_command     ; Invalid command
   118 0000002B EB06                    	jmp	error_exit
   119                                  
   120                                  good_exit:
   121 0000002D 30E4                    	xor	ah,ah			; clear the carry, AH=0
   122                                  exit_sequence:
   123 0000002F 08E4                            or      ah,ah
   124 00000031 7401                            jz     exit_pops
   125                                  error_exit:
   126 00000033 F9                      	stc				; set the carry
   127                                  exit_pops:
   128 00000034 88660F                          mov     [bp+offset_AH],ah          ; set the error code
   129 00000037 89EC                            mov     sp,bp			; deallocate any variables
   130 00000039 611F07                          popm    ALL,ds,es
   131                                  %if SOFT_DEBUG & 0
   132                                  	int 5
   133                                  %endif
   134 0000003C CA0200                          retf	2			; rather than IRET
   135                                  
   136                                  
   137                                  dispatch:
   138 0000003F [E507]                          dw      fn00    ; Reset Disk System
   139 00000041 [2900]                          dw      fn01    ; 
   140 00000043 [F007]                          dw      fn02
   141 00000045 [F007]                          dw      fn03
   142 00000047 [F007]                          dw      fn04
   143 00000049 [2900]                          dw      fn05
   144 0000004B [2900]                          dw      fn06
   145 0000004D [2900]                          dw      fn07
   146 0000004F [3C08]                          dw      fn08
   147 00000051 [2900]                          dw      fn09
   148 00000053 [2900]                          dw      fn0A
   149 00000055 [2900]                          dw      fn0B
   150 00000057 [2900]                          dw      fn0C
   151 00000059 [2900]                          dw      fn0D
   152 0000005B [2900]                          dw      fn0E
   153 0000005D [2900]                          dw      fn0F
   154 0000005F [2900]                          dw      fn10
   155 00000061 [2900]                          dw      fn11
   156 00000063 [2900]                          dw      fn12
   157 00000065 [2900]                          dw      fn13
   158 00000067 [2900]                          dw      fn14
   159 00000069 [6508]                          dw      fn15
   160 0000006B [2900]                          dw      fn16
   161 0000006D [2900]                          dw      fn17
   162 0000006F [2900]                          dw      fn18
   163                                  max     equ     $-dispatch
   164                                  
   165                                  dispatch41:
   166 00000071 [8908]                          dw      fn41
   167 00000073 [B008]                          dw      fn42
   168 00000075 [B008]                          dw      fn43
   169 00000077 [B008]                          dw      fn44
   170 00000079 [2900]                          dw      fn45
   171 0000007B [2900]                          dw      fn46
   172 0000007D [B008]                          dw      fn47
   173 0000007F [ED08]                          dw      fn48
   174 00000081 [2900]                          dw      fn49
   175 00000083 [2900]                          dw      undefined       ; 4A
   176 00000085 [2900]                          dw      undefined       ; 4B
   177 00000087 [2900]                          dw      undefined       ; 4C
   178 00000089 [2900]                          dw      undefined       ; 4D
   179 0000008B [6209]                          dw      fn4E
   180                                  max41   equ     $-dispatch41
   181                                  
   182                                  
   183                                  
   184                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   185                                  ; SDsetunit	set the selected unit (0 or 1) in DI and in SDselect reg.
   186                                  ;
   187                                  ;  Enter with:
   188                                  ;	DS =	Bios Data Area pointer is set
   189                                  ;	DL =	hard drive specifier (80h..83h)
   190                                  ;
   191                                  ;  Return with:
   192                                  ;	DI = 	unit number selected in the h/w (0 or 1)
   193                                  ;	All other registers preserved, including AX
   194                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   195                                  SDsetunit:
   196 0000008D 89D7                    	mov	di,dx			; device code to DI
   197 0000008F 83E703                  	and	di,FIXED_DISK_MAX-1	; mask device code
   198 00000092 8BBDA900                	mov	di,[fixed_disk_tab+di]	; only the low byte matters
   199 00000096 83E701                  	and	di,UnitMask
   200 00000099 52                      	push	dx   			; save DX
   201 0000009A 97                      	xchg	ax,di			; save AX and DI
   202 0000009B BA0904                  	mov	dx,SDselect		; unit selection register
   203 0000009E EE                      	out	dx,al			; select unit 0 or 1
   204 0000009F 97                      	xchg	ax,di			; restore AX and DI
   205 000000A0 5A                      	pop	dx			; restore DX
   206 000000A1 C3                      	ret
   207                                  
   208                                  
   209                                  
   210                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   211                                  ; SDgetunit	get the selected unit# in DI
   212                                  ;
   213                                  ;  Enter with:
   214                                  ;	Nothing
   215                                  ;
   216                                  ;  Return with:
   217                                  ;	DI = 	unit number selected in the h/w (0 or 1)
   218                                  ;	DX =	Operation Register device code
   219                                  ;	All other registers preserved, including AX
   220                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   221                                  SDgetunit:
   222 000000A2 97                      	xchg	ax,di		; save AX in DI
   223 000000A3 BA0904                  	mov	dx,SDselect	; get Select register device code
   224 000000A6 EC                      	in	al,dx
   225 000000A7 83E001                  	and	ax,UnitMask
   226 000000AA 97                      	xchg	ax,di		; set DI, restore AX
   227 000000AB 4A                      	dec	dx		; set Operation Register device code
   228 000000AC C3                      	ret
   229                                  
   230                                  
   231                                  
   232                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   233                                  ; SDputchar	Put a byte to DATIN on the SD card
   234                                  ;
   235                                  ;  Enter with:
   236                                  ;	AL = byte to put out
   237                                  ;	DX = SDoperation register I/O device code
   238                                  ;  Assume:
   239                                  ;	Chip Select is already asserted
   240                                  ;	Clock may be high or low
   241                                  ;
   242                                  ;  Return with:
   243                                  ;	AX is trashed
   244                                  ;	Clock is deasserted, Chip Select is asserted
   245                                  ;
   246                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   247                                  	global	SDputchar
   248                                  SDputchar:
   249 000000AD 51                      	pushm	cx
   250                                  
   251 000000AE 88C4                    	mov	ah,al			; move character to AH
   252 000000B0 B90800                  	mov	cx,8			; count 8 bits
   253                                  
   254 000000B3 B002                    .1:	mov	al, ChipSelect / 2	; will shift it, no clock yet
   255 000000B5 D1C0                    	rol	ax,1			; rotate bit into register
   256 000000B7 EE                      	out	dx,al			; output data, no clock
   257 000000B8 0C02                    	or	al, Clock		; rising clock edge
   258 000000BA EE                      	out	dx,al			; 
   259 000000BB E2F6                    	loop	.1
   260                                  
   261 000000BD 24FD                    	and	al,~Clock
   262 000000BF EE                      	out	dx,al			; set clock low
   263                                  
   264 000000C0 59                      	popm	cx
   265 000000C1 C3                      	ret
   266                                  
   267                                  
   268                                  
   269                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   270                                  ; SDgetchar	Get a byte from DATOUT on the SD card
   271                                  ;
   272                                  ;  Enter with:
   273                                  ;	DX = SDoperation register I/O device code
   274                                  ;  Assume:
   275                                  ;	Chip Select is already asserted
   276                                  ;	Clock is low
   277                                  ;
   278                                  ;  Return with:
   279                                  ;	AL = the byte received
   280                                  ;	AH = copy of AL
   281                                  ;	Clock is low, Chip Select is still asserted
   282                                  ;
   283                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   284                                  	global	SDgetchar
   285                                  SDgetchar:
   286 000000C2 51                      	push	cx
   287                                  
   288 000000C3 B005                    	mov	al, ChipSelect | DataIn
   289 000000C5 EE                      	out	dx,al			; set clock low
   290                                  
   291 000000C6 B90800                  	mov	cx,8			; count 8 bits
   292 000000C9 EC                      .1:	in	al,dx			; get input bit
   293 000000CA D0E8                    	shr	al,1
   294 000000CC D0D4                    	rcl	ah,1			; bit into AH
   295 000000CE B007                    	mov	al,ChipSelect | Clock | DataIn
   296 000000D0 EE                      	out	dx,al			; acknowledge receipt of bit
   297 000000D1 B005                    	mov	al, ChipSelect | DataIn		; no clock
   298 000000D3 EE                      	out	dx,al
   299 000000D4 E2F3                    	loop	.1
   300                                  
   301 000000D6 88E0                    	mov	al,ah			; return byte in AL
   302 000000D8 59                      	pop	cx
   303 000000D9 C3                      	ret
   304                                  
   305                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   306                                  ; spin		apply clock pulses to the SD card
   307                                  ;
   308                                  ;  Enter with:
   309                                  ;	CX = character count to spin
   310                                  ;
   311                                  ;  Exit with:
   312                                  ;	AX is trashed
   313                                  ;	CX = 0
   314                                  ;	DX = SDoperation register I/O device code
   315                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   316                                  spin:
   317 000000DA BA0804                  	mov	dx,SDoperation
   318 000000DD B0FF                    .1:	mov	al,-1
   319 000000DF E8CBFF                  	call	SDputchar
   320 000000E2 E2F9                      	loop	.1
   321 000000E4 C3                       	ret
   322                                  
   323                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   324                                  ; SDsendclks	send clock transitions to the card
   325                                  ;
   326                                  ;  Enter with:
   327                                  ;	AL = initial state of bits to bang
   328                                  ;	CX = transition count
   329                                  ;	DX = card Operation Register device code
   330                                  ;
   331                                  ;  Return with:
   332                                  ;	AL modified
   333                                  ;	CX = 0
   334                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   335                                  SDsendclks:
   336 000000E5 EE                      .1:	out	dx,al		; put out state of bits specified
   337 000000E6 3402                    	xor	al,Clock
   338 000000E8 E2FB                    	loop	.1
   339 000000EA EE                      	out	dx,al		; put out last transition
   340 000000EB C3                      	ret
   341                                  
   342                                  
   343                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   344                                  ; SDdone	complete a transaction
   345                                  ;
   346                                  ;  Enter with:
   347                                  ;	DX = Operation Register device code
   348                                  ;
   349                                  ;  Return with:
   350                                  ;	All registers are preserved
   351                                  ;	Flags are preserved, too
   352                                  ;
   353                                  ;	The card is deselected!!!
   354                                  ;
   355                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   356                                  SDdone:
   357 000000EC 9C5150                  	pushm	ax,cx,f
   358                                  
   359 000000EF B001                    	mov	al,DataIn	; no ChipSelect or Clock
   360 000000F1 B91000                  	mov	cx,16
   361 000000F4 E8EEFF                  	call	SDsendclks
   362                                  
   363 000000F7 58599D                  	popm	ax,cx,f
   364 000000FA C3                      	ret
   365                                  
   366                                  
   367                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   368                                  ; SDwaitrdy	wait for card to become ready
   369                                  ;
   370                                  ;  Enter with:
   371                                  ;	DX = Operation Register device code
   372                                  ;
   373                                  ;  Return with:
   374                                  ;	Carry = 0	Clear means no error	(AL = 0)
   375                                  ;	Carry = 1	Set means error		(AL = 0xFF)
   376                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   377                                  SDwaitrdy:
   378 000000FB 51                      	pushm	cx
   379                                  
   380 000000FC B005                    	mov	al, ChipSelect | DataIn
   381 000000FE EE                      	out	dx,al		; set clock to 0
   382                                  
   383 000000FF B9FF7F                  	mov	cx,7FFFh
   384                                  .1:
   385 00000102 E8BDFF                  	call	SDgetchar
   386 00000105 FEC0                    	inc	al		; 0FFh -> 00h
   387 00000107 7407                    	jz	.9
   388 00000109 E2F7                    	loop	.1
   389                                  
   390 0000010B FEC8                    	dec	al		; return error byte
   391 0000010D F9                      	stc			; flag error
   392 0000010E EB01                    	jmp	.99		; error exit
   393                                  
   394 00000110 F8                      .9:	clc			; clear the carry
   395 00000111 98                      .99:	cbw			; extend byte to full word
   396 00000112 59                      	popm	cx
   397 00000113 C3                      	ret
   398                                  	
   399                                  
   400                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   401                                  ; SDgoidle	put card in the idle state
   402                                  ;
   403                                  ;  Enter with:
   404                                  ;	DX	Operation register device code
   405                                  ;
   406                                  ;  Return with:
   407                                  ;	AX	response to CMD0
   408                                  ;	Zero flag is set by compare to '01'
   409                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   410                                  SDgoidle:
   411 00000114 B98813                  	mov	cx,5000		; about 5 milliseconds
   412 00000117 90                      .0:	nop
   413 00000118 E2FD                    	loop	.0
   414                                  
   415 0000011A BE[7002]                	mov	si,CMD0
   416 0000011D 0E                      	pushm	cs
   417 0000011E 07                      	popm	es
   418 0000011F E81902                  	call	cmd_R1
   419                                  
   420 00000122 E8C7FF                  	call	SDdone
   421 00000125 7402                    	jz	.5
   422 00000127 3C01                    	cmp	al,01h
   423                                  .5:
   424 00000129 C3                      	ret
   425                                  
   426                                  
   427                                  
   428                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   429                                  ; SDcmdset	set up a command with parameters
   430                                  ;
   431                                  ;  Enter with:
   432                                  ;	BL	command byte (40h | ??)
   433                                  ;	DX:AX	4-byte parameter, DH is ms-byte, AL is ls-byte
   434                                  ;
   435                                  ;  Exit with:
   436                                  ;	SP	decreased by 6 bytes
   437                                  ;	ES:SI	(or SS:SP) points at command in the stack
   438                                  ;	AX,BX,CX  are all trashed
   439                                  ;	DX	is reset to Operation register device code
   440                                  ;
   441                                  ;  After the command is executed, the stack is cleared with
   442                                  ;	ADD	SP,6
   443                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   444                                  SDcmdset:
   445 0000012A 59                      	pop	cx		; pop return address
   446                                  
   447                                  ;  bl:dh:dl:ah:al:FF
   448 0000012B 86D3                    	xchg	dl,bl
   449                                  ;  dl:dh:bl:ah:al:FF
   450 0000012D 86C3                    	xchg	al,bl
   451                                  ;  dl:dh:al:ah:bl:FF
   452                                  ;;;	mov	bh,0FFh
   453                                  ;  dl:dh:al:ah:bl:bh
   454 0000012F 53                      	push	bx
   455 00000130 50                      	push	ax
   456 00000131 52                      	push	dx
   457 00000132 89E6                    	mov	si,sp
   458 00000134 16                      	pushm	ss
   459 00000135 07                      	popm	es
   460 00000136 51                      	push	cx		; reset return address
   461                                  %if USE_CRCs
   462 00000137 B90500                  	mov	cx,5		; CRC7 for 5 bytes
   463 0000013A E8EE01                  	call	calcCRC7
   464 0000013D 268804                    es	mov	[si],al		; store the CRC7
   465 00000140 83EE05                  	sub	si,5		; reset SI to point at CMD string
   466                                  %endif
   467 00000143 BA0804                  	mov	dx,SDoperation	; set for Operation Register device code
   468 00000146 C3                      	ret
   469                                  
   470                                  
   471                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   472                                  ; SDcmdset0	set up a command with no parameters
   473                                  ;
   474                                  ;  Enter with:
   475                                  ;	AL	command code
   476                                  ;
   477                                  ;  Return with:
   478                                  ;	SP	decreased by 6 bytes
   479                                  ;	ES:SI	(or SS:SP) points at command in the stack
   480                                  ;	DX	is reset to Operation register device code
   481                                  ;	AX	is destroyed
   482                                  ;
   483                                  ;  After the command is executed, the stack is cleared with
   484                                  ;	ADD	SP,6
   485                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   486                                  SDcmdset0:
   487 00000147 5A                      	pop	dx		; save return address
   488 00000148 6A00                    	push	0		; push 0,CRC
   489 0000014A 6A00                    	push	0		; push 0,0
   490 0000014C 30E4                    	xor	ah,ah
   491 0000014E 50                      	push	ax		; push CMDx,0
   492                                  	
   493 0000014F 89E6                    	mov	si,sp		; set DS:SI to point at command
   494 00000151 16                      	pushm	ss
   495 00000152 07                      	popm	es
   496 00000153 52                      	push	dx		; push return address
   497                                  
   498                                  %if USE_CRCs
   499 00000154 5651                    	pushm	cx,si
   500 00000156 B90500                  	mov	cx,5		; CRC7 for 5 bytes
   501 00000159 E8CF01                  	call	calcCRC7
   502 0000015C 8804                    	mov	[si],al		; store the CRC7
   503 0000015E 595E                    	popm	cx,si		; DS:SI set, DX=Oper. reg
   504                                  %endif
   505 00000160 BA0804                  	mov	dx,SDoperation	; set for Operation Register device code
   506 00000163 C3                      	ret
   507                                  
   508                                  
   509                                  
   510                                  
   511                                  
   512                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   513                                  ; SDinit	initialize card status to "init required"
   514                                  ;
   515                                  ;  Enter with:
   516                                  ;	nothing
   517                                  ;
   518                                  ;  Return with:
   519                                  ;	nothing
   520                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   521                                  	global	@SDinit		; C-fastcall
   522                                  @SDinit:
   523                                  SDinit:
   524 00000164 1E                      	push	ds
   525 00000165 6A40                    	push	bios_data_seg
   526 00000167 1F                      	pop	ds
   527 00000168 C706A500FFFF            	mov	word [SDstatus], -1	; zap both status bytes to 0FFh
   528 0000016E 1F                      	pop	ds
   529 0000016F C3                      	ret
   530                                  
   531                                  
   532                                  
   533                                  
   534                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   535                                  ; SDinitcard	initialize a newly inserted SD card
   536                                  ;
   537                                  ;  Enter with:
   538                                  ;	AX = card selection (0 or 1)
   539                                  ;
   540                                  ;  Return with:
   541                                  ;	AX = status	(0 means success)
   542                                  ;	Zero flag reflects status
   543                                  ;
   544                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   545                                  	global	@SDinitcard		; C-fastcall
   546                                  @SDinitcard:
   547 00000170 1E525153                	pushm	bx,cx,dx,ds
   548 00000174 6A40                    	push	bios_data_seg		; get BDA on a C-call
   549 00000176 1F                      	pop	ds
   550 00000177 E80500                  	call	SDinitcard
   551 0000017A 5B595A1F                	popm	bx,cx,dx,ds
   552 0000017E C3                      	ret
   553                                  
   554                                  SDinitcard:
   555 0000017F 065756                  	pushm	si,di,es
   556                                  
   557 00000182 A9FEFF                  	test	ax,~UnitMask		; bits must not be set
   558 00000185 7403E9E000              	jnz	.error1
   559                                  
   560 0000018A BA0904                  	mov	dx,SDselect
   561 0000018D EE                      	out	dx,al			; select card  1 or 0
   562 0000018E 4A                      	dec	dx			; set to Operation Register
   563 0000018F 89C7                    	mov	di,ax			; set Unit Index
   564                                  
   565                                  ; Check for card present
   566 00000191 EC                      	in	al,dx			; read Operation register
   567 00000192 A820                    	test	al,20h			; test for Card Detect bit
   568 00000194 B8FCFF                  	mov	ax,-4			; error code for No Card inserted
   569 00000197 8885A500                	mov	[SDstatus + di],al	; say there is no card
   570 0000019B 7503E9C700              	jz	.error			; set error code & return
   571                                   
   572 000001A0 E849FF                  	call	SDdone			; seems to help some cards
   573                                  
   574 000001A3 B005                    	mov	al,ChipSelect | DataIn	; DataIn is into the SDcard
   575 000001A5 B90001                  	mov	cx,256			; 256 clock transitions
   576 000001A8 E83AFF                  	call	SDsendclks
   577                                  
   578 000001AB E84DFF                  	call	SDwaitrdy		; wait for card to go ready
   579 000001AE 7303E9AC00              	jc	.rdytimeout
   580                                  
   581                                  ;;;	call	SDgoidle
   582                                  ;;;	je	.okay
   583 000001B3 E85EFF                  	call	SDgoidle		; only 1 needed
   584                                  ;;	mov	ah,$-Zero
   585 000001B6 7403E9AC00              	jne	.error			; SDsendclks glitch fixed
   586                                  
   587 000001BB 0E                      	pushm	cs
   588 000001BC 07                      	popm	es
   589 000001BD BE[7602]                	mov	si,CMD8			; v.2 cards require CMD8
   590 000001C0 E87801                  	call	cmd_R1
   591 000001C3 A8FE                    	test	al,~01h			; any error bits set (v.1 card)
   592 000001C5 750C                    	jnz	.0
   593 000001C7 E8F8FE                  	call	SDgetchar		; v.2 card returns 4 more bytes
   594 000001CA E8F5FE                  	call	SDgetchar
   595 000001CD E8F2FE                  	call	SDgetchar
   596 000001D0 E8EFFE                  	call	SDgetchar
   597                                  .0:
   598 000001D3 E816FF                  	call	SDdone
   599                                  
   600 000001D6 B9FF7F                  	mov	cx,7FFFh	; init try counter
   601                                  .1:
   602 000001D9 51                      	pushm	cx
   603 000001DA B98813                  	mov	cx,5000		; about 5 milliseconds
   604 000001DD 90                      .11:	nop
   605 000001DE E2FD                    	loop	.11		; delay loop
   606 000001E0 59                      	popm	cx
   607                                  
   608 000001E1 0E                      	pushm	cs
   609 000001E2 07                      	popm	es
   610 000001E3 BE[8E02]                	mov	si,CMD55
   611 000001E6 E85201                  	call	cmd_R1
   612 000001E9 E800FF                  	call	SDdone
   613 000001EC 7579                    	jnz	.error
   614 000001EE A8FE                    	test	al,~01h		; only 0 and 1 are okay responses
   615                                  ;;	mov	ah,$-Zero
   616 000001F0 7575                    	jnz	.error
   617                                  
   618 000001F2 BE[9402]                	mov	si,ACMD41
   619 000001F5 E84301                  	call	cmd_R1
   620 000001F8 E8F1FE                  	call	SDdone
   621 000001FB 08C0                    	or	al,al		; test for zero
   622 000001FD 7408                    	jz	.2
   623 000001FF FEC8                    	dec	al		; test for 1
   624                                  ;;	mov	ah,$-Zero
   625 00000201 7564                    	jnz	.error
   626 00000203 E2D4                    	loop	.1
   627                                  
   628 00000205 EB5D                    	jmp	.timeout
   629                                  
   630                                  .2:
   631                                  
   632 00000207 BE[9A02]                	mov	si,CMD58
   633 0000020A E82E01                  	call	cmd_R1
   634 0000020D 754B                    	jnz	.err58			; must respond with a 00h
   635 0000020F E8B0FE                  	call	SDgetchar		; get command response
   636 00000212 B402                    	mov	ah,SDtypeSDSC		; assume standard card
   637 00000214 A840                    	test	al,40h			; test bit 30 of response
   638 00000216 7402                    	jz	.21
   639 00000218 B403                    	mov	ah,SDtypeSDHC		; set HC card type
   640 0000021A E885FE                  .21:	call	SDgetunit
   641 0000021D 88A5A700                	mov	[SDcardtype + di],ah	; set card type
   642                                  
   643 00000221 E89EFE                  	call	SDgetchar		; discard rest of the response
   644 00000224 E89BFE                  	call	SDgetchar		; 
   645 00000227 E898FE                  	call	SDgetchar		; 
   646 0000022A E8BFFE                  	call	SDdone
   647                                  
   648                                  %if USE_CRCs
   649 0000022D B80100                  	mov	ax,1			; turn on CRC checking
   650 00000230 31D2                    	xor	dx,dx
   651 00000232 B37B                    	mov	bl, 40h | 59		; CMD59 (CRC on/off)
   652 00000234 E8F3FE                  	call	SDcmdset
   653 00000237 E80101                  	call	cmd_R1
   654 0000023A 89F4                    	mov	sp,si			; clear command from stack
   655 0000023C E8ADFE                  	call	SDdone
   656                                  ;;	mov	ah,$-Zero
   657 0000023F 7526                    	jnz	.error
   658                                  %endif
   659                                  
   660                                  ; set the desired block length -- CMD16(512)
   661 00000241 0E                      	pushm	cs
   662 00000242 07                      	popm	es
   663 00000243 BE[8802]                	mov	si,CMD16
   664 00000246 E8F200                  	call	cmd_R1
   665 00000249 E8A0FE                  	call	SDdone
   666                                  ;;	mov	ah,$-Zero
   667 0000024C 7519                    	jnz	.error
   668                                  
   669 0000024E 31C0                    .okay:	xor	ax,ax			; clear the carry, too
   670                                  
   671                                  .exitstatus:
   672 00000250 8885A500                	mov	[SDstatus + di], al	; save SD card status
   673                                  .exit:
   674 00000254 5E5F07                  	popm	si,di,es
   675 00000257 08C0                    	or	al,al			; set the Z-flag
   676 00000259 C3                      	ret
   677                                  
   678                                  .err58:
   679 0000025A E88FFE                  	call	SDdone
   680                                  ;;	mov	ah,$-Zero
   681 0000025D EB08                    	jmp	.error
   682                                  .rdytimeout:
   683 0000025F B8FEFF                  	mov	ax,-2
   684 00000262 EB03                    	jmp	.error
   685                                  .timeout:
   686 00000264 B8FFFF                  	mov	ax,-1
   687                                  ;;;	jmp	.error
   688                                  .error:	
   689 00000267 F9                      	stc
   690 00000268 EBE6                    	jmp	.exitstatus
   691                                  
   692                                  .error1:			; caution here, DI is not set up
   693 0000026A B8FDFF                  	mov	ax,-3
   694 0000026D F9                      	stc
   695 0000026E EBE4                    	jmp	.exit
   696                                  
   697                                  
   698                                  
   699                                  
   700                                  
   701                                  CRC_unknown	equ	0FFh
   702                                  
   703                                  ;ResetCommand:
   704 00000270 400000000095            CMD0		db	40h | 0, 0, 0, 0, 0, 95h
   705 00000276 48000001AA87            CMD8		db	40h | 8, 0, 0, 01h, 0AAh, 87h
   706 0000027C 4900000000AF            CMD9		db	40h | 9, 0, 0, 0, 0, 0AFh
   707 00000282 4A000000001B            CMD10:		db	40h | 10, 0, 0, 0, 0, 01Bh
   708 00000288 500000020015            CMD16:		db	40h | 16, 0, 0, 512>>8, 512&0xFF, 015h
   709 0000028E 770000000065            CMD55		db	40h | 55, 0, 0, 0, 0, 065h
   710 00000294 694000000077            ACMD41		db	40h | 41, 40h, 0, 0, 0, 077h
   711 0000029A 7A00000000FD            CMD58		db	40h | 58, 0, 0, 0, 0, 0FDh
   712                                  
   713                                  
   714                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   715                                  ;  DSDgetInfo	C-callable routine to get OCR, CSD, & CID
   716                                  ;
   717                                  ;	byte DSDgetInfo(int unit, byte buffer[36]);
   718                                  ;
   719                                  ;  Return:
   720                                  ;	buffer filled with OCR, CSD, CID
   721                                  ;
   722                                  ;  Errors:
   723                                  ;	No Error	0
   724                                  ;	get OCR		1
   725                                  ;	get CSD		2
   726                                  ;	get CID		3
   727                                  ;
   728                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   729                                  	global	_DSDgetInfo
   730                                  _DSDgetInfo:
   731 000002A0 55                              push    bp
   732 000002A1 89E5                            mov     bp,sp
   733 000002A3 065657525153            	pushm	bx,cx,dx,di,si,es
   734                                  
   735 000002A9 8B4604                  	mov	ax,ARG(1)
   736 000002AC BA0804                  	mov	dx,SDoperation
   737 000002AF EE                      	out	dx,al
   738                                  
   739 000002B0 E848FE                  	call	SDwaitrdy	; wait for card to go ready
   740 000002B3 C45E06                  	les	bx,ARG(2)
   741                                  
   742                                  ; get the OCR
   743 000002B6 06                      	push	es
   744 000002B7 0E                      	pushm	cs
   745 000002B8 07                      	pop	es
   746 000002B9 BE[9A02]                	mov	si,CMD58
   747 000002BC E87C00                  	call	cmd_R1
   748 000002BF 07                      	pop	es
   749 000002C0 B80101                  	mov	ax,0101h		; AH=1, AL=1
   750 000002C3 750E                          	jnz	.ocr2			; error if not Zero
   751 000002C5 B90400                  	mov	cx,4
   752 000002C8 E8F7FD                  .ocr	call	SDgetchar		; discard rest of the response
   753 000002CB 268807                    es	mov	[bx],al
   754 000002CE 43                        	inc	bx
   755 000002CF E2F7                    	loop	.ocr
   756 000002D1 31C0                    	xor	ax,ax			; set the Z flag
   757                                  .ocr2:
   758 000002D3 E816FE                  	call	SDdone
   759 000002D6 7532                    	jnz	.error
   760                                  
   761                                  ; get the Card Specific Data (CSD) register contents
   762 000002D8 06                      	push	es
   763 000002D9 0E                      	pushm	cs
   764 000002DA 07                      	pop	es
   765 000002DB BE[7C02]                	mov	si,CMD9
   766 000002DE E85A00                  	call	cmd_R1
   767 000002E1 07                      	pop	es
   768 000002E2 B91000                  	mov	cx,16
   769 000002E5 E8B000                  	call	SDgetdata
   770 000002E8 E801FE                  	call	SDdone
   771 000002EB B80202                  	mov	ax,0202h		; AH=2, AL=2
   772 000002EE 751A                    	jnz	.error
   773                                  
   774                                  
   775                                  ; get the Card Identification Data (CID) register contents
   776 000002F0 06                      	push	es
   777                                  
   778 000002F1 0E                      	pushm	cs
   779 000002F2 07                      	pop	es
   780 000002F3 BE[8202]                	mov	si,CMD10
   781 000002F6 E84200                  	call	cmd_R1
   782 000002F9 07                      	pop	es
   783                                  
   784 000002FA B91000                  	mov	cx,16
   785 000002FD E89800                  	call	SDgetdata
   786 00000300 E8E9FD                  	call	SDdone
   787 00000303 B80303                  	mov	ax,0303h		; AH=3, AL=3
   788 00000306 7502                    	jnz	.error
   789                                  
   790 00000308 31C0                    	xor	ax,ax		; signal No Error
   791                                  .error:
   792                                  
   793 0000030A 5B595A5F5E07            	popm	bx,cx,dx,di,si,es
   794 00000310 89EC                    	mov	sp,bp
   795 00000312 5D                      	pop	bp
   796 00000313 C3                      	ret
   797                                  
   798                                  
   799                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   800                                  ; stepCRC7	include a byte in a CRC7 polynomial
   801                                  ;
   802                                  ;  Enter with:
   803                                  ;	DL = partial CRC calculation
   804                                  ;	AL = character to add into the calculation
   805                                  ;
   806                                  ;  Return with:
   807                                  ;	DL = updated CRC calculation
   808                                  ;	AX is trashed
   809                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   810                                  CRC7poly	equ	00001001b
   811                                  CRC7poly2	equ	CRC7poly*2	; 7 bits only
   812                                  
   813                                  	 global stepCRC7
   814                                  stepCRC7:
   815 00000314 51                      	push	cx
   816                                  
   817 00000315 B90800                  	mov	cx,8 			; 8 bits in AL
   818                                  .1:	
   819 00000318 88D4                    	mov	ah,dl			; copy CRC to AH
   820 0000031A 30C4                    	xor	ah,al			; Sign bit is 0 or 1
   821 0000031C D1E0                    	shl	ax,1
   822 0000031E 18E4                    	sbb	ah,ah			; AH is 0 or -1
   823 00000320 D0E2                    	shl	dl,1			; shift polynomial
   824 00000322 80E412                  	and	ah,CRC7poly2		; get bits to add into the CRC
   825 00000325 30E2                    	xor	dl,ah			; update the polynomial
   826 00000327 E2EF                    	loop	.1
   827                                  
   828 00000329 59                      	pop	cx
   829 0000032A C3                      	ret
   830                                  	
   831                                  
   832                                  
   833                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   834                                  ; calcCRC7	calculate a CRC7 polynomial (for a command)
   835                                  ;
   836                                  ;  Enter with:
   837                                  ;	ES:SI	points at a string of bytes
   838                                  ;	CX	count of bytes in the string
   839                                  ;	direction flag clear
   840                                  ;
   841                                  ;  Return with:
   842                                  ;	ES:SI	point at next byte beyond end of string
   843                                  ;	CX = 0
   844                                  ;	AL = CRC7 polynomial byte
   845                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   846                                  calcCRC7:
   847 0000032B 52                      	push	dx
   848 0000032C 31D2                    	xor	dx,dx		; start CRC7 at zero
   849                                  .1:
   850 0000032E 26AC                      es	lodsb
   851 00000330 E8E1FF                  	call	stepCRC7
   852 00000333 E2F9                    	loop	.1
   853                                  
   854 00000335 88D0                    	mov	al,dl		; final CRC7 to AL
   855 00000337 0C01                    	or	al,01h		; set the low bit
   856 00000339 5A                      	pop	dx
   857 0000033A C3                      	ret
   858                                  
   859                                  
   860                                  
   861                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   862                                  ; cmd_R1	issue command and get R1 response
   863                                  ;
   864                                  ;  Enter with:
   865                                  ;	ES:SI	far pointer to command string
   866                                  ;	DX	device code for Operation register
   867                                  ;
   868                                  ;  Exit with:
   869                                  ;	byte value of response to the command
   870                                  ;	-1 if error (such as no response)
   871                                  ;
   872                                  ;	SI	is incremented by 6, the length of a command
   873                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   874                                  cmd_R1:
   875 0000033B 51                      	pushm	cx
   876 0000033C B90600                  	mov	cx,6		; all commands are 6 bytes
   877                                  .1:
   878 0000033F 26AC                      es	lodsb
   879 00000341 E869FD                  	call	SDputchar
   880 00000344 E2F9                    	loop	.1
   881                                  %if DEBUG>=4
   882                                  	pushm	bx,di,es
   883                                  
   884                                  	mov	bx,-1
   885                                  	mov	cx,lbuf
   886                                  	pushm	cs
   887                                  	popm	es
   888                                  	mov	di,buffer
   889                                  .2:
   890                                  	call	SDgetchar
   891                                  	stosb				; save for debug
   892                                  	test	al,80h
   893                                  	jz	.3
   894                                  	mov	bl,al
   895                                  	loop	.2
   896                                  	mov	ax,bx 
   897                                  .3:
   898                                  	popm	bx,di,es
   899                                  %else
   900 00000346 B90900                  	mov	cx,9			; response must come within 8 chars
   901 00000349 E876FD                  .2:	call	SDgetchar
   902 0000034C A880                    	test	al,80h			; check high bit for zero
   903 0000034E 7405                    	jz	.4			; 0xxx xxxxb is result byte
   904 00000350 E2F7                    	loop	.2
   905                                  %endif
   906 00000352 98                      	cbw				; extend to whole word
   907 00000353 08C0                    	or	al,al			; clear zero flag
   908                                  .4:				; Zero flag set if jumped here
   909 00000355 59                      	popm	cx
   910 00000356 C3                      	ret
   911                                  
   912                                  
   913                                  
   914                                  %if USE_CRCs
   915                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   916                                  ; crc_step	one step in CRC calculation
   917                                  ;
   918                                  ;  Enter with:
   919                                  ;	AL	byte to be added to the CRC computation
   920                                  ;	CX,DX	not to be touched
   921                                  ;	SI	partial CRC computation
   922                                  ;
   923                                  ;  Return with:
   924                                  ;	CX,DX	preserved
   925                                  ;	BX	is destroyed
   926                                  ;	SI	updated CRC computation
   927                                  ;
   928                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   929                                  crc_step:
   930 00000357 87CE                    	xchg	cx,si		; preserve CX in SI
   931                                  .2:
   932 00000359 88EB                    	mov	bl,ch		; form index into table
   933 0000035B 30FF                    	xor	bh,bh		; zap BH
   934 0000035D 30C3                    	xor	bl,al		; use current byte in AL
   935                                  
   936 0000035F 88CD                      	mov	ch,cl		; update CRC16
   937 00000361 30C9                    	xor	cl,cl
   938 00000363 D1E3                    	shl	bx,1
   939 00000365 2E338F[3105]              cs	xor	cx,[crc16tab + bx]
   940                                  
   941 0000036A 87CE                    	xchg	cx,si		; put new crc back in SI
   942 0000036C C3                      	ret
   943                                  %if 0	
   944                                  	mov	bx,si
   945                                  	shr	bx,8
   946                                  	xor	bl,al
   947                                  	shl	si,8
   948                                  	shl	bx,1
   949                                    cs	xor	si,[crc16tab + bx]
   950                                    	ret
   951                                  %endif
   952                                  
   953                                  %endif
   954                                  
   955                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   956                                  ; SDtestdata	test crc on a block of data
   957                                  ;
   958                                  ;  Enter with:
   959                                  ;	CX	count of data bytes to get
   960                                  ;	DX	set to Operation register device code
   961                                  ;
   962                                  ;  Return with:
   963                                  ;    Good return:
   964                                  ;	CX =	CRC16 returned by the call
   965                                  ;	AX =	0
   966                                  ;	Zero flag is set
   967                                  ;
   968                                  ;    Error return:
   969                                  ;	BX	not changed
   970                                  ;	CX	not changed
   971                                  ;	AX =	error code
   972                                  ;	Zero flag is clear
   973                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   974                                  SDtestdata:
   975 0000036D 5653                    	pushm	bx,si			; save BX, SI
   976                                  
   977 0000036F 51                      	pushm	cx			; save byte count
   978                                  
   979 00000370 B9FF7F                  	mov	cx,7FFFh		; timeout count
   980                                  .1:
   981 00000373 E84CFD                  	call	SDgetchar		; get an input byte
   982 00000376 3CFF                    	cmp	al,0FFh			; any return yet?
   983 00000378 7502                    	jne	.2			;
   984 0000037A E2F7                    	loop	.1
   985                                  .2:
   986 0000037C 59                      	popm	cx			; restore data count
   987                                  
   988 0000037D 3CFE                    	cmp	al,0FEh			; timeout or start of data?
   989 0000037F 7511                    	jne	.4			; jump if timeout
   990                                  
   991 00000381 31F6                    	xor	si,si			; start CRC at zero
   992 00000383 83C102                  	add	cx,2			; 
   993 00000386 E839FD                  .3:	call	SDgetchar
   994                                  %if USE_CRCs
   995 00000389 E8CBFF                  	call	crc_step		; update the CRC in SI
   996                                  %endif
   997 0000038C E2F8                    	loop	.3			; get all the bytes
   998                                  
   999                                  .99:
  1000 0000038E 89F1                    	mov	cx,si			; CRC to CX
  1001 00000390 31C0                    	xor	ax,ax			; good return
  1002                                  .4:				; error return
  1003 00000392 98                      	cbw
  1004 00000393 08C0                    	or	al,al
  1005 00000395 5B5E                    	popm	bx,si			; restore regs
  1006 00000397 C3                      	ret
  1007                                  	global	verify_crc
  1008                                  verify_crc	equ	.99
  1009                                  
  1010                                  
  1011                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1012                                  ; SDgetdata	get a block of data
  1013                                  ;
  1014                                  ;  Enter with:
  1015                                  ;	ES:BX	points at buffer to receive data
  1016                                  ;	CX	count of data bytes to get
  1017                                  ;	DX	set to Operation register device code
  1018                                  ;
  1019                                  ;  Return with:
  1020                                  ;    Good return:
  1021                                  ;	CX =	CRC16 returned by the call
  1022                                  ;	AX =	0
  1023                                  ;	Zero flag is set
  1024                                  ;
  1025                                  ;    Error return:
  1026                                  ;	ES:BX	not changed
  1027                                  ;	CX	not changed
  1028                                  ;	AX =	error code
  1029                                  ;	Zero flag is clear
  1030                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1031                                  SDgetdata:
  1032 00000398 51                      	pushm	cx			; save byte count
  1033                                  
  1034 00000399 B9FF7F                  	mov	cx,7FFFh		; timeout count
  1035                                  .1:
  1036 0000039C E823FD                  	call	SDgetchar		; get an input byte
  1037 0000039F 3CFF                    	cmp	al,0FFh			; any return yet?
  1038 000003A1 7502                    	jne	.2			;
  1039 000003A3 E2F7                    	loop	.1
  1040                                  .2:
  1041 000003A5 59                      	popm	cx			; restore data count
  1042 000003A6 3CFE                    	cmp	al,0FEh			; timeout or start of data?
  1043 000003A8 7515                    	jne	.4			; jump if timeout
  1044                                  
  1045 000003AA E815FD                  .3:	call	SDgetchar
  1046 000003AD 268807                    es	mov	[bx],al			; store data read
  1047 000003B0 43                        	inc	bx
  1048 000003B1 E2F7                    	loop	.3			; get all the bytes
  1049                                  
  1050 000003B3 E80CFD                  	call	SDgetchar		; get first CRC16 byte
  1051 000003B6 88C5                    	mov	ch,al
  1052 000003B8 E807FD                  	call	SDgetchar
  1053 000003BB 88C1                    	mov	cl,al			; low order CRC16 byte
  1054                                  
  1055 000003BD 31C0                    	xor	ax,ax
  1056                                  .4:				; error return
  1057 000003BF 98                      	cbw
  1058 000003C0 08C0                    	or	al,al
  1059 000003C2 C3                      	ret
  1060                                  
  1061                                  
  1062                                  
  1063                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1064                                  ; SDputdata	put out the data block
  1065                                  ;
  1066                                  ;  Enter with:
  1067                                  ;	AX	CRC16 bytes to send
  1068                                  ;	ES:BX	pointer to the data block to put out
  1069                                  ;	CX	count of data bytes to send
  1070                                  ;	DX	device code of Operation register
  1071                                  ;
  1072                                  ;  Return with:
  1073                                  ;	ES:BX	points beyond end of data
  1074                                  ;	CX	is trash
  1075                                  ;
  1076                                  ;	AX = 0, Z=1  means a good return
  1077                                  ;   or	Z=0, AX = error return byte
  1078                                  ;
  1079                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1080                                  SDputdata:
  1081 000003C3 50                      	pushm	ax			; save CRC16 bytes
  1082                                  
  1083 000003C4 B0FE                    	mov	al,0FEh			; start of data packet
  1084 000003C6 E8E4FC                  	call	SDputchar
  1085                                  .1:
  1086 000003C9 268A07                    es	mov	al,[bx]			; get data byte
  1087 000003CC 43                        	inc	bx
  1088 000003CD E8DDFC                  	call	SDputchar
  1089 000003D0 E2F7                    	loop	.1
  1090                                  
  1091 000003D2 59                      	popm	cx			; get CRC bytes
  1092 000003D3 88E8                    	mov	al,ch			; put out hi-CRC16
  1093 000003D5 E8D5FC                  	call	SDputchar
  1094 000003D8 88C8                    	mov	al,cl			; put out lo-CRC16
  1095 000003DA E8D0FC                  	call	SDputchar
  1096                                  
  1097 000003DD B9FF7F                  	mov	cx,7FFFh		; timeout count
  1098                                  .2:
  1099 000003E0 E8DFFC                  	call	SDgetchar		; get byte != FF
  1100 000003E3 3CFF                    	cmp	al,0FFh
  1101 000003E5 7502                    	jne	.3
  1102 000003E7 E2F7                    	loop	.2
  1103                                  .3:
  1104 000003E9 241F                    	and	al,1Fh			; mask return acknowledge
  1105 000003EB 98                      	cbw
  1106 000003EC 3C05                    	cmp	al,05h
  1107 000003EE 7502                           	jne	.error			; Z=0
  1108 000003F0 31C0                    	xor	ax,ax			; Z=1, AX=0
  1109                                  .error:
  1110 000003F2 C3                      	ret
  1111                                  
  1112                                  
  1113                                  %if SOFT_DEBUG
  1114                                  	global	SD_put_return
  1115                                  SD_put_return equ  .3
  1116                                  %endif
  1117                                  
  1118                                  
  1119                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1120                                  ; SDcheck	check for drive readable/writeable
  1121                                  ;
  1122                                  ;  Enter with:
  1123                                  ;	AH = 2	check for card readable
  1124                                  ;	AH = 3	check for card writeable
  1125                                  ;
  1126                                  ;  Return with:
  1127                                  ;	AX =	error code (0 means okay)
  1128                                  ;	Zero flag is set/reset per AX
  1129                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1130                                  SDcheck:
  1131 000003F3 E8ACFC                  	call	SDgetunit		; set up DX, DI
  1132                                  
  1133 000003F6 EC                      	in	al,dx			; check HW status
  1134 000003F7 A820                    	test	al,CardDetect		; card inserted?
  1135 000003F9 741B                    	jz	.nocard
  1136 000003FB F6C401                  	test	ah,1			; test LSB of AH
  1137 000003FE 7404                    	jz	.0			; read test
  1138 00000400 A810                    	test	al,WrProt		; writeable?
  1139 00000402 7517                    	jnz	.wrprot			; not writeable
  1140                                  .0:
  1141 00000404 80BDA50000              	cmp	byte [SDstatus + di], 0	; check for unit initialized
  1142 00000409 7407                    	je	.1
  1143 0000040B 89F8                    	mov	ax,di
  1144 0000040D E86FFD                  	call	SDinitcard
  1145 00000410 750E                    	jne	.ret			; return if error on init
  1146                                  .1:
  1147 00000412 31C0                    	xor	ax,ax			; good return
  1148 00000414 EB0A                    	jmp	.ret
  1149                                  
  1150                                  .nocard:
  1151 00000416 B8FAFF                  	mov	ax,-6			; no card inserted
  1152 00000419 EB03                    	jmp	.exit
  1153                                  .wrprot:
  1154 0000041B B8F9FF                  	mov	ax,-7			; card is write protected
  1155                                  
  1156 0000041E 09C0                    .exit:	or	ax,ax
  1157 00000420 C3                      .ret:	ret
  1158                                  
  1159                                  
  1160                                  
  1161                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1162                                  ; SDsetaddr	set up card sector address
  1163                                  ;
  1164                                  ;  Enter with:
  1165                                  ;	DX:AX	sector address (512 byte sectors)
  1166                                  ;	DI	unit number
  1167                                  ;
  1168                                  ;  Return with:
  1169                                  ;	DX:AX	byte address for SDSC cards
  1170                                  ;		unchanged for SDHC cards
  1171                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1172                                  SDsetaddr:
  1173 00000421 80BDA70003              	cmp	byte [SDcardtype + di], SDtypeSDHC
  1174 00000426 730C                    	jae	.6
  1175                                  ; SDSC cards and below use byte addressing
  1176                                  ; multiply DX:AX by 512
  1177 00000428 88D6                    	mov	dh,dl		; shift by 8
  1178 0000042A 88E2                    	mov	dl,ah
  1179 0000042C 88C4                    	mov	ah,al
  1180 0000042E 30C0                    	xor	al,al		; **
  1181 00000430 D1E0                    	shl	ax,1		; double shift by one more
  1182 00000432 D1D2                    	rcl	dx,1
  1183                                  				; all shifted by 9 (2**9 == 512)
  1184                                  .6:
  1185 00000434 C3                      	ret
  1186                                  
  1187                                  
  1188                                  
  1189                                  
  1190                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1191                                  ; SDread1sec	Read a single sector (of 512 bytes)
  1192                                  ;
  1193                                  ;  Enter with:
  1194                                  ;	DX:AX	sector number to read
  1195                                  ;	ES:BX	buffer to receive data
  1196                                  ;
  1197                                  ;  Return with:
  1198                                  ;	CL	error code (0 means success)
  1199                                  ;	DX:AX	preserved
  1200                                  ;	ES:BX	preserved
  1201                                  ;	SI, DI, CH are preserved
  1202                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1203                                  SDread1sec:
  1204 00000435 5756525350              	pushm	ax,bx,dx,si,di
  1205 0000043A 51                      	pushm	cx
  1206                                  
  1207 0000043B 0653                    	pushm	bx,es		; save buffer address
  1208 0000043D 5250                    	pushm	ax,dx		; save sector number
  1209                                  
  1210 0000043F B402                    	mov	ah,2		; show it is a read check
  1211 00000441 E8AFFF                  	call	SDcheck
  1212 00000444 753C                    	jnz	.err2
  1213                                  
  1214 00000446 E8B2FC                  	call	SDwaitrdy	; wait for card to go ready
  1215 00000449 7237                    	jc	.err2
  1216                                  
  1217 0000044B 585A                    	popm	ax,dx		; get sector address
  1218 0000044D E8D1FF                  	call	SDsetaddr	; set up card address in DX:AX
  1219                                  ; DX:AX is byte address (SDSC) or sector address (SDHC)
  1220 00000450 B351                    	mov	bl, 40h | 17	; CMD17 = read one sector
  1221 00000452 E8D5FC                  	call	SDcmdset	; CMD17 (DX:AX) crc
  1222 00000455 E8E3FE                  	call	cmd_R1		; execute the command
  1223 00000458 89F4                    	mov	sp,si		; purge command from the stack
  1224 0000045A 7405                    	jz	.3
  1225 0000045C E88DFC                  	call	SDdone		; done if error
  1226 0000045F EB23                          	jmp	.err1		; exit on error
  1227                                  .3:
  1228 00000461 5B07                    	popm	bx,es		; restore data pointer
  1229 00000463 B90002                  	mov	cx,512		; read 512 bytes
  1230 00000466 E82FFF                  	call	SDgetdata	; **
  1231 00000469 E880FC                  	call	SDdone		; end of command
  1232                                  %if USE_CRCs
  1233 0000046C 7518                    	jnz	.exit
  1234 0000046E 51                      	pushm	cx		; save CRC16 read in
  1235 0000046F B90002                  	mov	cx,512		; check 512 bytes
  1236 00000472 29CB                    	sub	bx,cx		; set ES:BX
  1237 00000474 31C0                    	xor	ax,ax		; start CRC16 at zero
  1238 00000476 E89C00                  	call	crc16
  1239 00000479 59                      	popm	cx
  1240 0000047A 29C1                    	sub	cx,ax		; compare the two CRC16's
  1241 0000047C 7408                    	jz	.exit
  1242 0000047E B1F8                    	mov	cl,-8		; CRC error on read
  1243                                  %endif
  1244 00000480 EB04                    	jmp	.exit		; exit with error code
  1245                                  
  1246                                  .err2:
  1247 00000482 5E5F                    	popm	si,di		; clear sector number
  1248                                  .err1:
  1249 00000484 5E5F                    	popm	si,di		; clear buffer address
  1250                                  .exit:
  1251 00000486 58                      	popm	ax		; get CX saved
  1252 00000487 88E5                    	mov	ch,ah		; restore CH, CL is error code
  1253 00000489 585B5A5E5F              	popm	ax,bx,dx,si,di
  1254 0000048E 08C9                    	or	cl,cl		; set the Z flag
  1255 00000490 C3                      	ret
  1256                                  
  1257                                  
  1258                                  	
  1259                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1260                                  ; SDwrite1sec	write a sector
  1261                                  ;
  1262                                  ;  Enter with:
  1263                                  ;	DX:AX	sector number to write
  1264                                  ;	ES:BX	data buffer from which to write
  1265                                  ;
  1266                                  ;  Return with:
  1267                                  ;	CL	error code (0 means success)
  1268                                  ;	DX:AX	preserved
  1269                                  ;	ES:BX	preserved
  1270                                  ;	SI, DI, CH are preserved
  1271                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1272                                  SDwrite1sec:
  1273 00000491 5756525350              	pushm	ax,bx,dx,si,di
  1274 00000496 51                      	pushm	cx
  1275                                  
  1276 00000497 0653                    	pushm	bx,es		; save buffer address
  1277 00000499 5250                    	pushm	ax,dx		; save sector number
  1278                                  
  1279 0000049B B403                    	mov	ah,3		; show it is a write check
  1280 0000049D E853FF                  	call	SDcheck
  1281 000004A0 7532                    	jnz	.err2
  1282                                  
  1283 000004A2 E856FC                  	call	SDwaitrdy	; wait for card to go ready
  1284 000004A5 722D                    	jc	.err2
  1285                                  
  1286 000004A7 585A                    	popm	ax,dx		; get sector address
  1287 000004A9 E875FF                  	call	SDsetaddr	; set up card address in DX:AX
  1288                                  ; DX:AX is byte address (SDSC) or sector address (SDHC)
  1289 000004AC B358                    	mov	bl, 40h | 24	; CMD24 = write one sector
  1290 000004AE E879FC                  	call	SDcmdset	; CMD24 (DX:AX) crc
  1291 000004B1 E887FE                  	call	cmd_R1		; execute the command
  1292 000004B4 89F4                    	mov	sp,si		; purge command from the stack
  1293 000004B6 7405                    	jz	.3
  1294 000004B8 E831FC                  	call	SDdone		; done if error
  1295 000004BB EB19                          	jmp	.err1		; exit on error
  1296                                  .3:
  1297 000004BD 5B07                    	popm	bx,es		; restore data pointer
  1298                                  %if USE_CRCs
  1299 000004BF 31C0                    	xor	ax,ax		; start CRC16 at zero
  1300 000004C1 B90002                  	mov	cx,512		; write 512 bytes
  1301 000004C4 E84E00                  	call	crc16
  1302 000004C7 B90002                  	mov	cx,512		; write 512 bytes
  1303 000004CA 29CB                    	sub	bx,cx		; restore data pointer
  1304                                  %else
  1305                                  	mov	ax,0FFFFh	; dummy CRC16 
  1306                                  	mov	cx,512		; write 512 bytes
  1307                                  %endif
  1308 000004CC E8F4FE                  	call	SDputdata	; **
  1309 000004CF E81AFC                  	call	SDdone		; end of command
  1310 000004D2 EB04                    	jmp	.exit
  1311                                  
  1312                                  .err2:
  1313 000004D4 5E5F                    	popm	si,di		; clear sector number
  1314                                  .err1:
  1315 000004D6 5E5F                    	popm	si,di		; clear buffer address
  1316                                  .exit:
  1317 000004D8 88C1                    	mov	cl,al		; move error code to CL
  1318 000004DA 58                      	popm	ax		; get CX saved
  1319 000004DB 88E5                    	mov	ch,ah		; restore CH, CL is error code
  1320 000004DD 585B5A5E5F              	popm	ax,bx,dx,si,di
  1321 000004E2 08C9                    	or	cl,cl		; set the Z flag
  1322 000004E4 C3                      	ret
  1323                                  
  1324                                  
  1325                                  
  1326                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1327                                  ; SDverify1sec	Verify a single sector (of 512 bytes)
  1328                                  ;
  1329                                  ;  Enter with:
  1330                                  ;	DX:AX	sector number to read
  1331                                  ;
  1332                                  ;  Return with:
  1333                                  ;	CL	error code (0 means success)
  1334                                  ;	DX:AX	preserved
  1335                                  ;	ES:BX	preserved
  1336                                  ;	SI, DI, CH are preserved
  1337                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1338                                  SDverify1sec:
  1339 000004E5 5756525350              	pushm	ax,bx,dx,si,di
  1340 000004EA 51                      	pushm	cx
  1341                                  
  1342 000004EB 5250                    	pushm	ax,dx		; save sector number
  1343                                  
  1344 000004ED B402                    	mov	ah,2		; show it is a read check
  1345 000004EF E801FF                  	call	SDcheck
  1346 000004F2 7512                    	jnz	.err2
  1347                                  
  1348 000004F4 E804FC                  	call	SDwaitrdy	; wait for card to go ready
  1349 000004F7 720D                    	jc	.err2
  1350 000004F9 585A                    	popm	ax,dx		; get sector address
  1351                                  
  1352                                  %if QUICK_VERIFY
  1353 000004FB 31C9                    	xor	cx,cx
  1354                                  %else
  1355                                  	call	SDsetaddr	; set up card address in DX:AX
  1356                                  ; DX:AX is byte address (SDSC) or sector address (SDHC)
  1357                                  	mov	bl, 40h | 17	; CMD17 = read one sector
  1358                                  	call	SDcmdset	; CMD17 (DX:AX) crc
  1359                                  	call	cmd_R1		; execute the command
  1360                                  	mov	sp,si		; purge command from the stack
  1361                                  	jz	.3
  1362                                  	call	SDdone		; done if error
  1363                                        	jmp	.err1		; exit on error
  1364                                  .3:
  1365                                  	mov	cx,512		; read 512 bytes
  1366                                  	call	SDtestdata	; **
  1367                                  %endif
  1368 000004FD E8ECFB                  	call	SDdone		; end of command
  1369                                  
  1370 00000500 08E9                    	or	cl,ch		; is CRC zero, create error code
  1371 00000502 7406                    	jz	.exit
  1372                                  
  1373 00000504 B110                    	mov	cl, ERR_uncorrectable_CRC_error
  1374                                  .err2:
  1375 00000506 5E5F                    	popm	si,di		; clear sector number
  1376                                  .err1:
  1377                                  ;;;	popm	si,di		; clear buffer address
  1378 00000508 88E1                    	mov	cl,ah		; error code to CL
  1379                                  .exit:
  1380 0000050A 58                      	popm	ax		; get CX saved
  1381 0000050B 88E5                    	mov	ch,ah		; restore CH, CL is error code
  1382 0000050D 585B5A5E5F              	popm	ax,bx,dx,si,di
  1383 00000512 08C9                    	or	cl,cl		; set the Z flag
  1384 00000514 C3                      	ret
  1385                                  
  1386                                  
  1387                                  	
  1388                                  
  1389                                  %if USE_CRCs
  1390                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1391                                  ; crc16		add data to the input CRC16 calculation
  1392                                  ;
  1393                                  ;  Enter with:
  1394                                  ;	ES:BX	data pointer
  1395                                  ;	CX	count of bytes
  1396                                  ;	AX	partial CRC16 sum
  1397                                  ;
  1398                                  ;  Return with:
  1399                                  ;	ES:BX	updated data pointer
  1400                                  ;	CX = 0
  1401                                  ;	AX	updated CRC16 sum
  1402                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1403                                  	global	crc16
  1404                                  crc16:
  1405 00000515 56                      	pushm	si		; save SI
  1406                                  
  1407 00000516 89DE                    	mov	si,bx		; use ES:SI to address data
  1408                                  .2:
  1409 00000518 88E3                    	mov	bl,ah		; form index into table
  1410 0000051A 30FF                    	xor	bh,bh		; zap BH
  1411 0000051C 26321C                    es	xor	bl,[si]		; form table index
  1412 0000051F 46                        	inc	si
  1413 00000520 88C4                      	mov	ah,al		; update CRC16
  1414 00000522 30C0                    	xor	al,al
  1415 00000524 D1E3                    	shl	bx,1
  1416 00000526 2E3387[3105]              cs	xor	ax,[crc16tab + bx]
  1417 0000052B E2EB                      	loop	.2
  1418                                  
  1419 0000052D 89F3                    	mov	bx,si		; updated BX value
  1420 0000052F 5E                      	popm	si
  1421 00000530 C3                      	ret
  1422                                  
  1423                                  
  1424                                  %include "crc16tab.inc"
     1                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     2                              <1> ; crc16tab.inc
     3                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     4                              <1> ;
     5                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
     6                              <1> ;
     7                              <1> ; Copyright (c) 2013 John R. Coffman.  All rights reserved.
     8                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
     9                              <1> ;
    10                              <1> ; This program is free software: you can redistribute it and/or modify
    11                              <1> ; it under the terms of the GNU General Public License as published by
    12                              <1> ; the Free Software Foundation, either version 3 of the License, or
    13                              <1> ; (at your option) any later version.
    14                              <1> ;
    15                              <1> ; This program is distributed in the hope that it will be useful,
    16                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    17                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    18                              <1> ; GNU General Public License for more details.
    19                              <1> ;
    20                              <1> ; You should have received a copy of the GNU General Public License
    21                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    22                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    23                              <1> 
    24                              <1> crc16tab:
    25 00000531 000021104220633084- <1>   dw	0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50A5, 0x60C6, 0x70E7
    25 0000053A 40A550C660E770      <1>
    26 00000541 088129914AA16BB18C- <1>   dw	0x8108, 0x9129, 0xA14A, 0xB16B, 0xC18C, 0xD1AD, 0xE1CE, 0xF1EF
    26 0000054A C1ADD1CEE1EFF1      <1>
    27 00000551 3112100273325222B5- <1>   dw	0x1231, 0x0210, 0x3273, 0x2252, 0x52B5, 0x4294, 0x72F7, 0x62D6
    27 0000055A 529442F772D662      <1>
    28 00000561 399318837BB35AA3BD- <1>   dw	0x9339, 0x8318, 0xB37B, 0xA35A, 0xD3BD, 0xC39C, 0xF3FF, 0xE3DE
    28 0000056A D39CC3FFF3DEE3      <1>
    29 00000571 6224433420040114E6- <1>   dw	0x2462, 0x3443, 0x0420, 0x1401, 0x64E6, 0x74C7, 0x44A4, 0x5485
    29 0000057A 64C774A4448554      <1>
    30 00000581 6AA54BB528850995EE- <1>   dw	0xA56A, 0xB54B, 0x8528, 0x9509, 0xE5EE, 0xF5CF, 0xC5AC, 0xD58D
    30 0000058A E5CFF5ACC58DD5      <1>
    31 00000591 5336722611163006D7- <1>   dw	0x3653, 0x2672, 0x1611, 0x0630, 0x76D7, 0x66F6, 0x5695, 0x46B4
    31 0000059A 76F6669556B446      <1>
    32 000005A1 5BB77AA719973887DF- <1>   dw	0xB75B, 0xA77A, 0x9719, 0x8738, 0xF7DF, 0xE7FE, 0xD79D, 0xC7BC
    32 000005AA F7FEE79DD7BCC7      <1>
    33 000005B1 C448E5588668A77840- <1>   dw	0x48C4, 0x58E5, 0x6886, 0x78A7, 0x0840, 0x1861, 0x2802, 0x3823
    33 000005BA 08611802282338      <1>
    34 000005C1 CCC9EDD98EE9AFF948- <1>   dw	0xC9CC, 0xD9ED, 0xE98E, 0xF9AF, 0x8948, 0x9969, 0xA90A, 0xB92B
    34 000005CA 8969990AA92BB9      <1>
    35 000005D1 F55AD44AB77A966A71- <1>   dw	0x5AF5, 0x4AD4, 0x7AB7, 0x6A96, 0x1A71, 0x0A50, 0x3A33, 0x2A12
    35 000005DA 1A500A333A122A      <1>
    36 000005E1 FDDBDCCBBFFB9EEB79- <1>   dw	0xDBFD, 0xCBDC, 0xFBBF, 0xEB9E, 0x9B79, 0x8B58, 0xBB3B, 0xAB1A
    36 000005EA 9B588B3BBB1AAB      <1>
    37 000005F1 A66C877CE44CC55C22- <1>   dw	0x6CA6, 0x7C87, 0x4CE4, 0x5CC5, 0x2C22, 0x3C03, 0x0C60, 0x1C41
    37 000005FA 2C033C600C411C      <1>
    38 00000601 AEED8FFDECCDCDDD2A- <1>   dw	0xEDAE, 0xFD8F, 0xCDEC, 0xDDCD, 0xAD2A, 0xBD0B, 0x8D68, 0x9D49
    38 0000060A AD0BBD688D499D      <1>
    39 00000611 977EB66ED55EF44E13- <1>   dw	0x7E97, 0x6EB6, 0x5ED5, 0x4EF4, 0x3E13, 0x2E32, 0x1E51, 0x0E70
    39 0000061A 3E322E511E700E      <1>
    40 00000621 9FFFBEEFDDDFFCCF1B- <1>   dw	0xFF9F, 0xEFBE, 0xDFDD, 0xCFFC, 0xBF1B, 0xAF3A, 0x9F59, 0x8F78
    40 0000062A BF3AAF599F788F      <1>
    41 00000631 8891A981CAB1EBA10C- <1>   dw	0x9188, 0x81A9, 0xB1CA, 0xA1EB, 0xD10C, 0xC12D, 0xF14E, 0xE16F
    41 0000063A D12DC14EF16FE1      <1>
    42 00000641 8010A100C230E32004- <1>   dw	0x1080, 0x00A1, 0x30C2, 0x20E3, 0x5004, 0x4025, 0x7046, 0x6067
    42 0000064A 50254046706760      <1>
    43 00000651 B9839893FBA3DAB33D- <1>   dw	0x83B9, 0x9398, 0xA3FB, 0xB3DA, 0xC33D, 0xD31C, 0xE37F, 0xF35E
    43 0000065A C31CD37FE35EF3      <1>
    44 00000661 B1029012F322D23235- <1>   dw	0x02B1, 0x1290, 0x22F3, 0x32D2, 0x4235, 0x5214, 0x6277, 0x7256
    44 0000066A 42145277625672      <1>
    45 00000671 EAB5CBA5A89589856E- <1>   dw	0xB5EA, 0xA5CB, 0x95A8, 0x8589, 0xF56E, 0xE54F, 0xD52C, 0xC50D
    45 0000067A F54FE52CD50DC5      <1>
    46 00000681 E234C324A014810466- <1>   dw	0x34E2, 0x24C3, 0x14A0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405
    46 0000068A 74476424540544      <1>
    47 00000691 DBA7FAB79987B8975F- <1>   dw	0xA7DB, 0xB7FA, 0x8799, 0x97B8, 0xE75F, 0xF77E, 0xC71D, 0xD73C
    47 0000069A E77EF71DC73CD7      <1>
    48 000006A1 D326F2369106B01657- <1>   dw	0x26D3, 0x36F2, 0x0691, 0x16B0, 0x6657, 0x7676, 0x4615, 0x5634
    48 000006AA 66767615463456      <1>
    49 000006B1 4CD96DC90EF92FE9C8- <1>   dw	0xD94C, 0xC96D, 0xF90E, 0xE92F, 0x99C8, 0x89E9, 0xB98A, 0xA9AB
    49 000006BA 99E9898AB9ABA9      <1>
    50 000006C1 4458654806782768C0- <1>   dw	0x5844, 0x4865, 0x7806, 0x6827, 0x18C0, 0x08E1, 0x3882, 0x28A3
    50 000006CA 18E1088238A328      <1>
    51 000006D1 7DCB5CDB3FEB1EFBF9- <1>   dw	0xCB7D, 0xDB5C, 0xEB3F, 0xFB1E, 0x8BF9, 0x9BD8, 0xABBB, 0xBB9A
    51 000006DA 8BD89BBBAB9ABB      <1>
    52 000006E1 754A545A376A167AF1- <1>   dw	0x4A75, 0x5A54, 0x6A37, 0x7A16, 0x0AF1, 0x1AD0, 0x2AB3, 0x3A92
    52 000006EA 0AD01AB32A923A      <1>
    53 000006F1 2EFD0FED6CDD4DCDAA- <1>   dw	0xFD2E, 0xED0F, 0xDD6C, 0xCD4D, 0xBDAA, 0xAD8B, 0x9DE8, 0x8DC9
    53 000006FA BD8BADE89DC98D      <1>
    54 00000701 267C076C645C454CA2- <1>   dw	0x7C26, 0x6C07, 0x5C64, 0x4C45, 0x3CA2, 0x2C83, 0x1CE0, 0x0CC1
    54 0000070A 3C832CE01CC10C      <1>
    55 00000711 1FEF3EFF5DCF7CDF9B- <1>   dw	0xEF1F, 0xFF3E, 0xCF5D, 0xDF7C, 0xAF9B, 0xBFBA, 0x8FD9, 0x9FF8
    55 0000071A AFBABFD98FF89F      <1>
    56 00000721 176E367E554E745E93- <1>   dw	0x6E17, 0x7E36, 0x4E55, 0x5E74, 0x2E93, 0x3EB2, 0x0ED1, 0x1EF0
    56 0000072A 2EB23ED10EF01E      <1>
    57                              <1> 
    58                              <1> ; end crc16tab.inc
  1425                                  %endif
  1426                                  
  1427                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1428                                  ; xbits		extract BigEndian bits
  1429                                  ;
  1430                                  ;  Enter with:
  1431                                  ;	ES:SI	points at byte containing bit 0
  1432                                  ;	CH:CL	hi-bit : lo-bit	 to be extracted
  1433                                  ;
  1434                                  ;  Exit with:
  1435                                  ;	AX	extracted value
  1436                                  ;	no other registers altered
  1437                                  ;
  1438                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1439                                  xbits:
  1440 00000731 565153                  	pushm	bx,cx,si
  1441 00000734 88C8                    	mov	al,cl
  1442 00000736 30E4                    	xor	ah,ah
  1443 00000738 C1E803                  	shr	ax,3			; AX is byte offset
  1444 0000073B 29C6                    	sub	si,ax			; SI points at first byte
  1445 0000073D 28CD                    	sub	ch,cl			; CH is bit count - 1
  1446 0000073F 268A04                    es	mov	al,[si]
  1447 00000742 268A64FF                  es	mov	ah,[si-1]
  1448 00000746 268A5CFE                  es	mov	bl,[si-2]		; allow for max. of 12 bit field
  1449 0000074A 80E107                  	and	cl,7			; CL is bit offset
  1450 0000074D 7408                    	jz	.3
  1451 0000074F D0EB                    .1:	shr	bl,1
  1452 00000751 D1D8                    	rcr	ax,1
  1453 00000753 FEC9                    	dec	cl
  1454 00000755 75F8                    	jnz	.1
  1455 00000757 BBFEFF                  .3:	mov	bx,0FFFEh		; mask 1 bit
  1456 0000075A C1E908                  	shr	cx,8			; mov CH to CL, zero extended
  1457 0000075D D3E3                    	shl	bx,cl			; make BX into a mask
  1458 0000075F F7D3                    	not	bx
  1459 00000761 21D8                    	and	ax,bx			; mask bits in AX
  1460 00000763 5B595E                  	popm	bx,cx,si
  1461 00000766 C3                      	ret
  1462                                  
  1463                                  
  1464                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1465                                  ; _SDcsd	extract information from the CSD register
  1466                                  ;
  1467                                  ;  word __cdecl SDcsd(word what, byte *csd)
  1468                                  ;
  1469                                  ;  Enter with:
  1470                                  ;	arg1  = what: AH=hi-bit number, AL=lo-bit number
  1471                                  ;	arg2  = far pointer to CSD array
  1472                                  ;
  1473                                  ;  Exit with:
  1474                                  ;	AX = extracted value
  1475                                  ;
  1476                                  ;  Uses:
  1477                                  ;	xbits
  1478                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1479                                  	global	_SDcsd
  1480                                  _SDcsd:
  1481 00000767 55                      	push	bp
  1482 00000768 89E5                    	mov	bp,sp
  1483 0000076A 065651                  	pushm	cx,si,es
  1484                                  
  1485 0000076D 8B4E04                  	mov	cx,ARG(1)
  1486 00000770 C47606                  	les	si,ARG(2)
  1487 00000773 83C60F                  	add	si,15		; point at end of array
  1488 00000776 E8B8FF                  	call	xbits
  1489                                  
  1490 00000779 595E07                  	popm	cx,si,es
  1491 0000077C C9                      	leave
  1492 0000077D C3                      	ret
  1493                                  
  1494                                  
  1495                                  %if DEBUG>0
  1496                                  writeCSD:
  1497                                  	mov	si,SDcsd
  1498                                  	mov	cx,16
  1499                                  .1:	lodsb
  1500                                  	call	boutsp
  1501                                  	loop	.1
  1502                                  ; NewLine
  1503                                  crlf:
  1504                                  	mov	al,0Dh
  1505                                  	call	cout
  1506                                  	mov	al,0Ah
  1507                                  	call	cout
  1508                                  	ret
  1509                                  
  1510                                  
  1511                                  ; output byte from AL, then a space
  1512                                  boutsp:
  1513                                  	call	bout
  1514                                  	mov	al,20h
  1515                                  	call	cout
  1516                                  	ret
  1517                                  ; word output from AX
  1518                                  wout:
  1519                                  	xchg	al,ah
  1520                                  	call	bout
  1521                                  	xchg	al,ah
  1522                                  ; byte output from AL
  1523                                  bout:
  1524                                  	rol	al,4
  1525                                  	call	nout
  1526                                  	rol	al,4
  1527                                  ; nibble output from low nibble in AL
  1528                                  nout:
  1529                                  	push	ax
  1530                                  	and	al,0Fh		; mask nibble
  1531                                  	daa			; convert to decimal
  1532                                  	add	al,0F0h		; overflow to Carry
  1533                                  	adc	al,040h		; convert to ASCII decimal or hex digit
  1534                                  	call	cout
  1535                                  	pop	ax
  1536                                  	ret
  1537                                  	
  1538                                  ; character output from AL
  1539                                  cout:
  1540                                  	pushm	ax,bx
  1541                                  	mov	ah,0Eh		; write character in AL
  1542                                  	mov	bx,0007h
  1543                                  	int	10h
  1544                                  	popm	ax,bx
  1545                                  	ret
  1546                                  %endif
  1547                                  
  1548                                  	SEGMENT	_DATA
  1549                                  ;;;SDcardtype	db	0, 0		; SD card type SDtypeSDSC=2, HC=3, ...
  1550                                  ;;;SDstatus	db	0, 0		; status byte from command
  1551                                  
  1552                                  ;;;SDcsd		times 16 db 0		; SD card CSD
  1553                                  
  1554                                  %if DEBUG>=1
  1555                                  buffer:	
  1556                                  	times	512 db 0E7h
  1557                                  lbuf	equ	$-buffer
  1558                                  %endif
  1559                                  
  1560                                  
  1561                                  ;-------------------------------------------------------------------------------
  1562                                  
  1563                                  ;-----------------------------------------------------------------------------
  1564                                  ; End of SDcard disk driver
  1565                                  ;
  1566                                  ; Begin SBC-188 BIOS code
  1567                                  ;------------------------------------------------------------------------------------	
  1568                                  %ifndef STANDALONE
  1569                                  	
  1570                                  	SEGMENT	_TEXT
  1571                                  
  1572                                  
  1573                                  ; Standard int 13h stack frame layout is 
  1574                                  ; created by:   PUSHM  ALL,DS,ES
  1575                                  ;               MOV    BP,SP
  1576                                  ;
  1577                                  offset_DI       equ     0
  1578                                  offset_SI       equ     offset_DI+2
  1579                                  offset_BP       equ     offset_SI+2
  1580                                  offset_SP       equ     offset_BP+2
  1581                                  offset_BX       equ     offset_SP+2
  1582                                  offset_DX       equ     offset_BX+2
  1583                                  offset_CX       equ     offset_DX+2
  1584                                  offset_AX       equ     offset_CX+2
  1585                                  offset_DS       equ     offset_AX+2
  1586                                  offset_ES       equ     offset_DS+2
  1587                                  offset_IP       equ     offset_ES+2
  1588                                  offset_CS       equ     offset_IP+2
  1589                                  offset_FLAGS    equ     offset_CS+2
  1590                                  
  1591                                  ; The byte registers in the stack
  1592                                  offset_AL       equ     offset_AX
  1593                                  offset_AH       equ     offset_AX+1
  1594                                  offset_BL       equ     offset_BX
  1595                                  offset_BH       equ     offset_BX+1
  1596                                  offset_CL       equ     offset_CX
  1597                                  offset_CH       equ     offset_CX+1
  1598                                  offset_DL       equ     offset_DX
  1599                                  offset_DH       equ     offset_DX+1
  1600                                  
  1601                                  ; FDC error codes (returned in AH)
  1602                                  ;
  1603                                  ERR_no_error            equ     0       ; no error (return Carry clear)
  1604                                  ;   everything below returns with the Carry set to indicate an error
  1605                                  ERR_invalid_command     equ     1
  1606                                  ERR_address_mark_not_found      equ     2
  1607                                  ERR_write_protect       equ     3
  1608                                  ERR_sector_not_found    equ     4
  1609                                  ERR_disk_removed        equ     6
  1610                                  ERR_dma_overrun         equ     8
  1611                                  ERR_dma_crossed_64k     equ     9
  1612                                  ERR_media_type_not_found        equ     12
  1613                                  ERR_uncorrectable_CRC_error     equ     10h
  1614                                  ERR_controller_failure  equ     20h
  1615                                  ERR_seek_failed         equ     40h
  1616                                  ERR_disk_timeout        equ     80h
  1617                                  
  1618                                  
  1619                                  ; Packet call offsets
  1620                                  ;
  1621                                  pkt_size        equ     0       ; byte, size of packet (==16)
  1622                                  pkt_reserved1   equ     1       ; byte, reserved, must be zero
  1623                                  pkt_blocks      equ     2       ; byte, number of blocks to transfer
  1624                                                                  ; max is 127 (7Fh); 0 means no transfer
  1625                                  pkt_reserved3   equ     3       ; byte; reserved, must be zero
  1626                                  pkt_address     equ     4       ; dword; segment:offset of transfer
  1627                                  pkt_LBA         equ     8       ; qword; LBA of transfer
  1628                                  ; for convenience:
  1629                                  pkt_LBA0        equ     8       ; word
  1630                                  pkt_LBA1        equ     10      ; word
  1631                                  pkt_LBA2        equ     12      ; word          ; MBZ
  1632                                  pkt_LBA3        equ     14      ; word          ; MBZ
  1633                                  
  1634                                  ; Parameter Packet returns:
  1635                                  ;
  1636                                  ;pkt_size       equ     0       ; word
  1637                                  pkt_info        equ     2       ; word, information bits
  1638                                          ; bit   usage
  1639                                          ;  0    DMA boundary errors are handled transparently
  1640                                          ;  1    Geometry valid (bytes 8-12)
  1641                                          ;  2    Removable device (no)
  1642                                          ;  3    Supports Write with Verify (no)
  1643                                          ;  4    change line support (no)
  1644                                          ;  5    removable & lockable (no)
  1645                                          ;  6    max. geometry for a removable drive (no)
  1646                                          ;  7-15  MBZ
  1647                                  pkt_phys_cyl    equ     4       ; dword, physical cylinders
  1648                                  pkt_phys_hds    equ     8       ; dword, physical heads
  1649                                  pkt_phys_spt    equ     12      ; dword, sectors per track
  1650                                  pkt_sectors     equ     16      ; qword, total number of sectors
  1651                                  pkt_bytes       equ     24      ; word, bytes per sector
  1652                                  pkt_ptr         equ     26      ; dword, EDD configuration paramter pointer
  1653                                                                  ; FFFF:FFFF means invalid pointer
  1654                                  
  1655                                  
  1656                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1657                                  ; integrity:    Check integrity of fixed disk table
  1658                                  ;
  1659                                  ;  Call with:
  1660                                  ;       DL = device code (80h..83h)
  1661                                  ;       DS set to BIOS data area
  1662                                  ;
  1663                                  ;  Exit with:
  1664                                  ;       DS:SI points at the fixed disk table
  1665                                  ;	DI = unit number
  1666                                  ;
  1667                                  ;  Error Exit:
  1668                                  ;       If the disk table checksum is bad, give immediate error return
  1669                                  ;
  1670                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1671                                  integrity:
  1672 0000077E 5150                            pushm   ax,cx
  1673                                  %if 0
  1674                                          mov     al,7Fh
  1675                                          and     al,dl                   ; mask out the high bit
  1676                                          cmp     al,[n_fixed_disks]
  1677                                  %else
  1678                                  	extern	get_IDE_num
  1679 00000780 E8(0000)                	call	get_IDE_num		; get number of IDE disks total
  1680 00000783 88C4                    	mov	ah,al
  1681 00000785 B07F                    	mov	al,7Fh
  1682 00000787 20D0                            and     al,dl                   ; mask out the high bit
  1683 00000789 38E0                    	cmp	al,ah			; compare against max
  1684                                  %endif
  1685 0000078B 7203E999F8                      jae     undefined               ; harsh error exit
  1686 00000790 BEB000                          mov     si,fx80
  1687 00000793 B91000                          mov     cx,fx81-fx80            ; size of fixed disk table
  1688 00000796 84C0                    	test    al,al
  1689 00000798 7406                            jz      .1
  1690 0000079A 01CE                    .0:	add     si,cx                   ; point at fx81
  1691 0000079C FEC8                    	dec	al
  1692 0000079E 75FA                    	jnz	.0
  1693                                  .1:
  1694 000007A0 56                              push    si
  1695 000007A1 B800EE                          mov     ax,0EE00h               ; error code and zero checksum
  1696                                  
  1697 000007A4 0204                    .2:     add     al,[si]                 ; compute checksum
  1698 000007A6 46                              inc     si
  1699 000007A7 E2FB                            loop    .2                      ; loop back
  1700                                  
  1701 000007A9 5E                              pop     si
  1702 000007AA 08C0                            or      al,al                   ; test AL for zero
  1703 000007AC 7403E982F8                      jnz     error_exit              ; BIOS data area clobbered
  1704                                  
  1705 000007B1 E8D9F8                  	call	SDsetunit		; get DI as unit number
  1706                                  
  1707 000007B4 5859                            popm    ax,cx
  1708 000007B6 C3                              ret
  1709                                  
  1710                                  
  1711                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1712                                  ; cv_lba        Convert CHS in CX & DX to LBA address in DX:AX
  1713                                  ;
  1714                                  ;  Call with:
  1715                                  ;       DS:SI points to fixed disk table
  1716                                  ;       CX & DX are CHS input parameters
  1717                                  ;
  1718                                  ;  Exit with:
  1719                                  ;       DX:AX is the corresponding LBA address
  1720                                  ;       BX and CX are modified
  1721                                  ;
  1722                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1723                                  cv_lba:
  1724 000007B7 89C8                            mov     ax,cx           ; cylinder info to AX
  1725 000007B9 C0C002                          rol     al,2            ; position high 2 bits
  1726 000007BC 2403                            and     al,3            ; mask 2 bits
  1727 000007BE 86C4                            xchg    al,ah           ; AX = cylinder number
  1728 000007C0 C1EA08                          shr     dx,8            ; heads to DL   DH=0
  1729                                  
  1730 000007C3 89D3                            mov     bx,dx           ; heads to BX
  1731 000007C5 8A5402                          mov     dl,[fx_log_heads - fx80 + si]   ; may be 0, meaning 256
  1732 000007C8 FECA                            dec     dl
  1733 000007CA 42                              inc     dx              ; recover 256 !!!
  1734                                  
  1735 000007CB F7E2                            mul     dx
  1736 000007CD 01D8                            add     ax,bx           ; add in the head number
  1737 000007CF 83D200                          adc     dx,0            ; **
  1738                                  
  1739 000007D2 8A5C0E                          mov     bl,[fx_log_sectors - fx80 + si]    ; BH is already 0
  1740 000007D5 51                              push    cx
  1741 000007D6 E8(0000)                        call    @mulLS          ; DX:AX = DX:AX * BX
  1742 000007D9 59                              pop     cx
  1743 000007DA FEC9                            dec     cl              ; sector address is from 1, not 0
  1744 000007DC 83E13F                          and     cx,63
  1745 000007DF 01C8                            add     ax,cx           ; add in sector number
  1746 000007E1 83D200                          adc     dx,0            ; **
  1747 000007E4 C3                              ret
  1748                                  
  1749                                  
  1750                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1751                                  ; fn00 -- Reset the Disk Subsystem
  1752                                  ;
  1753                                  ;  Call with:
  1754                                  ;       AH = 0  function code
  1755                                  ;
  1756                                  ;  Exit with:
  1757                                  ;       Nothing
  1758                                  ;
  1759                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1760                                  fn00:
  1761 000007E5 E896FF                          call    integrity       ; perhaps no subsystem
  1762 000007E8 E879F9                  	call	SDinit		; no real init until referenced
  1763 000007EB B400                            mov     ah,0
  1764 000007ED E93FF8                          jmp     exit_sequence
  1765                                  
  1766                                  
  1767                                  
  1768                                  
  1769                                  
  1770                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1771                                  ; fn02 -- Disk Read
  1772                                  ; fn03 -- Disk Write
  1773                                  ; fn04 -- Disk Verify (future)
  1774                                  ;
  1775                                  ;  Enter with:
  1776                                  ;       AH = 2 (read)
  1777                                  ;       AH = 3 (write)
  1778                                  ;       AH = 4 (verify)
  1779                                  ;       AL = number of sectors to transfer
  1780                                  ;       CH = low 8 bits of cylinder number
  1781                                  ;       CL = sector number & high 2 bits of sector number
  1782                                  ;       DH = head number
  1783                                  ;       DL = device code
  1784                                  ;       ES:BX = buffer to receive/provide the data (except on verify)
  1785                                  ;
  1786                                  ;  Exit with:
  1787                                  ;       AH = success(0) or error code
  1788                                  ;       Carry flag set, if error; clear otherwise
  1789                                  ;
  1790                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1791                                  fn02:
  1792                                  fn03:
  1793                                  fn04:
  1794 000007F0 E88BFF                          call    integrity       ; set pointer to Fixed Disk Table in SI
  1795 000007F3 E8C1FF                          call    cv_lba          ; convert to LBA address in DX:AX
  1796 000007F6 30C9                    	xor	cl,cl		; no error to begin
  1797                                  
  1798 000007F8 8A6E0E                          mov     ch,[bp + offset_AL]      ; get sector count
  1799 000007FB 8B5E08                          mov     bx,[bp + offset_BX]      ; get transfer address
  1800                                  
  1801                                  ; Enter here on Read, Write, Verify or
  1802                                  ;     extended  Read, Write, Verify, Seek
  1803                                  RWV: 
  1804 000007FE FEC5                            inc     ch                      ; zero is valid for no transfer
  1805 00000800 EB31                            jmp     .6              ; enter loop at the bottom
  1806                                  ; the read/write/verify loop
  1807                                  .1:
  1808                                  ; LBA call is okay
  1809 00000802 F6460F04                        test    byte [bp+offset_AH],04h         ; Seek/Verify?
  1810 00000806 7514                            jnz     .4
  1811 00000808 F6460F01                        test    byte [bp+offset_AH],01h         ; Write?
  1812 0000080C 7507                            jnz     .3
  1813                                  .2:				; READ operation
  1814 0000080E E824FC                  	call	SDread1sec
  1815 00000811 740E                    	jz	.5
  1816 00000813 EB22                    	jmp	.8		; error code in CL
  1817                                  
  1818                                  .3:
  1819 00000815 E879FC                  	call	SDwrite1sec
  1820 00000818 7407                    	jz	.5
  1821 0000081A EB1B                            jmp     .8		; error code in CL
  1822                                  
  1823                                  .4:
  1824 0000081C E8C6FC                  	call	SDverify1sec
  1825 0000081F 7516                    	jnz	.8		; error code is in CL
  1826                                  
  1827                                  .5:
  1828 00000821 83C001                          add     ax,1            ; increment the LBA address
  1829 00000824 83D200                          adc     dx,0            ; **
  1830 00000827 80C702                          add     bh,2            ; add 512 == 200h to the BX
  1831 0000082A 7307                            jnc     .6
  1832 0000082C 8CC7                            mov     di,es
  1833 0000082E 83C710                          add     di,10h
  1834 00000831 8EC7                            mov     es,di           ; update the segment register
  1835 00000833 FECD                    .6:     dec     ch
  1836 00000835 75CB                            jnz     .1
  1837                                  
  1838 00000837 88CC                    .8:	mov	ah,cl		; error code to AH
  1839 00000839 E9F3F7                  	jmp     exit_sequence
  1840                                  
  1841                                  
  1842                                  
  1843                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1844                                  ; fn08  --  Get Drive Parameters
  1845                                  ;
  1846                                  ;  Call with:
  1847                                  ;       AH = 8  function code
  1848                                  ;       DL = drive code (80h, 81h, ...)
  1849                                  ;
  1850                                  ;  Exit with:
  1851                                  ;       CH = maximum cylinder number (low 8 bits)
  1852                                  ;       CL = max. sector number; max. cyl in high 2 bits
  1853                                  ;       DH = maximum head number
  1854                                  ;       DL = number of fixed disks
  1855                                  
  1856                                  ;       AH = 0  and Carry is clear on success
  1857                                  ;       AH = error code; Carry set on error
  1858                                  ;
  1859                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1860                                  fn08:           ; Get Drive Parameters
  1861 0000083C C6460A00                        mov     byte [bp + offset_DL],0         ; say no fixed disks
  1862                                  
  1863 00000840 E83BFF                          call    integrity       ; bad device code or no fixed disks
  1864                                  
  1865 00000843 8B04                            mov     ax,[fx_log_cylinders - fx80 + si]
  1866 00000845 48                              dec     ax
  1867 00000846 C0E406                          shl     ah,6
  1868 00000849 0A640E                          or      ah,[fx_log_sectors - fx80 + si]
  1869 0000084C 86C4                            xchg    al,ah
  1870 0000084E 89460C                          mov     [bp + offset_CX],ax
  1871 00000851 8A7402                          mov     dh,[fx_log_heads - fx80 + si]
  1872 00000854 FECE                            dec     dh
  1873                                  %if 0
  1874                                          mov     dl,[n_fixed_disks]      ; return parameter
  1875                                  %else
  1876 00000856 52                      	push	dx			; protect DH
  1877 00000857 E8(0000)                	call	get_IDE_num		; get number of IDE disks
  1878 0000085A 5A                      	pop	dx			; restore DH
  1879 0000085B 88C2                    	mov	dl,al
  1880                                  %endif
  1881 0000085D 89560A                          mov     [bp + offset_DX],dx
  1882                                  
  1883 00000860 30E4                            xor     ah,ah
  1884 00000862 E9CAF7                          jmp     exit_sequence
  1885                                  
  1886                                  
  1887                                          
  1888                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1889                                  ; fn15 -- Get Disk Type
  1890                                  ;
  1891                                  ;  Call With:
  1892                                  ;       AH = 15   function code
  1893                                  ;       DL = device code (80h or 81h)
  1894                                  ;
  1895                                  ;  Exit With:
  1896                                  ;     If successful, Carry is clear
  1897                                  ;       AH = 3  indicating a hard disk
  1898                                  ;       CX:DX   number of hard disk sectors
  1899                                  ;
  1900                                  ;     If unsuccessful, Carry is set
  1901                                  ;
  1902                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1903                                  fn15:
  1904 00000865 E816FF                          call    integrity       ; sets DS:SI
  1905 00000868 8B04                            mov     ax,[fx_log_cylinders - fx80 + si]
  1906 0000086A 8A5C02                          mov     bl,[fx_log_heads - fx80 + si]
  1907 0000086D 30FF                            xor     bh,bh
  1908 0000086F FECB                            dec     bl              ; 00 means 256
  1909 00000871 43                              inc     bx              ; do the conversion
  1910 00000872 F7E3                            mul     bx              ; cyls * heads
  1911 00000874 8A5C0E                          mov     bl,[fx_log_sectors - fx80 + si]
  1912 00000877 30FF                            xor     bh,bh
  1913 00000879 E8(0000)                        call    @mulLS          ; cyls * heads * sectors
  1914 0000087C 89560C                          mov     word [bp+offset_CX],dx  ; high order
  1915 0000087F 89460A                          mov     word [bp+offset_DX],ax  ; low order word
  1916 00000882 C6460F03                        mov     byte [bp+offset_AH],3   ; code for HARD DISK
  1917 00000886 E9A4F7                          jmp     good_exit
  1918                                  
  1919                                  
  1920                                  
  1921                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1922                                  ; fn41 -- Check Extensions Present
  1923                                  ;
  1924                                  ;  Call With:
  1925                                  ;       AH = 41h        function code
  1926                                  ;       BX = 55AAh      magic number
  1927                                  ;       DL = drive code (80h or 81h)
  1928                                  ;
  1929                                  ;  Exit With:
  1930                                  ;     carry clear
  1931                                  ;       AH = 21h        version 1.1 support
  1932                                  ;       BX = AA55h      magic number II
  1933                                  ;       CX = 0001b  bit0=packet support; bit2=EDD drive support
  1934                                  ;
  1935                                  ;     carry set
  1936                                  ;       AH = 01h        Invalid Command
  1937                                  ;
  1938                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1939                                  fn41:
  1940 00000889 E8F2FE                          call    integrity       ; test drive number (sets DS:SI)
  1941 0000088C 817E08AA55                      cmp     word [offset_BX + bp],55AAh
  1942 00000891 7403E993F7                      jne     undefined
  1943 00000896 F6440840                        test    byte [fx_drive_control - fx80 + si],40h         ; test LBA bit
  1944 0000089A 7503E98AF7                      jz      undefined
  1945                                  
  1946 0000089F C6460F21                        mov     byte [offset_AH + bp],21h       ; version 1.1
  1947 000008A3 C7460855AA                      mov     word [offset_BX + bp],0AA55h    ; magic number II
  1948 000008A8 C7460C0500                      mov     word [offset_CX + bp],00000101b       ; packet calls & EDD i/f
  1949 000008AD E97DF7                          jmp     good_exit
  1950                                  
  1951                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1952                                  ; fn42 -- Extended Read
  1953                                  ; fn43 -- Extended Write
  1954                                  ; fn44 -- Extended Verify
  1955                                  ; fn47 -- Extended Seek (implement as Verify)
  1956                                  ;
  1957                                  ;  Call With:
  1958                                  ;       AH = function code
  1959                                  ;       AL = 0,1 write with no verify; 2 write with verify
  1960                                  ;            not used for Read or Verify
  1961                                  ;       DL = drive number (80h or 81h)
  1962                                  ;       [DS:SI] was disk packet address; will be used in ES:BX
  1963                                  ;
  1964                                  ;  Exit With:
  1965                                  ;       AH = 0 (no error) and Carry Clear
  1966                                  ;       AH = error code and Carry Set
  1967                                  ;     The block count field is updated with the number of blocks
  1968                                  ;     correctly transferred/verified before the error occurred.
  1969                                  ;
  1970                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1971                                  fn42:
  1972                                  fn43:
  1973                                  fn44:
  1974                                  fn47:
  1975 000008B0 E8CBFE                          call    integrity       ; set pointer to Fixed Disk Table in SI
  1976 000008B3 8E4610                          mov     es,[bp + offset_DS]     ; packet pointer
  1977 000008B6 8B5E02                          mov     bx,[bp + offset_SI]     ; **
  1978 000008B9 26803F10                   es   cmp     byte [bx + pkt_size],16 ; check for correct size
  1979 000008BD 7303E967F7                      jb      undefined
  1980                                  
  1981 000008C2 268B470E                   es   mov     ax,[bx + pkt_LBA3]      ; LBA address
  1982 000008C6 260B470C                   es   or      ax,[bx + pkt_LBA2]      ; LBA address
  1983 000008CA 7403E95AF7                      jnz     undefined
  1984 000008CF 268B4708                   es   mov     ax,[bx + pkt_LBA0]      ; LBA address
  1985 000008D3 268B570A                   es   mov     dx,[bx + pkt_LBA1]      ; LBA address hi
  1986                                  
  1987 000008D7 B501                            mov     ch,1                    ; assume Seek
  1988 000008D9 807E0F47                        cmp     byte [offset_AH + bp],47h       ; Seek?
  1989 000008DD 7404                            je      .7
  1990 000008DF 268A6F02                   es   mov     ch,[bx + pkt_blocks]    ; sector count
  1991                                  .7:
  1992 000008E3 8A4C08                          mov     cl,[fx_drive_control - fx80 + si]
  1993 000008E6 26C45F04                   es   les     bx,[bx + pkt_address]   ; get transfer address
  1994                                  
  1995 000008EA E911FF                          jmp     RWV             ; common read/write/verify code
  1996                                  
  1997                                  
  1998                                          
  1999                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2000                                  ; fn48 -- Get Drive Parameters
  2001                                  ;
  2002                                  ;  Call With:
  2003                                  ;       AH = 48h        function code
  2004                                  ;       DL = drive number
  2005                                  ;       DS:SI = pointer to return buffer (26 or 30 bytes)
  2006                                  ;
  2007                                  ;  Exit With:
  2008                                  ;       AH = 0 and carry clear
  2009                                  ;       results in the buffer
  2010                                  ;
  2011                                  ;       AH = error code and carry set
  2012                                  ;
  2013                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2014                                  fn48:
  2015 000008ED E88EFE                          call    integrity               ; set DS:SI
  2016 000008F0 8E4610                          mov     es,[bp + offset_DS]     ; packet pointer
  2017 000008F3 8B5E02                          mov     bx,[bp + offset_SI]     ; **
  2018 000008F6 B9FFFF                          mov     cx,0FFFFh               ; CX = -1  (FFFFh)
  2019 000008F9 B81A00                          mov     ax,pkt_ptr              ; AX = 26
  2020 000008FC 263907                     es   cmp     [bx + pkt_size],ax      ; check for correct size = 26
  2021 000008FF 7303E925F7                      jb      undefined
  2022 00000904 83C004                          add     ax,4
  2023 00000907 263907                     es   cmp     [bx + pkt_size],ax      ; check for correct size = 30
  2024 0000090A 7208                            jb      .1
  2025 0000090C 26894F1A                   es   mov     [bx + pkt_ptr],cx       ; flag invalid pointer
  2026 00000910 26894F1C                   es   mov     [bx + pkt_ptr+2],cx     ; **
  2027                                  .1:
  2028 00000914 268907                     es   mov     [bx + pkt_size],ax      ; set the returned size
  2029                                  
  2030 00000917 41                              inc     cx                      ; CX = 0
  2031 00000918 26C747020300               es   mov     word [bx + pkt_info], 000011b   ; DMA bound/ Geom OK
  2032                                  
  2033 0000091E 8B4409                          mov     ax,[fx_phys_cylinders - fx80 + si]      ; cylinders
  2034 00000921 26894704                   es   mov     [bx + pkt_phys_cyl],ax  
  2035 00000925 26894F06                   es   mov     [bx + pkt_phys_cyl+2],cx
  2036                                  
  2037 00000929 8A440B                          mov     al,[fx_phys_heads - fx80 + si]          ; heads
  2038 0000092C 88EC                            mov     ah,ch
  2039 0000092E 26894708                   es   mov     [bx + pkt_phys_hds],ax  
  2040 00000932 26894F0A                   es   mov     [bx + pkt_phys_hds+2],cx
  2041                                  
  2042 00000936 8A4404                          mov     al,[fx_phys_sectors - fx80 + si]        ; sectors
  2043 00000939 2689470C                   es   mov     [bx + pkt_phys_spt],ax  
  2044 0000093D 26894F0E                   es   mov     [bx + pkt_phys_spt+2],cx
  2045                                  
  2046 00000941 8B440C                          mov     ax,[fx_LBA_low - fx80 + si]             ; total LBA sectors
  2047 00000944 26894710                   es   mov     [bx + pkt_sectors],ax                   ; total sectors
  2048 00000948 8B4405                          mov     ax,[fx_LBA_high - fx80 + si]            ; **
  2049 0000094B 26894712                   es   mov     [bx + pkt_sectors+2],ax                 ; **
  2050 0000094F 26894F14                   es   mov     [bx + pkt_sectors+4],cx                 ; **
  2051 00000953 26894F16                   es   mov     [bx + pkt_sectors+6],cx                 ; **
  2052 00000957 26C747180002               es   mov     word [bx + pkt_bytes],512               ; sector size
  2053 0000095D B400                            mov     ah,0
  2054 0000095F E9CDF6                          jmp     exit_sequence
  2055                                  
  2056                                  
  2057                                  
  2058                                          
  2059                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2060                                  ; fn4E -- set hardware configuration
  2061                                  ;
  2062                                  ;  Call With:
  2063                                  ;       AH = 4Eh        function code
  2064                                  ;       AL = hardware function sub-code
  2065                                  ;       DL = drive number
  2066                                  ;
  2067                                  ;  Exit With:
  2068                                  ;       AH = 0          carry is clear
  2069                                  ;       AL = 1          other devices affected
  2070                                  ;
  2071                                  ;       AH = error code and carry is set
  2072                                  ;
  2073                                  ;  This operation is a complete No-Op for the DIDE
  2074                                  ;
  2075                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2076                                  fn4E:
  2077 00000962 E819FE                          call    integrity
  2078 00000965 B80100                          mov     ax,0001h
  2079 00000968 E9C4F6                          jmp     exit_sequence
  2080                                  
  2081                                  
  2082                                  
  2083                                  
  2084                                  %endif  ; STANDALONE
  2085                                  
  2086                                  
  2087                                  
