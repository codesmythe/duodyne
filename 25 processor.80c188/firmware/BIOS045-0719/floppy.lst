     1                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     2                                  ; floppy.asm -- WD37C65B floppy disk controller driver
     3                                  ;		Version 2.0 -- Apr 2013, JRC
     4                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     5                                  ;
     6                                  ;   This version is for assembly by  NASM 0.98.39 or later
     7                                  ;
     8                                  ; Copyright (C) 2010-2013 John R. Coffman.  All rights reserved.
     9                                  ; Provided for hobbyist use on the N8VEM SBC-188 board.
    10                                  ;
    11                                  ; This program is free software: you can redistribute it and/or modify
    12                                  ; it under the terms of the GNU General Public License as published by
    13                                  ; the Free Software Foundation, either version 3 of the License, or
    14                                  ; (at your option) any later version.
    15                                  ;
    16                                  ; This program is distributed in the hope that it will be useful,
    17                                  ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    18                                  ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    19                                  ; GNU General Public License for more details.
    20                                  ;
    21                                  ; You should have received a copy of the GNU General Public License
    22                                  ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    23                                  ;
    24                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    25                                  %include        "config.asm"
     1                              <1> ;/*
     2                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     3                              <1> ; VGA3.CFG
     4                              <1> ;   Copied to CONFIG.ASM for general release.
     5                              <1> ;
     6                              <1> ;       Modify the parameters below to reflect your system
     7                              <1> ;
     8                              <1> ;
     9                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    10                              <1> ;
    11                              <1> ;   Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    12                              <1> ;   Provided for hobbyist use on the N8VEM SBC-188 board.
    13                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    14                              <1> ;
    15                              <1> ; Define the serial terminal that the Video BIOS must emulate
    16                              <1> ; Set one of the following to 1
    17                              <1> ; If you have no idea what to choose, set TTY to 1
    18                              <1> TTY     equ     0       ; hardcopy -- cannot position the cursor
    19                              <1> DUMB    equ     0       ; dumb CRT -- ^H, ^J, ^K, ^L can move the cursor
    20                              <1> ANSI    equ     1       ; very smart, like a VT-100
    21                              <1> WYSE    equ     0       ; very smart Wyse series (30, 50, ...)
    22                              <1> ; others may get added in the future
    23                              <1> ;  ONE OF THE ABOVE must BE SET TO 1!!!!!
    24                              <1> ;
    25                              <1> ; Does the hardware configuration contain the Color Video Display Unit?
    26                              <1> ; Both the 8563 and the 8242 are used.  The default is CVDU=0
    27                              <1> CVDU	equ	0	; system does not have the CVDU
    28                              <1> ;
    29                              <1> ; Does the hardware configuration contain the VGA3 a/n Video card?
    30                              <1> ; The 8563 will be disabled, but the 8242 code is shared with the CVDU
    31                              <1> ; The default is VGA3=0
    32                              <1> VGA3   equ     1       ; system has the VGA3
    33                              <1> ;
    34                              <1> ; Does the hardware configuration contain the front panel card?
    35                              <1> ; The default is FRONT_PANEL=0
    36                              <1> ;
    37                              <1> FRONT_PANEL   equ     1       ; system has the VGA3
    38                              <1> %if 0
    39                              <1> 	*/
    40                              <1> #define VGA3 1
    41                              <1> /*
    42                              <1> %endif
    43                              <1> ;
    44                              <1> ; Boot up keyboard mode:  20h for NumLock on
    45                              <1> ;CVDU_KEYBOARD_STATUS	equ	0	; NumLock OFF
    46                              <1> CVDU_KEYBOARD_STATUS	equ	20h	; NumLock ON
    47                              <1> 
    48                              <1> ; Define the UART startup bit rate - 1200-19200 are most common
    49                              <1> ;UART_RATE	equ	0		; 1200
    50                              <1> ;UART_RATE	equ	1		; 2400
    51                              <1> ;UART_RATE	equ	2		; 4800
    52                              <1> ;UART_RATE	equ	3		; 9600
    53                              <1> ;UART_RATE	equ	4		; 19200
    54                              <1> UART_RATE	equ	5		; 38400
    55                              <1> ;UART_RATE	equ	6		; 57600
    56                              <1> ;UART_RATE	equ	7		; 115200
    57                              <1> 
    58                              <1> ; Does the serial terminal use the DSR/DTR protocol for flow control?
    59                              <1> ;UART_DSR_PROTOCOL	equ		1	; Yes!
    60                              <1> UART_DSR_PROTOCOL       equ             WYSE    ; Wyse always uses it
    61                              <1> 						; but not ANSI
    62                              <1> ; Define the size of the ROM image on the system in Kilobytes
    63                              <1> ; It may be smaller than the actual EPROM in use.
    64                              <1> ; The following sizes are supported:  32, 64, 128, and 256
    65                              <1> %ifndef ROM
    66                              <1> ROM             equ     32              ; 64 is the default
    67                              <1> %endif
    68                              <1> 
    69                              <1> ; Define the number of Wait States at which the ROM operates
    70                              <1> ROM_WS          equ     1               ; 0..3  (1 is the default)
    71                              <1> 
    72                              <1> ; Define the size in Kilobytes of DOS RAM (low SRAM plus EMM allocate RAM)
    73                              <1> ; This is a desired size and will only be present if a 4MEM board is added
    74                              <1> RAM_DOS         equ     640
    75                              <1> 
    76                              <1> ; Define the size of the low SRAM on the system in Kilobytes
    77                              <1> ; the default is 512 kilobytes
    78                              <1> RAM             equ     512             ; (512 is the default)
    79                              <1> 
    80                              <1> ; Define the number of Wait States at which the RAM operates
    81                              <1> RAM_WS          equ     0               ; 0..3  (0 is the default)
    82                              <1> 
    83                              <1> ; Define the number of Wait States for Local Peripheral devices (600-7FF)
    84                              <1> LCL_IO_WS       equ     1               ; 0..3  (1 is the default)
    85                              <1> 
    86                              <1> ; Define the number of Wait States for ECB BUS peripheral devices (4xx)
    87                              <1> BUS_IO_WS       equ     3               ; 0..3  (3 is the default)
    88                              <1> 
    89                              <1> ; Define the time zone in which we build the Relocatable BIOS
    90                              <1> %ifndef TIMEZONE
    91                              <1> %define TIMEZONE "CDT"
    92                              <1> %endif
    93                              <1> 
    94                              <1> ; Has the REDBUG debugger been loaded?
    95                              <1> %ifndef SOFT_DEBUG
    96                              <1> %define SOFT_DEBUG 0
    97                              <1> %endif
    98                              <1> 
    99                              <1> ; Should the BIOS include "Tiny BASIC" in the image?
   100                              <1> %ifndef TBASIC
   101                              <1> TBASIC          equ     1		; default is 1
   102                              <1> %endif
   103                              <1> 
   104                              <1> ; Should the BIOS include the Floating Point Emulator?  The 80188 does
   105                              <1> ; not allow a floating point co-processor, so this is probably a good idea.
   106                              <1> %ifndef FPEM
   107                              <1> FPEM            equ     1               ; default is 1
   108                              <1> %endif
   109                              <1> 
   110                              <1> ; Define the maximum number of EMM (4MEM) boards supported
   111                              <1> EMM_BOARDS      equ     4
   112                              <1> 
   113                              <1> ; Should the Floating Point Emulator use temporary storage in the EBDA
   114                              <1> ; or at locations 0280h..3FFh in low memory?
   115                              <1> %if SOFT_DEBUG
   116                              <1> FPEM_USE_EBDA   equ     FPEM            ; default is 0
   117                              <1> %else
   118                              <1> FPEM_USE_EBDA   equ     0; FPEM            ; default is 0
   119                              <1> %endif
   120                              <1> 
   121                              <1> ; Define the size of the EPROM that is to be installed on the system
   122                              <1> ; It may be larger than the actual ROM image to be generated.
   123                              <1> %ifndef CHIP
   124                              <1> CHIP            equ     64
   125                              <1> %endif
   126                              <1> 
   127                              <1> ; Does the SBC-188 00.4 board have the LS138/LS08 piggyback fix
   128                              <1> ; Set to 1 for the SBC-188 v1.0 and later production boards
   129                              <1> FDC_PIGGYBACK_FIX       equ     0       ; Fix not installed
   130                              <1> ;FDC_PIGGYBACK_FIX       equ     1       ; fix  IS  installed
   131                              <1> 
   132                              <1> ; On SBC-188 rev 00.4 board, there is a published hardware fix (2010-09-18).
   133                              <1> ; If the wiring update is installed, or you have a later board, then
   134                              <1> ; set this to 0.  If you are using the software workaround, then set this
   135                              <1> ; to 1.  The rev 1.0 board has this fix already.
   136                              <1> NEED_TIMER_FIX  equ     0               ; have revised hardware
   137                              <1> ;NEED_TIMER_FIX  equ     1               ; use workaround
   138                              <1> 
   139                              <1> ; Define the UART oscillator speed
   140                              <1> UART_OSC        equ     1843200         ; 1.8432 Mhz is specified
   141                              <1> 
   142                              <1> 
   143                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   144                              <1> ; end of the User configuration
   145                              <1> ;       Do Not modify anything below this point
   146                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   147                              <1> 
   148                              <1> CVDU_8563	equ	CVDU		; separate inits
   149                              <1> CVDU_8242	equ	CVDU|VGA3 	; separate inits
   150                              <1> VGA3_6445       equ     VGA3            ; separate inits
   151                              <1> ; Suppress all UART output in color video Mode 3
   152                              <1> ;UART_MODE3_SUPPRESS	equ	0
   153                              <1> UART_MODE3_SUPPRESS	equ	CVDU_8563 | VGA3_6445
   154                              <1> CVDU_USE_MSDOS_KLUDGE	equ	0; CVDU_8242	; bad, bad MSDOS
   155                              <1> CVDU_USE_KBD_HOOK		equ	CVDU_8242
   156                              <1> 
   157                              <1> ; Define existence of any uart chip
   158                              <1> UART		equ	TTY+DUMB+ANSI+WYSE
   159                              <1> startuplength   equ     128                     ; may be up to 1024
   160                              <1> startseg        equ     0FFFFh - (ROM*64) + 1
   161                              <1> highrom         equ     (ROM*400h)&0FFFFh
   162                              <1> startupseg      equ     0FFFFh - (startuplength>>4) + 1
   163                              <1> bios_data_seg   equ     040h            ; segment of BIOS data area
   164                              <1> 
   165                              <1> 
   166                              <1> %define ARG(n) [bp+2+(n)*2]
   167                              <1> 
   168                              <1> %macro  check   1.nolist
   169                              <1>  %if (%1)
   170                              <1>    %error Check Failure: %1
   171                              <1>  %endif
   172                              <1> %endm
   173                              <1> %macro  range   3.nolist
   174                              <1>  %if (%1)<(%2)
   175                              <1>    %error Out of Range: %1
   176                              <1>  %elif (%1)>(%3)
   177                              <1>    %error Out of Range: %1
   178                              <1>  %endif
   179                              <1> %endm
   180                              <1> _terminal equ UART+CVDU
   181                              <1>  check   RAM_DOS&15
   182                              <1>  check   RAM&(RAM-1)
   183                              <1>  check   ROM&(ROM-1)
   184                              <1>  range   RAM,32,512
   185                              <1>  range   ROM,32,256
   186                              <1>  range   RAM_WS,0,3
   187                              <1>  range   ROM_WS,0,3
   188                              <1>  range   RAM_DOS,RAM,(1024-ROM)
   189                              <1>  range   LCL_IO_WS,0,3
   190                              <1>  range   BUS_IO_WS,0,3
   191                              <1>  range   UART_OSC,500000,16000000
   192                              <1>  range   UART_RATE,0,7
   193                              <1>  range	 UART,0,1
   194                              <1>  range	 _terminal,1,2
   195                              <1> 
   196                              <1> %ifndef SOFT_DEBUG
   197                              <1> %define SOFT_DEBUG 0
   198                              <1> %endif
   199                              <1> 
   200                              <1> %ifndef TRACE
   201                              <1> %define TRACE 0
   202                              <1> %endif
   203                              <1> 
   204                              <1> %ifdef MAKE_OBJECT_FILE
   205                              <1>         segment _DATA WORD PUBLIC CLASS=DATA
   206                              <1>         export _ROMsize
   207                              <1>         export _CHIPsize
   208                              <1> _ROMsize        dw      ROM
   209                              <1> _CHIPsize       dw      CHIP
   210                              <1> %endif
   211                              <1> ; end of the Hardware configuration file
   212                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   213                              <1> ;*/
    26                                  %include        "cpuregs.asm"
     1                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     2                              <1> ; CPUREGS.ASM
     3                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     4                              <1> ;
     5                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
     6                              <1> ;
     7                              <1> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
     8                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
     9                              <1> ;
    10                              <1> ; This program is free software: you can redistribute it and/or modify
    11                              <1> ; it under the terms of the GNU General Public License as published by
    12                              <1> ; the Free Software Foundation, either version 3 of the License, or
    13                              <1> ; (at your option) any later version.
    14                              <1> ;
    15                              <1> ; This program is distributed in the hope that it will be useful,
    16                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    17                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    18                              <1> ; GNU General Public License for more details.
    19                              <1> ;
    20                              <1> ; You should have received a copy of the GNU General Public License
    21                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    22                              <1> ;
    23                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    24                              <1>         cpu     186
    25                              <1> ;
    26                              <1> ;
    27                              <1> ; IBM model byte -- must be less than a 286
    28                              <1> ;
    29                              <1> ;MODEL_BYTE		equ	0FEh	; PC-XT
    30                              <1> ;SUBMODEL_BYTE		equ	0FFh	; not used
    31                              <1> 
    32                              <1> MODEL_BYTE		equ	0FEh	; PC-XT
    33                              <1> SUBMODEL_BYTE		equ	00h	;  "
    34                              <1> 
    35                              <1> 
    36                              <1> ; 80188 peripheral control register block address
    37                              <1> CPU_CSCR	        equ	0FF00h
    38                              <1> 
    39                              <1> ; Compatible Mode registers
    40                              <1> 
    41                              <1> cpu_relocation          equ     CPU_CSCR+0FEh
    42                              <1> 
    43                              <1> ; The memory and peripheral chip select register offsets from 0FF00h
    44                              <1> 
    45                              <1> cpu_umcs                equ     CPU_CSCR+0A0h          ; Upper memory select
    46                              <1> cpu_lmcs                equ     CPU_CSCR+0A2h          ; Lower memory select
    47                              <1> cpu_pacs                equ     CPU_CSCR+0A4h          ; Peripheral select
    48                              <1> cpu_mmcs                equ     CPU_CSCR+0A6h          ; Middle memory base
    49                              <1> cpu_mpcs                equ     CPU_CSCR+0A8h          ; Mid mem. & peripherals
    50                              <1> 
    51                              <1> ; Enhanced Mode registers
    52                              <1> 
    53                              <1> cpu_mdram               equ     CPU_CSCR+0E0h          ; memory partition reg.
    54                              <1> cpu_cdram               equ     CPU_CSCR+0E2h          ; clock prescaler
    55                              <1> cpu_edram               equ     CPU_CSCR+0E4h          ; Enable refresh reg.
    56                              <1> cpu_pdcon               equ     CPU_CSCR+0F0h          ; Power-Save control
    57                              <1> 
    58                              <1> 
    59                              <1> ; On-board internal peripheral equates
    60                              <1> ; Programmable Interrupt Controller
    61                              <1> PIC	        equ	CPU_CSCR+020H
    62                              <1> PIC_EOI	        equ	PIC+2           ; End Of Interrupt
    63                              <1> PIC_POLLR	equ	PIC+4
    64                              <1> PIC_POLLSR	equ	PIC+6
    65                              <1> PIC_IMASK	equ	PIC+8
    66                              <1> PIC_PMREG	equ	PIC+0AH
    67                              <1> PIC_SRVR	equ	PIC+0CH
    68                              <1> PIC_IRQR	equ	PIC+0EH
    69                              <1> PIC_IRQSR	equ	PIC+10H
    70                              <1> PIC_TCR	        equ	PIC+12H
    71                              <1> PIC_DMA0CR	equ	PIC+14H
    72                              <1> PIC_DMA1CR	equ	PIC+16H
    73                              <1> PIC_I0CON	equ	PIC+18H
    74                              <1> PIC_I1CON	equ	PIC+1AH
    75                              <1> PIC_I2CON	equ	PIC+1CH
    76                              <1> PIC_I3CON	equ	PIC+1EH
    77                              <1> 
    78                              <1> EOI_NSPEC       equ     8000h           ; Non-Specific EOI
    79                              <1> 
    80                              <1> ; Interrupt masks (Master Mode)
    81                              <1> ;
    82                              <1> mask_timer_all          equ     0001h
    83                              <1> mask_dma0               equ     0004h
    84                              <1> mask_dma1               equ     0008h
    85                              <1> mask_int0               equ     0010h
    86                              <1> mask_int1               equ     0020h
    87                              <1> mask_int2               equ     0040h
    88                              <1> mask_int3               equ     0080h
    89                              <1> 
    90                              <1> 
    91                              <1> 
    92                              <1> ; Timers
    93                              <1> TIM0	        equ	CPU_CSCR+050H
    94                              <1> TIM1	        equ	CPU_CSCR+058H
    95                              <1> TIM2	        equ	CPU_CSCR+060H
    96                              <1> 
    97                              <1> TCNT	        equ	0	; count register
    98                              <1> CMPA	        equ	2	; max count A
    99                              <1> CMPB	        equ	4	; max count B (not present on TIM2)
   100                              <1> TCON	        equ	6	; mode/control word
   101                              <1> 
   102                              <1> ; Timer control bits:
   103                              <1> tc_EN           equ     8000h   ; Enable bit
   104                              <1> tc_nINH         equ     4000h   ; not Inhibit Enable
   105                              <1> tc_INT          equ     2000h   ; Interrupt Enable
   106                              <1> tc_RIU          equ     1000h   ; Register A/B (0/1) in Use
   107                              <1> tc_MC           equ     0020h   ; Maximum Count reached
   108                              <1> tc_RTG          equ     0010h   ; Retrigger (internal source)
   109                              <1> tc_P            equ     0008h   ; Prescale internal clock (timers 0 & 1 only)
   110                              <1> tc_EXT          equ     0004h   ; External clock
   111                              <1> tc_ALT          equ     0002h   ; Alternate between A & B max count registers
   112                              <1> tc_CONT         equ     0001h   ; Continuous: continue after max count
   113                              <1> 
   114                              <1> 
   115                              <1> 
   116                              <1> 
   117                              <1> ; DMA
   118                              <1> DMA0	        equ	CPU_CSCR+0C0H
   119                              <1> DMA1	        equ	CPU_CSCR+0D0H
   120                              <1> DMASPL	        equ	0	; source pointer low
   121                              <1> DMASPU	        equ	2	; source pointer high
   122                              <1> DMADPL	        equ	4	; destination pointer low
   123                              <1> DMADPU	        equ	6	; destination pointer high
   124                              <1> DMATC	        equ	8	; terminal count
   125                              <1> DMACW	        equ	0AH	; control word
   126                              <1> 
   127                              <1> 
   128                              <1> 
   129                              <1> 
   130                              <1> 
   131                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   132                              <1> ;
   133                              <1> ;       SBC-188 external devices
   134                              <1> ;
   135                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   136                              <1> 
   137                              <1> IO_BASE			equ	0400h
   138                              <1> 
   139                              <1> 
   140                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   141                              <1> ; The UART registers
   142                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   143                              <1> uart_base               equ     IO_BASE+0280h
   144                              <1> uart_rbr                equ     uart_base       ;Rcvr Buffer / read only
   145                              <1> uart_thr                equ     uart_base       ;Transmit Holding / write only
   146                              <1> uart_ier                equ     uart_base+1     ;Interrupt Enable
   147                              <1> uart_iir                equ     uart_base+2     ;Interrupt Ident / read only
   148                              <1> uart_fcr                equ     uart_base+2     ;FIFO Control / write only
   149                              <1> uart_lcr                equ     uart_base+3     ;Line Control
   150                              <1> uart_mcr                equ     uart_base+4     ;Modem Control
   151                              <1> uart_lsr                equ     uart_base+5     ;Line Status
   152                              <1> uart_msr                equ     uart_base+6     ;Modem Status
   153                              <1> uart_sr			equ	uart_base+7	;Scratch
   154                              <1> 
   155                              <1> uart_dll                equ     uart_base       ;Divisor Latch LS Byte
   156                              <1> uart_dlm                equ     uart_base+1     ;Divisor Latch MS Byte
   157                              <1> 
   158                              <1> 
   159                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   160                              <1> ; Floppy controller
   161                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   162                              <1> FDC	        equ	IO_BASE+0200H
   163                              <1> FDC_MSR         equ     FDC
   164                              <1> FDC_DATA        equ     FDC_MSR+1
   165                              <1> FDC_DACK        equ	FDC+10H
   166                              <1> FDC_LDOR	equ	FDC+20H
   167                              <1> FDC_LDCR	equ	FDC+30H
   168                              <1> FDC_TC	        equ	FDC+40H
   169                              <1> FDC_DACK_TC     equ     FDC_DACK | FDC_TC
   170                              <1> 
   171                              <1> 
   172                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   173                              <1> ;DS1302 RTC
   174                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   175                              <1> RTC	equ	IO_BASE+0300H
   176                              <1> 
   177                              <1> 
   178                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   179                              <1> ; PIO 82C55 I/O 
   180                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   181                              <1> PPI	        equ	IO_BASE+0260H
   182                              <1> PIO_A	        equ	PPI+0	; (OUTPUT)
   183                              <1> PIO_B	        equ	PPI+1	; (INPUT)
   184                              <1> PIO_C	        equ	PPI+2	; (CENTRONICS control low nibble)  
   185                              <1> PIO_CTRL	equ	PPI+3	; CONTROL BYTE PIO 82C55
   186                              <1> 
   187                              <1> portA           equ     PPI+0   ;
   188                              <1> portB           equ     PPI+1   ;     LITES uses this for output
   189                              <1> portC           equ     PPI+2   ;
   190                              <1> 
   191                              <1> 
   192                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   193                              <1> ; Dual [DMA] IDE devices
   194                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   195                              <1> DIDE		equ	IO_BASE + 20H	; range 0x20..0x3F
   196                              <1> 
   197                              <1> DIDE0		equ	DIDE		; first interface (master & slave)
   198                              <1> DIDE1		equ	DIDE+10h	; second interface (master & slave)
   199                              <1> 
   200                              <1> 
   201                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   202                              <1> ; Cassette I/O
   203                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   204                              <1> cuart_base	EQU 	IO_BASE+80H	; BASE IO ADDRESS OF CASSETTE UART
   205                              <1> cuart_rbr	equ     cuart_base	;Rcvr Buffer / read only
   206                              <1> cuart_thr	equ     cuart_base	;Transmit Holding / write only
   207                              <1> cuart_ier	equ     cuart_base+1	;Interrupt Enable
   208                              <1> cuart_iir	equ     cuart_base+2	;Interrupt Ident / read only
   209                              <1> cuart_fcr	equ     cuart_base+2	;FIFO Control / write only
   210                              <1> cuart_lcr	equ     cuart_base+3	;Line Control
   211                              <1> cuart_mcr	equ     cuart_base+4	;Modem Control
   212                              <1> cuart_lsr	equ     cuart_base+5	;Line Status
   213                              <1> cuart_msr	equ     cuart_base+6	;Modem Status
   214                              <1> cuart_sr	equ	cuart_base+7	;Scratch
   215                              <1> 
   216                              <1> cuart_dll	equ     cuart_base	;Divisor Latch LS Byte
   217                              <1> cuart_dlm	equ	cuart_base+1	;Divisor Latch MS Byte
   218                              <1> 
   219                              <1> 
   220                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   221                              <1> ;
   222                              <1> ;       4MEM control registers
   223                              <1> ;
   224                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   225                              <1> EMM_addr        equ     1               ; high 6 bits of 20-bit address
   226                              <1> EMM_page        equ     0               ; 4MEM page in [0..254]
   227                              <1> 
   228                              <1> EMM_BASE        equ     IO_BASE + 000h          ; first EMM (4MEM) board
   229                              <1> EMM_unmapped    equ     255             ; unmapped 4MEM page
   230                              <1> 
   231                              <1> EMM0            equ     EMM_BASE        ; first  EMM board
   232                              <1> EMM1            equ     EMM0 + 2        ; second EMM board
   233                              <1> EMM2            equ     EMM1 + 2        ; third  EMM board
   234                              <1> EMM3            equ     EMM2 + 2        ; fourth EMM board
   235                              <1> 
   236                              <1> 
   237                              <1> 
   238                              <1> 
   239                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   240                              <1> ;
   241                              <1> ;	ColorVDU devices
   242                              <1> ;
   243                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   244                              <1> ;
   245                              <1> ;	major select on the Z80 bus
   246                              <1> ;
   247                              <1> devCVDU_8bit	equ	0xE0		; this may change to 0x10
   248                              <1> 
   249                              <1> devCVDUbase 	equ	IO_BASE + devCVDU_8bit
   250                              <1> 
   251                              <1> M8563status	equ	devCVDUbase + 4		; 4 == bitrev(2)
   252                              <1> M8563register	equ	devCVDUbase + 4
   253                              <1> M8563data	equ	devCVDUbase + 12	; 12 == bitrev(3)
   254                              <1> 
   255                              <1> %if CVDU_8563
   256                              <1> I8242status	equ	devCVDUbase + 10	; 10 == bitrev(5)
   257                              <1> I8242command	equ	devCVDUbase + 10
   258                              <1> I8242data	equ	devCVDUbase + 2		; 2 == bitrev(4)
   259                              <1> %endif
   260                              <1> 
   261                              <1> 
   262                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   263                              <1> ;
   264                              <1> ;	VGA3 devices
   265                              <1> ;
   266                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   267                              <1> ;
   268                              <1> ;	major select on the Z80 bus
   269                              <1> ;
   270                              <1> devVGA3_8bit    equ     0xE0                    ; same as CVDU
   271                              <1> 
   272                              <1> devVGA3base       equ     IO_BASE + devVGA3_8bit
   273                              <1> 
   274                              <1> %if VGA3_6445
   275                              <1> I8242status	equ	devVGA3base + 1
   276                              <1> I8242command	equ	devVGA3base + 1
   277                              <1> I8242data	equ	devVGA3base + 0
   278                              <1> %endif
   279                              <1> HD6445addr	equ	devVGA3base + 2		; to address the HD6445 registers
   280                              <1> HD6445reg	equ	devVGA3base + 3		; to r/w a register on the CRTC
   281                              <1> 
   282                              <1> vga3cfg		equ	devVGA3base + 4
   283                              <1> ; the following are probably not used on the SBC-188, except for testing/checking
   284                              <1> vga3adhi	equ	devVGA3base + 5
   285                              <1> vga3adlo	equ	devVGA3base + 6
   286                              <1> vga3data	equ	devVGA3base + 7
   287                              <1> 
   288                              <1> 
   289                              <1> 
   290                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   291                              <1> ;
   292                              <1> ;	Front Panel devices
   293                              <1> ;
   294                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   295                              <1> ;
   296                              <1> ; Front Panel 82C55 I/O 
   297                              <1> FPPPI	        equ	IO_BASE+0A0H
   298                              <1> FPPORTA         equ     FPPPI+0   	;
   299                              <1> FPPORTB         equ     FPPPI+1   	;    
   300                              <1> FPPORTC         equ     FPPPI+2   	;
   301                              <1> FPPIOCONT       equ     FPPPI+3   	;
   302                              <1> 
   303                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   304                              <1> ; debug port -- JRC only
   305                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   306                              <1> portD		equ	IO_BASE + 0FFh		; 0x04FF
   307                              <1> ;portD		equ	portB		     ; older 8255 output on PPI
   308                              <1> 
   309                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   310                              <1> ;
   311                              <1> ; some useful macros:
   312                              <1> ;
   313                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   314                              <1> ;
   315                              <1> 
   316                              <1> %imacro setloc  1.nolist
   317                              <1>  times   (%1-($-$$)) db 0FFh
   318                              <1> %endm
   319                              <1> 
   320                              <1> %imacro db_lo   1
   321                              <1>  db (%1)&255
   322                              <1> %endm
   323                              <1> 
   324                              <1> %imacro cnop    0.nolist
   325                              <1> %if SOFT_DEBUG
   326                              <1>         nop
   327                              <1> %endif
   328                              <1> %endm
   329                              <1> 
   330                              <1> %imacro popm 1-*.nolist
   331                              <1> %rep %0
   332                              <1> %ifidni %1,ALL
   333                              <1>  popa
   334                              <1> %elifidni %1,F
   335                              <1>  popf
   336                              <1> %else
   337                              <1>  pop %1
   338                              <1> %ifidni %1,DS
   339                              <1>  cnop
   340                              <1> %elifidni %1,ES
   341                              <1>  cnop
   342                              <1> %endif
   343                              <1> %endif
   344                              <1> %rotate 1
   345                              <1> %endrep
   346                              <1> %endm
   347                              <1> 
   348                              <1> %imacro pushm 1-*.nolist
   349                              <1> %rep %0
   350                              <1> %rotate -1
   351                              <1> %ifidni %1,ALL
   352                              <1>  pusha
   353                              <1> %elifidni %1,F
   354                              <1>  pushf
   355                              <1> %else
   356                              <1>  push %1
   357                              <1> %endif
   358                              <1> %endrep
   359                              <1> %endm
   360                              <1> 
   361                              <1> ; end CPUREGS.ASM
   362                              <1> 
    27                                  %include        "equates.asm"
     1                              <1> ;========================================================================
     2                              <1> ; EQUATES.ASM -- Lots of Defintions for Relocatable BIOS
     3                              <1> ;========================================================================
     4                              <1> ;   for the N8VEM SBC-188 v.00.4 and 00.5
     5                              <1> ;
     6                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
     7                              <1> ;
     8                              <1> ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
     9                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    10                              <1> ;
    11                              <1> ; This program is free software: you can redistribute it and/or modify
    12                              <1> ; it under the terms of the GNU General Public License as published by
    13                              <1> ; the Free Software Foundation, either version 3 of the License, or
    14                              <1> ; (at your option) any later version.
    15                              <1> ;
    16                              <1> ; This program is distributed in the hope that it will be useful,
    17                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    18                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    19                              <1> ; GNU General Public License for more details.
    20                              <1> ;
    21                              <1> ; You should have received a copy of the GNU General Public License
    22                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    23                              <1> ;
    24                              <1> ;========================================================================
    25                              <1> 
    26                              <1> %if 1
    27                              <1> 	SEGMENT  _TEXT ALIGN=16 PUBLIC CLASS=CODE
    28                              <1>         SEGMENT  CONST ALIGN=2 PUBLIC CLASS=DATA
    29                              <1> 	SEGMENT  _DATA ALIGN=2 PUBLIC CLASS=DATA
    30                              <1>         SEGMENT  CONST2 ALIGN=2 PUBLIC CLASS=DATA
    31                              <1> 	SEGMENT  _BSS  ALIGN=2 PUBLIC CLASS=BSS
    32                              <1> ;;;        SEGMENT  _BASIC ALIGN=16 PUBLIC CLASS=BASIC
    33                              <1> 
    34                              <1> 	GROUP	DGROUP CONST _DATA CONST2 _BSS
    35                              <1> 
    36                              <1>         global  FPEM_segment
    37                              <1> %endif
    38                              <1> 
    39                              <1> %include "ascii.asm"
     1                              <2> ; ascii.asm
     2                              <2> ;
     3                              <2> CTRL            equ     1Fh     ; masks a character to CTRL-x
     4                              <2> 
     5                              <2> NUL     equ     00h
     6                              <2> BEL     equ     (CTRL & 'G')
     7                              <2> BS      equ     08h
     8                              <2> HT      equ     09h
     9                              <2> LF	equ	0Ah
    10                              <2> NL      equ     LF
    11                              <2> CR	equ	0Dh
    12                              <2> XON     equ     (CTRL & 'Q')
    13                              <2> XOFF    equ     (CTRL & 'S')
    14                              <2> DC1     equ     XON
    15                              <2> DC3     equ     XOFF
    16                              <2> ESC     equ	1Bh
    17                              <2> 
    18                              <2> 
    40                              <1> 
    41                              <1> 
    42                              <1> ; POST error codes. Presently one byte but can expand to word.
    43                              <1> ER_BIOS equ	01h		; Bad ROM bios checksum, patch last byte
    44                              <1> ER_RAM	equ	02h		; Bad RAM in main memory, replace
    45                              <1> ER_CRT	equ	04h		; Bad RAM in video card, replace
    46                              <1> ER_FDC	equ	08h		; Bad FDC
    47                              <1> ER_UNK1	equ	10h		; {unassigned}
    48                              <1> ER_MEM	equ	20h		; Bad RAM in vector area, replace
    49                              <1> ER_ROM	equ	40h		; Bad ROM in expansion area, bad checksum
    50                              <1> ER_UNK2	equ	80h		; {unassigned}
    51                              <1> 
    52                              <1> 
    53                              <1> 
    54                              <1> ;; ************************ BIOS Data Segment ******************************
    55                              <1> ;; BIOS data segment - not all will  be used
    56                              <1> ;                struc   BIOS_DATA_AREA  ; at 0040:0000
    57                              <1> %include "bda.inc"
     1                              <2> ;/*======================================================================
     2                              <2> ; bda.inc -- BIOS data area definitions
     3                              <2> ;========================================================================
     4                              <2> ;   for the N8VEM SBC-188
     5                              <2> ;
     6                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
     7                              <2> ;
     8                              <2> ; Copyright (C) 2013 John R. Coffman.  All rights reserved.
     9                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    10                              <2> ;
    11                              <2> ; This program is free software: you can redistribute it and/or modify
    12                              <2> ; it under the terms of the GNU General Public License as published by
    13                              <2> ; the Free Software Foundation, either version 3 of the License, or
    14                              <2> ; (at your option) any later version.
    15                              <2> ;
    16                              <2> ; This program is distributed in the hope that it will be useful,
    17                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    18                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    19                              <2> ; GNU General Public License for more details.
    20                              <2> ;
    21                              <2> ; You should have received a copy of the GNU General Public License
    22                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    23                              <2> ;
    24                              <2> ;========================================================================
    25                              <2> 
    26                              <2> 			;*/ extern				/*
    27                              <2> 	ABSOLUTE  0	;*/ struct BDA {			/*
    28 00000000 <res 00000008>      <2> serial_ports    resw    4	;*/	word	serial_ports[4];	/*
    29 00000008 <res 00000008>      <2> parallel_ports  resw    4	;*/	word	parallel_ports[4];	/*
    30 00000010 <res 00000002>      <2> equipment_flag  resw    1	;*/	EQFL	equipment_flag;		/*
    31                              <2> ;	dw	?		; 40:10 	; Equipment present word
    32                              <2> ;  						;  = (1 iff floppies) *     1.
    33                              <2> ;                                               ;  + (1 iff 187     ) *     2.
    34                              <2> ;  						;  + (#+1 64K sys ram) *    4.
    35                              <2> ;  						;  + (init crt mode ) *    16.
    36                              <2> ;  						;  + (# of floppies ) *    64.
    37                              <2> ;  						;  + (# serial ports) *   512.
    38                              <2> ;  						;  + (1 iff toy port) *  4096.
    39                              <2> ;                                               ;  + (1 iff modem   ) *  8192.
    40                              <2> ;  						;  + (# parallel LPT) * 16384.
    41 00000012 <res 00000001>      <2> mfg_test_flags  resb    1	;*/	byte	mfg_test_flags;	/* 40:12 unused by us
    42 00000013 <res 00000002>      <2> memory_size     resw    1	;*/	word	memory_size;	/* 40:13 kilobytes
    43                              <2> uart_kbd_ctrl_R	equ	$	;*/				/*** JRC: count of ctrl-R's for reboot
    44 00000015 <res 00000001>      <2> IPL_errors      resb    1	;*/	byte	IPL_errors;	/* 40:15 IPL errors<-table/scratchpad
    45 00000016 <res 00000001>      <2> unused_01       resb    1	;*/	byte	unused_01;	/*
    46                              <2> ;;---------------[Keyboard data area]------------;
    47 00000017 <res 00000002>      <2> keyboard_flags_0 resw   1	;*/	word	keyboard_flags_0;  /* 40:17 Shift/Alt/etc. keyboard flags
    48                              <2> keyboard_flags_1 equ	$-1	;     2nd byte	keyboard_flags_1;  
    49 00000019 <res 00000001>      <2> keypad_char	resb	1	;*/	byte	keypad_char;	/* 40:19 Alt-KEYPAD char. goes here
    50 0000001A <res 00000002>      <2> kbd_buffer_head resw    1	;*/	word	kbd_buffer_head;   /* 40:1A --> keyboard buffer head
    51 0000001C <res 00000002>      <2> kbd_buffer_tail resw    1	;*/	word	kbd_buffer_tail;   /* 40:1C --> keyboard buffer tail
    52 0000001E <res 00000020>      <2> kbd_buffer      resw    16	;*/	word	kbd_buffer[16];	/* 40:1E Keyboard Buffer (Scan,Value)
    53                              <2> kbd_buffer_last	equ	$	;*/				/*
    54                              <2> ;;---------------[Diskette data area]------------;
    55 0000003E <res 00000001>      <2> fdc_drv_calib   resb    1	;*/	byte	fdc_drive_calib;   /* 40:3E
    56 0000003F <res 00000001>      <2> fdc_motor_LDOR  resb    1	;*/	byte	fdc_motor_LDOR;	   /* 40:3F Motor, DMA, select control
    57 00000040 <res 00000001>      <2> fdc_motor_ticks resb    1	;*/	byte	fdc_motor_ticks;   /* 40:40 ticks til motor off
    58 00000041 <res 00000001>      <2> fdc_status      resb    1	;*/	byte	fdc_status;	   /* 40:41
    59                              <2> ;				Floppy return code stat byte
    60                              <2> ;				;  1 = bad ic 765 command req.
    61                              <2> ;				;  2 = address mark not found
    62                              <2> ;				;  3 = write to protected disk
    63                              <2> ;				;  4 = sector not found
    64                              <2> ;				;  8 = data late (DMA overrun)
    65                              <2> ;				;  9 = DMA failed 64K page end
    66                              <2> ;				; 16 = bad CRC on floppy read
    67                              <2> ;				; 32 = bad NEC 765 controller
    68                              <2> ;				; 64 = seek operation failed
    69                              <2> ;				;128 = disk drive timed out
    70 00000042 <res 00000007>      <2> fdc_ctrl_status resb    7	;*/	byte	fdc_ctrl_status[7];  /* 40:42 Status bytes from NEC 765
    71                              <2> ;;---------------[Video display area]------------;
    72 00000049 <res 00000001>      <2> video_mode      resb    1	;*/	byte	video_mode;	/* 40:49
    73                              <2> ;			 	; Current CRT mode  (software)
    74                              <2> ;				;  0 = 40 x 25 text (no color)
    75                              <2> ;				;  1 = 40 x 25 text (16 color)
    76                              <2> ;				;  2 = 80 x 25 text (no color)
    77                              <2> ;				;  3 = 80 x 25 text (16 color)
    78                              <2> ;				;  4 = 320 x 200 grafix 4 color
    79                              <2> ;				;  5 = 320 x 200 grafix 0 color
    80                              <2> ;				;  6 = 640 x 200 grafix 0 color
    81                              <2> ;				;  7 = 80 x 25 text (mono card)
    82 0000004A <res 00000002>      <2> video_columns   resw    1	;*/	word video_columns;	/* 40:4A Columns on CRT screen
    83 0000004C <res 00000002>      <2> video_regen_bytes  resw 1	;*/	word video_regen_bytes;	/* 40:4C Bytes in the regen region
    84 0000004E <res 00000002>      <2> video_regen_offset resw 1	;*/	word video_regen_offset;/* 40:4E Byte offset in regen region
    85 00000050 <res 00000010>      <2> video_cursor_pos  resw  8	;*/	word video_cursor_pos[8];  /* 40:50 Cursor pos for up to 8 pages
    86 00000060 <res 00000002>      <2> video_cursor_mode resw  1	;*/	word video_cursor_mode;	/* 40:60 Current cursor mode setting
    87 00000062 <res 00000001>      <2> video_page      resb    1	;*/	byte video_page;	/* 40:62 Current page on display
    88 00000063 <res 00000002>      <2> video_base_seg  resw    1	;*/	word video_base_seg;	/* 40:63 Base address (B000h or B800h)
    89 00000065 <res 00000001>      <2> video_hw_mode   resb    1	;*/	byte video_hw_mode;	/* 40:65 ic 6845 mode reg. (hardware)
    90 00000066 <res 00000001>      <2> video_cga_palette resb  1	;*/	byte video_cga_palette;	/* 40:66 Current CGA palette
    91                              <2> ;;---------------[Used to setup ROM]-------------;
    92 00000067 <res 00000004>      <2> eprom_address   resd    1	;*/	dword eprom_address;	/* 40:67 Eprom base Offset,Segment
    93 0000006B <res 00000001>      <2> spurious_irq    resb    1	;*/	byte spurious_irq;	/* 40:6B Last spurious interrupt IRQ
    94                              <2> ;;---------------[Timer data area]---------------;
    95 0000006C <res 00000004>      <2> timer_ticks     resd    1	;*/	dword timer_ticks;	/* 40:6C Ticks since midnight (lo,hi)
    96 00000070 <res 00000001>      <2> timer_new_day   resb    1	;*/	byte timer_new_day;	/* 40:70 Non-zero if new day
    97                              <2> ;;---------------[System data area]--------------;
    98 00000071 <res 00000001>      <2> break_flag      resb    1	;*/	byte break_flag;	/* 40:71 Sign bit set iff break
    99 00000072 <res 00000002>      <2> warm_boot       resw    1	;*/	word warm_boot;		/* 40:72 Warm boot iff==1234h
   100                              <2> ;;---------------[Hard disk scratchpad]----------;
   101 00000074 <res 00000004>      <2> hdd_scratch     resd    1	;*/	word hdd_scratch[2];	/* 40:74
   102                              <2> ;;---------------[Timout areas/PRT/LPT]----------;
   103 00000078 <res 00000004>      <2> lpt_timeout     resb    4	;*/	byte lpt_timeout[4];	/* 40:78 Ticks for LPT 1-4 timeouts
   104 0000007C <res 00000004>      <2> com_timeout     resb    4	;*/	byte com_timeout[4];	/* 40:7C Ticks for COM 1-4 timeouts
   105                              <2> ;;---obsolete----[Keyboard buf start/end]---jrc--;
   106 00000080 <res 00000002>      <2> kbd_buffer_start resw   1	;*/	word kbd_buffer_start;	/* 40:80 KBD buffer head (PC/AT)
   107 00000082 <res 00000002>      <2> kbd_buffer_end  resw    1	;*/	word kbd_buffer_end;	/* 40:82 KBD buffer tail (PC/AT)
   108                              <2> ;;---------------[EGA stuff]---------------------;
   109 00000084 <res 00000007>      <2> EGA_stuff	resb	7	;*/	byte EGA_stuff[7];	/* 40:84 Unspecified EGA data
   110                              <2> ;;---------------[Floppy/Fixed Media Info]-------------;
   111 0000008B <res 00000001>      <2> fdc_last_rate	resb	1	;*/	byte fdc_last_rate;	/* 40:8B Last floppy step rate/data rate?
   112 0000008C <res 00000004>      <2> fx_misc_unused	resb	4	;*/	byte fx_misc_unused[4];	/* 40:8C Fixed disk miscellaneous ???
   113 00000090 <res 00000002>      <2> fdc_disk_state	resb	2	;*/	byte fdc_disk_state[2];	/* 40:90 Floppy disk state
   114 00000092 <res 00000002>      <2> fdc_op_start	resb	2	;*/	byte fdc_op_start[2];	/* 40:92 Floppy operation start state machine
   115 00000094 <res 00000002>      <2> fdc_cylinder	resb	2	;*/	byte fdc_cylinder[2];	/* 40:94 Floppy present cylinder
   116                              <2> ;;---------------[Additional KBD flags]----------------;
   117 00000096 <res 00000001>      <2> kbd_flag_3	resb	1	;*/	byte kbd_flag_3;	/* 40:96 kbd ???
   118 00000097 <res 00000001>      <2> kbd_flag_2	resb	1	;*/	byte kbd_flag_2;	/* 40:97 kbd ???
   119                              <2> ;;---------------[RTC/timer1 data]---------------------;
   120 00000098 <res 00000004>      <2> user_semaphore	resw	2	;*/	byte *user_semaphore;	/* 40:98 User semaphore in (bit 7)
   121 0000009C <res 00000004>      <2> rtc_count	resd	1	;*/	dword rtc_count;	/* 40:9C RTC tick counter
   122 000000A0 <res 00000001>      <2> rtc_wait_active	resb	1	;*/	byte rtc_wait_active;	/* 40:A0 Busy=01, Posted=80h, 
   123                              <2> ;;---------------[Cassette I/O stuff]------------------;
   124 000000A1 <res 00000001>      <2> last_val	resb	1	;*/	byte last_val;		/* 40:A1 Last byte read value
   125 000000A2 <res 00000002>      <2> crc_reg		resw	1	;*/	word crc_reg;		/* 40:A2 CRC accumulation area
   126                              <2> ;									Post Acknowleged=00;
   127 000000A4 <res 00000001>      <2> EGA_data	resb	1	;*/	byte EGA_data;		/* 40:A4 Various usage
   128 000000A5 <res 00000002>      <2> SDstatus	resb	2	;*/	byte SDstatus[2];	/* 40:A5 Status byte from command
   129 000000A7 <res 00000002>      <2> SDcardtype	resb	2	;*/	byte SDcardtype[2];	/* 40:A7 SDcard type SDSC=2, HC=3, ...
   130                              <2> ;
   131 000000A9 <res 00000004>      <2> fixed_disk_tab	resb	4	;*/	byte fixed_disk_tab[4];	/* dispatch table to fixed disk drivers
   132 000000AD <res 00000001>      <2> wait12_count	resb	1	;*/	byte wait12_count;	/* 40:AD 12usec CX count
   133 000000AE <res 00000001>      <2> lock_count	resb	1	;*/	byte lock_count;	/* 40:AE lock level counter
   134 000000AF <res 00000001>      <2> EMS_start       resb    1	;*/	byte EMS_start;		/* start EMS allocation from here
   135                              <2> fx80		equ	$	;*/	struct EDD_disk fx80;	/* fixed disk parameter area 0
   136 000000B0 <res 00000002>      <2> fx_log_cylinders resw   1	;	word fx_log_cylinders;	 logical number of cylinders
   137 000000B2 <res 00000001>      <2> fx_log_heads    resb    1	;	byte fx_log_heads;	 logical number of heads
   138 000000B3 <res 00000001>      <2> fx_signature	resb	1	;	byte fx_signature;	 A0h signature = translated geom
   139 000000B4 <res 00000001>      <2> fx_phys_sectors	resb    1       ;	byte fx_phys_sectors;	 physical number of sectors per track
   140 000000B5 <res 00000002>      <2> fx_LBA_high     resw    1       ;	word fx_LBA_high;	 high word of LBA28 number of sectors
   141 000000B7 <res 00000001>      <2> fx_reserved7    resb	1	;	byte fx_reserved;	 MBZ
   142 000000B8 <res 00000001>      <2> fx_drive_control resb   1       ;	byte fx_drive_control;	 flag bits for IDE head register
   143 000000B9 <res 00000002>      <2> fx_phys_cylinders resw	1	;	word fx_phys_cylinders;	 physical number of cylinders
   144 000000BB <res 00000001>      <2> fx_phys_heads	resb	1	;	byte fx_phys_heads;	 physical number of heads
   145 000000BC <res 00000002>      <2> fx_LBA_low	resw	1	;	word fx_LBA_low;	 low word of LBA28 number of sectors
   146 000000BE <res 00000001>      <2> fx_log_sectors	resb	1	;	byte fx_log_sectors;	 logical number of sectors per track
   147 000000BF <res 00000001>      <2> fx_checksum	resb	1	;	byte fx_checksum;	 checksum, dunno how to compute
   148 000000C0 <res 00000010>      <2> fx81            resb    16	;*/	struct EDD_disk fx81;	/* fixed disk parameter area 1
   149 000000D0 <res 00000010>      <2> fx82            resb    16	;*/	struct EDD_disk fx82;	/* fixed disk parameter area 2
   150 000000E0 <res 00000010>      <2> fx83            resb    16	;*/	struct EDD_disk fx83;	/* fixed disk parameter area 3
   151                              <2> ;
   152                              <2> ;
   153                              <2> 
   154 000000F0 <res 00000002>      <2> FPEM_segment    resw    1       ;*/	word FPEM_segment;	/* FPEM data segment
   155                              <2> 
   156 000000F2 <res 00000002>      <2> EBDA_paragraph  resw    1       ;*/	word EBDA_paragraph;	/* lowest EBDA paragraph
   157                              <2> 
   158 000000F4 <res 00000002>      <2> dma0_cw         resw    1       ;*/	word dma0_cw;		/* end of dma control word
   159 000000F6 <res 00000002>      <2> dma1_cw         resw    1       ;*/	word dma1_cw;		/*   ditto
   160                              <2> 
   161 000000F8 <res 00000002>      <2> fdc_type	resb	2	;*/	byte fdc_type[2];	/* disk type in low nibble, alternate in hi nib 
   162                              <2> 
   163 000000FA <res 00000004>      <2> debug_static_ptr  resw	2	;*/	void *debug_static_ptr;	/* pointer to debug static area
   164                              <2> 
   165 000000FE <res 00000001>      <2> n_fixed_disks   resb    1       ;*/	byte n_fixed_disks;	/* number of fixed disks
   166                              <2> 
   167 000000FF <res 00000001>      <2> cpu_xtal        resb    1       ;*/	byte cpu_xtal;		/* CPU crystal frequency in Mhz 
   168                              <2> ;								   CPU clock is half of this
   169                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   170                              <2> ;
   171                              <2> ;  System configuration stuff below
   172                              <2> ;	c.f., CONFIG.ASM (ANSI.CFG, CVDU.CFG, etc.), User configuration stuff
   173                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   174                              <2> %if 0				;*/
   175                              <2> #define FIXED_DISK_MAX 4		/*
   176                              <2> %else
   177                              <2> %define FIXED_DISK_MAX 4
   178                              <2> %endif
   179                              <2> %if 0				;*/
   180                              <2> #define PPIDE_driver 1		/*
   181                              <2> %else
   182                              <2> %define PPIDE_driver 1
   183                              <2> %endif
   184                              <2> %if 0				;*/
   185                              <2> #define DIDE_driver 1		/*
   186                              <2> %else
   187                              <2> %define DIDE_driver 1
   188                              <2> %endif
   189                              <2> %if 0				;*/
   190                              <2> #define DSD_driver 1		/*
   191                              <2> %else
   192                              <2> %define DSD_driver 1
   193                              <2> %endif
   194                              <2> 				;*/
    58                              <1> 
    59                              <1> ;  this must be the same in EQUATES.H */
    60                              <1> %if SOFT_DEBUG
    61                              <1> %define NBREAK  8
    62                              <1> %endif
    63                              <1> 
    64                              <1> 
    65                              <1> %if 0
    66                              <1>         segment _TEXT
    67                              <1> ;; *************************************************************************
    68                              <1> 
    69                              <1> 
    70                              <1> 
    71                              <1> 
    72                              <1> ;; ************************ DOS Data Segment *******************************
    73                              <1> ;dosdir	SEGMENT at 50h				; Boot disk directory from IPL
    74                              <1> ;xerox	label	byte				;  0 if Print Screen idle
    75                              <1> ;						;  1 if PrtSc xeroxing screen
    76                              <1> ;						;255 if PrtSc error in xerox
    77                              <1> ;						;  ...non-grafix PrtSc in bios
    78                              <1> ;	db	200h dup(?)			; PC-DOS bootstrap procedure
    79                              <1> ;						;  ...IBMBIO.COM buffers the
    80                              <1> ;						;  ...directory of the boot
    81                              <1> ;						;  ...device here at IPL time
    82                              <1> ;						;  ...when locating the guts
    83                              <1> ;						;  ...of the operating system
    84                              <1> ;						;  ...filename "IBMDOS.COM"
    85                              <1> ;dosdir	ends
    86                              <1> ;; *************************************************************************
    87                              <1> ;; ************************ DOS IPL Segment ********************************
    88                              <1> ;dosseg	SEGMENT at 70h				; "Kernel" of PC-DOS op sys
    89                              <1> ;;IBMBIO.COM file loaded by boot block. Device Drivers/Bootstrap. CONTIGUOUS<---
    90                              <1> ;;IBMDOS.COM operating system nucleus immediately follows IBMBIO.COM and       !
    91                              <1> ;;     doesn`t have to be contiguous.  The IBMDOS operating system nucleus     !
    92                              <1> ;;     binary image is loaded by transient code in IBMBIO binary image	      !
    93                              <1> ;dosseg	ends					;			      !
    94                              <1> ;iplseg	SEGMENT at 0h				; Segment for boot block      !
    95                              <1> ;;The following boot block is loaded with 512 bytes on the first sector of     !
    96                              <1> ;;the bootable device by code resident in the ROM-resident bios.  Control is   !
    97                              <1> ;;then transferred to the first word 0000:7C00 of the disk-resident bootstrap  !
    98                              <1> ;	ORG	07C00h				;  ..offset for boot block    !
    99                              <1> ;boot	db	200h dup(?)			;  ..start disk resident boot--
   100                              <1> ;iplseg	ends
   101                              <1> 
   102                              <1> %endif
    28                                  
    29                                  %define DUMP 0
    30                                  
    31                                  ; sterilize SOFT_DEBUG for now
    32                                  %if SOFT_DEBUG > 1
    33                                  %undef SOFT_DEBUG
    34                                  %define SOFT_DEBUG 1
    35                                  %endif
    36                                  
    37                                  	global  BIOS_call_13h
    38                                  ;;	global  Floppy_BIOS_call_13h_entry
    39                                  	global  wait12
    40                                  	global	@enable, @disable
    41                                  %if SOFT_DEBUG
    42                                  	extern	_cprintf
    43                                  	global  undefined
    44                                  	global	fn00,fn02,fn03,fn04
    45                                  	global  get_msr
    46                                  	global	check_DL
    47                                  	global	get_disk_type
    48                                  	global	get_media
    49                                  	global	set_media_pointer
    50                                  	global	rwv_common
    51                                  	global	Seek, recalibrate, Specify
    52                                  	global	rwv_common.marker
    53                                  	global	end_rwv
    54                                  	global	xfer_read_sector, xfer_write_sector, xfer_verify_sector
    55                                  	global	xfer_format_track
    56                                   	global	Check_RW_Status
    57                                  %endif
    58                                  
    59                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    60                                  ; Error, Okay, Complete status conditions
    61                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    62                                  
    63                                  %define	Error		stc
    64                                  ;  test with:
    65                                  ;	JC xxx	(jump on error)
    66                                  ;	JNC xxx	(jump on no error)
    67                                  
    68                                  %define	Okay		xor ah,ah
    69                                  ;  test with:
    70                                  ;	JZ xxx	(jump okay)
    71                                  ;	JNZ xxx (jump not okay)
    72                                  
    73                                  %define Complete	or ah,3
    74                                  ;  test with:
    75                                  ;	JA xxx	(jump complete AND no error)
    76                                  ;	JNZ xxx	(jump complete)
    77                                  ;	JZ xxx	(jump not complete)
    78                                  
    79                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    80                                  
    81                                  
    82                                  ; at most we use 2 floppies
    83                                  %define FLOPPY_MAX	2
    84                                  
    85                                  ; there is some disagreement about whether ES:DI gets set
    86                                  ; for Floppy calls to "int 13h, function 8"
    87                                  FN08_SET_ES_DI   equ     1
    88                                  ;FN08_SET_ES_DI   equ     0
    89                                  
    90                                  ; Define the three modes of operation of the WD37C65B floppy controller
    91                                  %define BASE    0FFh
    92                                  %define SPECIAL 80h
    93                                  %define PC_AT   00h
    94                                  
    95                                  ; DMA watch threshhold
    96                                  %define THRESHHOLD  12
    97                                  
    98                                  ; Do we use DMA or Programmed I/O
    99                                  %define USE_DMA 1       ; We want this to be 1
   100                                  %define USE_DMA_INTs	1	; Use DMA interrupts
   101                                  
   102                                  ; Define the mode in which the WD37C65B is operated
   103                                  %define MODE    PC_AT   ; This MUST NOT be changed
   104                                  
   105                                  ; specify bits in the Operations Register
   106                                  %define DSEL1    00h
   107                                  %define DSEL2    01h
   108                                  %define DSEL_MASK (DSEL1|DSEL2)
   109                                  %define NO_RESET 04h
   110                                  %define RESET    00h
   111                                  %define DMAEN    08h
   112                                  %define MOEN1    10h
   113                                  %define MOEN2    20h
   114                                  %define MOEN_MASK (MOEN1|MOEN2)
   115                                  
   116                                  %define TurnOn	8			; used by all DSEL's
   117                                  
   118                                  ; the Motor turn-on delay in milliseconds
   119                                  %define MOTOR_DELAY     (TurnOn*125)
   120                                  
   121                                  ; define the disk density clock rate selects
   122                                  %define FDC_HD  00h
   123                                  %define FDC_DD  02h
   124                                  
   125                                  ; The individual floppy disk status bits
   126                                  %define FDC_DRIVE_PRESENT  1
   127                                  %define FDC_DRIVE_READY    2
   128                                  
   129                                  
   130                                  ; define the MSR bits:
   131                                  RQM     equ     80h             ; request for master
   132                                  DIO     equ     40h             ; data IN=1, out=0
   133                                  EXM     equ     20h             ; Execution phase in non-DMA mode
   134                                  				;  this should NEVER be set
   135                                  BUSY    equ     10h             ; Controller Busy
   136                                  FD3     equ     08h             ; DS3 is seeking
   137                                  FD2     equ     04h             ; DS2 is seeking
   138                                  FD1     equ     02h             ; DS1 is seeking
   139                                  FD0     equ     01h             ; DS0 is seeking
   140                                  
   141                                  ; MSR I/O status (in/out from CPU)
   142                                  MSR_IN	equ	RQM | DIO
   143                                  MSR_OUT	equ	RQM
   144                                  MSR_MASK equ	RQM | DIO
   145                                  
   146                                  ;  This is the list of controller commands that we use
   147                                  
   148                                  CMD_RECALIBRATE         equ     7       ; 1 param byte (unit #)
   149                                  					; No result bytes
   150                                  CMD_SENSE_INT_STATUS    equ     8       ; No paramter bytes
   151                                  					; 2 result bytes
   152                                  CMD_SENSE_DRIVE_STATUS  equ     4       ; 1 param byte
   153                                  					; 1 result byte
   154                                  CMD_SPECIFY             equ     3       ; 2 parameter bytes
   155                                  					; No result bytes
   156                                  CMD_SEEK                equ     15      ; 2 parameter bytes
   157                                  					; No result bytes
   158                                  CMD_READ_ID             equ     10      ; param in cmd; 1 param byte
   159                                  					; 7 result bytes
   160                                  CMD_READ_DATA           equ     6       ; params in cmd; 8 param bytes
   161                                  					; 7 result bytes
   162                                  CMD_WRITE_DATA          equ     5       ; params in cmd; 8 param bytes
   163                                  					; 7 result bytes
   164                                  CMD_READ_A_TRACK        equ     2       ; params in cmd; 8 param bytes
   165                                  					; 7 result bytes
   166                                  CMD_FORMAT_A_TRACK      equ     13      ; params in cmd; 5 param bytes
   167                                  					; 7 result bytes
   168                                  CMD_SCAN_EQUAL          equ     11h     ; params in cmd; 8 param bytes
   169                                  					; 7 result bytes
   170                                  CMD_SCAN_LOW_OR_EQUAL   equ     19h     ; params in cmd; 8 param bytes
   171                                  					; 7 result bytes
   172                                  CMD_SCAN_HIGH_OR_EQUAL  equ     1Dh     ; params in cmd; 8 param bytes
   173                                  					; 7 result bytes
   174                                  
   175                                  
   176                                  ; define the extra bits in some command codes
   177                                  
   178                                  CMD_MT          equ     80h             ; Multi-track operation
   179                                  CMD_MF          equ     40h             ; MFM recording mode
   180                                  CMD_SK          equ     20h             ; skip deleted data mark
   181                                  
   182                                  
   183                                  
   184                                  ; define the ST3 status bits
   185                                  
   186                                  ST3_WP          equ     40h             ; NOT Write Protected
   187                                  ST3_TR00        equ     10h             ; Track 0 signal
   188                                  ST3_WP2         equ     08h             ; duplicate of ST3_WP; ST3_2S for 8" floppies
   189                                  ST3_HS          equ     04h             ; head 0 or 1
   190                                  ST3_US          equ     03h             ; Unit mask (0..3)
   191                                  
   192                                  
   193                                  ; define the ST2 status bits
   194                                  
   195                                  ST2_CM          equ     40h             ; Control Mark (deleted data mark)
   196                                  ST2_DD          equ     20h             ; Data Error (data field)
   197                                  ST2_WC          equ     10h             ; Wrong Cylinder
   198                                  ST2_SH          equ     08h             ; Scan Hit (not used here)
   199                                  ST2_SN          equ     04h             ; Scan Not Satisfied (not used here)
   200                                  ST2_BC          equ     02h             ; Bad Cylinder
   201                                  ST2_MD          equ     01h             ; Missing address mark
   202                                  
   203                                  ST2_ANY         equ     ST2_CM+ST2_DD+ST2_WC+ST2_BC+ST2_MD
   204                                  
   205                                  
   206                                  ; define the ST1 status bits
   207                                  
   208                                  ST1_EN          equ     80h             ; End of cylinder
   209                                  ST1_DE          equ     20h             ; Data error (CRC err in address or data field)
   210                                  ST1_OR          equ     10h             ; Overrun (we will always see this flag)
   211                                  ST1_ND          equ     04h             ; No Data
   212                                  ST1_NW          equ     02h             ; Not writeable (WP is set)
   213                                  ST1_MA          equ     01h             ; Missing address mark
   214                                  
   215                                  %if FDC_PIGGYBACK_FIX
   216                                  ST1_ANY         equ     ST1_EN+ST1_DE+ST1_OR+ST1_ND+ST1_NW+ST1_MA
   217                                  %else
   218                                  ;ST1_ANY         equ     ST1_EN+ST1_DE+ST1_ND+ST1_NW+ST1_MA
   219                                  ST1_ANY         equ            ST1_DE+ST1_ND+ST1_NW+ST1_MA
   220                                  %endif
   221                                  
   222                                  ; define the ST0 status bits
   223                                  
   224                                  ST0_IC          equ     0C0h            ; Interrupt code mask
   225                                  					; 00 = normal termination
   226                                  					; 01 = abnormal termination
   227                                  					; 10 = invalid command
   228                                  					; 11 = abnormal termination -- change in ready status
   229                                  
   230                                  ST0_SE          equ     20h             ; Seek end
   231                                  ST0_EC          equ     10h             ; Equipment check
   232                                  ST0_NR          equ     08h             ; Not Ready (always 0 on WD37C65B)
   233                                  ST0_HS          equ     04h             ; Head Select
   234                                  ;ST0_US          equ     03h             ; Unit select mask
   235                                  ST0_US          equ     01h             ; Unit select mask
   236                                  
   237                                  ST0_ANY         equ     ST0_EC+ST0_NR   ; Any ST0 error
   238                                  
   239                                  
   240                                  
   241                                  ; The FDC interrupt control register
   242                                  fdc_int_control         equ     PIC_I3CON
   243                                  
   244                                  
   245                                  ; Standard int 13h stack frame layout is 
   246                                  ; created by:   PUSHM  ALL,DS,ES
   247                                  ;               MOV    BP,SP
   248                                  ;
   249                                  offset_DI       equ     0
   250                                  offset_SI       equ     offset_DI+2
   251                                  offset_BP       equ     offset_SI+2
   252                                  offset_SP       equ     offset_BP+2
   253                                  offset_BX       equ     offset_SP+2
   254                                  offset_DX       equ     offset_BX+2
   255                                  offset_CX       equ     offset_DX+2
   256                                  offset_AX       equ     offset_CX+2
   257                                  offset_DS       equ     offset_AX+2
   258                                  offset_ES       equ     offset_DS+2
   259                                  offset_IP       equ     offset_ES+2
   260                                  offset_CS       equ     offset_IP+2
   261                                  offset_FLAGS    equ     offset_CS+2
   262                                  
   263                                  ; The byte registers in the stack
   264                                  offset_AL       equ     offset_AX
   265                                  offset_AH       equ     offset_AX+1
   266                                  offset_BL       equ     offset_BX
   267                                  offset_BH       equ     offset_BX+1
   268                                  offset_CL       equ     offset_CX
   269                                  offset_CH       equ     offset_CX+1
   270                                  offset_DL       equ     offset_DX
   271                                  offset_DH       equ     offset_DX+1
   272                                  
   273                                  
   274                                  ; FDC error codes (returned in AH)
   275                                  ;
   276                                  ERR_no_error            equ     0       ; no error (return Carry clear)
   277                                  ;   everything below returns with the Carry set to indicate an error
   278                                  ERR_invalid_command     equ     1
   279                                  ERR_address_mark_not_found      equ     2
   280                                  ERR_write_protect       equ     3
   281                                  ERR_sector_not_found    equ     4
   282                                  ERR_disk_removed        equ     6
   283                                  ERR_dma_overrun         equ     8
   284                                  ERR_dma_crossed_64k     equ     9
   285                                  
   286                                  
   287                                  ERR_media_type_not_found        equ     12	; 0Ch
   288                                  ERR_uncorrectable_CRC_error     equ     10h
   289                                  ERR_controller_failure  equ     20h
   290                                  ERR_seek_failed         equ     40h
   291                                  ERR_disk_timeout        equ     80h
   292                                  
   293                                  ERR_81			equ	81h	; fdc_ready_for_cmd, not rdy for input
   294                                  ERR_82			equ	82h	; fdc_ready_for_result, not rdy for output
   295                                  ERR_83			equ	83h	; input_result_from_fdc, after input, still busy
   296                                  ERR_84			equ	84h	; fdc_wait_seek_done, abnormal ST0_IC code
   297                                  ERR_85			equ	85h	; xfer_read_sector timeout
   298                                  ERR_86			equ	86h	; cylinder requested is invalid for drive
   299                                  ERR_87			equ	87h	; not on track 0 after recalibrate
   300                                  ERR_88			equ	88h	; wait for operation complete to be posted
   301                                  ERR_89			equ	89h	; fdc_ready_for_cmd, unexpectedly BUSY
   302                                  ERR_8A			equ	8Ah	; second "seek failed" error (ignore during Format)
   303                                  
   304                                  ERR_unknown		equ	8Fh	;   ADDED--JRC (may need to change)
   305                                  
   306                                  
   307                                  	SEGMENT	_TEXT
   308                                  %if SOFT_DEBUG > 1
   309                                  	extern  lites
   310                                  %endif
   311                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   312                                  ;  BIOS call entry for Floppy Disk driver
   313                                  ;       int  13h
   314                                  ;
   315                                  ; The Fixed Disk driver will move the vector from 13h to 40h
   316                                  ; At the moment there is no Fixed Disk Driver
   317                                  ;
   318                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   319                                  	global  BIOS_call_13h
   320                                  BIOS_call_13h:          ; Floppy driver entry
   321 00000000 FB                      	sti                     ; Enable interrupts
   322 00000001 061E60                  	pushm   all,ds,es       ; Standard register save
   323 00000004 89E5                    	mov     bp,sp           ; establish stack addressing
   324                                  
   325 00000006 FC                      	cld			; may NOT assume direction flag is clear
   326 00000007 6A40                    	push    bios_data_seg
   327 00000009 1F                      	popm	ds              ; establish addressability for all functions
   328 0000000A C606AE0000              	mov	byte [lock_count],0	; clear the lock counter
   329                                  
   330                                  %if SOFT_DEBUG & DUMP
   331                                  	pushm	ax,cx,dx,es
   332                                  
   333                                  	push	bx
   334                                  	push	es
   335                                  	xor	bh,bh
   336                                  	mov	bl,dl
   337                                  	push	bx
   338                                  	mov	bl,cl
   339                                  	push	bx
   340                                  	mov	bl,dh
   341                                  	push	bx
   342                                  	mov	bl,ch
   343                                  	push	bx
   344                                  	mov	bx,ax
   345                                  	push	bx
   346                                  	push	cs
   347                                  	push	rwvc
   348                                  	call	_cprintf
   349                                  	add	sp,18
   350                                  
   351                                  	popm	ax,cx,dx,es
   352                                  	xor	bh,bh
   353                                  %endif
   354 0000000F 88E3                    	mov     bl,ah           ; set to index into dispatch table
   355 00000011 80FC19                  	cmp     ah,max/2
   356 00000014 7202                    	jb	.1
   357 00000016 B314                    	mov	bl,14h		; fn not defined for Floppy diskette
   358 00000018 30FF                    .1:	xor     bh,bh
   359 0000001A D1E3                    	shl     bx,1            ; index words
   360 0000001C 2EFF97[3400]                cs  call    near [dispatch+bx]
   361                                  
   362                                  ; returns come here with AH set
   363                                  
   364 00000021 08E4                    	or	ah,ah		; is return code 0? sets carry=0, too
   365 00000023 7401                    	jz	exit_pops
   366                                  error_exit:
   367 00000025 F9                      	stc
   368                                  exit_pops:
   369 00000026 88660F                  	mov	[bp+offset_AH],ah	; store for return
   370 00000029 89EC                    	mov     sp,bp		; remove any allocated variables
   371                                  %if SOFT_DEBUG & DUMP
   372                                  	pushm	f	;  ,ax,bx,cx,dx,es
   373                                  	mov	al,ah		; save AH in AL
   374                                  	lahf			; get flags
   375                                  	xor	bh,bh		; Zap BH
   376                                  	mov	bl,[fdc_op_start+1]
   377                                  	push	bx
   378                                  	mov	bl,[fdc_op_start]
   379                                  	push	bx
   380                                  	mov	bl,ah
   381                                  	and	bx,1		; mask Carry
   382                                  	push	bx
   383                                  	mov	bl,al		; former AH
   384                                  	push	bx
   385                                  	push	cs		; far pointer to ...
   386                                  	push	fnret		;   format
   387                                  	call	_cprintf
   388                                  	add	sp,12
   389                                  	popm	f	; ,ax,bx,cx,dx,es
   390                                  %endif
   391 0000002B 611F07                  	popm    all,ds,es
   392 0000002E CA0200                  	retf	2			; return the carry
   393                                  
   394                                  
   395                                  
   396                                  ;fn00           ; Reset Disk System
   397                                  fn01:           ; Get Disk System Status
   398                                  ;fn02           ; Read Sector
   399                                  ;fn03           ; Write Sector
   400                                  ;fn04           ; Verify Sector
   401                                  ;fn05:           ; Format Track
   402                                  fn06:           ; Format Bad Track (fixed disk) [PC]
   403                                  fn07:           ; Format Drive (fixed disk)     [PC]
   404                                  ;fn08           ; Get Drive Parameters
   405                                  fn09:
   406                                  fn0A:
   407                                  fn0B:
   408                                  fn0C:
   409                                  fn0D:
   410                                  fn0E:
   411                                  fn0F:
   412                                  fn10:
   413                                  fn11:
   414                                  fn12:
   415                                  fn13:
   416                                  fn14:		; *** fixed disk only ***
   417                                  ;fn15:		; Get Disk Type                 [AT]
   418                                  ;fn16:           ; Get Disk Change Status (floppy)
   419                                  fn17:           ; Set Disk Type (floppy)
   420                                  ;fn18:           ; Set Media Type for Format (floppy)
   421                                  undefined:
   422 00000031 B401                    	mov     ah,ERR_invalid_command	; equ 1
   423 00000033 C3                      	ret
   424                                  
   425                                  
   426                                  dispatch:
   427 00000034 [8302]                  	dw      fn00    ; Reset Disk System
   428 00000036 [3100]                  	dw      fn01    ; 
   429 00000038 [2603]                  	dw      fn02
   430 0000003A [9203]                  	dw      fn03
   431 0000003C [FE03]                  	dw      fn04
   432 0000003E [7A04]                  	dw      fn05
   433 00000040 [3100]                  	dw      fn06
   434 00000042 [3100]                  	dw      fn07
   435 00000044 [EA02]                  	dw      fn08
   436 00000046 [3100]                  	dw      fn09
   437 00000048 [3100]                  	dw      fn0A
   438 0000004A [3100]                  	dw      fn0B
   439 0000004C [3100]                  	dw      fn0C
   440 0000004E [3100]                  	dw      fn0D
   441 00000050 [3100]                  	dw      fn0E
   442 00000052 [3100]                  	dw      fn0F
   443 00000054 [3100]                  	dw      fn10
   444 00000056 [3100]                  	dw      fn11
   445 00000058 [3100]                  	dw      fn12
   446 0000005A [3100]                  	dw      fn13
   447 0000005C [3100]                  	dw      fn14
   448 0000005E [0A05]                  	dw      fn15
   449 00000060 [2005]                  	dw      fn16
   450 00000062 [3100]                  	dw      fn17
   451 00000064 [3805]                  	dw      fn18
   452                                  max     equ     $-dispatch
   453                                  
   454                                  
   455                                  ;
   456                                  ;   Floppy Drive Types  (fn08)
   457                                  ;
   458                                  ;                               We support:
   459                                  ;       1 = 5.25" 360K 40track     yes
   460                                  ;       2 = 5.25" 1.2M 80track     yes
   461                                  ;       3 = 3.5"  720K 80track     yes
   462                                  ;       4 = 3.5" 1.44M 80track     yes
   463                                  ;       6 = 3.5" 2.88M 80track      no  (WD37C65CJM & 32Mhz osc)
   464                                  ;	7 = 3.5" 1.28M 1024sect	    no  (Japan)
   465                                  ;
   466                                  ;   Floppy Combos
   467                                  ;       5 = 5.25" 360K 40track in Drive Type 2   	no
   468                                  ;	8 = 5.25" 512k 77track/128sector in Drv 2	(future) CP/M
   469                                  ;	9 = 3.5" 256k 77track/128sector in Drv 3	(future) CP/M
   470                                  ;      10 = 3.5" 512k 77track/128sector in Drv 4	(future) CP/M
   471                                  ;;
   472                                  
   473                                  D_table:
   474 00000066 0000                    	dw      0
   475 00000068 [7C00]                  	dw      DTAB1	; 360K	(MFM)
   476 0000006A [8900]                  	dw      DTAB2	; 1.2M
   477 0000006C [9600]                  	dw      DTAB3	; 720K
   478 0000006E [A300]                  	dw      DTAB4	; 1.44M
   479 00000070 0000                    	dw      0; DTAB5
   480 00000072 0000                    	dw      0; DTAB6
   481 00000074 [CA00]                  	dw      DTAB7	; 1024 byte sectors (Japan)
   482 00000076 [D700]                  	dw      DTAB8	; CP/M 26/77 in 1.2M drive	(128 byte FM sectors)
   483 00000078 [E400]                  	dw      DTAB9	; CP/M 13/77 in 720K drive
   484 0000007A [F100]                  	dw      DTAB10	; CP/M 26/77 in 1.44M drive
   485                                  L_table         equ     ($ - D_table)/2
   486                                  
   487                                  
   488                                  ;   Disk Information
   489                                  ;               specify  off   N  R  gp   DTL   gp3  fill  unk  on cyl clk
   490                                  ;;; The DOS MFM floppies
   491                                  ; 360K 5.25" DD floppy
   492 0000007C DF022502092AFF50F6-     DTAB1:  db      0DFh, 2, 25h,  2, 9, 2Ah, 0FFh, 50h, 0F6h, 0Fh, 8, 39, 80h
   492 00000085 0F082780           
   493                                  
   494                                  ; 1.2M 5.25" HD floppy
   495 00000089 DF0225020F1BFF54F6-     DTAB2:  db      0DFh, 2, 25h,  2, 15, 1Bh, 0FFh, 54h, 0F6h, 0Fh, 8, 79, 00h
   495 00000092 0F084F00           
   496                                  
   497                                  ; 720K 3.5" or 5.25" DD floppy
   498 00000096 DF022502092AFF50F6-     DTAB3:  db      0DFh, 2, 25h,  2, 9, 2Ah, 0FFh, 50h, 0F6h, 0Fh, 8, 79, 80h
   498 0000009F 0F084F80           
   499                                  
   500                                  ; 1.44M 3.5" HD floppy
   501 000000A3 AF022502121BFF6CF6-     DTAB4:  db      0AFh, 2, 25h,  2, 18, 1Bh, 0FFh, 6Ch, 0F6h, 0Fh, 8, 79, 00h
   501 000000AC 0F084F00           
   502                                  
   503                                  ; 360K 5.25" DD floppy in 1.2M HD drive
   504 000000B0 DF022502092AFF50F6-     DTAB5:	db	0DFh, 2, 25h,  2, 9, 2Ah, 0FFh, 50h, 0F6h, 0Fh, 8, 39, 40h
   504 000000B9 0F082740           
   505                                  
   506                                  ; 2.88M 3.5" XD floppy
   507 000000BD AF022502241BFF50F6-     DTAB6:	db      0AFh, 2, 25h,  2, 36, 1Bh, 0FFh, 50h, 0F6h, 0Fh, 8, 79, 0C0h
   507 000000C6 0F084FC0           
   508                                  
   509                                  ; 1.28M 3.5" HD floppy with 1K sectors (Japan)
   510 000000CA AF0225030835FF74F6-     DTAB7:	db	0AFh, 2, 25h,  3,  8, 35h, 0FFh, 74h, 0F6h, 0Fh, 8, 79, 00h
   510 000000D3 0F084F00           
   511                                  
   512                                  ;               specify  off   N  R  gp   DTL   gp3  fill  unk  on cyl clk
   513                                  ;;; The CP/M FM floppies
   514                                  ; 500K 5.25" CP/M (FM) floppy in 1.2M drive
   515 000000D7 DF0225001A098023E5-     DTAB8:  db      0DFh, 2, 25h,  0, 26,  9, 80h, 35, 0E5h, 0Fh, 8, 76, 00h
   515 000000E0 0F084C00           
   516                                  ;;;				       7h      1Bh
   517                                  
   518                                  ; 250K 3.5" CP/M (FM) floppy in 720K drive
   519 000000E4 DF0225000D138046E5-     DTAB9:  db      0DFh, 2, 25h,  0, 13, 19, 80h, 70, 0E5h, 0Fh, 8, 76, 80h
   519 000000ED 0F084C80           
   520                                  
   521                                  ; 500K 3.5" CP/M (FM) floppy in 1.44M drive
   522 000000F1 AF0225001A15804BE5-     DTAB10: db      0AFh, 2, 25h,  0, 26, 21, 80h, 75, 0E5h, 0Fh, 8, 76, 00h
   522 000000FA 0F084C00           
   523                                  
   524                                  
   525                                  ; DTAB table offsets
   526                                  DTAB_specify    	equ     0
   527                                  DTAB_specify2   	equ     DTAB_specify+1
   528                                  DTAB_turnoff_ticks	equ     DTAB_specify2+1
   529                                  DTAB_N_param    	equ     DTAB_turnoff_ticks+1
   530                                  DTAB_EOT_nsect  	equ     DTAB_N_param+1
   531                                  DTAB_rw_gap     	equ     DTAB_EOT_nsect+1
   532                                  DTAB_data_len   	equ     DTAB_rw_gap+1
   533                                  DTAB_fmt_gap3   	equ     DTAB_data_len+1
   534                                  DTAB_fmt_fill   	equ     DTAB_fmt_gap3+1
   535                                  DTAB_unknown    equ     DTAB_fmt_fill+1
   536                                  DTAB_startup		equ     DTAB_unknown+1	; in 1/8 seconds
   537                                  DTAB_max_cylinder	equ     DTAB_startup+1
   538                                  DTAB_control    equ     DTAB_max_cylinder+1
   539                                  
   540                                  
   541                                  
   542                                  ;
   543                                  ; Returns:
   544                                  ;	AL = contents of FDC_MSR  (Main Status Register)
   545                                  ;
   546                                  get_msr:
   547 000000FE 52                      	push	dx
   548 000000FF BA0006                  	mov     dx,FDC_MSR
   549 00000102 EC                      	in      al,dx
   550                                  %if SOFT_DEBUG > 1
   551                                  	push    ax
   552                                  	call    lites
   553                                  %endif
   554 00000103 5A                      	pop	dx
   555 00000104 C3                      	ret
   556                                  
   557                                  ; delay for about 12 microseconds for MSR to be set
   558                                  	extern  microsecond
   559                                  	global  wait12
   560                                  wait12:
   561 00000105 51                      	push    cx
   562                                  %if 1
   563                                  ;	mov	cx,12		; 12 microseconds
   564 00000106 30ED                    	xor	ch,ch
   565 00000108 8A0EFF00                	mov	cl,[cpu_xtal]	; 2x clock (32usec on 16Mhz CPU)
   566 0000010C D0E9                    	shr	cl,1
   567 0000010E 83E905                  	sub	cx,5		; fudge factor for overhead
   568                                  %else
   569                                  	xor	ch,ch
   570                                  	mov	cl,[wait12_count]
   571                                  %endif
   572 00000111 E8(0000)                	call    microsecond
   573 00000114 59                      	pop     cx
   574 00000115 C3                      	ret
   575                                  
   576                                  
   577                                  wait1000:
   578 00000116 51                      	push	cx
   579 00000117 B9E803                  	mov	cx,1000		; 1 ms delay
   580 0000011A E8(0000)                	call	microsecond
   581 0000011D 59                      	pop	cx
   582 0000011E C3                      	ret
   583                                  
   584                                  ;
   585                                  ;  Convention used below
   586                                  ;     Flags:           Meaning:
   587                                  ;       C=1             error
   588                                  ;       C=0, AH=0       okay
   589                                  ;       C=0, AH=3+      complete
   590                                  ;
   591                                  	global  fdc_ready_for_command
   592                                  fdc_ready_for_command:
   593 0000011F 51                      	push	cx
   594                                  
   595                                  .0:
   596 00000120 B9E803                  	mov	cx,1000
   597 00000123 E8DFFF                  .1:	call	wait12
   598 00000126 E8D5FF                  	call    get_msr
   599 00000129 A880                    	test    al,RQM 		; C=0
   600 0000012B E1F6                    	loopz	.1
   601                                  ; try to compensate for MSDOS anomaly with a BUSY test
   602 0000012D 7508                    	jnz	.req
   603 0000012F A810                    	test	al,BUSY		; How does MSDOS manage this???
   604 00000131 74ED                    	jz      .0
   605 00000133 B489                    	mov	ah,ERR_89
   606 00000135 EB06                    	jmp	.err
   607                                  
   608                                  .req:
   609 00000137 A840                    	test    al,DIO          ; C=0,	clear the carry
   610 00000139 7405                    	jz     .2               ; ready for input?
   611 0000013B B481                    	mov	ah,ERR_81	; not ready for input
   612 0000013D F9                      .err:	Error			; C=1, signal error
   613 0000013E EB02                    	jmp	.99
   614                                  
   615 00000140 30E4                    .2:	Okay			; AH=0, C=0
   616 00000142 59                      .99:	pop	cx
   617 00000143 C3                      	ret
   618                                  ; returns Error or Okay
   619                                  
   620                                  
   621                                  	global  fdc_ready_for_result
   622                                  fdc_ready_for_result:
   623 00000144 E8BEFF                  	call    wait12
   624 00000147 E8B4FF                  	call    get_msr
   625 0000014A A810                    	test    al,BUSY         ; controller busy?
   626 0000014C 7505                    	jnz	.0 		; jump if busy
   627 0000014E 80CC03                  	Complete		; not busy, return Complete
   628 00000151 EB15                    	jmp	.99
   629                                  .0:
   630 00000153 E8AFFF                  	call	wait12
   631 00000156 E8A5FF                  .1:	call    get_msr
   632 00000159 A880                    	test    al,RQM          ; wait for RQM
   633 0000015B 74F9                    	jz      .1
   634                                  
   635 0000015D A840                    	test    al,DIO		; set C=0, Z-flag
   636 0000015F 7505                    	jnz     .5		; DIO==1 means output
   637 00000161 B482                    	mov	ah,ERR_82
   638 00000163 F9                      	Error
   639 00000164 EB02                    	jmp	.99
   640                                  
   641 00000166 30E4                    .5:	Okay
   642 00000168 C3                      .99:	ret
   643                                  ; returns Error, Okay, or Complete
   644                                  
   645                                  
   646                                  
   647                                  ; byte to output is in AL
   648                                  ; AH=0 and Carry=0 if all Okay
   649                                  ; Carry=1, AH=code if FDC not ready
   650                                  	global  output_byte_to_fdc
   651                                  output_byte_to_fdc:
   652 00000169 52                      	pushm	dx
   653                                  
   654 0000016A 88C2                    	mov	dl,al
   655 0000016C E8B0FF                  	call    fdc_ready_for_command
   656 0000016F 88D0                    	mov	al,dl
   657 00000171 7206                    	jc      .8              ; propagate error
   658                                  
   659 00000173 BA0106                  	mov     dx,FDC_DATA
   660 00000176 EE                      	out     dx,al
   661 00000177 30E4                    	Okay			; C=0, AH=okay
   662                                  .8:     
   663 00000179 5A                      	popm	dx
   664 0000017A C3                      	ret                     ; C=0, AH=okay
   665                                  ; returns Error or Okay
   666                                  
   667                                  
   668                                  	global  input_byte_from_fdc
   669                                  input_byte_from_fdc:
   670 0000017B 52                      	push	dx
   671 0000017C E8C5FF                  	call    fdc_ready_for_result
   672 0000017F 7208                    	jc      .9              ; propagate error
   673 00000181 7506                    	jnz	.9		; if (Complete) return Complete;
   674                                  
   675 00000183 BA0106                  	mov     dx,FDC_DATA
   676 00000186 EC                      	in      al,dx
   677 00000187 30E4                    	Okay			; return Okay
   678                                  .9:     
   679 00000189 5A                      	pop	dx
   680 0000018A C3                      	ret                     ;
   681                                  ; returns Error, Okay, or Complete
   682                                  
   683                                  
   684                                  ;  CX = length of command
   685                                  ;  DX:SI = pointer to command (not DS:SI, we'll set this up)
   686                                  ;  
   687                                  	global  output_cmd_to_fdc
   688                                  output_cmd_to_fdc:
   689 0000018B 0656                    	pushm   si,es
   690 0000018D 8EC2                    	mov     es,dx           ; DS:SI is now the source
   691                                  	cnop
   692                                  
   693                                  %if SOFT_DEBUG & DUMP
   694                                    es	mov	al,[si]			; record two bytes of command
   695                                    	mov	[fdc_op_start],al
   696                                    es	mov	al,[si+1]		; first & second
   697                                    	mov	[fdc_op_start+1],al
   698                                  %endif
   699                                  
   700 0000018F E8E806                  	call	@disable
   701                                  .1:
   702 00000192 26AC                      es	lodsb			; note segment override
   703 00000194 E8D2FF                  	call    output_byte_to_fdc  ; returns error or okay
   704 00000197 7206                    	jc      .7              ; propagate any error
   705 00000199 E2F7                    	loop    .1
   706                                  
   707 0000019B 30E4                    	Okay			; return ok
   708 0000019D EB01                    	jmp	.9
   709                                  
   710 0000019F F9                      .7:	Error			; propagate error
   711                                  
   712 000001A0 E8E606                  .9:	call	@enable
   713 000001A3 5E07                    	popm	si,es
   714 000001A5 C3                      	ret
   715                                  ; returns Error or Okay
   716                                  
   717                                  
   718                                  
   719                                  ; assumes DS points at BIOS Data Area
   720                                  ; preserves DI
   721                                  	global  input_result_from_fdc
   722                                  input_result_from_fdc:
   723 000001A6 5157                    	pushm   di,cx
   724 000001A8 E8CF06                  	call	@disable	; lock the operation
   725                                  
   726 000001AB BF4200                  	mov     di,fdc_ctrl_status      ; in BIOS Data Area
   727 000001AE B90800                  	mov     cx,8            ; 7 bytes input, then 'complete'
   728                                  
   729 000001B1 E8C7FF                  .0:     call    input_byte_from_fdc
   730 000001B4 7217                    	jc      .9              ; propagate error
   731 000001B6 7511                    	jnz     .8              ; if complete, return okay
   732                                  
   733 000001B8 8805                    	mov     byte [di],al    ; store the result
   734 000001BA 47                      	inc     di
   735 000001BB E2F4                    	loop    .0
   736                                  
   737 000001BD E845FF                  	call	wait12		;
   738 000001C0 E83BFF                  	call	get_msr		; check for busy
   739 000001C3 A810                    	test	al,BUSY
   740                                  
   741 000001C5 B483                    	mov	ah,ERR_83
   742 000001C7 7504                    	jnz	.95		; return error if busy
   743                                  
   744                                  .8:
   745 000001C9 30E4                    	Okay			; return okay
   746 000001CB EB01                    	jmp	.99		; single return point
   747                                  
   748                                  .9:
   749 000001CD F9                      .95:	Error			; return error;
   750                                  
   751 000001CE E8B806                  .99:	call	@enable		; unlock the operation
   752 000001D1 5F59                    	popm	di,cx
   753 000001D3 C3                      	ret
   754                                  ; returns Error, Okay, or Complete
   755                                  
   756                                  
   757                                  %define INT_ENABLE 1
   758                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   759                                  ; 
   760                                  ;  Floppy Disk Controller
   761                                  ;               Interrupt Handler
   762                                  ;
   763                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   764                                  	global  fdc_interrupt_level
   765                                  fdc_interrupt_level:
   766                                  %if INT_ENABLE
   767 000001D4 FB                      	sti
   768                                  %endif
   769 000001D5 1E60                    	pushm   all,ds
   770 000001D7 FC                      	cld                     ; just be sure
   771                                  	
   772 000001D8 6A40                    	push    bios_data_seg
   773 000001DA 1F                      	popm    ds
   774                                  %if INT_ENABLE==0
   775                                  	inc	byte [lock_count]	; so we don't re-enable
   776                                  %endif
   777 000001DB E820FF                  	call    get_msr
   778 000001DE A810                    	test    al,BUSY         ; test for controller busy
   779 000001E0 740A                    	jz      .4
   780                                  ; BUSY is set
   781 000001E2 E8C1FF                  	call    input_result_from_fdc
   782 000001E5 18C0                    	sbb     al,al           ; carry to AL
   783 000001E7 A24100                  	mov     byte [fdc_status],al    ; FF=error, 0=okay 
   784 000001EA EB2C                    	jmp     .9              ; we got the results
   785                                  
   786                                  
   787                                  ; FDC not busy:
   788                                  
   789                                  .4:
   790                                  ;;        xor     bh,bh           ; BH = false
   791 000001EC B008                    .5:     mov     al,CMD_SENSE_INT_STATUS
   792 000001EE E878FF                  	call    output_byte_to_fdc
   793 000001F1 7225                    	jc      .9              ; quit if error
   794 000001F3 E8B0FF                  	call    input_result_from_fdc
   795 000001F6 7220                    	jc      .9
   796                                  
   797 000001F8 A04200                  	mov	al,[fdc_ctrl_status]	; get ST0
   798 000001FB 3480                    	xor	al,80h			; IC= 10xxxxxxb (invalid)
   799 000001FD 24C0                    	and	al,ST0_IC		; isolate IC
   800 000001FF 7417                    	je	.9			; invalid command
   801                                  
   802 00000201 A14200                  	mov	ax,[fdc_ctrl_status]	; get ST0 + PCN (present cylinder)
   803 00000204 A820                    	test	al,ST0_SE		; test Seek End condition
   804 00000206 74E4                    	jz	.5
   805                                  
   806 00000208 89C7                    	mov	di,ax			;
   807 0000020A 83E701                  	and	di,ST0_US		; isolate unit number
   808 0000020D 88A59400                	mov	[fdc_cylinder+di],ah	; set PCN from controller
   809 00000211 800E3E0004              	or	byte [fdc_drv_calib],04h     ;POST Seek End seen
   810 00000216 EBD4                    	jmp     .5
   811                                  
   812                                  
   813                                  .9:
   814 00000218 800E3E0001              	or	byte [fdc_drv_calib],01h     ;POST end of FDC interrupt
   815                                  %if INT_ENABLE==0
   816                                  	dec	byte [lock_count]	; restore the lock count
   817                                  %endif
   818                                  ; signal EOI (End of Interrupt)
   819 0000021D BA22FF                  	mov     dx,PIC_EOI              ; EOI register
   820 00000220 B80080                  	mov     ax,EOI_NSPEC            ; non-specific
   821 00000223 EF                      	out     dx,ax                   ; signal it
   822                                  	
   823 00000224 611F                    	popm    all,ds
   824 00000226 CF                      	iret
   825                                  
   826                                  
   827                                  
   828                                  	global  fdc_timer_hook
   829                                  ; called from Timer Tick code with DS->BIOS data area
   830                                  ; Destroys AX and DX
   831                                  	global  fdc_timer_hook
   832                                  fdc_timer_hook:
   833 00000227 803E400000              	cmp     byte [fdc_motor_ticks],0
   834 0000022C 740E                    	je      .9
   835 0000022E FE0E4000                	dec     byte [fdc_motor_ticks]
   836 00000232 7508                    	jnz     .9
   837                                  ; timer expired, stop the motors
   838 00000234 80263F00CF              	and     byte [fdc_motor_LDOR],~(MOEN1+MOEN2)
   839 00000239 E80100                  	call    out_LDOR_mem
   840 0000023C C3                      .9:     ret
   841                                  
   842                                  
   843                                  
   844                                  ; FDC Operations Register operations
   845                                  ; put out the LDOR write-only register
   846                                  ;  Assumes DS is BIOS data segment
   847                                  ; Destroys AX and DX
   848                                  out_LDOR_mem:
   849 0000023D A03F00                  	mov     al,[fdc_motor_LDOR]
   850 00000240 BA2006                  	mov     dx,FDC_LDOR
   851 00000243 EE                      	out     dx,al
   852 00000244 C3                      	ret
   853                                  
   854                                  
   855                                  ; wait until all seeking is done
   856                                  ; assumes DS is set to BIOS data area
   857                                  ;
   858                                  	global  fdc_wait_seek_done
   859                                  fdc_wait_seek_done:
   860                                  .1:     
   861 00000245 E8BDFE                  	call    wait12
   862 00000248 E8B3FE                  	call    get_msr
   863 0000024B A80F                    	test    al,0Fh          ; test all the seek bits
   864 0000024D 740C                    	jz      .8
   865 0000024F 803E400000              	cmp     byte [fdc_motor_ticks],0
   866 00000254 75EF                    	jnz     .1
   867 00000256 B480                    	mov	ah,ERR_disk_timeout
   868 00000258 F9                      .7:     Error			; signal error
   869 00000259 EB22                    	jmp	.9
   870                                  
   871                                  .8:     ; seek is done, check ST0 bits
   872 0000025B F6063E0004              	test	byte [fdc_drv_calib],04h	; Seek End seen?
   873 00000260 7512                    	jnz	.okay
   874                                  
   875 00000262 F6064200C0              	test    byte [fdc_ctrl_status],ST0_IC   ; interrupt code
   876 00000267 B484                    	mov	ah,ERR_84
   877 00000269 75ED                    	jnz     .7
   878 0000026B F606420020              	test    byte [fdc_ctrl_status],ST0_SE   ; Seek End
   879 00000270 B440                    	mov	ah,ERR_seek_failed
   880 00000272 74E4                    	jz      .7
   881                                  .okay:
   882                                  
   883                                  %if 0
   884                                  ; add settle time -- may not really be needed
   885                                  	mov	al,[fdc_motor_ticks]
   886                                  	add	al,450/54
   887                                  	xchg	al,[fdc_motor_ticks]
   888                                  .settle:
   889                                  	cmp	[fdc_motor_ticks],al
   890                                  	ja	.settle
   891                                  %else
   892                                  ; add time for more revolutions if a seek occurs
   893 00000274 2E8A4702                  cs	mov	al,[DTAB_turnoff_ticks+bx]
   894 00000278 A24000                    	mov	[fdc_motor_ticks],al
   895                                  %endif
   896                                  
   897 0000027B 30E4                    	Okay					; IC==00 and SE=1
   898 0000027D C3                      .9	ret
   899                                  
   900                                  ;
   901                                  ;  power on init
   902                                  ;
   903                                  	global  @floppy_init
   904                                  @floppy_init:
   905 0000027E B400                    	mov     ah,0            ; fn00
   906 00000280 CD13                    	int     13h
   907 00000282 C3                      	ret
   908                                  
   909                                  
   910                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   911                                  ;  Function 00h         Reset the Disk System
   912                                  ;       Used both at power on and after a serious error
   913                                  ;
   914                                  ;  Enter with:
   915                                  ;       AH = 00h
   916                                  ;       DL = drive 0 or 1
   917                                  ;
   918                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   919                                  fn00:
   920 00000283 B81700                  	mov     ax,0017h        ; LTM=1, MSK=0, PRI=7    (07h for LTM=0)
   921 00000286 BA3EFF                  	mov     dx,fdc_int_control
   922 00000289 EF                      	out     dx,ax           ; enable interrupt controller
   923 0000028A C606AD0020              	mov	byte [wait12_count],32	; this is about the max.
   924                                  
   925 0000028F E873FE                  	call    wait12          ; wait 12 microseconds
   926 00000292 E869FE                  	call    get_msr         ; set BASE mode
   927 00000295 E86DFE                  	call    wait12          ; wait 12 microseconds
   928                                  
   929 00000298 C6063F0008              	mov     byte [fdc_motor_LDOR],(MODE + RESET + DMAEN)         ; set PC_AT mode
   930 0000029D E89DFF                  	call    out_LDOR_mem
   931 000002A0 E862FE                  	call    wait12
   932                                  
   933                                  %if 1
   934                                  ;;; This read may not be necessary, unless Special Mode is set
   935 000002A3 BA3006                  	mov     dx,FDC_LDCR
   936 000002A6 EC                      	in      al,dx           ; read a write-only register to latch Mode
   937                                  ;;;;;
   938                                  %endif
   939 000002A7 E86CFE                  	call	wait1000
   940                                  
   941 000002AA 800E3F000C              	or	byte [fdc_motor_LDOR],(MODE + NO_RESET + DMAEN)      ; remove the RESET
   942 000002AF E88BFF                  	call    out_LDOR_mem
   943 000002B2 E850FE                  	call	wait12
   944                                  
   945                                  %if 0
   946                                  	mov     dx,FDC_LDCR
   947                                  	mov     al,FDC_HD               ; set for HD disks
   948                                  	out     dx,al
   949                                  %endif
   950                                  
   951 000002B5 BACAFF                  	mov	dx,DMA0+DMACW
   952                                  %if 1
   953 000002B8 B80400                  	mov	ax,4			; set change bit
   954                                  %else
   955                                  	in	ax,dx
   956                                  	and	ax,~2			; clear the stop bit
   957                                  	or	ax,4			; set the change bit
   958                                  %endif
   959 000002BB EF                      	out	dx,ax
   960                                  
   961 000002BC BA34FF                  	mov     dx,PIC_DMA0CR
   962 000002BF B80700                  	mov     ax,0007h        ; MSK=0, PRI=7
   963 000002C2 EF                      	out     dx,ax           ; enable DMA0 interrupts
   964                                  
   965 000002C3 31C0                    	xor	ax,ax
   966 000002C5 A24000                  	mov	[fdc_motor_ticks],al	; Zero the timer tick counter
   967 000002C8 A28B00                  	mov	[fdc_last_rate],al	; force a specify command
   968                                  
   969 000002CB 8EC0                    	mov	es,ax
   970                                  	cnop
   971 000002CD 26A37800                  es	mov	[1Eh*4],ax
   972 000002D1 26A37A00                  es	mov	[1Eh*4+2],ax		; Zap the parameter pointer
   973                                  
   974 000002D5 C7069400FFFF            	mov	word [fdc_cylinder],-1	; Specify & Recalibration needed
   975                                  ;***	mov	[fdc_cylinder+1],-1	; done by above instruction
   976                                  
   977                                  ; now allow time for the polling interrupts
   978 000002DB B90100                  	mov	cx, 102400>>16		; 0.1 seconds
   979 000002DE 31D2                    	xor	dx,dx			; CX:DX is delay in usec
   980 000002E0 B486                    	mov	ah,86h			; delay in microseconds
   981 000002E2 CD15                    	int	15h
   982                                  
   983 000002E4 E8BFFE                  	call	input_result_from_fdc
   984                                  
   985 000002E7 30E4                    	Okay			; signal good execution
   986 000002E9 C3                      	ret			; end of FN00
   987                                  
   988                                  
   989                                  
   990                                  
   991                                  
   992                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   993                                  ;  Function 08h         Get Drive Parameters
   994                                  ;
   995                                  ;  Enter with:
   996                                  ;       AH = 08h
   997                                  ;       DL = drive 0 or 1
   998                                  ;
   999                                  ;  Return with:
  1000                                  ;       Carry clear if no error
  1001                                  ;       BL = drive type (2 or 4 for us)
  1002                                  ;       CH = max cylinder number
  1003                                  ;       CL = max sector number
  1004                                  ;       DH = max head number
  1005                                  ;       DL = number of drives
  1006                                  ;       ES:DI = address of disk parameter table
  1007                                  ;
  1008                                  ;       Carry set on error
  1009                                  ;       AH = error code
  1010                                  ;
  1011                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1012                                  fn08:           ; Get Drive Parameters
  1013 000002EA A01000                  	mov	al,[equipment_flag]
  1014 000002ED B401                    	mov	ah,1
  1015 000002EF 20C4                    	and	ah,al			; any floppies at all?
  1016 000002F1 7407                    	jz	.2
  1017 000002F3 C0C002                  	rol	al,2			; at least one
  1018 000002F6 2403                    	and	al,3
  1019 000002F8 00C4                    	add	ah,al			; 1..4
  1020                                  .2:
  1021 000002FA 88660A                  	mov	[offset_DL+bp],ah		; return # of drives
  1022 000002FD E89302                  	call	check_DL
  1023 00000300 7221                    	jc	.err_no_drive
  1024 00000302 E8A502                  	call	get_disk_type
  1025 00000305 884608                  	mov	[offset_BL+bp],al		; return BL = disk type
  1026 00000308 E8AE02                  	call	get_media
  1027 0000030B 2E8A670B                  cs	mov	ah,[DTAB_max_cylinder+bx]
  1028 0000030F 2E8A4704                  cs	mov	al,[DTAB_EOT_nsect+bx]
  1029 00000313 89460C                    	mov	[offset_CX+bp],ax		; return CYL | SECT in CX
  1030 00000316 C6460B01                	mov	byte [offset_DH+bp],1		; head max. always 1
  1031 0000031A 8C4E12                  	mov	[offset_ES+bp],cs		; return ES  param table
  1032 0000031D 895E00                  	mov	[offset_DI+bp],bx		; return DI  param table
  1033                                  
  1034 00000320 30E4                    	xor	ah,ah				; no error
  1035 00000322 C3                      	ret
  1036                                  
  1037                                  .err_no_drive:
  1038 00000323 B401                    	mov	ah,ERR_invalid_command		; error if no floppies
  1039 00000325 C3                      	ret					; DL is still zero !!!
  1040                                  
  1041                                  
  1042                                  
  1043                                  
  1044                                  
  1045                                  
  1046                                  %if 0
  1047                                  ; validate the READ/WRITE CHS,SC parameters
  1048                                  ;       Enter with DI pointing at the type table
  1049                                  ;
  1050                                  ;  Carry clear if okay
  1051                                  ;  Carry set if invalid
  1052                                  ;       AX & all other registers are preserved
  1053                                  validate_call:
  1054                                  	push    ax
  1055                                  
  1056                                     cs   cmp     ch,[DTAB_max_cyl+di]
  1057                                  	jnbe    .7
  1058                                     cs   mov     ah,[DI_heads+di]
  1059                                  	sub     ah,dh
  1060                                  	jbe     .7
  1061                                     cs   mov     al,[DTAB_EOT_nsect+di]
  1062                                  	dec     cl      ; base sectors at 0
  1063                                  	cmp     cl,al
  1064                                  	jnc     .6      ; JNC = JNB = JAE
  1065                                  	mul     ah
  1066                                  ; AX is 1 or 2 * sectors
  1067                                  	sub     al,cl
  1068                                  ; AL is the maximum number of sectors we can transfer
  1069                                  	cmp     al,[offset_AX+bp]       ; compare to sector count
  1070                                  .6:     inc     cl      ; back to sectors from 1
  1071                                  	jnc     .8      ; JAE = JNB = JNC
  1072                                  .7:     stc
  1073                                  .8:     pop     ax      ;
  1074                                  	ret
  1075                                  %endif
  1076                                  
  1077                                  
  1078                                  
  1079                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1080                                  ;  Function 02h         Read Sectors
  1081                                  ;  Function 03h         Write Sectors
  1082                                  ;  Function 04h         Verify Sectors
  1083                                  ;
  1084                                  ;  Enter with:
  1085                                  ;       AH = 02h (read)
  1086                                  ;       AH = 03h (write)
  1087                                  ;       AH = 04h (verify)
  1088                                  ;       AL = number of sectors to transfer
  1089                                  ;       CH = cylinder number
  1090                                  ;       CL = sector number
  1091                                  ;       DH = head number
  1092                                  ;       DL = drive 0 or 1
  1093                                  ;       ES:BX = buffer to read into or write from
  1094                                  ;
  1095                                  ;  Return with:
  1096                                  ;       Carry clear if no error
  1097                                  ;       AH = 0
  1098                                  ;       AL = number of sectors transferred
  1099                                  ;
  1100                                  ;       Carry set on error
  1101                                  ;       AH = error code
  1102                                  ;
  1103                                  ;       All other registers are preserved.
  1104                                  ;
  1105                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1106                                  ;
  1107                                  ;  Stack variables
  1108                                  ;
  1109                                  rwv_return	equ	-2	; offset from BP
  1110                                  rwv_dma		equ	rwv_return - 2
  1111                                  rwv_xfer	equ	rwv_dma - 2
  1112                                  rwv_cmd		equ	rwv_xfer - 9
  1113                                  rwv_AL		equ	rwv_cmd - 1
  1114                                  rwv_stack	equ	- rwv_AL
  1115                                  
  1116                                  ;FDC_DMA_READ	equ (101b<<13)+(011b<<10)+(11b<<8)+(01b<<6)+(00b<<4)+0110b
  1117                                  FDC_DMA_READ	equ (101b<<13)+(000b<<10)+(11b<<8)+(01b<<6)+(10b<<4)+0110b
  1118                                  
  1119                                  ;FDC_DMA_WRITE	equ (011b<<13)+(101b<<10)+(11b<<8)+(10b<<6)+(00b<<4)+0110b
  1120                                  FDC_DMA_WRITE	equ (000b<<13)+(101b<<10)+(11b<<8)+(10b<<6)+(10b<<4)+0110b
  1121                                  
  1122                                  ;FDC_DMA_READ	equ (101b<<13)+(000b<<10)+(11b<<8)+(01b<<6)+(10b<<4)+0110b
  1123                                  FDC_DMA_SCAN	equ (100b<<13)+(000b<<10)+(11b<<8)+(01b<<6)+(10b<<4)+0110b
  1124                                  
  1125                                  FDC_DMA_FORMAT	equ	FDC_DMA_WRITE
  1126                                  
  1127                                  
  1128                                  %if SOFT_DEBUG
  1129                                  	dw	FDC_DMA_READ
  1130                                  	dw	FDC_DMA_WRITE
  1131                                  	dw	FDC_DMA_SCAN
  1132                                  %endif
  1133                                  
  1134                                  fn02:	; READ
  1135                                  
  1136                                  
  1137                                  %if FRONT_PANEL
  1138 00000326 50                      	PUSH AX
  1139 00000327 53                      	PUSH BX
  1140 00000328 51                      	PUSH CX
  1141 00000329 52                      	PUSH DX
  1142 0000032A 1E                      	PUSH 	DS
  1143 0000032B 8B1EE000                	MOV  BX,[fx83]
  1144 0000032F 53                      	PUSH BX
  1145 00000330 8B1EE200                	MOV  BX,[fx83+2]
  1146 00000334 53                      	PUSH BX
  1147 00000335 8B1EE400                	MOV  BX,[fx83+4]
  1148 00000339 53                      	PUSH BX
  1149 0000033A 8B1EE600                	MOV  BX,[fx83+6]
  1150 0000033E 53                      	PUSH BX
  1151                                  
  1152 0000033F 6A40                         	push    0X40
  1153 00000341 1F                              pop     ds              ; Source
  1154 00000342 51                              push 	cx
  1155                                  
  1156                                  
  1157 00000343 B386                    	mov  BL,0x86		; "I."
  1158 00000345 B701                    	mov  BH,1		; "-"   	
  1159 00000347 891EE000                	mov  [fx83],BX		
  1160                                  
  1161 0000034B 88F0                    	MOV  AL,DH 		; HEAD
  1162 0000034D B101                    	mov  cl,01
  1163 0000034F BAE000                  	mov  dx,fx83		;    	
  1164 00000352 B452                        	mov  ah, 0x52       	; ah=0x51 - "Write BUFFER TO FRONT PANEL"    	
  1165 00000354 CD15                        	INT  0x15  		;
  1166                                  
  1167 00000356 59                          	pop  cx
  1168 00000357 51                          	push cx
  1169 00000358 88E8                    	MOV  AL,ch 		; cyl
  1170 0000035A B102                    	mov  cl,02
  1171 0000035C BAE000                  	mov  dx,fx83		;    	
  1172 0000035F B452                        	mov  ah, 0x52       	; ah=0x51 - "Write BUFFER TO FRONT PANEL"    	
  1173 00000361 CD15                        	INT  0x15  		;
  1174                                  
  1175 00000363 59                          	pop  cx
  1176 00000364 88C8                    	MOV  AL,cl 		; sec
  1177 00000366 B103                    	mov  cl,03
  1178 00000368 BAE000                  	mov  dx,fx83		;    	
  1179 0000036B B452                        	mov  ah, 0x52       	; ah=0x51 - "Write BUFFER TO FRONT PANEL"    	
  1180 0000036D CD15                        	INT  0x15  		;
  1181                                  
  1182 0000036F 5B                          	pop BX
  1183 00000370 891EE600                	MOV [fx83+6],BX
  1184 00000374 5B                      	POP BX
  1185 00000375 891EE400                	MOV [fx83+4],BX
  1186 00000379 5B                      	POP BX
  1187 0000037A 891EE200                	MOV [fx83+2],BX
  1188 0000037E 5B                      	POP BX
  1189 0000037F 891EE000                	MOV [fx83],BX
  1190                                  
  1191 00000383 1F                          	pop 	DS
  1192 00000384 5A                          	pop     DX
  1193 00000385 59                          	POP     CX
  1194 00000386 5B                          	POP     BX
  1195 00000387 58                          	POP     AX
  1196                                  
  1197                                  %endif
  1198                                  
  1199                                  
  1200                                  
  1201                                  
  1202                                  
  1203                                  
  1204                                  
  1205 00000388 B4E6                    	mov	ah,(CMD_READ_DATA | CMD_MT | CMD_MF | CMD_SK)
  1206 0000038A BF66A3                  	mov	di,FDC_DMA_READ
  1207 0000038D BB[9B06]                	mov	bx,xfer_read_sector
  1208 00000390 EB74                    	jmp	rwv_common
  1209                                  
  1210                                  %define EXTRA 0
  1211                                  fn03:	; WRITE
  1212                                  
  1213                                  %if FRONT_PANEL
  1214 00000392 50                      	PUSH AX
  1215 00000393 53                      	PUSH BX
  1216 00000394 51                      	PUSH CX
  1217 00000395 52                      	PUSH DX
  1218 00000396 1E                      	PUSH 	DS
  1219 00000397 8B1EE000                	MOV  BX,[fx83]
  1220 0000039B 53                      	PUSH BX
  1221 0000039C 8B1EE200                	MOV  BX,[fx83+2]
  1222 000003A0 53                      	PUSH BX
  1223 000003A1 8B1EE400                	MOV  BX,[fx83+4]
  1224 000003A5 53                      	PUSH BX
  1225 000003A6 8B1EE600                	MOV  BX,[fx83+6]
  1226 000003AA 53                      	PUSH BX
  1227                                  
  1228 000003AB 6A40                         	push    0X40
  1229 000003AD 1F                              pop     ds              ; Source
  1230 000003AE 51                              push 	cx
  1231                                  
  1232                                  
  1233 000003AF B3FE                    	mov  BL,0xFE		; "O."
  1234 000003B1 B701                    	mov  BH,1		; "-"   	
  1235 000003B3 891EE000                	mov  [fx83],BX		
  1236                                  
  1237                                  
  1238                                  
  1239 000003B7 88F0                    	MOV  AL,DH 		; HEAD
  1240 000003B9 B101                    	mov  cl,01
  1241 000003BB BAE000                  	mov  dx,fx83		;    	
  1242 000003BE B452                        	mov  ah, 0x52       	; ah=0x51 - "Write BUFFER TO FRONT PANEL"    	
  1243 000003C0 CD15                        	INT  0x15  		;
  1244                                  
  1245 000003C2 59                          	pop  cx
  1246 000003C3 51                          	push cx
  1247 000003C4 88E8                    	MOV  AL,ch 		; cyl
  1248 000003C6 B102                    	mov  cl,02
  1249 000003C8 BAE000                  	mov  dx,fx83		;    	
  1250 000003CB B452                        	mov  ah, 0x52       	; ah=0x51 - "Write BUFFER TO FRONT PANEL"    	
  1251 000003CD CD15                        	INT  0x15  		;
  1252                                  
  1253 000003CF 59                          	pop  cx
  1254 000003D0 88C8                    	MOV  AL,cl 		; sec
  1255 000003D2 B103                    	mov  cl,03
  1256 000003D4 BAE000                  	mov  dx,fx83		;    	
  1257 000003D7 B452                        	mov  ah, 0x52       	; ah=0x51 - "Write BUFFER TO FRONT PANEL"    	
  1258 000003D9 CD15                        	INT  0x15  		;
  1259                                  
  1260 000003DB 5B                          	pop BX
  1261 000003DC 891EE600                	MOV [fx83+6],BX
  1262 000003E0 5B                      	POP BX
  1263 000003E1 891EE400                	MOV [fx83+4],BX
  1264 000003E5 5B                      	POP BX
  1265 000003E6 891EE200                	MOV [fx83+2],BX
  1266 000003EA 5B                      	POP BX
  1267 000003EB 891EE000                	MOV [fx83],BX
  1268                                  
  1269 000003EF 1F                          	pop 	DS
  1270 000003F0 5A                          	pop     DX
  1271 000003F1 59                          	POP     CX
  1272 000003F2 5B                          	POP     BX
  1273 000003F3 58                          	POP     AX
  1274                                  
  1275                                  %endif
  1276                                  
  1277                                  
  1278                                  
  1279                                  
  1280                                  %if EXTRA
  1281                                  	cmp	al,1
  1282                                  	jbe	.10
  1283                                  
  1284                                  	mov	bx,[offset_BX+bp]	; restore BX
  1285                                  	mov	[offset_AH+bp],al	; use return code as counter
  1286                                  
  1287                                  .1:	mov	ax,0301h		; write 1 sector
  1288                                  	int	13h
  1289                                  	jc	.5
  1290                                  
  1291                                  	inc	cl			; increment sector number
  1292                                  	add	bx,200h			; increment transfer address
  1293                                  	dec	byte [offset_AH+bp]
  1294                                  	jnz	.1
  1295                                  
  1296                                  	Okay				; all went Okay
  1297                                  	ret
  1298                                  
  1299                                  ; process error return
  1300                                  ;  AH = error code
  1301                                  .5:	mov	al,[offset_AL+bp]	; sectors requested
  1302                                  	sub	al,[offset_AH+bp]	; sectors remaining
  1303                                  	mov	[offset_AL+bp],al	; set sectors transferred
  1304                                  	Error
  1305                                  	ret
  1306                                  
  1307                                  .10:
  1308                                  %endif
  1309 000003F4 B4C5                    	mov	ah,(CMD_WRITE_DATA | CMD_MT | CMD_MF)
  1310 000003F6 BFA617                  	mov	di,FDC_DMA_WRITE
  1311 000003F9 BB[1607]                	mov	bx,xfer_write_sector
  1312 000003FC EB08                    	jmp	rwv_common
  1313                                  
  1314                                  fn04:	; VERIFY
  1315 000003FE B4E6                    	mov	ah,(CMD_READ_DATA | CMD_MT | CMD_MF | CMD_SK)
  1316 00000400 BF6683                  	mov	di,FDC_DMA_SCAN
  1317 00000403 BB[4B07]                	mov	bx,xfer_verify_sector
  1318                                  ;;;	jmp	rwv_common
  1319                                  
  1320                                  ;  Common code to READ, WRITE, and VERIFY
  1321                                  rwv_common:
  1322 00000406 57                      	push	di			; dma control register
  1323 00000407 53                      	push	bx			; transfer function
  1324 00000408 83EC08                  	sub	sp,rwv_stack - 8	; 4 words in stack by pushes or Call
  1325 0000040B 50                      	push	ax			; including this push
  1326                                  
  1327 0000040C E88401                  	call	check_DL		; sets DI
  1328 0000040F B401                    	mov	ah,ERR_invalid_command
  1329 00000411 7263                    	jc	.exit
  1330 00000413 E89401                  	call	get_disk_type
  1331 00000416 E8A001                  	call	get_media		; get media pointer to CS:BX
  1332 00000419 E8A901                  	call	set_media_pointer	; set up Int 1Eh
  1333 0000041C E81702                  	call	motor_on		; use DI to start motor
  1334                                  
  1335 0000041F E8AD03                  	call	Seek			; use CH to seek to track
  1336                                  					; recalibrate is possible
  1337 00000422 7252                    	jc	.exit			; AH is error code
  1338                                  
  1339 00000424 E85D02                  	call	make_head_unit		; AL is next byte
  1340                                  
  1341 00000427 571E06                  	pushm	es,ds,di
  1342 0000042A 8D7EF2                  	lea	di,[rwv_cmd+1+bp]		; SS override not needed
  1343 0000042D 8D7703                  	lea	si,[DTAB_N_param+bx]
  1344 00000430 160E                    	pushm	cs,ss
  1345 00000432 1F07                    	popm	ds,es
  1346 00000434 AA                      	stosb				; store head unit in cmd stream
  1347 00000435 88E8                    	mov	al,ch			; cylinder
  1348 00000437 AA                      	stosb
  1349 00000438 88F0                    	mov	al,dh			; head
  1350 0000043A AA                      	stosb
  1351 0000043B 88C8                    	mov	al,cl			; sector (R)
  1352 0000043D AA                      	stosb
  1353 0000043E AC                      	lodsb				; get N
  1354 0000043F 88C1                    	mov	cl,al
  1355 00000441 AA                      	stosb				; store N
  1356 00000442 A4                      	movsb				; EOT
  1357 00000443 A4                      	movsb				; GPL
  1358 00000444 A4                      	movsb				; DTL = FF
  1359 00000445 8D76F1                  	lea	si,[rwv_cmd+bp]		; get command start
  1360 00000448 071F5F                  	popm	es,ds,di
  1361                                  
  1362 0000044B B88000                  	mov	ax,128			; minimum sector size
  1363 0000044E F666F0                  	mul	byte [rwv_AL+bp]	; times number of sectors to transfer
  1364 00000451 D3E0                    	shl	ax,cl			; shift by N_param
  1365 00000453 89C1                    	mov	cx,ax			; CX is byte count of transfer
  1366                                  
  1367 00000455 53                      	pushm	bx			; save DTAB pointer
  1368                                  
  1369 00000456 8B4608                  	mov	ax,[offset_BX+bp]	; get Xfer address offset
  1370 00000459 8CC3                    	mov	bx,es			; segment to AX
  1371 0000045B 89DA                    	mov	dx,bx			; and to DX
  1372 0000045D C1EB0C                  	shr	bx,12			; high 4 bits of address
  1373 00000460 C1E204                  	shl	dx,4			; high part of offset from segment
  1374 00000463 01D0                    	add	ax,dx			; form low 16 bits of 20-bit address
  1375 00000465 83D300                  	adc	bx,0			; and carry into the high bits
  1376                                  
  1377 00000468 8CD2                    	mov	dx,ss			; DX:SI points at command start
  1378                                  
  1379                                  .marker:
  1380                                  ;	BX:AX	transfer 20-bit address in memory
  1381                                  ;	CX	transfer byte count
  1382                                  ;	DX:SI	pointer to 9-byte FDC command
  1383                                  ;
  1384 0000046A 80263E0000              	and	byte [fdc_drv_calib],00h	;POST no interrupts received
  1385                                  
  1386 0000046F FF56FA                  	call	near [rwv_xfer+bp]		;call specific transfer function
  1387                                  
  1388 00000472 5B                      	popm	bx				; restor DTAB pointer (CS:BX)
  1389                                  ;;;	jc	.exit			; AH is set to error code
  1390                                  
  1391 00000473 E8BD03                  	call	Check_RW_Status		; get final return code
  1392                                  
  1393                                  .exit:
  1394 00000476 8D66FE                  	lea	sp,[rwv_return+bp]
  1395 00000479 C3                      	ret
  1396                                  
  1397                                  %if SOFT_DEBUG
  1398                                  end_rwv		equ	$
  1399                                  %endif
  1400                                  
  1401                                  
  1402                                  
  1403                                  ; Format stack layout
  1404                                  fmt_return	equ	-2			; return from fn05 call
  1405                                  fmt_dma		equ	fmt_return - 2
  1406                                  fmt_cmd		equ	fmt_dma - 6
  1407                                  fmt_stack	equ	-fmt_cmd		; stack size
  1408                                  
  1409                                  %if fmt_dma != rwv_dma
  1410                                  %error "fmt_dma != rwv_dma"
  1411                                  %endif
  1412                                  
  1413                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1414                                  ;  Function 05h         Format a Track
  1415                                  ;
  1416                                  ;  Precede with call to Function 18h (or 17h) to set the disk type
  1417                                  ;
  1418                                  ;  Enter with:
  1419                                  ;       AH = 05h
  1420                                  ;       CH = cylinder number
  1421                                  ;       DH = head number
  1422                                  ;       DL = drive 0 or 1
  1423                                  ;       ES:BX = segment/offset of address field list (C/H/R/N)
  1424                                  ;
  1425                                  ;  Return with:
  1426                                  ;       Carry clear if no error
  1427                                  ;       AH = 0
  1428                                  ;
  1429                                  ;       Carry set on error
  1430                                  ;       AH = error code
  1431                                  ;
  1432                                  ;       All other registers are preserved.
  1433                                  ;
  1434                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1435                                  fn05:
  1436 0000047A 83EC0A                  	sub	sp,fmt_stack		; allocate stack space
  1437 0000047D C746FCA617              	mov	word [fmt_dma+bp],FDC_DMA_FORMAT
  1438                                  
  1439 00000482 E80E01                  	call	check_DL		; sets DI
  1440 00000485 B401                    	mov	ah,ERR_invalid_command
  1441 00000487 726C                    	jc	.exit
  1442                                  
  1443 00000489 06                      	pushm	es		; save ES
  1444 0000048A 6A00                    	push	0
  1445 0000048C 07                      	popm	es
  1446 0000048D 8CCB                    	mov	bx,cs		; get CS segment
  1447 0000048F 263B1E7A00                es	cmp	bx,[1Eh*4+2]	; check segment is CS
  1448 00000494 755F                    	jne	.exit		; (will restore stack)
  1449                                  
  1450 00000496 268B1E7800                es	mov	bx,[1Eh*4]	; get CS:BX as disk param table pointer
  1451 0000049B 07                      	popm	es     		; restore Stack
  1452                                  
  1453 0000049C E89701                  	call	motor_on		; use DI to start motor
  1454                                  
  1455 0000049F E82D03                  	call	Seek			; use CH to seek to track
  1456                                  					; recalibrate is possible
  1457 000004A2 7251                    	jc	.exit			; AH is error code
  1458                                  
  1459 000004A4 E8DD01                  	call	make_head_unit		; AL is next byte
  1460 000004A7 88C4                    	mov	ah,al			; save head/unit in AH
  1461                                  
  1462 000004A9 571E06                  	pushm	es,ds,di
  1463                                  
  1464 000004AC 160E                    	pushm	cs,ss
  1465 000004AE 1F07                    	popm	ds,es
  1466 000004B0 8D7EF6                  	lea	di,[bp+fmt_cmd]
  1467 000004B3 8D7703                  	lea	si,[bx+DTAB_N_param]
  1468                                  
  1469 000004B6 B00D                    	mov	al,CMD_FORMAT_A_TRACK
  1470 000004B8 803C00                  	cmp	byte [si],0		; is N==0
  1471 000004BB 7402                    	je	.2
  1472 000004BD 0C40                    	or	al,CMD_MF		; MFM recording
  1473                                  .2:
  1474 000004BF AB                      	stosw				; AH=head/unit, AL=format cmd
  1475 000004C0 A4                      	movsb				; set N
  1476 000004C1 AC                      	lodsb				; get SC
  1477 000004C2 88C1                    	mov	cl,al			; save SC in AL
  1478 000004C4 AA                      	stosb				; set SC
  1479 000004C5 83C602                  	add	si,2			; advance to GPL3
  1480 000004C8 A5                      	movsw				; set GPL3 and Fill
  1481                                  
  1482 000004C9 8D76F6                  	lea	si,[bp+fmt_cmd]
  1483 000004CC 071F5F                  	popm	es,ds,di    		; restore regs
  1484                                  
  1485 000004CF 30ED                    	xor	ch,ch			; CX = sector count
  1486 000004D1 C1E102                  	shl	cx,2			; CX = byte count of param table
  1487                                  
  1488 000004D4 53                      	pushm	bx			; save DTAB pointer
  1489                                  
  1490 000004D5 8B4608                  	mov	ax,[offset_BX+bp]	; get Xfer address offset
  1491 000004D8 8CC3                    	mov	bx,es			; segment to AX
  1492 000004DA 89DA                    	mov	dx,bx			; and to DX
  1493 000004DC C1EB0C                  	shr	bx,12			; high 4 bits of address
  1494 000004DF C1E204                  	shl	dx,4			; high part of offset from segment
  1495 000004E2 01D0                    	add	ax,dx			; form low 16 bits of 20-bit address
  1496 000004E4 83D300                  	adc	bx,0			; and carry into the high bits
  1497                                  
  1498 000004E7 8CD2                    	mov	dx,ss			; DX:SI points at command start
  1499                                  
  1500                                  ;.marker:
  1501                                  ;	BX:AX	transfer 20-bit address in memory
  1502                                  ;	CX	transfer byte count
  1503                                  ;	DX:SI	pointer to 9-byte FDC command
  1504                                  ;
  1505 000004E9 80263E0000              	and	byte [fdc_drv_calib],00h	;POST no interrupts received
  1506                                  
  1507 000004EE E82502                  	call	xfer_format_track	; format the track
  1508                                  
  1509 000004F1 5B                      	popm	bx				; restor DTAB pointer (CS:BX)
  1510                                  ;;;	jc	.exit			; AH is set to error code
  1511                                  
  1512 000004F2 E83E03                  	call	Check_RW_Status		; get final return code
  1513                                  
  1514                                  
  1515                                  .exit:
  1516 000004F5 8D66FE                  	lea	sp,[rwv_return+bp]	; restore stack location
  1517 000004F8 C3                      	ret
  1518                                  
  1519                                  
  1520                                  
  1521                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1522                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1523                                  	global  dma0_interrupt
  1524                                  dma0_interrupt:
  1525 000004F9 1E5250                  	pushm   ax,dx,ds
  1526                                  	
  1527 000004FC 6A40                    	push    bios_data_seg
  1528 000004FE 1F                      	popm    ds
  1529                                  
  1530                                  %if SOFT_DEBUG
  1531                                  	or	byte [fdc_drv_calib],02h		;POST dma interrupt
  1532                                  %endif
  1533                                  
  1534                                  %if 0
  1535                                  	mov     dx,FDC_TC               ; Terminal Count
  1536                                  	in      al,dx                   ; pulse the line
  1537                                  %endif
  1538                                  
  1539                                  %if 0
  1540                                  	mov     dx,DMA0+DMACW           ; DMA0 control word
  1541                                  	in      ax,dx
  1542                                  	mov     [dma0_cw],ax            ; post the resulting CW
  1543                                  %endif
  1544                                  
  1545                                  ; signal EOI (End of Interrupt)
  1546 000004FF BA22FF                  	mov     dx,PIC_EOI              ; EOI register
  1547 00000502 B80080                  	mov     ax,EOI_NSPEC            ; non-specific
  1548 00000505 EF                      	out     dx,ax                   ; signal it
  1549                                  
  1550 00000506 585A1F                  	popm    ax,dx,ds
  1551 00000509 CF                      	iret
  1552                                  
  1553                                  
  1554                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1555                                  ;  Function 15h         Get Disk Type 
  1556                                  ;
  1557                                  ;  Enter with:
  1558                                  ;       AH = 15h
  1559                                  ;       DL = drive 0 or 1
  1560                                  ;
  1561                                  ;  Return with:
  1562                                  ;       Carry clear if no error
  1563                                  ;       AH = drive type code
  1564                                  ;               0 = no drive present
  1565                                  ;               1 = floppy without change line support
  1566                                  ;               2 = floppy with change line support
  1567                                  ;               3 = fixed disk
  1568                                  ;
  1569                                  ;       Carry set on error
  1570                                  ;       AH = error code
  1571                                  ;
  1572                                  ;       All other registers are preserved.
  1573                                  ;
  1574                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1575                                  fn15:
  1576 0000050A 30E4                    	xor	ah,ah			; No drive present
  1577 0000050C E88400                  	call	check_DL
  1578 0000050F 7309                    	jnc	.ok
  1579 00000511 83FFFF                  	cmp	di,-1
  1580 00000514 7503E918FB              	je	undefined		; DL is really bad
  1581 00000519 C3                      	ret				; AH=0, no drive present
  1582                                  					; carry will be cleared
  1583                                  .ok:
  1584 0000051A FEC4                    	inc	ah			; drive ok, no change line support
  1585 0000051C F8                      	clc
  1586 0000051D E906FB                  	jmp	exit_pops		;
  1587                                  
  1588                                  
  1589                                  
  1590                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1591                                  ;  Function 16h         Get Disk Change Status
  1592                                  ;
  1593                                  ;  Enter with:
  1594                                  ;       AH = 16h
  1595                                  ;       DL = drive 0 or 1
  1596                                  ;
  1597                                  ;  Return with:
  1598                                  ;       Carry clear
  1599                                  ;       AH = 0  disk not changed
  1600                                  ;
  1601                                  ;       Carry set
  1602                                  ;       AH = 6  disk has been changed
  1603                                  ;            0  error
  1604                                  ;
  1605                                  ;       All other registers are preserved.
  1606                                  ;
  1607                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1608                                  fn16:
  1609 00000520 E87000                  	call	check_DL
  1610 00000523 7303E909FB              	jc	undefined
  1611                                  
  1612 00000528 89F8                    	mov	ax,di			; AL = 0, 1	AH = 0
  1613                                  ; AH is now 0
  1614 0000052A FEC0                    	inc	al			; AL = 1, 2
  1615 0000052C C0C004                  	rol	al,4			; AL = MOEN1 or MOEN2
  1616 0000052F 84063F00                	test	[fdc_motor_LDOR],al	; test if motor running
  1617 00000533 7502                    	jnz     .on
  1618                                  
  1619 00000535 B406                    	mov     ah,ERR_disk_removed	; signal disk changed
  1620                                  .on:
  1621 00000537 C3                      	ret			; AH=6, Carry will be set
  1622                                  	
  1623                                  
  1624                                  
  1625                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1626                                  ;  Function 17h		Set Disk Type for Format	(PC-AT)
  1627                                  ;
  1628                                  ;  Enter with:
  1629                                  ;	AH = 17h
  1630                                  ;	AL =	00h     not used
  1631                                  ;		01h     160, 180, 320, or 360Kb diskette in 360kb drive
  1632                                  ;		02h     360Kb diskette in 1.2Mb drive
  1633                                  ;		03h     1.2Mb diskette in 1.2Mb drive
  1634                                  ;		04h     720Kb diskette in 720Kb drive
  1635                                  ;	DL = drive number
  1636                                  ;
  1637                                  ;  Return with:
  1638                                  ;	AH = 0		success
  1639                                  ;	Carry clear
  1640                                  ;
  1641                                  ;	Carry set	error
  1642                                  ;	AH = error code
  1643                                  ;
  1644                                  ;  note 1) This function is probably enhanced for the PS/2 series to detect
  1645                                  ;	   1.44 in 1.44 and 720k in 1.44.
  1646                                  ;	2) This function is not supported for floppy disks on the PC or XT.
  1647                                  ;	3) If the change line is active for the specified drive, it is reset.
  1648                                  ;	4) The BIOS sets the data rate for the specified drive and media type.
  1649                                  ;	   The rate is 250k/sec for double-density media and 500k/sec for high
  1650                                  ;	   density media. The proper hardware is required.
  1651                                  ;	5) This function is used by DOS <= 3.1
  1652                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1653                                  ;fn17:
  1654                                  ;;;	ret
  1655                                  
  1656                                  
  1657                                  
  1658                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1659                                  ;  Function 18h		Set Media Type For Format  (diskette)   (AT, XT2, XT/286, PS/2)
  1660                                  ;
  1661                                  ;  Enter with:
  1662                                  ;	AH = 18h
  1663                                  ;	CH = max. cylinder number (80 or 40  minus  1)
  1664                                  ;	CL = number of sectors (9, 15, 18)
  1665                                  ;	DL = drive number
  1666                                  ;
  1667                                  ;  Return with:
  1668                                  ;	Carry clear -- no errors
  1669                                  ;	AH =	00h      if requested combination supported
  1670                                  ;	ES:DI	pointer to 13-byte parameter table
  1671                                  ;
  1672                                  ;	Carry set -- error
  1673                                  ;	AH =	01h      if function not available
  1674                                  ;		0Ch      if not suppported or drive type unknown
  1675                                  ;		80h      if there is no media in the drive
  1676                                  ;
  1677                                  ;  note 1) A floppy disk must be present in the drive.
  1678                                  ;	2) This function should be called prior to formatting a disk with Int 13h
  1679                                  ;	   Fn 05h so the BIOS can set the correct data rate for the media.
  1680                                  ;	3) If the change line is active for the specified drive, it is reset.
  1681                                  ;	4) This function is used by DOS >= 3.2
  1682                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1683                                  fn18:
  1684 00000538 E85800                  	call	check_DL		; check validity of drive no.
  1685 0000053B 7303E9F1FA              	jc	undefined
  1686                                  
  1687 00000540 E86700                  	call	get_disk_type		; get disk type to AL
  1688 00000543 3C0B                    	cmp	al,L_table
  1689 00000545 7327                    	jnb	.alt
  1690 00000547 88C3                    	mov	bl,al
  1691 00000549 30FF                    	xor	bh,bh
  1692 0000054B D1E3                    	shl	bx,1
  1693 0000054D 2E8B9F[6600]              cs	mov	bx,[D_table+bx]		; get offset of DTAB entry
  1694 00000552 85DB                    	test	bx,bx
  1695 00000554 743A                    	jz	.errC
  1696 00000556 2E384F04                  cs	cmp	[DTAB_EOT_nsect+bx],cl	; check number of sectors
  1697 0000055A 7512                      	jne	.alt			; try alternate
  1698 0000055C 2E386F0B                  cs	cmp	[DTAB_max_cylinder+bx],ch  ; check number of cylinders
  1699 00000560 750C                      	jne	.alt
  1700                                  .found:
  1701 00000562 E86000                         	call	set_media_pointer
  1702 00000565 895E00                  	mov	[offset_DI+bp],bx
  1703 00000568 8C4E12                  	mov	[offset_ES+bp],cs	; return in ES:DI
  1704 0000056B 30E4                    	xor	ah,ah
  1705 0000056D C3                      	ret
  1706                                  
  1707                                  .alt:
  1708 0000056E E84000                  	call	get_disk_alt_type	; get disk type to AL
  1709 00000571 3C0B                    	cmp	al,L_table
  1710 00000573 731B                    	jnb	.errC
  1711 00000575 88C3                    	mov	bl,al
  1712 00000577 30FF                    	xor	bh,bh
  1713 00000579 D1E3                    	shl	bx,1
  1714 0000057B 2E8B9F[6600]              cs	mov	bx,[D_table+bx]		; get offset of DTAB entry
  1715 00000580 85DB                    	test	bx,bx
  1716 00000582 740C                    	jz	.errC
  1717 00000584 2E384F04                  cs	cmp	[DTAB_EOT_nsect+bx],cl	; check number of sectors
  1718 00000588 7506                      	jne	.errC			; no match?
  1719 0000058A 2E386F0B                  cs	cmp	[DTAB_max_cylinder+bx],ch  ; check number of cylinders
  1720 0000058E 74D2                    	je	.found
  1721                                  
  1722 00000590 B40C                    .errC:	mov	ah,ERR_media_type_not_found
  1723 00000592 C3                      	ret
  1724                                  
  1725                                  
  1726                                  
  1727                                  
  1728                                  
  1729                                  check   cpu_xtal-0FFh
  1730                                  
  1731                                  
  1732                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1733                                  ;  check_DL -- check for valid disk #
  1734                                  ;
  1735                                  ;  Return:
  1736                                  ;	DI = 0 or 1 if DL is valid floppy
  1737                                  ;	Carry clear
  1738                                  ;
  1739                                  ;	DI not valid if DL is invalid
  1740                                  ;	Carry set
  1741                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1742                                  check_DL:
  1743 00000593 BFFFFF                  	mov	di,-1				; invalid DI
  1744 00000596 80FA02                  	cmp	dl,FLOPPY_MAX
  1745 00000599 730D                    	jnb	.err
  1746 0000059B 89D7                    	mov	di,dx
  1747 0000059D 83E701                  	and	di,FLOPPY_MAX-1			; clear the carry
  1748 000005A0 F685F8000F              	test	byte [fdc_type+di],0Fh		; drive present?
  1749 000005A5 7401                    	jz	.err
  1750 000005A7 C3                      	ret					; carry is clear
  1751                                  
  1752 000005A8 F9                      .err:	stc
  1753 000005A9 C3                      	ret
  1754                                  
  1755                                  
  1756                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1757                                  ;  get_disk_type
  1758                                  ;
  1759                                  ;  Enter with:
  1760                                  ;	DI = drive no.
  1761                                  ;
  1762                                  ;  Return with:
  1763                                  ;	AL = drive type (0..4)
  1764                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1765                                  get_disk_type:
  1766 000005AA 8A85F800                	mov	al,[fdc_type+di]	; get type byte
  1767 000005AE 240F                    	and	al,0Fh			; mask low nibble
  1768 000005B0 C3                      	ret
  1769                                  
  1770                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1771                                  ;  get_disk_alt_type
  1772                                  ;
  1773                                  ;  Enter with:
  1774                                  ;	DI = drive no.
  1775                                  ;
  1776                                  ;  Return with:
  1777                                  ;	AL = drive type (0..4)
  1778                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1779                                  get_disk_alt_type:
  1780 000005B1 8A85F800                	mov	al,[fdc_type+di]	; get type byte
  1781 000005B5 C0E804                  	shr	al,4
  1782 000005B8 C3                      	ret
  1783                                  
  1784                                  
  1785                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1786                                  ;  get_media
  1787                                  ;
  1788                                  ;  Call with:
  1789                                  ;	AL = disk type
  1790                                  ;
  1791                                  ;  Return with:
  1792                                  ;	CS:BX		pointer to 13-byte disk media table
  1793                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1794                                  get_media:
  1795 000005B9 88C3                    	mov	bl,al
  1796 000005BB 30FF                    	xor	bh,bh
  1797 000005BD D1E3                    	shl	bx,1
  1798 000005BF 2E8B9F[6600]              cs	mov	bx,[D_table+bx]		; get offset of DTAB entry
  1799 000005C4 C3                        	ret
  1800                                  
  1801                                  
  1802                                  
  1803                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1804                                  ;  set_media_pointer
  1805                                  ;
  1806                                  ;  Call with:
  1807                                  ;	CS:BX	pointer to 13-byte disk media table
  1808                                  ;	DS	BIOS data area pointer
  1809                                  ;
  1810                                  ;  Return with:
  1811                                  ;	CS:BX		pointer to 13-byte disk media table
  1812                                  ;	Int 1Eh 	floppy media pointer set
  1813                                  ;
  1814                                  ;	Carry Set = new media pointer (needed Specify command)
  1815                                  ;	Carry Clear = same media pointer (Specify not needed)
  1816                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1817                                  set_media_pointer:
  1818 000005C5 0651                    	pushm	cx,es			; save for later
  1819 000005C7 6A00                    	push	0			; address interrupt vectors
  1820 000005C9 07                      	pop	es			; **
  1821 000005CA 8CC9                    	mov	cx,cs
  1822 000005CC 26391E7800                es	cmp	word [1Eh*4],bx
  1823 000005D1 7508                    	jne	.diff
  1824 000005D3 26390E7A00                es	cmp	word [1Eh*4+2],cx	; segment
  1825 000005D8 F8                      	clc
  1826 000005D9 7410                    	jz	.same
  1827                                  .diff:
  1828 000005DB 26891E7800                es	mov	word [1Eh*4],bx		; offset
  1829 000005E0 26890E7A00                es	mov	word [1Eh*4+2],cx	; segment
  1830 000005E5 8EC1                    	mov	es,cx
  1831                                  	cnop
  1832 000005E7 E80400                  	call	Specify			; ES:BX is table pointer
  1833 000005EA F9                      	stc
  1834                                  .same:
  1835 000005EB 5907                    	popm	cx,es			; restore DS
  1836 000005ED C3                      	ret
  1837                                  
  1838                                  
  1839                                  
  1840                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1841                                  ;  Specify		issue specify command to FDC
  1842                                  ;
  1843                                  ;  Call with:
  1844                                  ;	ES:BX		pointer to 13-byte disk table
  1845                                  ;	DS		BIOS data area pointer
  1846                                  ;
  1847                                  ;  Return with:
  1848                                  ;	Nothing
  1849                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1850                                  Specify:
  1851 000005EE 56525350                	pushm	ax,bx,dx,si
  1852 000005F2 83EC04                  	sub	sp,4			; allocate 4 bytes for command
  1853 000005F5 89E6                    	mov	si,sp
  1854                                  
  1855 000005F7 268A470C                  es	mov	al,[DTAB_control+bx]	; clock bits
  1856 000005FB C0C002                    	rol	al,2
  1857 000005FE BA3006                  	mov	dx,FDC_LDCR		; Control Register
  1858 00000601 EE                      	out	dx,al
  1859                                  
  1860 00000602 B20C                    	mov	dl,12			; 12 usec delay  = T time
  1861 00000604 08C0                    	or	al,al			; test for hi (00) or lo (80) data rate
  1862 00000606 7502                    	jnz	.3
  1863 00000608 D0EA                    	shr	dl,1			; crystal has factor of 2 already
  1864                                  .3:
  1865 0000060A A0FF00                  	mov	al,[cpu_xtal]		; 2x clock frequency
  1866 0000060D F6E2                    	mul	dl			; AX = 2xClock * T or 2xclock * T/2 (80 or 00)
  1867 0000060F 83E82C                  	sub	ax,44			; overhead CPU clocks
  1868 00000612 B214                    	mov	dl,20			; loop clock count
  1869 00000614 F6F2                    	div	dl
  1870 00000616 FEC0                    	inc	al			; for good measure
  1871 00000618 A2AD00                  	mov	[wait12_count],al	; save count
  1872                                  
  1873 0000061B 36C60403                  ss	mov	byte [si],CMD_SPECIFY
  1874 0000061F 268B07                    es	mov	ax,[DTAB_specify+bx]	; get two specify bytes
  1875 00000622 36894401                  ss	mov	word [si+1],ax
  1876 00000626 8CD2                      	mov	dx,ss
  1877 00000628 B90300                  	mov	cx,3			; length of command = 3
  1878 0000062B E85DFB                  	call	output_cmd_to_fdc
  1879 0000062E 83C404                  	add	sp,4
  1880 00000631 585B5A5E                	popm	ax,bx,dx,si
  1881 00000635 C3                      	ret
  1882                                  
  1883                                  
  1884                                  
  1885                                  
  1886                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1887                                  ;  motor_on			Start the drive motor & wait
  1888                                  ;
  1889                                  ;  Call with:
  1890                                  ;	DI = drive to start (0, 1)
  1891                                  ;	CS:BX = drive parameter table pointer
  1892                                  ;
  1893                                  ;  Return with:
  1894                                  ;	motor is running and startup delay has been taken
  1895                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1896                                  	global	motor_on
  1897                                  motor_on:
  1898 00000636 525150                  	pushm	ax,cx,dx
  1899 00000639 89F8                    	mov	ax,di			; drive # to AL
  1900 0000063B 0401                    	add	al,MOEN1>>4		; form MOENx >> 4
  1901 0000063D C0E004                  	shl	al,4			; form MOENx bitmask
  1902 00000640 88C4                    	mov	ah,al			; MOENx -> AH
  1903 00000642 01F8                    	add	ax,di			; MOENx + DSELx -> AL
  1904                                  
  1905 00000644 B1B6                    	mov	cl,182				;10 seconds
  1906 00000646 880E4000                  	mov	byte [fdc_motor_ticks],cl	; set long timer = 10 seconds
  1907                                  
  1908 0000064A 84263F00                	test	byte [fdc_motor_LDOR],ah	; motor already on?
  1909 0000064E 88C5                    	mov	ch,al
  1910 00000650 750F                    	jnz	.its_on
  1911                                  
  1912                                  ; motor is not running
  1913 00000652 2E8B470A                  cs	mov	ax,[DTAB_startup+bx]	; get startup delay in 1/8 seconds
  1914 00000656 98                        	cbw
  1915 00000657 6BC07D                    	imul	ax,125			; * 125 ms
  1916 0000065A B236                    	mov	dl,54
  1917 0000065C F6F2                    	div	dl			; divided by 54ms/tick
  1918 0000065E 40                      	inc	ax			; one more tick for good measure
  1919 0000065F 28C1                    	sub	cl,al			; CL is tick to wait for
  1920                                  
  1921                                  ; if motor was already running, then CL has not been changed
  1922                                  ; Do the select
  1923                                  .its_on:
  1924 00000661 322E3F00                	xor	ch,[fdc_motor_LDOR]	; set selected bits
  1925 00000665 80E531                  	and	ch,(MOEN_MASK | DSEL_MASK)
  1926 00000668 302E3F00                	xor	[fdc_motor_LDOR],ch
  1927 0000066C E8CEFB                  	call	out_LDOR_mem		; Motor Starts here, or continues
  1928 0000066F EB01                    	jmp	.wait
  1929                                  
  1930 00000671 F4                      	hlt
  1931 00000672 380E4000                .wait:	cmp	[fdc_motor_ticks],cl	; has tick counter expired?
  1932 00000676 77F9                    	ja	.wait-1
  1933                                  
  1934                                  ; reduce timer to turn-off delay time
  1935 00000678 2E8A4F02                  cs	mov	cl,[DTAB_turnoff_ticks+bx]	; 2 seconds
  1936 0000067C 880E4000                  	mov	[fdc_motor_ticks],cl
  1937                                  
  1938 00000680 58595A                  	popm	ax,cx,dx
  1939 00000683 C3                      	ret
  1940                                  
  1941                                  
  1942                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1943                                  ;  make_head_unit
  1944                                  ;
  1945                                  ;  Enter with:
  1946                                  ;	DH = head number
  1947                                  ;	DI = unit number
  1948                                  ;
  1949                                  ;  Return with:
  1950                                  ;	AL = 0000 0huu
  1951                                  ;	Carry clear
  1952                                  ;
  1953                                  ;	Carry is set on error
  1954                                  ;
  1955                                  ;  Assumes "motor_on" has done the real unit select in the LDOR (operations register)
  1956                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1957                                  make_head_unit:
  1958 00000684 88F0                    	mov	al,dh			; head number to AL
  1959 00000686 A8FE                    	test	al, ~1			; check for head 0 or 1
  1960 00000688 F9                      	stc				; set to signal error
  1961 00000689 7507                    	jnz	.err
  1962 0000068B 2401                    	and	al,1			; defensive programming
  1963 0000068D C0E002                  	shl	al,2			; shift H to position
  1964 00000690 09F8                    	or	ax,di			; clear the carry
  1965 00000692 C3                      .err:	ret
  1966                                  
  1967                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1968                                  ;  dma_outd		output a double word to a DMA double word register
  1969                                  ;
  1970                                  ;  Call with:
  1971                                  ;	BX:AX	double word to put out
  1972                                  ;	DX	low port address in the DMA controller
  1973                                  
  1974                                  ;  Exit with:
  1975                                  ;	DX incremented by 4
  1976                                  ;
  1977                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1978                                  dma_outd:
  1979 00000693 EF                      	out	dx,ax
  1980 00000694 42                      	inc	dx
  1981 00000695 42                      	inc	dx
  1982 00000696 93                      	xchg	ax,bx
  1983 00000697 EF                      	out	dx,ax
  1984 00000698 42                      	inc	dx
  1985 00000699 42                      	inc	dx
  1986 0000069A C3                      	ret
  1987                                  
  1988                                  
  1989                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1990                                  ;  xfer_read_sector
  1991                                  ;
  1992                                  ;  Call with:
  1993                                  ;	BX:AX	transfer address in memory
  1994                                  ;	CX	transfer byte count
  1995                                  ;	DX:SI	pointer to 9-byte FDC command
  1996                                  ;
  1997                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1998                                  xfer_read_sector:
  1999 0000069B 52                      	push	dx
  2000                                  
  2001                                  ;;;	and	byte [fdc_drv_calib],00h	;POST no interrupts
  2002                                  						; operation is not complete
  2003                                  
  2004                                  ;   BX:AX is the transfer destination address
  2005 0000069C BAC4FF                  	mov	dx,DMA0+DMADPL		; set low destination
  2006 0000069F E8F1FF                  	call	dma_outd
  2007                                  
  2008 000006A2 89C8                    	mov	ax,cx			; total byte count
  2009 000006A4 EF                      	out	dx,ax			; set terminal count
  2010                                  
  2011 000006A5 31DB                    	xor	bx,bx
  2012 000006A7 B81006                  	mov	ax,FDC_DACK
  2013                                  ;   BX:AX is the transfer source port
  2014 000006AA BAC0FF                  	mov	dx,DMA0+DMASPL		; set low source pointer
  2015 000006AD E8E3FF                  	call	dma_outd
  2016                                  
  2017 000006B0 8B46FC                  	mov	ax,[rwv_dma+bp]		; get Control register
  2018 000006B3 BACAFF                  	mov	dx,DMA0+DMACW
  2019 000006B6 EF                      	out	dx,ax			; starts the DMA
  2020                                  
  2021 000006B7 5A                      	pop	dx		; reset DX:SI command pointer
  2022                                  
  2023 000006B8 B90900                  	mov	cx,9			; 9-byte FDC command
  2024 000006BB E8CDFA                  	call	output_cmd_to_fdc
  2025                                  
  2026                                  
  2027 000006BE BBC0FF                  	mov	bx,DMA0+DMASPL
  2028 000006C1 B95006                  	mov	cx,FDC_DACK_TC
  2029                                  
  2030                                  xfer_common_wait:
  2031 000006C4 BAC8FF                  	mov	dx,DMA0+DMATC
  2032                                  .loop1:
  2033 000006C7 803E400000              	cmp	byte [fdc_motor_ticks],0
  2034                                  ;;;	cmp	byte [fdc_motor_ticks],20h	; 2Fh - 0Fh in DTABx entries
  2035 000006CC 7625                    	jbe	.timeout
  2036                                  
  2037 000006CE E834FA                  	call	wait12
  2038 000006D1 ED                      	in	ax,dx
  2039 000006D2 83F80C                  	cmp	ax,THRESHHOLD
  2040 000006D5 73F0                    	jae	.loop1
  2041                                  
  2042 000006D7 E8A001                  	call	@disable
  2043                                  .loop2:
  2044 000006DA 90                      	nop
  2045 000006DB 90                      	nop
  2046 000006DC ED                      	in	ax,dx
  2047 000006DD 83F801                  	cmp	ax,1
  2048 000006E0 77F8                    	ja	.loop2
  2049                                  
  2050 000006E2 89DA                    	mov	dx,bx	; Source low
  2051 000006E4 89C8                    	mov	ax,cx	; FDC_DACK_TC
  2052 000006E6 EF                      	out	dx,ax
  2053                                  
  2054 000006E7 E89F01                  	call	@enable
  2055                                  
  2056                                  ;;;	mov	ax,100b			; stop the channel
  2057                                  ;;;	mov	dx,DMA0+DMACW			; DMA control word
  2058                                  ;;;	out	dx,ax
  2059                                  
  2060 000006EA E81100                  	call	wait_operation_complete
  2061 000006ED 720E                    	jc	.99
  2062                                  
  2063                                  ;;;	mov	ax,100b			; stop the channel
  2064                                  ;;;	mov	dx,DMA0+DMACW			; DMA control word
  2065                                  ;;;	out	dx,ax
  2066                                  
  2067 000006EF 30E4                    	Okay
  2068 000006F1 EB0A                    	jmp	.99
  2069                                  
  2070                                  .timeout:
  2071                                  ;;;	call	@enable
  2072                                  ; add the following:
  2073 000006F3 B80400                  	mov	ax,100b			; stop the channel
  2074 000006F6 BACAFF                  	mov	dx,DMA0+DMACW			; DMA control word
  2075 000006F9 EF                      	out	dx,ax
  2076                                  
  2077 000006FA B485                    	mov	ah,ERR_85
  2078 000006FC F9                      	Error
  2079 000006FD C3                      .99:	ret
  2080                                  
  2081                                  
  2082                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2083                                  ;  wait_operation_complete		; wait for disk operation
  2084                                  ;					; to post a "complete" status
  2085                                  ;  Call with:
  2086                                  ;	DS = BIOS data area segment
  2087                                  ;
  2088                                  ;  Return with:
  2089                                  ;	CY = 0		success
  2090                                  ;	CY = 1		timed out, AH=error code
  2091                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2092                                  wait_operation_complete:
  2093 000006FE F6063E0001              .1:	test	byte [fdc_drv_calib],01h	; FDC interrupt posted "complete"?
  2094 00000703 7509                    	jnz	.okay
  2095 00000705 803E400000              	cmp	byte [fdc_motor_ticks],0
  2096 0000070A 75F2                    	jne	.1
  2097 0000070C EB04                    	jmp	.timeout
  2098                                  
  2099 0000070E 30E4                    .okay:	Okay
  2100 00000710 EB03                    	jmp	.99
  2101                                  
  2102                                  .timeout:
  2103 00000712 B488                    	mov	ah,ERR_88		; mark timeout
  2104 00000714 F9                      	Error
  2105 00000715 C3                      .99:	ret
  2106                                  
  2107                                  
  2108                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2109                                  ;  xfer_write_sector
  2110                                  ;  xfer_format_track	(only command count is different)
  2111                                  ;
  2112                                  ;  Call with:
  2113                                  ;	BX:AX	transfer address in memory
  2114                                  ;	CX	transfer byte count
  2115                                  ;	DX:SI	pointer to 9-byte FDC command
  2116                                  ;
  2117                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2118                                  xfer_format_track:
  2119                                  xfer_write_sector:
  2120 00000716 52                      	push	dx
  2121                                  
  2122                                  ;   BX:AX is the transfer source address
  2123 00000717 BAC0FF                  	mov	dx,DMA0+DMASPL		; set low source address
  2124 0000071A E876FF                  	call	dma_outd
  2125                                  
  2126 0000071D 31DB                    	xor	bx,bx
  2127 0000071F B81006                  	mov	ax,FDC_DACK
  2128                                  
  2129                                  ;   BX:AX is the transfer destination port
  2130 00000722 BAC4FF                  	mov	dx,DMA0+DMADPL		; set low destination port
  2131 00000725 E86BFF                  	call	dma_outd
  2132                                  
  2133 00000728 89C8                    	mov	ax,cx			; total byte count
  2134 0000072A EF                      	out	dx,ax			; set terminal count
  2135                                  
  2136 0000072B 8B46FC                  	mov	ax,[rwv_dma+bp]		; get Control register
  2137 0000072E BACAFF                  	mov	dx,DMA0+DMACW
  2138 00000731 EF                      	out	dx,ax			; starts the DMA
  2139                                  
  2140 00000732 5A                      	pop	dx		; reset DX:SI command pointer
  2141                                  
  2142 00000733 B90900                  	mov	cx,9			; 9-byte FDC command
  2143 00000736 36F60408                  ss	test	byte [si], 01000b	; test for FORMAT command
  2144 0000073A 7403                      	jz	.4
  2145 0000073C B90600                  	mov	cx,6			; it is FORMAT
  2146                                  .4:
  2147 0000073F E849FA                  	call	output_cmd_to_fdc
  2148                                  
  2149                                  
  2150 00000742 BBC4FF                  	mov	bx,DMA0+DMADPL		; Destination to be updated
  2151 00000745 B95006                  	mov	cx,FDC_DACK_TC
  2152                                  
  2153 00000748 E979FF                  	jmp	xfer_common_wait
  2154                                  
  2155                                  
  2156                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2157                                  ;  xfer_verify_sector
  2158                                  ;
  2159                                  ;  Call with:
  2160                                  ;	BX:AX	transfer address in memory
  2161                                  ;	CX	transfer byte count
  2162                                  ;	DX:SI	pointer to 9-byte FDC command
  2163                                  ;
  2164                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2165                                  xfer_verify_sector:
  2166 0000074B 52                      	push	dx
  2167                                  
  2168 0000074C 31DB                    	xor	bx,bx			; BX:AX is transfer address
  2169 0000074E B84204                  	mov	ax, (bios_data_seg<<4)+fdc_ctrl_status
  2170                                  
  2171                                  ;   BX:AX is the transfer destination address
  2172 00000751 BAC4FF                  	mov	dx,DMA0+DMADPL		; set low destination
  2173 00000754 E83CFF                  	call	dma_outd
  2174                                  
  2175 00000757 89C8                    	mov	ax,cx			; total byte count
  2176 00000759 EF                      	out	dx,ax			; set terminal count
  2177                                  
  2178 0000075A 31DB                    	xor	bx,bx
  2179 0000075C B81006                  	mov	ax,FDC_DACK
  2180                                  ;   BX:AX is the transfer source port
  2181 0000075F BAC0FF                  	mov	dx,DMA0+DMASPL		; set low source pointer
  2182 00000762 E82EFF                  	call	dma_outd
  2183                                  
  2184 00000765 8B46FC                  	mov	ax,[rwv_dma+bp]		; get Control register
  2185 00000768 BACAFF                  	mov	dx,DMA0+DMACW
  2186 0000076B EF                      	out	dx,ax			; starts the DMA
  2187                                  
  2188 0000076C 5A                      	pop	dx		; reset DX:SI command pointer
  2189                                  
  2190 0000076D B90900                  	mov	cx,9			; 9-byte FDC command
  2191 00000770 E818FA                  	call	output_cmd_to_fdc
  2192                                  
  2193                                  
  2194 00000773 BBC0FF                  	mov	bx,DMA0+DMASPL
  2195 00000776 B95006                  	mov	cx,FDC_DACK_TC
  2196                                  
  2197 00000779 E948FF                  	jmp	xfer_common_wait
  2198                                  
  2199                                  
  2200                                  
  2201                                  
  2202                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2203                                  ;  recalibrate
  2204                                  ;
  2205                                  ;  Enter with:
  2206                                  ;	DI = drive number
  2207                                  ;	CS:BX = parameter area pointer
  2208                                  ;	DS = BIOS data area pointer
  2209                                  ;
  2210                                  ;  Return with:
  2211                                  ;	Carry = 0 -- okay
  2212                                  ;
  2213                                  ;	Carry = 1 -- error
  2214                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2215                                  recalibrate:
  2216 0000077C 565251                  	pushm   cx,dx,si
  2217                                  
  2218                                  ;;;	call    motor_on
  2219                                  
  2220 0000077F 80263E0000              	and	byte [fdc_drv_calib],00h	;POST no interrupts
  2221                                  
  2222 00000784 B001                    	mov	al,ST0_US	; mask to 2 drives
  2223 00000786 21F8                    	and	ax,di		; unit number to AL
  2224 00000788 86C4                    	xchg    al,ah		; AH is second byte of command
  2225 0000078A B007                    	mov     al,CMD_RECALIBRATE
  2226 0000078C 50                      	push    ax		; push 2 byte command
  2227 0000078D 89E6                    	mov     si,sp           ; form command pointer
  2228 0000078F 8CD2                    	mov     dx,ss           ; DX:SI points at command
  2229 00000791 B90200                  	mov     cx,2		
  2230 00000794 E8F4F9                  	call    output_cmd_to_fdc	; output the command
  2231 00000797 7231                    	jc      .7
  2232                                  
  2233 00000799 E862FF                  	call	wait_operation_complete
  2234 0000079C 722C                    	jc	.7
  2235                                  
  2236 0000079E E8A4FA                  	call    fdc_wait_seek_done
  2237 000007A1 7227                    	jc      .7
  2238                                  
  2239 000007A3 58                      	pop     ax		; get unit # to AH
  2240 000007A4 B004                    	mov     al,CMD_SENSE_DRIVE_STATUS
  2241 000007A6 50                      	push    ax		; push 2 byte command again
  2242 000007A7 B90200                  	mov     cx,2
  2243 000007AA 89E6                    	mov     si,sp
  2244 000007AC 8CD2                    	mov     dx,ss		; DX:SI points at the 2 byte command
  2245 000007AE E8DAF9                  	call    output_cmd_to_fdc
  2246 000007B1 7217                    	jc      .7
  2247                                  
  2248 000007B3 E8C5F9                  	call    input_byte_from_fdc	; get ST3
  2249 000007B6 7212                    	jc      .7
  2250 000007B8 88859000                	mov     [fdc_disk_state+di],al	; save ST3 for drive
  2251 000007BC B487                    	mov	ah,ERR_87		; not on track 0
  2252 000007BE A810                    	test    al,ST3_TR00
  2253 000007C0 F9                      	Error				; signal error
  2254 000007C1 7407                    	jz      .7                      ; Not on Track 00, C=1 error
  2255                                  
  2256 000007C3 C685940000              	mov	byte [fdc_cylinder+di],0	; set present cylinder
  2257                                  
  2258                                  %if SOFT_DEBUG > 1
  2259                                  	push    -1
  2260                                  	call    lites
  2261                                  %endif
  2262 000007C8 30E4                    	Okay			;
  2263                                  	
  2264 000007CA 5E                      .7:     pop     si		; Command is still in the stack
  2265 000007CB 595A5E                  	popm    cx,dx,si	; restore
  2266 000007CE C3                      	ret
  2267                                  
  2268                                  
  2269                                  
  2270                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2271                                  ;  Seek			seek to proper cylinder
  2272                                  ;
  2273                                  ;  Call with:
  2274                                  ;	CH = cylinder to which to position heads
  2275                                  ;	CS:BX = disk parameter area
  2276                                  ;	DI = unit number
  2277                                  ;	DS = BIOS data area pointer
  2278                                  ;
  2279                                  ;  Return with:
  2280                                  ;	Carry = 0	success
  2281                                  ;
  2282                                  ;	Carry = 1	error
  2283                                  ;  
  2284                                  ;  Assumes "motor_on" has done the real unit select in the LDOR (operations register)
  2285                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2286                                  Seek:
  2287 000007CF 565251                  	pushm	cx,dx,si
  2288                                  
  2289                                  ; check for a recalibration needed
  2290 000007D2 8A859400                	mov	al,[fdc_cylinder+di]	; get present cylinder (0FFh forces recalibrate)
  2291 000007D6 2E3A470B                 cs	cmp	al,[DTAB_max_cylinder+bx]	; compare to maximum
  2292 000007DA 760E                    	jbe	.no_recal
  2293                                  
  2294 000007DC BE0200                  	mov	si,2			; two recalibrates max.
  2295                                  .rerecal:
  2296 000007DF E89AFF                  	call	recalibrate
  2297 000007E2 7306                    	jnc	.no_recal
  2298 000007E4 4E                      	dec	si
  2299 000007E5 F9                      	Error
  2300 000007E6 7442                    	jz	.exit			; two have failed
  2301 000007E8 EBF5                    	jmp	.rerecal		; try again
  2302                                  
  2303                                  .no_recal:
  2304 000007EA 3AAD9400                	cmp	ch,[fdc_cylinder+di]	; sought : present cylinder
  2305 000007EE 7438                    	je	.okay
  2306                                  
  2307                                  ; we are not on the cylinder we want
  2308                                  
  2309 000007F0 2E3A6F0B                  cs	cmp	ch,[DTAB_max_cylinder+bx]  ; validate cylinder number
  2310 000007F4 7738                    	ja	.invalid
  2311                                  
  2312                                  .valid:
  2313 000007F6 80263E0000              	and	byte [fdc_drv_calib],00h	;POST no interrupts
  2314                                  
  2315 000007FB 86CD                    	xchg	cl,ch			; cylinder to CL
  2316 000007FD 51                      	push	cx			; CL = sought cylinder
  2317 000007FE E883FE                  	call	make_head_unit
  2318 00000801 B40F                    	mov	ah,CMD_SEEK		; command byte
  2319 00000803 86C4                    	xchg	al,ah			; command byte must be first in stack
  2320 00000805 50                      	push	ax			; push 3 byte command
  2321 00000806 89E6                    	mov	si,sp
  2322 00000808 8CD2                    	mov	dx,ss			; DX:SI points at command
  2323 0000080A B90300                  	mov	cx,3			; 3 byte command
  2324 0000080D E87BF9                  	call	output_cmd_to_fdc
  2325 00000810 5E59                    	popm	si,cx			; fix stack; get CL=seek to cylinder
  2326 00000812 86CD                    	xchg	cl,ch			; CH=seek to cylinder
  2327 00000814 7214                    	jc	.exit
  2328                                  
  2329 00000816 E8E5FE                  	call	wait_operation_complete
  2330 00000819 720F                    	jc	.exit
  2331                                  
  2332                                  ;;;	mov	[fdc_cylinder+di],ch	; set new cylinder number
  2333                                  
  2334 0000081B E827FA                  	call	fdc_wait_seek_done	; AH=error code if C=1
  2335 0000081E 720A                    	jc	.exit
  2336                                  
  2337                                  %if 0
  2338                                  ; probably have to skip the following during Format
  2339                                  	call	read_track_id		; just to be sure
  2340                                  	jc	.exit
  2341                                  %endif
  2342                                  
  2343 00000820 B440                    	mov	ah,ERR_seek_failed
  2344 00000822 3AAD9400                	cmp	ch,[fdc_cylinder+di]	; PCN filled in
  2345 00000826 7508                    	jne	.err
  2346                                  ;;;	mov	ah,ERR_8A
  2347                                  ;;;	cmp	ch,[fdc_ctrl_status+3]	; read cylinder number
  2348                                  ;;;	jne	.err
  2349                                  
  2350                                  
  2351                                  .okay:
  2352 00000828 30E4                    	Okay
  2353                                  .exit:
  2354 0000082A 595A5E                  	popm	cx,dx,si
  2355 0000082D C3                      	ret
  2356                                  
  2357                                  .invalid:
  2358                                  ; error -- the cylinder requested is invalid for this drive
  2359 0000082E B486                    	mov	ah,ERR_86
  2360 00000830 F9                      .err:	Error
  2361 00000831 EBF7                    	jmp	.exit		  	; jump WAY out
  2362                                  
  2363                                  
  2364                                  
  2365                                  
  2366                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2367                                  ;  Check_RW_Status		check ST0 & ST1 error bits
  2368                                  ;
  2369                                  ;  Call with:
  2370                                  ;	CY = 0,1	needs to be examined
  2371                                  ;
  2372                                  ;  Return with:
  2373                                  ;	CY = 0, AH = 0		no error detected
  2374                                  ;
  2375                                  ;	CY = 1, AH = final error code	error in status bits
  2376                                  ;
  2377                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2378                                   	global	Check_RW_Status
  2379                                  Check_RW_Status:
  2380 00000833 061E56525153            	pushm	bx,cx,dx,si,ds,es
  2381                                  
  2382                                  %if SOFT_DEBUG & DUMP
  2383                                  	xchg	al,ah			; error code to AL
  2384                                  	lahf				; flags to AH
  2385                                  	push	ax
  2386                                  
  2387                                  	xor	ah,ah			; zero hi-byte
  2388                                  	mov	cx,7
  2389                                  	mov	si,fdc_ctrl_status+6	; byte to start
  2390                                  .1	std
  2391                                  	lodsb
  2392                                    	push	ax			; push argument
  2393                                  	loop	.1
  2394                                  	cld
  2395                                  	push	cs
  2396                                  	push	fcrw
  2397                                  	call	_cprintf
  2398                                  	add	sp,18
  2399                                  
  2400                                  	pop	ax
  2401                                  	sahf				; restore flags
  2402                                  	xchg	al,ah			; restore error code to AH
  2403                                  %endif
  2404                                  
  2405                                  %if 1
  2406 00000839 7309                    	jnc	.no_err
  2407                                  
  2408 0000083B C6460E00                	mov	byte [offset_AL+bp],0	; say nothing transferred
  2409                                  
  2410                                  ; Carry is set, what happened?
  2411 0000083F 80FC81                  	cmp	ah,ERR_81		; first of our new error codes
  2412                                  	;;;
  2413 00000842 EB2E                    	jmp	.error		; for now
  2414                                  %endif
  2415                                  
  2416                                  
  2417                                  .no_err:
  2418 00000844 8A264200                	mov	ah,[fdc_ctrl_status]	; get ST0 to AH
  2419 00000848 88E0                    	mov	al,ah			; retain copy in AL
  2420 0000084A 80E4C0                  	and	ah,ST0_IC		; check interrupt code
  2421 0000084D 7424                    	jz	.exit	; Okay is set
  2422                                  	
  2423 0000084F B420                    	mov	ah,ERR_controller_failure
  2424 00000851 A810                    	test	al,ST0_EC
  2425 00000853 751D                    	jnz	.error
  2426                                  
  2427 00000855 A04300                  	mov	al,[fdc_ctrl_status+1]	; get ST1 to AL
  2428 00000858 B402                    	mov	ah,ERR_address_mark_not_found
  2429 0000085A A801                    	test	al,ST1_MA		; test Missing Address mark
  2430 0000085C 7514                    	jnz	.error
  2431                                  
  2432 0000085E FEC4                    	inc	ah			; Write Protect
  2433 00000860 A802                    	test	al,ST1_NW		;
  2434 00000862 750E                    	jnz	.error
  2435                                  
  2436 00000864 FEC4                    	inc	ah			; Sector not Found
  2437 00000866 A804                    	test	al,ST1_ND		; No Data
  2438 00000868 7508                    	jnz	.error
  2439                                  
  2440 0000086A B410                    	mov	ah,ERR_uncorrectable_CRC_error
  2441 0000086C A820                    	test	al,ST1_DE
  2442 0000086E 7502                    	jnz	.error
  2443                                  
  2444 00000870 B48F                    	mov	ah,ERR_unknown		; may be in ST2
  2445                                  
  2446 00000872 F9                      .error:	Error				; code is in AH
  2447                                  .exit:
  2448 00000873 5B595A5E1F07            	popm	bx,cx,dx,si,ds,es
  2449 00000879 C3                      	ret
  2450                                  
  2451                                  
  2452                                  %if SOFT_DEBUG & DUMP
  2453                                  fcrw	db	NL,"ST0 %02x  ST1 %02x  ST2 %02x  C+ %02x  H+ %02x  S+ %02x  N %x", 0
  2454                                  rwvc	db	NL,"AX %04x  CHS %02x:%02x:%02x  DL %02x  ES:BX %04x:%04x", 0
  2455                                  fnret	db	NL,"AH %02x  CY %d  CMD %02x %02x",NL, 0
  2456                                  %endif
  2457                                  
  2458                                  
  2459                                  
  2460                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2461                                  ;  @enable / @disable		Interrupt enable/disable
  2462                                  ;
  2463                                  ;  On a @disable, increment the lock counter and CLI
  2464                                  ;  On an @enable, decrement the lock counter and if it goes to zero, STI
  2465                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2466                                  	global	@enable, @disable
  2467                                  @disable:
  2468 0000087A 1E50                    	pushm	ax,ds
  2469 0000087C 9F                      	lahf				; save user flags
  2470 0000087D 6A40                    	push	bios_data_seg		; universal addressing
  2471 0000087F 1F                      	popm	ds
  2472 00000880 FA                      	cli				; guarantee locked operation
  2473 00000881 FE06AE00                	inc	byte [lock_count]
  2474 00000885 9E                      	sahf				; restore user flags
  2475 00000886 581F                    	popm	ax,ds
  2476 00000888 C3                      	ret
  2477                                  
  2478                                  @enable:
  2479 00000889 1E50                    	pushm	ax,ds
  2480 0000088B 9F                      	lahf				; save user flags
  2481 0000088C 6A40                    	push	bios_data_seg
  2482 0000088E 1F                      	popm	ds
  2483 0000088F FE0EAE00                	dec	byte [lock_count]	; test the lock count
  2484 00000893 7501                    	jnz	.5
  2485 00000895 FB                      	sti				; lock count went to zero, re-enable
  2486                                  .5:
  2487 00000896 9E                      	sahf				; restore user flags
  2488 00000897 581F                    	popm	ax,ds
  2489 00000899 C3                      	ret
  2490                                  
  2491                                  
  2492                                  
  2493                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2494                                  ;  read_track_id			; read address mark information
  2495                                  ;
  2496                                  ;  Call with:
  2497                                  ;	DS = BIOS data segment
  2498                                  ;	DI = unit number
  2499                                  ;	DH = head number
  2500                                  ;
  2501                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2502                                  read_track_id:
  2503 0000089A 525156                  	pushm	si,cx,dx
  2504                                  
  2505 0000089D C6063E0000              	mov	byte [fdc_drv_calib],0	; clear interrupt flags
  2506                                  
  2507 000008A2 E8DFFD                  	call	make_head_unit		; head/un
  2508 000008A5 88C4                    	mov	ah,al			; move to AH (second byte of command)
  2509 000008A7 B04A                    	mov	al,CMD_READ_ID | CMD_MF
  2510 000008A9 50                      	push	ax			; push the 2-byte command
  2511 000008AA 89E6                    	mov	si,sp
  2512 000008AC 8CD2                    	mov	dx,ss			; DX:SI points at command
  2513 000008AE B90200                  	mov	cx,2			; 2 bytes to READ_ID
  2514 000008B1 E8D7F8                  	call 	output_cmd_to_fdc	; issue the command
  2515 000008B4 58                      	pop	ax			; discard word in stack
  2516                                  
  2517 000008B5 E846FE                  	call	wait_operation_complete
  2518                                  
  2519 000008B8 5E595A                  	popm	si,cx,dx
  2520 000008BB C3                      	ret
  2521                                  
  2522                                  
  2523                                  
