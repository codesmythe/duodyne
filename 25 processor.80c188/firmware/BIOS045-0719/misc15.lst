     1                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     2                                  ; MISC15.ASM -- Miscellaneous BIOS calls (mostly int 15h)
     3                                  ;  with mods for version -45 assembly
     4                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     5                                  ;
     6                                  ;   This version is for assembly by  NASM 0.98.39 or later
     7                                  ;
     8                                  ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
     9                                  ; Provided for hobbyist use on the N8VEM SBC-188 board.
    10                                  ;
    11                                  ; This program is free software: you can redistribute it and/or modify
    12                                  ; it under the terms of the GNU General Public License as published by
    13                                  ; the Free Software Foundation, either version 3 of the License, or
    14                                  ; (at your option) any later version.
    15                                  ;
    16                                  ; This program is distributed in the hope that it will be useful,
    17                                  ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    18                                  ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    19                                  ; GNU General Public License for more details.
    20                                  ;
    21                                  ; You should have received a copy of the GNU General Public License
    22                                  ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    23                                  ;
    24                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    25                                  %include        "config.asm"
     1                              <1> ;/*
     2                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     3                              <1> ; VGA3.CFG
     4                              <1> ;   Copied to CONFIG.ASM for general release.
     5                              <1> ;
     6                              <1> ;       Modify the parameters below to reflect your system
     7                              <1> ;
     8                              <1> ;
     9                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    10                              <1> ;
    11                              <1> ;   Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    12                              <1> ;   Provided for hobbyist use on the N8VEM SBC-188 board.
    13                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    14                              <1> ;
    15                              <1> ; Define the serial terminal that the Video BIOS must emulate
    16                              <1> ; Set one of the following to 1
    17                              <1> ; If you have no idea what to choose, set TTY to 1
    18                              <1> TTY     equ     0       ; hardcopy -- cannot position the cursor
    19                              <1> DUMB    equ     0       ; dumb CRT -- ^H, ^J, ^K, ^L can move the cursor
    20                              <1> ANSI    equ     1       ; very smart, like a VT-100
    21                              <1> WYSE    equ     0       ; very smart Wyse series (30, 50, ...)
    22                              <1> ; others may get added in the future
    23                              <1> ;  ONE OF THE ABOVE must BE SET TO 1!!!!!
    24                              <1> ;
    25                              <1> ; Does the hardware configuration contain the Color Video Display Unit?
    26                              <1> ; Both the 8563 and the 8242 are used.  The default is CVDU=0
    27                              <1> CVDU	equ	0	; system does not have the CVDU
    28                              <1> ;
    29                              <1> ; Does the hardware configuration contain the VGA3 a/n Video card?
    30                              <1> ; The 8563 will be disabled, but the 8242 code is shared with the CVDU
    31                              <1> ; The default is VGA3=0
    32                              <1> VGA3   equ     1       ; system has the VGA3
    33                              <1> ;
    34                              <1> ; Does the hardware configuration contain the front panel card?
    35                              <1> ; The default is FRONT_PANEL=0
    36                              <1> ;
    37                              <1> FRONT_PANEL   equ     1       ; system has the VGA3
    38                              <1> %if 0
    39                              <1> 	*/
    40                              <1> #define VGA3 1
    41                              <1> /*
    42                              <1> %endif
    43                              <1> ;
    44                              <1> ; Boot up keyboard mode:  20h for NumLock on
    45                              <1> ;CVDU_KEYBOARD_STATUS	equ	0	; NumLock OFF
    46                              <1> CVDU_KEYBOARD_STATUS	equ	20h	; NumLock ON
    47                              <1> 
    48                              <1> ; Define the UART startup bit rate - 1200-19200 are most common
    49                              <1> ;UART_RATE	equ	0		; 1200
    50                              <1> ;UART_RATE	equ	1		; 2400
    51                              <1> ;UART_RATE	equ	2		; 4800
    52                              <1> ;UART_RATE	equ	3		; 9600
    53                              <1> ;UART_RATE	equ	4		; 19200
    54                              <1> UART_RATE	equ	5		; 38400
    55                              <1> ;UART_RATE	equ	6		; 57600
    56                              <1> ;UART_RATE	equ	7		; 115200
    57                              <1> 
    58                              <1> ; Does the serial terminal use the DSR/DTR protocol for flow control?
    59                              <1> ;UART_DSR_PROTOCOL	equ		1	; Yes!
    60                              <1> UART_DSR_PROTOCOL       equ             WYSE    ; Wyse always uses it
    61                              <1> 						; but not ANSI
    62                              <1> ; Define the size of the ROM image on the system in Kilobytes
    63                              <1> ; It may be smaller than the actual EPROM in use.
    64                              <1> ; The following sizes are supported:  32, 64, 128, and 256
    65                              <1> %ifndef ROM
    66                              <1> ROM             equ     32              ; 64 is the default
    67                              <1> %endif
    68                              <1> 
    69                              <1> ; Define the number of Wait States at which the ROM operates
    70                              <1> ROM_WS          equ     1               ; 0..3  (1 is the default)
    71                              <1> 
    72                              <1> ; Define the size in Kilobytes of DOS RAM (low SRAM plus EMM allocate RAM)
    73                              <1> ; This is a desired size and will only be present if a 4MEM board is added
    74                              <1> RAM_DOS         equ     640
    75                              <1> 
    76                              <1> ; Define the size of the low SRAM on the system in Kilobytes
    77                              <1> ; the default is 512 kilobytes
    78                              <1> RAM             equ     512             ; (512 is the default)
    79                              <1> 
    80                              <1> ; Define the number of Wait States at which the RAM operates
    81                              <1> RAM_WS          equ     0               ; 0..3  (0 is the default)
    82                              <1> 
    83                              <1> ; Define the number of Wait States for Local Peripheral devices (600-7FF)
    84                              <1> LCL_IO_WS       equ     1               ; 0..3  (1 is the default)
    85                              <1> 
    86                              <1> ; Define the number of Wait States for ECB BUS peripheral devices (4xx)
    87                              <1> BUS_IO_WS       equ     3               ; 0..3  (3 is the default)
    88                              <1> 
    89                              <1> ; Define the time zone in which we build the Relocatable BIOS
    90                              <1> %ifndef TIMEZONE
    91                              <1> %define TIMEZONE "CDT"
    92                              <1> %endif
    93                              <1> 
    94                              <1> ; Has the REDBUG debugger been loaded?
    95                              <1> %ifndef SOFT_DEBUG
    96                              <1> %define SOFT_DEBUG 0
    97                              <1> %endif
    98                              <1> 
    99                              <1> ; Should the BIOS include "Tiny BASIC" in the image?
   100                              <1> %ifndef TBASIC
   101                              <1> TBASIC          equ     1		; default is 1
   102                              <1> %endif
   103                              <1> 
   104                              <1> ; Should the BIOS include the Floating Point Emulator?  The 80188 does
   105                              <1> ; not allow a floating point co-processor, so this is probably a good idea.
   106                              <1> %ifndef FPEM
   107                              <1> FPEM            equ     1               ; default is 1
   108                              <1> %endif
   109                              <1> 
   110                              <1> ; Define the maximum number of EMM (4MEM) boards supported
   111                              <1> EMM_BOARDS      equ     4
   112                              <1> 
   113                              <1> ; Should the Floating Point Emulator use temporary storage in the EBDA
   114                              <1> ; or at locations 0280h..3FFh in low memory?
   115                              <1> %if SOFT_DEBUG
   116                              <1> FPEM_USE_EBDA   equ     FPEM            ; default is 0
   117                              <1> %else
   118                              <1> FPEM_USE_EBDA   equ     0; FPEM            ; default is 0
   119                              <1> %endif
   120                              <1> 
   121                              <1> ; Define the size of the EPROM that is to be installed on the system
   122                              <1> ; It may be larger than the actual ROM image to be generated.
   123                              <1> %ifndef CHIP
   124                              <1> CHIP            equ     64
   125                              <1> %endif
   126                              <1> 
   127                              <1> ; Does the SBC-188 00.4 board have the LS138/LS08 piggyback fix
   128                              <1> ; Set to 1 for the SBC-188 v1.0 and later production boards
   129                              <1> FDC_PIGGYBACK_FIX       equ     0       ; Fix not installed
   130                              <1> ;FDC_PIGGYBACK_FIX       equ     1       ; fix  IS  installed
   131                              <1> 
   132                              <1> ; On SBC-188 rev 00.4 board, there is a published hardware fix (2010-09-18).
   133                              <1> ; If the wiring update is installed, or you have a later board, then
   134                              <1> ; set this to 0.  If you are using the software workaround, then set this
   135                              <1> ; to 1.  The rev 1.0 board has this fix already.
   136                              <1> NEED_TIMER_FIX  equ     0               ; have revised hardware
   137                              <1> ;NEED_TIMER_FIX  equ     1               ; use workaround
   138                              <1> 
   139                              <1> ; Define the UART oscillator speed
   140                              <1> UART_OSC        equ     1843200         ; 1.8432 Mhz is specified
   141                              <1> 
   142                              <1> 
   143                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   144                              <1> ; end of the User configuration
   145                              <1> ;       Do Not modify anything below this point
   146                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   147                              <1> 
   148                              <1> CVDU_8563	equ	CVDU		; separate inits
   149                              <1> CVDU_8242	equ	CVDU|VGA3 	; separate inits
   150                              <1> VGA3_6445       equ     VGA3            ; separate inits
   151                              <1> ; Suppress all UART output in color video Mode 3
   152                              <1> ;UART_MODE3_SUPPRESS	equ	0
   153                              <1> UART_MODE3_SUPPRESS	equ	CVDU_8563 | VGA3_6445
   154                              <1> CVDU_USE_MSDOS_KLUDGE	equ	0; CVDU_8242	; bad, bad MSDOS
   155                              <1> CVDU_USE_KBD_HOOK		equ	CVDU_8242
   156                              <1> 
   157                              <1> ; Define existence of any uart chip
   158                              <1> UART		equ	TTY+DUMB+ANSI+WYSE
   159                              <1> startuplength   equ     128                     ; may be up to 1024
   160                              <1> startseg        equ     0FFFFh - (ROM*64) + 1
   161                              <1> highrom         equ     (ROM*400h)&0FFFFh
   162                              <1> startupseg      equ     0FFFFh - (startuplength>>4) + 1
   163                              <1> bios_data_seg   equ     040h            ; segment of BIOS data area
   164                              <1> 
   165                              <1> 
   166                              <1> %define ARG(n) [bp+2+(n)*2]
   167                              <1> 
   168                              <1> %macro  check   1.nolist
   169                              <1>  %if (%1)
   170                              <1>    %error Check Failure: %1
   171                              <1>  %endif
   172                              <1> %endm
   173                              <1> %macro  range   3.nolist
   174                              <1>  %if (%1)<(%2)
   175                              <1>    %error Out of Range: %1
   176                              <1>  %elif (%1)>(%3)
   177                              <1>    %error Out of Range: %1
   178                              <1>  %endif
   179                              <1> %endm
   180                              <1> _terminal equ UART+CVDU
   181                              <1>  check   RAM_DOS&15
   182                              <1>  check   RAM&(RAM-1)
   183                              <1>  check   ROM&(ROM-1)
   184                              <1>  range   RAM,32,512
   185                              <1>  range   ROM,32,256
   186                              <1>  range   RAM_WS,0,3
   187                              <1>  range   ROM_WS,0,3
   188                              <1>  range   RAM_DOS,RAM,(1024-ROM)
   189                              <1>  range   LCL_IO_WS,0,3
   190                              <1>  range   BUS_IO_WS,0,3
   191                              <1>  range   UART_OSC,500000,16000000
   192                              <1>  range   UART_RATE,0,7
   193                              <1>  range	 UART,0,1
   194                              <1>  range	 _terminal,1,2
   195                              <1> 
   196                              <1> %ifndef SOFT_DEBUG
   197                              <1> %define SOFT_DEBUG 0
   198                              <1> %endif
   199                              <1> 
   200                              <1> %ifndef TRACE
   201                              <1> %define TRACE 0
   202                              <1> %endif
   203                              <1> 
   204                              <1> %ifdef MAKE_OBJECT_FILE
   205                              <1>         segment _DATA WORD PUBLIC CLASS=DATA
   206                              <1>         export _ROMsize
   207                              <1>         export _CHIPsize
   208                              <1> _ROMsize        dw      ROM
   209                              <1> _CHIPsize       dw      CHIP
   210                              <1> %endif
   211                              <1> ; end of the Hardware configuration file
   212                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   213                              <1> ;*/
    26                                  %include        "cpuregs.asm"
     1                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     2                              <1> ; CPUREGS.ASM
     3                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     4                              <1> ;
     5                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
     6                              <1> ;
     7                              <1> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
     8                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
     9                              <1> ;
    10                              <1> ; This program is free software: you can redistribute it and/or modify
    11                              <1> ; it under the terms of the GNU General Public License as published by
    12                              <1> ; the Free Software Foundation, either version 3 of the License, or
    13                              <1> ; (at your option) any later version.
    14                              <1> ;
    15                              <1> ; This program is distributed in the hope that it will be useful,
    16                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    17                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    18                              <1> ; GNU General Public License for more details.
    19                              <1> ;
    20                              <1> ; You should have received a copy of the GNU General Public License
    21                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    22                              <1> ;
    23                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    24                              <1>         cpu     186
    25                              <1> ;
    26                              <1> ;
    27                              <1> ; IBM model byte -- must be less than a 286
    28                              <1> ;
    29                              <1> ;MODEL_BYTE		equ	0FEh	; PC-XT
    30                              <1> ;SUBMODEL_BYTE		equ	0FFh	; not used
    31                              <1> 
    32                              <1> MODEL_BYTE		equ	0FEh	; PC-XT
    33                              <1> SUBMODEL_BYTE		equ	00h	;  "
    34                              <1> 
    35                              <1> 
    36                              <1> ; 80188 peripheral control register block address
    37                              <1> CPU_CSCR	        equ	0FF00h
    38                              <1> 
    39                              <1> ; Compatible Mode registers
    40                              <1> 
    41                              <1> cpu_relocation          equ     CPU_CSCR+0FEh
    42                              <1> 
    43                              <1> ; The memory and peripheral chip select register offsets from 0FF00h
    44                              <1> 
    45                              <1> cpu_umcs                equ     CPU_CSCR+0A0h          ; Upper memory select
    46                              <1> cpu_lmcs                equ     CPU_CSCR+0A2h          ; Lower memory select
    47                              <1> cpu_pacs                equ     CPU_CSCR+0A4h          ; Peripheral select
    48                              <1> cpu_mmcs                equ     CPU_CSCR+0A6h          ; Middle memory base
    49                              <1> cpu_mpcs                equ     CPU_CSCR+0A8h          ; Mid mem. & peripherals
    50                              <1> 
    51                              <1> ; Enhanced Mode registers
    52                              <1> 
    53                              <1> cpu_mdram               equ     CPU_CSCR+0E0h          ; memory partition reg.
    54                              <1> cpu_cdram               equ     CPU_CSCR+0E2h          ; clock prescaler
    55                              <1> cpu_edram               equ     CPU_CSCR+0E4h          ; Enable refresh reg.
    56                              <1> cpu_pdcon               equ     CPU_CSCR+0F0h          ; Power-Save control
    57                              <1> 
    58                              <1> 
    59                              <1> ; On-board internal peripheral equates
    60                              <1> ; Programmable Interrupt Controller
    61                              <1> PIC	        equ	CPU_CSCR+020H
    62                              <1> PIC_EOI	        equ	PIC+2           ; End Of Interrupt
    63                              <1> PIC_POLLR	equ	PIC+4
    64                              <1> PIC_POLLSR	equ	PIC+6
    65                              <1> PIC_IMASK	equ	PIC+8
    66                              <1> PIC_PMREG	equ	PIC+0AH
    67                              <1> PIC_SRVR	equ	PIC+0CH
    68                              <1> PIC_IRQR	equ	PIC+0EH
    69                              <1> PIC_IRQSR	equ	PIC+10H
    70                              <1> PIC_TCR	        equ	PIC+12H
    71                              <1> PIC_DMA0CR	equ	PIC+14H
    72                              <1> PIC_DMA1CR	equ	PIC+16H
    73                              <1> PIC_I0CON	equ	PIC+18H
    74                              <1> PIC_I1CON	equ	PIC+1AH
    75                              <1> PIC_I2CON	equ	PIC+1CH
    76                              <1> PIC_I3CON	equ	PIC+1EH
    77                              <1> 
    78                              <1> EOI_NSPEC       equ     8000h           ; Non-Specific EOI
    79                              <1> 
    80                              <1> ; Interrupt masks (Master Mode)
    81                              <1> ;
    82                              <1> mask_timer_all          equ     0001h
    83                              <1> mask_dma0               equ     0004h
    84                              <1> mask_dma1               equ     0008h
    85                              <1> mask_int0               equ     0010h
    86                              <1> mask_int1               equ     0020h
    87                              <1> mask_int2               equ     0040h
    88                              <1> mask_int3               equ     0080h
    89                              <1> 
    90                              <1> 
    91                              <1> 
    92                              <1> ; Timers
    93                              <1> TIM0	        equ	CPU_CSCR+050H
    94                              <1> TIM1	        equ	CPU_CSCR+058H
    95                              <1> TIM2	        equ	CPU_CSCR+060H
    96                              <1> 
    97                              <1> TCNT	        equ	0	; count register
    98                              <1> CMPA	        equ	2	; max count A
    99                              <1> CMPB	        equ	4	; max count B (not present on TIM2)
   100                              <1> TCON	        equ	6	; mode/control word
   101                              <1> 
   102                              <1> ; Timer control bits:
   103                              <1> tc_EN           equ     8000h   ; Enable bit
   104                              <1> tc_nINH         equ     4000h   ; not Inhibit Enable
   105                              <1> tc_INT          equ     2000h   ; Interrupt Enable
   106                              <1> tc_RIU          equ     1000h   ; Register A/B (0/1) in Use
   107                              <1> tc_MC           equ     0020h   ; Maximum Count reached
   108                              <1> tc_RTG          equ     0010h   ; Retrigger (internal source)
   109                              <1> tc_P            equ     0008h   ; Prescale internal clock (timers 0 & 1 only)
   110                              <1> tc_EXT          equ     0004h   ; External clock
   111                              <1> tc_ALT          equ     0002h   ; Alternate between A & B max count registers
   112                              <1> tc_CONT         equ     0001h   ; Continuous: continue after max count
   113                              <1> 
   114                              <1> 
   115                              <1> 
   116                              <1> 
   117                              <1> ; DMA
   118                              <1> DMA0	        equ	CPU_CSCR+0C0H
   119                              <1> DMA1	        equ	CPU_CSCR+0D0H
   120                              <1> DMASPL	        equ	0	; source pointer low
   121                              <1> DMASPU	        equ	2	; source pointer high
   122                              <1> DMADPL	        equ	4	; destination pointer low
   123                              <1> DMADPU	        equ	6	; destination pointer high
   124                              <1> DMATC	        equ	8	; terminal count
   125                              <1> DMACW	        equ	0AH	; control word
   126                              <1> 
   127                              <1> 
   128                              <1> 
   129                              <1> 
   130                              <1> 
   131                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   132                              <1> ;
   133                              <1> ;       SBC-188 external devices
   134                              <1> ;
   135                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   136                              <1> 
   137                              <1> IO_BASE			equ	0400h
   138                              <1> 
   139                              <1> 
   140                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   141                              <1> ; The UART registers
   142                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   143                              <1> uart_base               equ     IO_BASE+0280h
   144                              <1> uart_rbr                equ     uart_base       ;Rcvr Buffer / read only
   145                              <1> uart_thr                equ     uart_base       ;Transmit Holding / write only
   146                              <1> uart_ier                equ     uart_base+1     ;Interrupt Enable
   147                              <1> uart_iir                equ     uart_base+2     ;Interrupt Ident / read only
   148                              <1> uart_fcr                equ     uart_base+2     ;FIFO Control / write only
   149                              <1> uart_lcr                equ     uart_base+3     ;Line Control
   150                              <1> uart_mcr                equ     uart_base+4     ;Modem Control
   151                              <1> uart_lsr                equ     uart_base+5     ;Line Status
   152                              <1> uart_msr                equ     uart_base+6     ;Modem Status
   153                              <1> uart_sr			equ	uart_base+7	;Scratch
   154                              <1> 
   155                              <1> uart_dll                equ     uart_base       ;Divisor Latch LS Byte
   156                              <1> uart_dlm                equ     uart_base+1     ;Divisor Latch MS Byte
   157                              <1> 
   158                              <1> 
   159                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   160                              <1> ; Floppy controller
   161                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   162                              <1> FDC	        equ	IO_BASE+0200H
   163                              <1> FDC_MSR         equ     FDC
   164                              <1> FDC_DATA        equ     FDC_MSR+1
   165                              <1> FDC_DACK        equ	FDC+10H
   166                              <1> FDC_LDOR	equ	FDC+20H
   167                              <1> FDC_LDCR	equ	FDC+30H
   168                              <1> FDC_TC	        equ	FDC+40H
   169                              <1> FDC_DACK_TC     equ     FDC_DACK | FDC_TC
   170                              <1> 
   171                              <1> 
   172                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   173                              <1> ;DS1302 RTC
   174                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   175                              <1> RTC	equ	IO_BASE+0300H
   176                              <1> 
   177                              <1> 
   178                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   179                              <1> ; PIO 82C55 I/O 
   180                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   181                              <1> PPI	        equ	IO_BASE+0260H
   182                              <1> PIO_A	        equ	PPI+0	; (OUTPUT)
   183                              <1> PIO_B	        equ	PPI+1	; (INPUT)
   184                              <1> PIO_C	        equ	PPI+2	; (CENTRONICS control low nibble)  
   185                              <1> PIO_CTRL	equ	PPI+3	; CONTROL BYTE PIO 82C55
   186                              <1> 
   187                              <1> portA           equ     PPI+0   ;
   188                              <1> portB           equ     PPI+1   ;     LITES uses this for output
   189                              <1> portC           equ     PPI+2   ;
   190                              <1> 
   191                              <1> 
   192                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   193                              <1> ; Dual [DMA] IDE devices
   194                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   195                              <1> DIDE		equ	IO_BASE + 20H	; range 0x20..0x3F
   196                              <1> 
   197                              <1> DIDE0		equ	DIDE		; first interface (master & slave)
   198                              <1> DIDE1		equ	DIDE+10h	; second interface (master & slave)
   199                              <1> 
   200                              <1> 
   201                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   202                              <1> ; Cassette I/O
   203                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   204                              <1> cuart_base	EQU 	IO_BASE+80H	; BASE IO ADDRESS OF CASSETTE UART
   205                              <1> cuart_rbr	equ     cuart_base	;Rcvr Buffer / read only
   206                              <1> cuart_thr	equ     cuart_base	;Transmit Holding / write only
   207                              <1> cuart_ier	equ     cuart_base+1	;Interrupt Enable
   208                              <1> cuart_iir	equ     cuart_base+2	;Interrupt Ident / read only
   209                              <1> cuart_fcr	equ     cuart_base+2	;FIFO Control / write only
   210                              <1> cuart_lcr	equ     cuart_base+3	;Line Control
   211                              <1> cuart_mcr	equ     cuart_base+4	;Modem Control
   212                              <1> cuart_lsr	equ     cuart_base+5	;Line Status
   213                              <1> cuart_msr	equ     cuart_base+6	;Modem Status
   214                              <1> cuart_sr	equ	cuart_base+7	;Scratch
   215                              <1> 
   216                              <1> cuart_dll	equ     cuart_base	;Divisor Latch LS Byte
   217                              <1> cuart_dlm	equ	cuart_base+1	;Divisor Latch MS Byte
   218                              <1> 
   219                              <1> 
   220                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   221                              <1> ;
   222                              <1> ;       4MEM control registers
   223                              <1> ;
   224                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   225                              <1> EMM_addr        equ     1               ; high 6 bits of 20-bit address
   226                              <1> EMM_page        equ     0               ; 4MEM page in [0..254]
   227                              <1> 
   228                              <1> EMM_BASE        equ     IO_BASE + 000h          ; first EMM (4MEM) board
   229                              <1> EMM_unmapped    equ     255             ; unmapped 4MEM page
   230                              <1> 
   231                              <1> EMM0            equ     EMM_BASE        ; first  EMM board
   232                              <1> EMM1            equ     EMM0 + 2        ; second EMM board
   233                              <1> EMM2            equ     EMM1 + 2        ; third  EMM board
   234                              <1> EMM3            equ     EMM2 + 2        ; fourth EMM board
   235                              <1> 
   236                              <1> 
   237                              <1> 
   238                              <1> 
   239                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   240                              <1> ;
   241                              <1> ;	ColorVDU devices
   242                              <1> ;
   243                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   244                              <1> ;
   245                              <1> ;	major select on the Z80 bus
   246                              <1> ;
   247                              <1> devCVDU_8bit	equ	0xE0		; this may change to 0x10
   248                              <1> 
   249                              <1> devCVDUbase 	equ	IO_BASE + devCVDU_8bit
   250                              <1> 
   251                              <1> M8563status	equ	devCVDUbase + 4		; 4 == bitrev(2)
   252                              <1> M8563register	equ	devCVDUbase + 4
   253                              <1> M8563data	equ	devCVDUbase + 12	; 12 == bitrev(3)
   254                              <1> 
   255                              <1> %if CVDU_8563
   256                              <1> I8242status	equ	devCVDUbase + 10	; 10 == bitrev(5)
   257                              <1> I8242command	equ	devCVDUbase + 10
   258                              <1> I8242data	equ	devCVDUbase + 2		; 2 == bitrev(4)
   259                              <1> %endif
   260                              <1> 
   261                              <1> 
   262                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   263                              <1> ;
   264                              <1> ;	VGA3 devices
   265                              <1> ;
   266                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   267                              <1> ;
   268                              <1> ;	major select on the Z80 bus
   269                              <1> ;
   270                              <1> devVGA3_8bit    equ     0xE0                    ; same as CVDU
   271                              <1> 
   272                              <1> devVGA3base       equ     IO_BASE + devVGA3_8bit
   273                              <1> 
   274                              <1> %if VGA3_6445
   275                              <1> I8242status	equ	devVGA3base + 1
   276                              <1> I8242command	equ	devVGA3base + 1
   277                              <1> I8242data	equ	devVGA3base + 0
   278                              <1> %endif
   279                              <1> HD6445addr	equ	devVGA3base + 2		; to address the HD6445 registers
   280                              <1> HD6445reg	equ	devVGA3base + 3		; to r/w a register on the CRTC
   281                              <1> 
   282                              <1> vga3cfg		equ	devVGA3base + 4
   283                              <1> ; the following are probably not used on the SBC-188, except for testing/checking
   284                              <1> vga3adhi	equ	devVGA3base + 5
   285                              <1> vga3adlo	equ	devVGA3base + 6
   286                              <1> vga3data	equ	devVGA3base + 7
   287                              <1> 
   288                              <1> 
   289                              <1> 
   290                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   291                              <1> ;
   292                              <1> ;	Front Panel devices
   293                              <1> ;
   294                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   295                              <1> ;
   296                              <1> ; Front Panel 82C55 I/O 
   297                              <1> FPPPI	        equ	IO_BASE+0A0H
   298                              <1> FPPORTA         equ     FPPPI+0   	;
   299                              <1> FPPORTB         equ     FPPPI+1   	;    
   300                              <1> FPPORTC         equ     FPPPI+2   	;
   301                              <1> FPPIOCONT       equ     FPPPI+3   	;
   302                              <1> 
   303                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   304                              <1> ; debug port -- JRC only
   305                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   306                              <1> portD		equ	IO_BASE + 0FFh		; 0x04FF
   307                              <1> ;portD		equ	portB		     ; older 8255 output on PPI
   308                              <1> 
   309                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   310                              <1> ;
   311                              <1> ; some useful macros:
   312                              <1> ;
   313                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   314                              <1> ;
   315                              <1> 
   316                              <1> %imacro setloc  1.nolist
   317                              <1>  times   (%1-($-$$)) db 0FFh
   318                              <1> %endm
   319                              <1> 
   320                              <1> %imacro db_lo   1
   321                              <1>  db (%1)&255
   322                              <1> %endm
   323                              <1> 
   324                              <1> %imacro cnop    0.nolist
   325                              <1> %if SOFT_DEBUG
   326                              <1>         nop
   327                              <1> %endif
   328                              <1> %endm
   329                              <1> 
   330                              <1> %imacro popm 1-*.nolist
   331                              <1> %rep %0
   332                              <1> %ifidni %1,ALL
   333                              <1>  popa
   334                              <1> %elifidni %1,F
   335                              <1>  popf
   336                              <1> %else
   337                              <1>  pop %1
   338                              <1> %ifidni %1,DS
   339                              <1>  cnop
   340                              <1> %elifidni %1,ES
   341                              <1>  cnop
   342                              <1> %endif
   343                              <1> %endif
   344                              <1> %rotate 1
   345                              <1> %endrep
   346                              <1> %endm
   347                              <1> 
   348                              <1> %imacro pushm 1-*.nolist
   349                              <1> %rep %0
   350                              <1> %rotate -1
   351                              <1> %ifidni %1,ALL
   352                              <1>  pusha
   353                              <1> %elifidni %1,F
   354                              <1>  pushf
   355                              <1> %else
   356                              <1>  push %1
   357                              <1> %endif
   358                              <1> %endrep
   359                              <1> %endm
   360                              <1> 
   361                              <1> ; end CPUREGS.ASM
   362                              <1> 
    27                                  %include	"date.asm"
     1                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     2                              <1> ; date.asm
     3                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     4                              <1> ; string 0 is for "startup.asm" inclusion; must be 8 chars exactly
     5                              <1> ; string 1 is for RBIOS.ASM inclusion; should be very readable
     6                              <1> 
     7                              <1> %define DATE_STRING0	"06/18/17"
     8                              <1> %define DATE_STRING1	"18-Jun-2017"
     9                              <1> 
    10                              <1> %define VERSION_MAJOR		3
    11                              <1> %define VERSION_MINOR		0
    12                              <1> %define VERSION_REVISION	45
    13                              <1> %define VERSION_SUFFIX		"-beta"
    14                              <1> %define VERSION_STRING		"3.0-45",VERSION_SUFFIX
    15                              <1> 
    16                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    17                              <1> ; Revision information:
    18                              <1> ;  ver.	2.1 -- table-driven support for all IBM floppy types
    19                              <1> ;	2.2 -- Dual IDE driver; CVDU memory sizing
    20                              <1> ;	2.3 -- font_vga corrects (i grave) (n_tilde)
    21                              <1> ;	    &  Dual SDcard & Minix boot
    22                              <1> ;	2.4 -- Int 15h multiprogramming hooks: fn90, fn91 (never done)
    23                              <1> ;	3.0 -- VGA3 support
    24                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    28                                  %include        "equates.asm"
     1                              <1> ;========================================================================
     2                              <1> ; EQUATES.ASM -- Lots of Defintions for Relocatable BIOS
     3                              <1> ;========================================================================
     4                              <1> ;   for the N8VEM SBC-188 v.00.4 and 00.5
     5                              <1> ;
     6                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
     7                              <1> ;
     8                              <1> ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
     9                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    10                              <1> ;
    11                              <1> ; This program is free software: you can redistribute it and/or modify
    12                              <1> ; it under the terms of the GNU General Public License as published by
    13                              <1> ; the Free Software Foundation, either version 3 of the License, or
    14                              <1> ; (at your option) any later version.
    15                              <1> ;
    16                              <1> ; This program is distributed in the hope that it will be useful,
    17                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    18                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    19                              <1> ; GNU General Public License for more details.
    20                              <1> ;
    21                              <1> ; You should have received a copy of the GNU General Public License
    22                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    23                              <1> ;
    24                              <1> ;========================================================================
    25                              <1> 
    26                              <1> %if 1
    27                              <1> 	SEGMENT  _TEXT ALIGN=16 PUBLIC CLASS=CODE
    28                              <1>         SEGMENT  CONST ALIGN=2 PUBLIC CLASS=DATA
    29                              <1> 	SEGMENT  _DATA ALIGN=2 PUBLIC CLASS=DATA
    30                              <1>         SEGMENT  CONST2 ALIGN=2 PUBLIC CLASS=DATA
    31                              <1> 	SEGMENT  _BSS  ALIGN=2 PUBLIC CLASS=BSS
    32                              <1> ;;;        SEGMENT  _BASIC ALIGN=16 PUBLIC CLASS=BASIC
    33                              <1> 
    34                              <1> 	GROUP	DGROUP CONST _DATA CONST2 _BSS
    35                              <1> 
    36                              <1>         global  FPEM_segment
    37                              <1> %endif
    38                              <1> 
    39                              <1> %include "ascii.asm"
     1                              <2> ; ascii.asm
     2                              <2> ;
     3                              <2> CTRL            equ     1Fh     ; masks a character to CTRL-x
     4                              <2> 
     5                              <2> NUL     equ     00h
     6                              <2> BEL     equ     (CTRL & 'G')
     7                              <2> BS      equ     08h
     8                              <2> HT      equ     09h
     9                              <2> LF	equ	0Ah
    10                              <2> NL      equ     LF
    11                              <2> CR	equ	0Dh
    12                              <2> XON     equ     (CTRL & 'Q')
    13                              <2> XOFF    equ     (CTRL & 'S')
    14                              <2> DC1     equ     XON
    15                              <2> DC3     equ     XOFF
    16                              <2> ESC     equ	1Bh
    17                              <2> 
    18                              <2> 
    40                              <1> 
    41                              <1> 
    42                              <1> ; POST error codes. Presently one byte but can expand to word.
    43                              <1> ER_BIOS equ	01h		; Bad ROM bios checksum, patch last byte
    44                              <1> ER_RAM	equ	02h		; Bad RAM in main memory, replace
    45                              <1> ER_CRT	equ	04h		; Bad RAM in video card, replace
    46                              <1> ER_FDC	equ	08h		; Bad FDC
    47                              <1> ER_UNK1	equ	10h		; {unassigned}
    48                              <1> ER_MEM	equ	20h		; Bad RAM in vector area, replace
    49                              <1> ER_ROM	equ	40h		; Bad ROM in expansion area, bad checksum
    50                              <1> ER_UNK2	equ	80h		; {unassigned}
    51                              <1> 
    52                              <1> 
    53                              <1> 
    54                              <1> ;; ************************ BIOS Data Segment ******************************
    55                              <1> ;; BIOS data segment - not all will  be used
    56                              <1> ;                struc   BIOS_DATA_AREA  ; at 0040:0000
    57                              <1> %include "bda.inc"
     1                              <2> ;/*======================================================================
     2                              <2> ; bda.inc -- BIOS data area definitions
     3                              <2> ;========================================================================
     4                              <2> ;   for the N8VEM SBC-188
     5                              <2> ;
     6                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
     7                              <2> ;
     8                              <2> ; Copyright (C) 2013 John R. Coffman.  All rights reserved.
     9                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    10                              <2> ;
    11                              <2> ; This program is free software: you can redistribute it and/or modify
    12                              <2> ; it under the terms of the GNU General Public License as published by
    13                              <2> ; the Free Software Foundation, either version 3 of the License, or
    14                              <2> ; (at your option) any later version.
    15                              <2> ;
    16                              <2> ; This program is distributed in the hope that it will be useful,
    17                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    18                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    19                              <2> ; GNU General Public License for more details.
    20                              <2> ;
    21                              <2> ; You should have received a copy of the GNU General Public License
    22                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    23                              <2> ;
    24                              <2> ;========================================================================
    25                              <2> 
    26                              <2> 			;*/ extern				/*
    27                              <2> 	ABSOLUTE  0	;*/ struct BDA {			/*
    28 00000000 <res 00000008>      <2> serial_ports    resw    4	;*/	word	serial_ports[4];	/*
    29 00000008 <res 00000008>      <2> parallel_ports  resw    4	;*/	word	parallel_ports[4];	/*
    30 00000010 <res 00000002>      <2> equipment_flag  resw    1	;*/	EQFL	equipment_flag;		/*
    31                              <2> ;	dw	?		; 40:10 	; Equipment present word
    32                              <2> ;  						;  = (1 iff floppies) *     1.
    33                              <2> ;                                               ;  + (1 iff 187     ) *     2.
    34                              <2> ;  						;  + (#+1 64K sys ram) *    4.
    35                              <2> ;  						;  + (init crt mode ) *    16.
    36                              <2> ;  						;  + (# of floppies ) *    64.
    37                              <2> ;  						;  + (# serial ports) *   512.
    38                              <2> ;  						;  + (1 iff toy port) *  4096.
    39                              <2> ;                                               ;  + (1 iff modem   ) *  8192.
    40                              <2> ;  						;  + (# parallel LPT) * 16384.
    41 00000012 <res 00000001>      <2> mfg_test_flags  resb    1	;*/	byte	mfg_test_flags;	/* 40:12 unused by us
    42 00000013 <res 00000002>      <2> memory_size     resw    1	;*/	word	memory_size;	/* 40:13 kilobytes
    43                              <2> uart_kbd_ctrl_R	equ	$	;*/				/*** JRC: count of ctrl-R's for reboot
    44 00000015 <res 00000001>      <2> IPL_errors      resb    1	;*/	byte	IPL_errors;	/* 40:15 IPL errors<-table/scratchpad
    45 00000016 <res 00000001>      <2> unused_01       resb    1	;*/	byte	unused_01;	/*
    46                              <2> ;;---------------[Keyboard data area]------------;
    47 00000017 <res 00000002>      <2> keyboard_flags_0 resw   1	;*/	word	keyboard_flags_0;  /* 40:17 Shift/Alt/etc. keyboard flags
    48                              <2> keyboard_flags_1 equ	$-1	;     2nd byte	keyboard_flags_1;  
    49 00000019 <res 00000001>      <2> keypad_char	resb	1	;*/	byte	keypad_char;	/* 40:19 Alt-KEYPAD char. goes here
    50 0000001A <res 00000002>      <2> kbd_buffer_head resw    1	;*/	word	kbd_buffer_head;   /* 40:1A --> keyboard buffer head
    51 0000001C <res 00000002>      <2> kbd_buffer_tail resw    1	;*/	word	kbd_buffer_tail;   /* 40:1C --> keyboard buffer tail
    52 0000001E <res 00000020>      <2> kbd_buffer      resw    16	;*/	word	kbd_buffer[16];	/* 40:1E Keyboard Buffer (Scan,Value)
    53                              <2> kbd_buffer_last	equ	$	;*/				/*
    54                              <2> ;;---------------[Diskette data area]------------;
    55 0000003E <res 00000001>      <2> fdc_drv_calib   resb    1	;*/	byte	fdc_drive_calib;   /* 40:3E
    56 0000003F <res 00000001>      <2> fdc_motor_LDOR  resb    1	;*/	byte	fdc_motor_LDOR;	   /* 40:3F Motor, DMA, select control
    57 00000040 <res 00000001>      <2> fdc_motor_ticks resb    1	;*/	byte	fdc_motor_ticks;   /* 40:40 ticks til motor off
    58 00000041 <res 00000001>      <2> fdc_status      resb    1	;*/	byte	fdc_status;	   /* 40:41
    59                              <2> ;				Floppy return code stat byte
    60                              <2> ;				;  1 = bad ic 765 command req.
    61                              <2> ;				;  2 = address mark not found
    62                              <2> ;				;  3 = write to protected disk
    63                              <2> ;				;  4 = sector not found
    64                              <2> ;				;  8 = data late (DMA overrun)
    65                              <2> ;				;  9 = DMA failed 64K page end
    66                              <2> ;				; 16 = bad CRC on floppy read
    67                              <2> ;				; 32 = bad NEC 765 controller
    68                              <2> ;				; 64 = seek operation failed
    69                              <2> ;				;128 = disk drive timed out
    70 00000042 <res 00000007>      <2> fdc_ctrl_status resb    7	;*/	byte	fdc_ctrl_status[7];  /* 40:42 Status bytes from NEC 765
    71                              <2> ;;---------------[Video display area]------------;
    72 00000049 <res 00000001>      <2> video_mode      resb    1	;*/	byte	video_mode;	/* 40:49
    73                              <2> ;			 	; Current CRT mode  (software)
    74                              <2> ;				;  0 = 40 x 25 text (no color)
    75                              <2> ;				;  1 = 40 x 25 text (16 color)
    76                              <2> ;				;  2 = 80 x 25 text (no color)
    77                              <2> ;				;  3 = 80 x 25 text (16 color)
    78                              <2> ;				;  4 = 320 x 200 grafix 4 color
    79                              <2> ;				;  5 = 320 x 200 grafix 0 color
    80                              <2> ;				;  6 = 640 x 200 grafix 0 color
    81                              <2> ;				;  7 = 80 x 25 text (mono card)
    82 0000004A <res 00000002>      <2> video_columns   resw    1	;*/	word video_columns;	/* 40:4A Columns on CRT screen
    83 0000004C <res 00000002>      <2> video_regen_bytes  resw 1	;*/	word video_regen_bytes;	/* 40:4C Bytes in the regen region
    84 0000004E <res 00000002>      <2> video_regen_offset resw 1	;*/	word video_regen_offset;/* 40:4E Byte offset in regen region
    85 00000050 <res 00000010>      <2> video_cursor_pos  resw  8	;*/	word video_cursor_pos[8];  /* 40:50 Cursor pos for up to 8 pages
    86 00000060 <res 00000002>      <2> video_cursor_mode resw  1	;*/	word video_cursor_mode;	/* 40:60 Current cursor mode setting
    87 00000062 <res 00000001>      <2> video_page      resb    1	;*/	byte video_page;	/* 40:62 Current page on display
    88 00000063 <res 00000002>      <2> video_base_seg  resw    1	;*/	word video_base_seg;	/* 40:63 Base address (B000h or B800h)
    89 00000065 <res 00000001>      <2> video_hw_mode   resb    1	;*/	byte video_hw_mode;	/* 40:65 ic 6845 mode reg. (hardware)
    90 00000066 <res 00000001>      <2> video_cga_palette resb  1	;*/	byte video_cga_palette;	/* 40:66 Current CGA palette
    91                              <2> ;;---------------[Used to setup ROM]-------------;
    92 00000067 <res 00000004>      <2> eprom_address   resd    1	;*/	dword eprom_address;	/* 40:67 Eprom base Offset,Segment
    93 0000006B <res 00000001>      <2> spurious_irq    resb    1	;*/	byte spurious_irq;	/* 40:6B Last spurious interrupt IRQ
    94                              <2> ;;---------------[Timer data area]---------------;
    95 0000006C <res 00000004>      <2> timer_ticks     resd    1	;*/	dword timer_ticks;	/* 40:6C Ticks since midnight (lo,hi)
    96 00000070 <res 00000001>      <2> timer_new_day   resb    1	;*/	byte timer_new_day;	/* 40:70 Non-zero if new day
    97                              <2> ;;---------------[System data area]--------------;
    98 00000071 <res 00000001>      <2> break_flag      resb    1	;*/	byte break_flag;	/* 40:71 Sign bit set iff break
    99 00000072 <res 00000002>      <2> warm_boot       resw    1	;*/	word warm_boot;		/* 40:72 Warm boot iff==1234h
   100                              <2> ;;---------------[Hard disk scratchpad]----------;
   101 00000074 <res 00000004>      <2> hdd_scratch     resd    1	;*/	word hdd_scratch[2];	/* 40:74
   102                              <2> ;;---------------[Timout areas/PRT/LPT]----------;
   103 00000078 <res 00000004>      <2> lpt_timeout     resb    4	;*/	byte lpt_timeout[4];	/* 40:78 Ticks for LPT 1-4 timeouts
   104 0000007C <res 00000004>      <2> com_timeout     resb    4	;*/	byte com_timeout[4];	/* 40:7C Ticks for COM 1-4 timeouts
   105                              <2> ;;---obsolete----[Keyboard buf start/end]---jrc--;
   106 00000080 <res 00000002>      <2> kbd_buffer_start resw   1	;*/	word kbd_buffer_start;	/* 40:80 KBD buffer head (PC/AT)
   107 00000082 <res 00000002>      <2> kbd_buffer_end  resw    1	;*/	word kbd_buffer_end;	/* 40:82 KBD buffer tail (PC/AT)
   108                              <2> ;;---------------[EGA stuff]---------------------;
   109 00000084 <res 00000007>      <2> EGA_stuff	resb	7	;*/	byte EGA_stuff[7];	/* 40:84 Unspecified EGA data
   110                              <2> ;;---------------[Floppy/Fixed Media Info]-------------;
   111 0000008B <res 00000001>      <2> fdc_last_rate	resb	1	;*/	byte fdc_last_rate;	/* 40:8B Last floppy step rate/data rate?
   112 0000008C <res 00000004>      <2> fx_misc_unused	resb	4	;*/	byte fx_misc_unused[4];	/* 40:8C Fixed disk miscellaneous ???
   113 00000090 <res 00000002>      <2> fdc_disk_state	resb	2	;*/	byte fdc_disk_state[2];	/* 40:90 Floppy disk state
   114 00000092 <res 00000002>      <2> fdc_op_start	resb	2	;*/	byte fdc_op_start[2];	/* 40:92 Floppy operation start state machine
   115 00000094 <res 00000002>      <2> fdc_cylinder	resb	2	;*/	byte fdc_cylinder[2];	/* 40:94 Floppy present cylinder
   116                              <2> ;;---------------[Additional KBD flags]----------------;
   117 00000096 <res 00000001>      <2> kbd_flag_3	resb	1	;*/	byte kbd_flag_3;	/* 40:96 kbd ???
   118 00000097 <res 00000001>      <2> kbd_flag_2	resb	1	;*/	byte kbd_flag_2;	/* 40:97 kbd ???
   119                              <2> ;;---------------[RTC/timer1 data]---------------------;
   120 00000098 <res 00000004>      <2> user_semaphore	resw	2	;*/	byte *user_semaphore;	/* 40:98 User semaphore in (bit 7)
   121 0000009C <res 00000004>      <2> rtc_count	resd	1	;*/	dword rtc_count;	/* 40:9C RTC tick counter
   122 000000A0 <res 00000001>      <2> rtc_wait_active	resb	1	;*/	byte rtc_wait_active;	/* 40:A0 Busy=01, Posted=80h, 
   123                              <2> ;;---------------[Cassette I/O stuff]------------------;
   124 000000A1 <res 00000001>      <2> last_val	resb	1	;*/	byte last_val;		/* 40:A1 Last byte read value
   125 000000A2 <res 00000002>      <2> crc_reg		resw	1	;*/	word crc_reg;		/* 40:A2 CRC accumulation area
   126                              <2> ;									Post Acknowleged=00;
   127 000000A4 <res 00000001>      <2> EGA_data	resb	1	;*/	byte EGA_data;		/* 40:A4 Various usage
   128 000000A5 <res 00000002>      <2> SDstatus	resb	2	;*/	byte SDstatus[2];	/* 40:A5 Status byte from command
   129 000000A7 <res 00000002>      <2> SDcardtype	resb	2	;*/	byte SDcardtype[2];	/* 40:A7 SDcard type SDSC=2, HC=3, ...
   130                              <2> ;
   131 000000A9 <res 00000004>      <2> fixed_disk_tab	resb	4	;*/	byte fixed_disk_tab[4];	/* dispatch table to fixed disk drivers
   132 000000AD <res 00000001>      <2> wait12_count	resb	1	;*/	byte wait12_count;	/* 40:AD 12usec CX count
   133 000000AE <res 00000001>      <2> lock_count	resb	1	;*/	byte lock_count;	/* 40:AE lock level counter
   134 000000AF <res 00000001>      <2> EMS_start       resb    1	;*/	byte EMS_start;		/* start EMS allocation from here
   135                              <2> fx80		equ	$	;*/	struct EDD_disk fx80;	/* fixed disk parameter area 0
   136 000000B0 <res 00000002>      <2> fx_log_cylinders resw   1	;	word fx_log_cylinders;	 logical number of cylinders
   137 000000B2 <res 00000001>      <2> fx_log_heads    resb    1	;	byte fx_log_heads;	 logical number of heads
   138 000000B3 <res 00000001>      <2> fx_signature	resb	1	;	byte fx_signature;	 A0h signature = translated geom
   139 000000B4 <res 00000001>      <2> fx_phys_sectors	resb    1       ;	byte fx_phys_sectors;	 physical number of sectors per track
   140 000000B5 <res 00000002>      <2> fx_LBA_high     resw    1       ;	word fx_LBA_high;	 high word of LBA28 number of sectors
   141 000000B7 <res 00000001>      <2> fx_reserved7    resb	1	;	byte fx_reserved;	 MBZ
   142 000000B8 <res 00000001>      <2> fx_drive_control resb   1       ;	byte fx_drive_control;	 flag bits for IDE head register
   143 000000B9 <res 00000002>      <2> fx_phys_cylinders resw	1	;	word fx_phys_cylinders;	 physical number of cylinders
   144 000000BB <res 00000001>      <2> fx_phys_heads	resb	1	;	byte fx_phys_heads;	 physical number of heads
   145 000000BC <res 00000002>      <2> fx_LBA_low	resw	1	;	word fx_LBA_low;	 low word of LBA28 number of sectors
   146 000000BE <res 00000001>      <2> fx_log_sectors	resb	1	;	byte fx_log_sectors;	 logical number of sectors per track
   147 000000BF <res 00000001>      <2> fx_checksum	resb	1	;	byte fx_checksum;	 checksum, dunno how to compute
   148 000000C0 <res 00000010>      <2> fx81            resb    16	;*/	struct EDD_disk fx81;	/* fixed disk parameter area 1
   149 000000D0 <res 00000010>      <2> fx82            resb    16	;*/	struct EDD_disk fx82;	/* fixed disk parameter area 2
   150 000000E0 <res 00000010>      <2> fx83            resb    16	;*/	struct EDD_disk fx83;	/* fixed disk parameter area 3
   151                              <2> ;
   152                              <2> ;
   153                              <2> 
   154 000000F0 <res 00000002>      <2> FPEM_segment    resw    1       ;*/	word FPEM_segment;	/* FPEM data segment
   155                              <2> 
   156 000000F2 <res 00000002>      <2> EBDA_paragraph  resw    1       ;*/	word EBDA_paragraph;	/* lowest EBDA paragraph
   157                              <2> 
   158 000000F4 <res 00000002>      <2> dma0_cw         resw    1       ;*/	word dma0_cw;		/* end of dma control word
   159 000000F6 <res 00000002>      <2> dma1_cw         resw    1       ;*/	word dma1_cw;		/*   ditto
   160                              <2> 
   161 000000F8 <res 00000002>      <2> fdc_type	resb	2	;*/	byte fdc_type[2];	/* disk type in low nibble, alternate in hi nib 
   162                              <2> 
   163 000000FA <res 00000004>      <2> debug_static_ptr  resw	2	;*/	void *debug_static_ptr;	/* pointer to debug static area
   164                              <2> 
   165 000000FE <res 00000001>      <2> n_fixed_disks   resb    1       ;*/	byte n_fixed_disks;	/* number of fixed disks
   166                              <2> 
   167 000000FF <res 00000001>      <2> cpu_xtal        resb    1       ;*/	byte cpu_xtal;		/* CPU crystal frequency in Mhz 
   168                              <2> ;								   CPU clock is half of this
   169                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   170                              <2> ;
   171                              <2> ;  System configuration stuff below
   172                              <2> ;	c.f., CONFIG.ASM (ANSI.CFG, CVDU.CFG, etc.), User configuration stuff
   173                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   174                              <2> %if 0				;*/
   175                              <2> #define FIXED_DISK_MAX 4		/*
   176                              <2> %else
   177                              <2> %define FIXED_DISK_MAX 4
   178                              <2> %endif
   179                              <2> %if 0				;*/
   180                              <2> #define PPIDE_driver 1		/*
   181                              <2> %else
   182                              <2> %define PPIDE_driver 1
   183                              <2> %endif
   184                              <2> %if 0				;*/
   185                              <2> #define DIDE_driver 1		/*
   186                              <2> %else
   187                              <2> %define DIDE_driver 1
   188                              <2> %endif
   189                              <2> %if 0				;*/
   190                              <2> #define DSD_driver 1		/*
   191                              <2> %else
   192                              <2> %define DSD_driver 1
   193                              <2> %endif
   194                              <2> 				;*/
    58                              <1> 
    59                              <1> ;  this must be the same in EQUATES.H */
    60                              <1> %if SOFT_DEBUG
    61                              <1> %define NBREAK  8
    62                              <1> %endif
    63                              <1> 
    64                              <1> 
    65                              <1> %if 0
    66                              <1>         segment _TEXT
    67                              <1> ;; *************************************************************************
    68                              <1> 
    69                              <1> 
    70                              <1> 
    71                              <1> 
    72                              <1> ;; ************************ DOS Data Segment *******************************
    73                              <1> ;dosdir	SEGMENT at 50h				; Boot disk directory from IPL
    74                              <1> ;xerox	label	byte				;  0 if Print Screen idle
    75                              <1> ;						;  1 if PrtSc xeroxing screen
    76                              <1> ;						;255 if PrtSc error in xerox
    77                              <1> ;						;  ...non-grafix PrtSc in bios
    78                              <1> ;	db	200h dup(?)			; PC-DOS bootstrap procedure
    79                              <1> ;						;  ...IBMBIO.COM buffers the
    80                              <1> ;						;  ...directory of the boot
    81                              <1> ;						;  ...device here at IPL time
    82                              <1> ;						;  ...when locating the guts
    83                              <1> ;						;  ...of the operating system
    84                              <1> ;						;  ...filename "IBMDOS.COM"
    85                              <1> ;dosdir	ends
    86                              <1> ;; *************************************************************************
    87                              <1> ;; ************************ DOS IPL Segment ********************************
    88                              <1> ;dosseg	SEGMENT at 70h				; "Kernel" of PC-DOS op sys
    89                              <1> ;;IBMBIO.COM file loaded by boot block. Device Drivers/Bootstrap. CONTIGUOUS<---
    90                              <1> ;;IBMDOS.COM operating system nucleus immediately follows IBMBIO.COM and       !
    91                              <1> ;;     doesn`t have to be contiguous.  The IBMDOS operating system nucleus     !
    92                              <1> ;;     binary image is loaded by transient code in IBMBIO binary image	      !
    93                              <1> ;dosseg	ends					;			      !
    94                              <1> ;iplseg	SEGMENT at 0h				; Segment for boot block      !
    95                              <1> ;;The following boot block is loaded with 512 bytes on the first sector of     !
    96                              <1> ;;the bootable device by code resident in the ROM-resident bios.  Control is   !
    97                              <1> ;;then transferred to the first word 0000:7C00 of the disk-resident bootstrap  !
    98                              <1> ;	ORG	07C00h				;  ..offset for boot block    !
    99                              <1> ;boot	db	200h dup(?)			;  ..start disk resident boot--
   100                              <1> ;iplseg	ends
   101                              <1> 
   102                              <1> %endif
    29                                  
    30                                  
    31                                  %if NEED_TIMER_FIX
    32                                  ; swap the timers in the intiialization table
    33                                  timer0          equ     TIM1
    34                                  timer1          equ     TIM0
    35                                  %else
    36                                  ; timers are their true selves in the initialization table
    37                                  timer0          equ     TIM0
    38                                  timer1          equ     TIM1
    39                                  %endif
    40                                  
    41                                  
    42                                  	SEGMENT	_TEXT
    43                                  
    44                                          global  BIOS_call_15h
    45                                  
    46                                  ; The stack offsets 
    47                                  offset_BP       equ     0
    48                                  offset_AX       equ     offset_BP+2
    49                                  ;offset_AL	equ	offset_AX+0
    50                                  offset_AH       equ     offset_AX+1
    51                                  offset_BX       equ     offset_AX+2
    52                                  offset_DX	equ	offset_BX+2	; added for cassette I/O
    53                                  offset_DS       equ     offset_DX+2
    54                                  offset_IP       equ     offset_DS+2
    55                                  offset_CS       equ     offset_IP+2
    56                                  offset_FLAGS    equ     offset_CS+2
    57                                  
    58                                  
    59                                  BIOS_call_15h:
    60 00000000 1E52535055                      pushm   bp,ax,bx,dx,ds
    61 00000005 89E5                            mov     bp,sp           ; establish stack frame addressing
    62                                  
    63 00000007 80FC4F                  	cmp     ah,04Fh         ; null keyboard intercept handler
    64 0000000A 7457                            je      set_carry
    65                                  
    66                                  %if FRONT_PANEL
    67 0000000C 80FC51                  	cmp     ah,051h
    68 0000000F 7503E9AC00                      je      fn51
    69 00000014 80FC52                          cmp     ah,052h
    70 00000017 7503E9AC00                      je      fn52
    71 0000001C 80FC53                  	cmp     ah,053h
    72 0000001F 7503E9C500                      je      fn53
    73 00000024 80FC54                          cmp     ah,054h
    74 00000027 7503E9C600                      je      fn54
    75                                  %endif
    76                                  
    77                                  %if 0
    78                                  	cmp	ah,0		; cassette motor on command
    79                                  	je	fn00
    80                                  	cmp	ah,1		; cassette motor off
    81                                  	je	fn01
    82                                  	cmp	ah,2		; cassette read block
    83                                  	je	fn02
    84                                  	cmp	ah,3		; cassette write block
    85                                  	je	fn03
    86                                  	cmp	ah,4		; cassette GPIO2 on command
    87                                  	je	fn04
    88                                  	cmp	ah,5		; cassette GPIO2 off command
    89                                  	je	fn05
    90                                  %else	
    91 0000002C 88E3                            mov     bl,ah
    92 0000002E 30FF                            xor     bh,bh
    93 00000030 80FB06                          cmp     bl,fn00max/2
    94 00000033 7307                            jae     try_fn80
    95                                  
    96 00000035 01DB                            add     bx,bx
    97 00000037 2EFFA7[7700]                cs  jmp     near [int15fn00+bx]     ; dispatch
    98                                  %endif
    99                                  
   100                                  try_fn80:
   101 0000003C 80FCC0                  	cmp     ah,0C0h
   102 0000003F 7503E98603                      je      fnC0
   103 00000044 80FCC1                          cmp     ah,0C1h
   104 00000047 7503E98A03                      je      fnC1
   105                                  
   106 0000004C 88E3                            mov     bl,ah
   107 0000004E 30FF                            xor     bh,bh
   108                                  
   109 00000050 80EB80                          sub     bl,80h          ; miscellaneous Int15 functions
   110 00000053 80FB11                          cmp     bl,fn80max/2
   111 00000056 7307                            jae     unknown
   112                                  
   113 00000058 01DB                            add     bx,bx
   114 0000005A 2EFFA7[8300]                cs  jmp     near [int15fn80+bx]     ; dispatch
   115                                  
   116                                           
   117                                  unknown:
   118 0000005F C64603FF                	mov	byte [offset_AH+bp],0FFh	; flag error
   119                                  set_carry:
   120 00000063 804E0E01                        or      byte [bp+offset_FLAGS],1        ; set the carry bit
   121 00000067 EB08                            jmp     bye_bye
   122                                  
   123                                  okay:
   124 00000069 C6460300                	mov	byte [offset_AH+bp],00h		; flag dummy okay
   125                                  clear_carry:
   126 0000006D 80660EFE                        and     byte [bp+offset_FLAGS],~1       ; clear the carry flag
   127                                  bye_bye:
   128 00000071 5D585B5A1F                      popm    bp,ax,bx,dx,ds
   129 00000076 CF                              iret
   130                                  
   131                                  
   132                                  int15fn00:
   133 00000077 [5002]                  	dw	fn00		; cassette motor on command
   134 00000079 [6402]                  	dw	fn01		; cassette motor off
   135 0000007B [7102]                  	dw	fn02		; cassette read block
   136 0000007D [1D03]                  	dw	fn03		; cassette write block
   137 0000007F [8303]                  	dw	fn04		; cassette GPIO2 on command
   138 00000081 [9203]                  	dw	fn05		; cassette GPIO2 off command
   139                                  fn00max         equ     $-int15fn00
   140                                  
   141                                  int15fn80:
   142 00000083 [6900]                          dw      fn80            ; device open
   143 00000085 [6900]                          dw      fn81            ; device close
   144 00000087 [6900]                          dw      fn82            ; process termination
   145 00000089 [1D04]                          dw      fn83            ; event wait
   146 0000008B [5F00]                          dw      fn84            ; read joystick
   147 0000008D [6900]                          dw      fn85            ; SysReq key
   148 0000008F [6604]                          dw      fn86            ; delay
   149 00000091 [5F00]                          dw      fn87            ; move extended memory block
   150 00000093 [A500]                          dw      fn88            ; get extended memory size
   151 00000095 [5F00]                          dw      fn89            ; enter protected mode
   152                                  %if TBASIC
   153 00000097 [AC00]                          dw      fn8a            ; getline code
   154                                  %else
   155                                  	dw	unknown		; no TBASIC, so no call
   156                                  %endif
   157 00000099 [5F00]                  	dw	fn8b
   158 0000009B [5F00]                  	dw	fn8c
   159 0000009D [5F00]                  	dw	fn8e
   160 0000009F [5F00]                  	dw	fn8f
   161 000000A1 [6900]                  	dw	fn90		; Device Wait
   162 000000A3 [6900]                  	dw	fn91		; Device Post
   163                                  fn80max         equ     $-int15fn80
   164                                  
   165                                  
   166                                  ; Dummy routines for the following:
   167                                  fn80    equ     okay		; Device Open
   168                                  fn81    equ     okay		; Device Close
   169                                  fn82    equ     okay		; Process Termination
   170                                  
   171                                  fn84    equ     unknown		; Read Joystick
   172                                  fn85    equ     okay		; SysReq Key make/break
   173                                  
   174                                  fn87    equ     unknown		; Move Extended Memory Block
   175                                  fn89    equ     unknown		; Enter Protected Mode
   176                                  
   177                                  fn8b	equ	unknown
   178                                  fn8c	equ	unknown
   179                                  fn8d	equ	unknown
   180                                  fn8e	equ	unknown
   181                                  fn8f	equ	unknown
   182                                  
   183                                  fn90	equ	okay		; Device Wait
   184                                  fn91	equ	okay		; Device Post
   185                                  
   186                                  ;
   187                                  ; Get Extended Memory size
   188                                  ;
   189                                  ;       There is No high memory on an 80186/8
   190                                  ;       Always return 0
   191                                  ;
   192                                  fn88:
   193 000000A5 C746020000                      mov     word [bp+offset_AX],0
   194 000000AA EBC1                            jmp     clear_carry
   195                                  
   196                                  
   197                                          
   198                                  %if TBASIC
   199                                  ; Get Line (direct access to SIO.C 'getline' routine)
   200                                  ;
   201                                  ;  Enter with:
   202                                  ;       CX      length of buffer
   203                                  ;       DS:DX   pointer to the buffer
   204                                  ;
   205                                  ;  Return with:
   206                                  ;       Buffer of length-1 characters (maximum), NUL terminated
   207                                  ;
   208                                  fn8a:
   209 000000AC FB                              sti                             ; enable interrupts
   210 000000AD 5251                            pushm   cx,dx
   211                                  
   212 000000AF 89D0                            mov     ax,dx                   ; DX:AX is pointer argument
   213 000000B1 8CDA                            mov     dx,ds                   ; **
   214 000000B3 89CB                            mov     bx,cx                   ; BX is second argument
   215                                  
   216 000000B5 68[0000]                        push    DGROUP                  ; for the C-code
   217 000000B8 1F                              popm    ds
   218                                          extern  getline_                ; this is a __fastcall entry
   219 000000B9 E8(0000)                        call    getline_
   220                                  
   221 000000BC 595A                            popm    cx,dx
   222 000000BE EBAD                            jmp     clear_carry
   223                                  %endif
   224                                  
   225                                  %if FRONT_PANEL
   226                                  %include "FPSUP.ASM"
     1                              <1> ;__FPSUP______________________________________________________________________________________________	
     2                              <1> ;
     3                              <1> ;  Support for the Front Panel Board by Dan Werner
     4                              <1> ;  
     5                              <1> ;  V 0.1 6-18-2017
     6                              <1> ;
     7                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
     8                              <1> ;
     9                              <1> ;____________________________________________________________________________________________________	
    10                              <1> 
    11                              <1> 
    12                              <1> 
    13                              <1> 
    14                              <1> ;_FN51_______________________________________________________________________________________________	
    15                              <1> ;
    16                              <1> ;  Support for function 51h -- display buffer on the Front Panel Board
    17                              <1> ;  
    18                              <1> ;  	DS:DX - address of buffer to display
    19                              <1> ;
    20                              <1> ;  
    21                              <1> ;
    22                              <1> ;____________________________________________________________________________________________________	
    23                              <1> fn51:
    24                              <1> 
    25 000000C0 E83800              <1>     	CALL 	FP_Init 	; Init Front Panel
    26 000000C3 E8CB00              <1>     	call 	SEGDISPLAY 	; display Segments
    27 000000C6 EBA5                <1>     	jmp	clear_carry	; Signal Success
    28                              <1> 
    29                              <1> 
    30                              <1> 
    31                              <1> ;_FN52______________________________________________________________________________________________	
    32                              <1> ;
    33                              <1> ;  Support for function 52h -- display decoded byte on Front Panel Board
    34                              <1> ;  
    35                              <1> ;  	DS:DX - address of buffer to display
    36                              <1> ;   	AL - byte to Display
    37                              <1> ;  	CL - Location of byte
    38                              <1> ;
    39                              <1> ;____________________________________________________________________________________________________	
    40                              <1> fn52:
    41 000000C8 51                  <1> 	PUSH CX 		; STORE CX
    42                              <1> 
    43 000000C9 52                  <1> 	PUSH DX 		; STORE DX
    44 000000CA 88C2                <1>     	MOV  DL,AL 		; place byte in DL
    45 000000CC E89F00              <1>     	call ENCODEDISPLAY      ; Call Encode Display (IN=DL, OUT=AX)
    46 000000CF 5A                  <1>     	pop  dx 		; restore DX (Buffer)
    47                              <1> 
    48 000000D0 50                  <1>     	push ax 		; save encoded Value
    49 000000D1 89D0                <1>     	mov  ax,dx 		; move buffer address to AX
    50 000000D3 30ED                <1>     	xor  ch,ch 		; clear High byte of C
    51                              <1> 
    52 000000D5 01C8                <1>     	add  ax,cx 		; add offset to buffer address
    53 000000D7 01C8                <1>     	add  ax,cx 		; add offset to buffer address (twice, this is for words)
    54 000000D9 59                  <1>     	pop  cx 		; restore encoded value into CX
    55                              <1> 
    56 000000DA 53                  <1>     	push BX 		; Store BX
    57 000000DB 89C3                <1>     	mov  BX,AX 		; Park offset address in BX
    58 000000DD 890F                <1>     	mov  [BX],cx 		; move value into display buffer
    59 000000DF 5B                  <1>     	pop  BX 		; Restore BX
    60                              <1>     	
    61 000000E0 59                  <1>     	pop  CX 		; restore CX
    62                              <1> 
    63 000000E1 E81700              <1>     	CALL 	FP_Init 	; Init Front Panel
    64 000000E4 E8AA00              <1>     	call 	SEGDISPLAY 	; display Segments
    65 000000E7 EB84                <1>     	jmp	clear_carry	; Signal Success
    66                              <1> 
    67                              <1> 
    68                              <1> ;_FN53______________________________________________________________________________________________	
    69                              <1> ;
    70                              <1> ;  Support for function 53h -- Get key press on Front Panel Board (Wait)
    71                              <1> ;  
    72                              <1> ;   	AL - return byte 
    73                              <1> ;
    74                              <1> ;____________________________________________________________________________________________________	
    75                              <1> fn53:
    76                              <1> 
    77 000000E9 E8BE00              <1> 	CALL	KB_Get			; Get Key from KB
    78 000000EC 884602              <1> 	mov	byte [bp+offset_AX],AL	; RETURN KEY	
    79 000000EF E97BFF              <1>     	jmp	clear_carry		; Signal Success	
    80                              <1> 
    81                              <1> 
    82                              <1> ;_FN54______________________________________________________________________________________________	
    83                              <1> ;
    84                              <1> ;  Support for function 54h -- Get key press on Front Panel Board (do not Wait)
    85                              <1> ;  
    86                              <1> ;   	AL - return byte 
    87                              <1> ;
    88                              <1> ;____________________________________________________________________________________________________	
    89                              <1> fn54:
    90                              <1> 
    91 000000F2 E8EF00              <1> 	CALL	KB_Scan			; Get Key from KB
    92 000000F5 884602              <1> 	mov	byte [bp+offset_AX],AL	; RETURN KEY
    93 000000F8 E972FF              <1>     	jmp	clear_carry		; Signal Success	
    94                              <1> 
    95                              <1> 
    96                              <1> 
    97                              <1> 
    98                              <1> 
    99                              <1> 
   100                              <1> 
   101                              <1> ;__FP_Init________________________________________________________________________________________
   102                              <1> ;
   103                              <1> ; Initialize MAX7219 on Front Panel Display
   104                              <1> ;
   105                              <1> ;  Uses FPPIOCONT,FPPORTC
   106                              <1> ;  requires MAXOUT
   107                              <1> ;  returns nothing
   108                              <1> ;  
   109                              <1> ;____________________________________________________________________________________________________
   110                              <1> FP_Init:
   111 000000FB 50                  <1> 	push	ax		; Store Registers
   112 000000FC 52                  <1> 	push 	dX 		;
   113                              <1> 
   114 000000FD BAA304              <1>      	mov     dx,FPPIOCONT 	;
   115 00000100 B082                <1>         mov     al,82h          ; 
   116 00000102 EE                  <1>         out     dx,al 		;
   117                              <1> 
   118 00000103 BAA204              <1>      	mov     dx,FPPORTC 	;
   119 00000106 B004                <1>         mov     al,04h          ; 
   120 00000108 EE                  <1>         out     dx,al 		;
   121                              <1>    
   122                              <1>         
   123 00000109 BA0009              <1>         mov    	dx,0900H        ; SET ADDRESS 9 TO 0, NO DECODE
   124 0000010C E81B00              <1>         CALL   	MAXOUT          ; SEND TO MAX7219
   125 0000010F BA0F0A              <1>         mov    	dx,0A0FH        ; SET ADDRESS A TO 0F, FULL INTENSITY
   126 00000112 E81500              <1>         CALL   	MAXOUT          ; SEND TO MAX7219
   127 00000115 BA070B              <1>         mov    	dx,0B07H        ; SET ADDRESS B TO 07, DISPLAY ALL DIGITS
   128 00000118 E80F00              <1>         CALL   	MAXOUT          ; SEND TO MAX7219
   129 0000011B BA010C              <1>         mov    	dx,0C01H        ; SET ADDRESS C TO 01, NO SHUTDOWN
   130 0000011E E80900              <1>         CALL   	MAXOUT          ; SEND TO MAX7219
   131 00000121 BA000F              <1>         mov    	dx,0F00H        ; SET ADDRESS F TO 00, NO SELF-TEST
   132 00000124 E80300              <1>         CALL   	MAXOUT          ; SEND TO MAX7219    
   133                              <1>         
   134 00000127 5A                  <1>         pop	dx 		; Restore Registers
   135 00000128 58                  <1>         pop 	ax 		;
   136 00000129 C3                  <1> 	RET
   137                              <1> 
   138                              <1> 
   139                              <1> 
   140                              <1> ;__MAXOUT____________________________________________________________________________________________
   141                              <1> ;
   142                              <1> ;  Command OUT TO MAX7219
   143                              <1> ;
   144                              <1> ;  Send byte to MAX7219 display.
   145                              <1> ;  Value to Send:  DL
   146                              <1> ;  Address to Send: DH
   147                              <1> ;
   148                              <1> ;  Uses FPPORTC (IO address of port)
   149                              <1> ;  requires that 7219 be properly initialized prior to calling procedure
   150                              <1> ;  returns nothing
   151                              <1> ;  
   152                              <1> ;     
   153                              <1> ;____________________________________________________________________________________________________
   154                              <1> MAXOUT:
   155 0000012A 52                  <1> 	push 	dx 		; store Registers
   156 0000012B 51                  <1> 	push 	cx		; 
   157 0000012C 53                  <1> 	PUSH 	BX 		; 
   158 0000012D 50                  <1> 	push 	ax 	 	; 
   159 0000012E 89D3                <1> 	mov 	bx,dx 		; MOVE DX TO work register	
   160 00000130 B110                <1>       	mov	cl,16 		; iterate over 16 bits
   161                              <1> MAXOUT_1:   
   162 00000132 D1C3                <1>         rol     bx,1		; get bit
   163                              <1> 
   164 00000134 7211                <1>         JC      MAXOUT_1A	; is 1 or 0?
   165                              <1> 
   166 00000136 BAA204              <1>      	mov     dx,FPPORTC 	; output 0
   167 00000139 B000                <1>         mov     al,00h          ; 
   168 0000013B EE                  <1>         out     dx,al 		;
   169 0000013C E80E01              <1>         CALL    PAUSE                
   170 0000013F BAA204              <1>      	mov     dx,FPPORTC 	;
   171 00000142 B002                <1>         mov     al,02h          ; 
   172 00000144 EE                  <1>         out     dx,al		;
   173 00000145 EB0F                <1>         JMP     MAXOUT_1B
   174                              <1> 
   175                              <1> MAXOUT_1A:
   176 00000147 BAA204              <1>      	mov     dx,FPPORTC 	; output 1
   177 0000014A B001                <1>         mov     al,01h          ; 
   178 0000014C EE                  <1>         out     dx,al		;
   179 0000014D E8FD00              <1>         CALL    PAUSE                
   180 00000150 BAA204              <1>      	mov     dx,FPPORTC 	;
   181 00000153 B003                <1> 	mov     al,03h          ; 
   182 00000155 EE                  <1>         out     dx,al		;
   183                              <1> 
   184                              <1> MAXOUT_1B:                 
   185 00000156 E8F400              <1>         CALL    PAUSE 		; done with bit
   186 00000159 BAA204              <1>      	mov     dx,FPPORTC 	;
   187 0000015C B000                <1> 	mov     al,00h          ; 
   188 0000015E EE                  <1>         out     dx,al		;
   189 0000015F FEC9                <1>         DEC     cl
   190 00000161 75CF                <1>         Jnz	MAXOUT_1
   191                              <1> 
   192 00000163 BAA204              <1>     	mov      dx,FPPORTC 	; done with sequence
   193 00000166 B004                <1> 	mov      al,4
   194 00000168 EE                  <1>         OUT      dx,al
   195                              <1> 
   196 00000169 58                  <1>         pop 	ax		; restore registers
   197 0000016A 5B                  <1>         pop 	bx		;
   198 0000016B 59                  <1>         pop 	cx		;
   199 0000016C 5A                  <1>         POP 	dx		;
   200 0000016D C3                  <1>         RET    
   201                              <1> 	
   202                              <1> 
   203                              <1> 
   204                              <1> 
   205                              <1> 
   206                              <1> 
   207                              <1> ;__ENCODEDISPLAY_____________________________________________________________________________________
   208                              <1> ;
   209                              <1> ;  Encode value in dl return LED formatted code in AX
   210                              <1> ;
   211                              <1> ;  Value to Encode:  DL
   212                              <1> ;
   213                              <1> ;  returns coded value in AX 
   214                              <1> ;  
   215                              <1> ;     
   216                              <1> ;____________________________________________________________________________________________________
   217                              <1> ENCODEDISPLAY:
   218 0000016E 53                  <1> 	PUSH	BX			; STORE registers
   219 0000016F 52                  <1> 	push 	DX 			;
   220 00000170 1E                  <1> 	push    DS
   221 00000171 68[0000]            <1> 	push    DGROUP
   222 00000174 1F                  <1> 	pop     DS
   223 00000175 89D3                <1> 	mov 	bx,dx 			;
   224 00000177 83E30F              <1> 	and	bx,000fh		; get low nibble	
   225 0000017A 3E8AA7[0000]        <1> 	mov	ah,[DS:SEGDECODE+bx]	; GET low VALUE	
   226 0000017F 89D3                <1> 	mov 	bx,dx 			;
   227 00000181 81E3F000            <1> 	and	bx,00f0h		; get high nibble	
   228 00000185 C1CB04              <1> 	ror 	bx,4 			;
   229 00000188 3E8A87[0000]        <1> 	mov	al,[DS:SEGDECODE+bx]	; GET high VALUE 	
   230 0000018D 1F                  <1> 	pop     DS
   231 0000018E 5A                  <1> 	pop 	DX 			; restore registers
   232 0000018F 5B                  <1> 	POP	BX			; 
   233 00000190 C3                  <1> 	RET
   234                              <1> 
   235                              <1> 
   236                              <1> ;__SEGDISPLAY________________________________________________________________________________________
   237                              <1> ;
   238                              <1> ;  Display contents of buffer TO MAX7219
   239                              <1> ;
   240                              <1> ;  Address of buffer: DX
   241                              <1> ;
   242                              <1> ;  Refrences MAXOUT
   243                              <1> ;  requires that 7219 be properly initialized prior to calling procedure
   244                              <1> ;  returns nothing
   245                              <1> ;     
   246                              <1> ;____________________________________________________________________________________________________
   247                              <1> SEGDISPLAY:
   248 00000191 50                  <1> 	push 	ax 			; Store Registers
   249 00000192 53                  <1> 	push 	bX
   250 00000193 51                  <1> 	push 	cx
   251 00000194 52                  <1> 	push 	dx
   252                              <1> 
   253 00000195 B408                <1> 	mov	ah,08H			; SET DIGIT COUNT
   254 00000197 89D3                <1> 	mov	bx,dx 			; set address
   255                              <1> SEGDISPLAY_LP:		
   256 00000199 8A17                <1> 	mov	dl,byte [BX]		; GET DISPLAY DIGIT
   257 0000019B 88E6                <1> 	mov     dh,ah	
   258 0000019D E88AFF              <1> 	CALL    MAXOUT
   259 000001A0 43                  <1> 	INC     bx			; INC POINTER
   260 000001A1 FECC                <1> 	DEC     ah
   261 000001A3 75F4                <1> 	Jnz     SEGDISPLAY_LP		; LOOP FOR NEXT DIGIT
   262                              <1> 
   263 000001A5 5A                  <1> 	pop 	dx 			; restore Registers
   264 000001A6 59                  <1> 	pop 	cx 
   265 000001A7 5B                  <1> 	pop 	bx 
   266 000001A8 58                  <1> 	pop 	ax	
   267 000001A9 C3                  <1> 	RET
   268                              <1> 
   269                              <1> 	
   270                              <1> 	
   271                              <1> ;__KB_Get____________________________________________________________________________________________
   272                              <1> ;
   273                              <1> ;  Get a Single Key and Decode
   274                              <1> ;
   275                              <1> ;
   276                              <1> ;  Refrences KB_Scan
   277                              <1> ;  Uses FPPORTA,FPPORTB
   278                              <1> ;  returns key in al
   279                              <1> ;          
   280                              <1> ;____________________________________________________________________________________________________
   281                              <1> KB_Get:
   282 000001AA 53                  <1> 	push 	bX 			; Store Registers
   283 000001AB 52                  <1> 	push 	DX
   284 000001AC 1E                  <1> 	push    DS
   285 000001AD 68[0000]            <1> 	push    DGROUP
   286 000001B0 1F                  <1> 	pop     DS
   287                              <1> 
   288                              <1> KB_Get_Loop:				;  WAIT FOR KEY
   289 000001B1 E83000              <1> 	CALL	KB_Scan			;  Scan KB Once	
   290 000001B4 3C00                <1> 	cmp 	al,00
   291 000001B6 74F9                <1> 	JZ	KB_Get_Loop		;  Loop while zero	
   292 000001B8 88C4                <1> 	MOV     ah,al			;  Store A
   293 000001BA B00F                <1> 	mov 	al,0fh 			;  turn lines on for scan
   294 000001BC BAA004              <1> 	mov 	dx,FPPORTA 		;
   295 000001BF EE                  <1> 	OUT 	dx,al 			;  Send to Column Lines
   296 000001C0 E88A00              <1>         CALL    PAUSE 			;  Delay to allow lines to stabilize
   297                              <1> KB_Clear_Loop:				;  WAIT FOR KEY TO CLEAR
   298 000001C3 BAA104              <1>        	mov 	dx,FPPORTB
   299 000001C6 EC                  <1> 	IN	al,DX 			;  Get Rows
   300 000001C7 241F                <1> 	AND	AL,01FH			;  Clear Top three Bits
   301 000001C9 3C00                <1> 	cmp 	al,00 			;
   302 000001CB 75F6                <1> 	Jnz	KB_Clear_Loop		;
   303 000001CD 88E0                <1> 	mov	al,ah			;  Restore A
   304 000001CF 31DB                <1> 	xor	bx,bX 			;
   305                              <1> KB_Get_LLoop:
   306 000001D1 3E3A87[1200]        <1> 	cmp     al,[DS:KB_Decode+bX] 	;  
   307 000001D6 7406                <1> 	Jz	KB_Get_Done		;  Found, Done
   308 000001D8 43                  <1> 	INC	bx 			;
   309 000001D9 83FB13              <1> 	cmp	bx,19			;  
   310 000001DC 75F3                <1> 	Jnz	KB_Get_LLoop		;  Not Found, Loop until EOT			
   311                              <1> KB_Get_Done:
   312 000001DE 88D8                <1> 	mov	Al,bl			;  Result Into A
   313 000001E0 1F                  <1> 	pop  	DS
   314 000001E1 5A                  <1> 	pop 	DX 			; restore Registers
   315 000001E2 5B                  <1> 	pop 	bx 	
   316 000001E3 C3                  <1> 	RET
   317                              <1> 
   318                              <1> 
   319                              <1> 
   320                              <1> ;__KB_Scan____________________________________________________________________________________________
   321                              <1> ;
   322                              <1> ;  Scan Keyboard Matrix for an input
   323                              <1> ;
   324                              <1> ;
   325                              <1> ;  Refrences PAUSE
   326                              <1> ;  Uses FPPORTA,FPPORTB
   327                              <1> ;  returns key in AL
   328                              <1> 
   329                              <1> ;     
   330                              <1> ;____________________________________________________________________________________________________
   331                              <1> KB_Scan:
   332 000001E4 53                  <1> 	push 	bX 			; store Registers
   333 000001E5 51                  <1> 	push 	cx
   334 000001E6 52                  <1> 	push 	dx
   335                              <1> 
   336                              <1> 
   337 000001E7 B400                <1> 	mov     ah,00H
   338 000001E9 B001                <1> 	mov	Al,01H			;  Scan Col One
   339 000001EB BAA004              <1> 	mov 	dx,FPPORTA
   340 000001EE EE                  <1> 	OUT 	dx,al 			;  Send to Column Lines
   341 000001EF E85B00              <1>         CALL    PAUSE 			;  Delay to allow lines to stabilize
   342 000001F2 BAA104              <1>         mov 	dx,FPPORTB
   343 000001F5 EC                  <1> 	IN	al,DX 			;  Get Rows
   344 000001F6 241F                <1> 	AND	al,01FH			;  Clear Top three Bits
   345 000001F8 7543                <1> 	JNZ	KB_Scan_Found		;  Yes, Exit.
   346                              <1> 
   347 000001FA B420                <1> 	mov     ah,20H
   348 000001FC B002                <1> 	mov	Al,02H	
   349 000001FE BAA004              <1> 	mov 	dx,FPPORTA		;  Scan Col Two
   350 00000201 EE                  <1> 	OUT 	dx,al 			;  Send to Column Lines
   351 00000202 E84800              <1>         CALL    PAUSE			;  Delay to allow lines to stabilize
   352 00000205 BAA104              <1>         mov 	dx,FPPORTB
   353 00000208 EC                  <1> 	IN	AL,dx 			;  Get Rows
   354 00000209 241F                <1> 	AND	AL,01FH			;  Clear Top three Bits
   355 0000020B 7530                <1> 	JNZ	KB_Scan_Found		;  Yes, Exit.
   356                              <1> 
   357 0000020D B440                <1> 	mov     AH,40H
   358 0000020F B004                <1> 	mov	AL,04H			;  Scan Col Three
   359 00000211 BAA004              <1> 	mov 	dx,FPPORTA		;  
   360 00000214 EE                  <1> 	OUT 	dx,al 			;  Send to Column Lines
   361 00000215 E83500              <1>         CALL    PAUSE			;  Delay to allow lines to stabilize
   362 00000218 BAA104              <1>         mov 	dx,FPPORTB
   363 0000021B EC                  <1> 	IN	AL,dx 			;  Get Rows
   364 0000021C 241F                <1> 	AND	AL,01FH			;  Clear Top three Bits
   365 0000021E 751D                <1> 	JNZ	KB_Scan_Found		;  Yes, Exit.
   366                              <1> 
   367 00000220 B480                <1> 	mov     ah,80H			;
   368 00000222 B008                <1> 	mov	Al,08H			;  Scan Col Four
   369 00000224 BAA004              <1> 	mov 	dx,FPPORTA		;  
   370 00000227 EE                  <1> 	OUT 	dx,al 			;  Send to Column Lines
   371 00000228 E82200              <1>         CALL    PAUSE			;  Delay to allow lines to stabilize
   372 0000022B BAA104              <1>         mov 	dx,FPPORTB
   373 0000022E EC                  <1> 	IN	AL,dx 			;  Get Rows
   374 0000022F 241F                <1> 	AND	AL,01FH			;  Clear Top three Bits
   375 00000231 750A                <1> 	JNZ	KB_Scan_Found		;  Yes, Exit.
   376                              <1> 
   377 00000233 30C0                <1> 	xor	Al,al			;  Turn off All Columns
   378 00000235 BAA004              <1> 	mov 	dx,FPPORTA		;  
   379 00000238 EE                  <1> 	OUT 	dx,al 			;  Send to Column Lines
   380                              <1> 
   381 00000239 5A                  <1> 	pop 	DX
   382 0000023A 59                  <1> 	pop 	cx
   383 0000023B 5B                  <1> 	pop 	bx
   384 0000023C C3                  <1> 	RET				;  Exit
   385                              <1> 
   386                              <1> KB_Scan_Found:
   387 0000023D 08C4                <1> 	OR	ah,al			;  Add in Row Bits 
   388 0000023F 30C0                <1> 	xor	al,al			;  Turn off All Columns
   389 00000241 BAA004              <1> 	mov 	dx,FPPORTA		;  
   390 00000244 EE                  <1> 	OUT 	dx,al 			;  Send to Column Lines
   391 00000245 88E0                <1> 	mov	Al,ah			;  Restore Value
   392 00000247 30E4                <1> 	xor 	Ah,ah 			;
   393 00000249 5A                  <1> 	pop 	DX 			; restore Registers
   394 0000024A 59                  <1> 	pop 	cx
   395 0000024B 5B                  <1> 	pop 	bx
   396 0000024C C3                  <1> 	RET				;  Exit
   397                              <1> 
   398                              <1> 
   399                              <1> 
   400                              <1> PAUSE:
   401 0000024D 60                  <1> 	PUSHm all
   402 0000024E 61                  <1> 	popm  all
   403 0000024F C3                  <1> 	ret
   404                              <1> 
   405                              <1> 
   406                              <1> 
   407                              <1> 	SEGMENT CONST
   408                              <1> 
   409                              <1> ;_Constants_______________________________________________________________________________________________________
   410                              <1> ; 
   411 00000000 7E306D79335B5F707F- <1> SEGDECODE:	DB	07EH,030H,06DH,079H,033H,05BH,05FH,070H,07FH,073H,077H,01FH,04EH,03DH,04FH,047H,000H,080H
   411 00000009 73771F4E3D4F470080  <1>
   412                              <1> ;
   413                              <1> KB_Decode:
   414                              <1> ;              		0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
   415 00000012 814142442122240102- <1> 		DB	81H,41H,42H,44H,21H,22H,24H,01H,02H,04H,48H,50H,28H,30H,08H,10H
   415 0000001B 04485028300810      <1>
   416                              <1> ;	                CL  EN  .  
   417 00000022 889084              <1> 		DB	88H,90H,84H
   418                              <1> ;
   419                              <1> ; F-Keys,
   420                              <1> ; CL = Clear
   421                              <1> ; EN = Enter
   422                              <1> ; . = .
   423                              <1> 	SEGMENT	_TEXT
   227                                  %endif
   228                                  
   229                                  %include "cassette.asm"
     1                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     2                              <1> ; CASSETTE.ASM -- Cassette I/O BIOS calls (int 15h functions)
     3                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     4                              <1> ;
     5                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
     6                              <1> ;
     7                              <1> ; Copyright (C) 2013 Richard Cini.  All rights reserved.
     8                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
     9                              <1> ;
    10                              <1> ; This program is free software: you can redistribute it and/or modify
    11                              <1> ; it under the terms of the GNU General Public License as published by
    12                              <1> ; the Free Software Foundation, either version 3 of the License, or
    13                              <1> ; (at your option) any later version.
    14                              <1> ;
    15                              <1> ; This program is distributed in the hope that it will be useful,
    16                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    17                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    18                              <1> ; GNU General Public License for more details.
    19                              <1> ;
    20                              <1> ; You should have received a copy of the GNU General Public License
    21                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    22                              <1> ;
    23                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    24                              <1> ;--------------------------------------------------------
    25                              <1> ; Cassette support routines
    26                              <1> ;	(AH) = 0 TURN CASSETTE MOTOR ON
    27                              <1> ;	(AH) = 1 TURN CASSETTE MOTOR OFF
    28                              <1> ;	(AH) = 2 READ 1 OR MORE 256 BYTE BLOCKS FROM CASSETTE
    29                              <1> ;		(ES,BX) = POINTER TO DATA BUFFER
    30                              <1> ;		(CX) = COUNT OF BYTES TO READ
    31                              <1> ;		ON EXIT:
    32                              <1> ;  		(ES,BX) = POINTER TO LAST BYTE READ + 1
    33                              <1> ;  		(DX) = COUNT OF BYTES ACTUALLY READ
    34                              <1> ;  		(CY) = 0 IF NO ERROR OCCURRED
    35                              <1> ;  		     = 1 IF ERROR OCCURRED
    36                              <1> ;  		(AH) = ERROR RETURN IF (CY)= 1
    37                              <1> ;  			= 01 IF CRC ERROR WAS DETECTED
    38                              <1> ;  			= 02 IF DATA TRANSITIONS ARE LOST
    39                              <1> ;  			= 04 IF NO DATA WAS FOUND
    40                              <1> ;  	(AH) = 3 WRITE 1 OR MORE 256 BYTE BLOCKS TO CASSETTE
    41                              <1> ;  		(ES,BX) = POINTER TO DATA BUFFER
    42                              <1> ;  		(CX) = COUNT OF BYTES TO WRITE
    43                              <1> ;  		ON EXIT:
    44                              <1> ;		(EX,BX) = POINTER TO LAST BYTE WRITTEN + 1
    45                              <1> ;		(CX) = 0
    46                              <1> ;	(AH) = 4 TURN GPIO2 ON
    47                              <1> ;	(AH) = 5 TURN GPIO2 OFF
    48                              <1> ;	(AH) = ANY OTHER THAN ABOVE VALUES CAUSES (CY)= 1
    49                              <1> ;		AND (AH)= 80 TO BE RETURNED (INVALID COMMAND).
    50                              <1> ;--------------------------------------------------------
    51                              <1> ; PURPOSE:
    52                              <1> ;  TO TURN ON CASSETTE MOTOR
    53                              <1> ;  16550 I/O pins are active low so we need to add
    54                              <1> ;  an inverter (7400) before the 75452 to make this work.
    55                              <1> ;  Cassette motor connected to OUT1* on 16550, which is
    56                              <1> ;  bit2 of MCR.
    57                              <1> ;--------------------------------------------------------
    58                              <1> fn00:
    59 00000250 802671007F          <1> 	and	byte [break_flag],07FH		; turn off break flag   jrc
    60 00000255 BA8404              <1> 	mov	dx,cuart_mcr			; get device code
    61 00000258 EC                  <1> 	in	al,dx				;read cassette uart mcr
    62 00000259 0C04                <1> 	or	al,04H				; SET BIT TO TURN ON
    63 0000025B EE                  <1> W3:	out	dx,al				;WRITE IT OUT
    64 0000025C C746020000          <1> 	mov	word [bp+offset_AX],0000h	; signal success to caller
    65 00000261 E909FE              <1> 	jmp	clear_carry
    66                              <1> 
    67                              <1> 
    68                              <1> ;----------------------------------
    69                              <1> ; PURPOSE:
    70                              <1> ;  TO TURN CASSETTE MOTOR OFF
    71                              <1> ;-----------------------------------
    72                              <1> fn01:
    73 00000264 802671007F          <1> 	and	byte [break_flag],07FH	; turn off break flag    jrc
    74 00000269 BA8404              <1> 	mov	dx,cuart_mcr		; get device code
    75 0000026C EC                  <1> 	in	al,dx			;read cassette uart mcr
    76 0000026D 24FB                <1> 	and	al,~04h			; clear bit to turn off motor
    77 0000026F EBEA                <1> 	jmp	W3			;write it, clear error, return
    78                              <1> 
    79                              <1> 
    80                              <1> ;--------------------------------------------
    81                              <1> ; PURPOSE:
    82                              <1> ;  TO READ 1 OR MORE 256 BYTE BLOCKS FROM CASSETTE
    83                              <1> ;
    84                              <1> ; ON ENTRY:
    85                              <1> ;  ES IS SEGMENT FOR MEMORY BUFFER (FOR COMPACT CODE)
    86                              <1> ;  BX POINTS TO START OF MEMORY BUFFER
    87                              <1> ;  CX CONTAINS NUMBER OF BYTES TO READ
    88                              <1> ; ON EXIT:
    89                              <1> ;  BX POINTS 1 BYTE PAST LAST BYTE PUT IN MEM
    90                              <1> ;  CX CONTAINS DECREMENTED BYTE COUNT
    91                              <1> ;  DX CONTAINS NUMBER OF BYTES ACTUALLY READ
    92                              <1> ;
    93                              <1> ;  CARRY FLAG IS CLEAR IF NO ERROR DETECTED
    94                              <1> ;  CARRY FLAG IS SET IF CRC ERROR DETECTED
    95                              <1> ;--------------------------------------------
    96                              <1> fn02:
    97                              <1> READ_BLOCK:
    98 00000271 53                  <1> 	PUSH	BX
    99 00000272 51                  <1> 	PUSH	CX
   100 00000273 56                  <1> 	PUSH	SI
   101 00000274 802671007F          <1> 	and	byte [break_flag],07FH	; turn off break flag    jrc
   102 00000279 BE0700              <1> 	MOV	SI,7		; retry count for leader
   103 0000027C E83C01              <1> 	CALL	BEGIN_OP	; start the tape
   104                              <1> 	
   105                              <1> W4:
   106 0000027F E81901              <1> 	CALL	READ_BYTE	; get initial byte
   107 00000282 A2A100              <1> 	MOV	[last_val],AL
   108 00000285 BA1000              <1> 	MOV	DX,010H		; look for 16 leader bytes
   109                              <1> 
   110                              <1> W5:
   111 00000288 F606710080          <1> 	TEST	byte [break_flag],80h		; jrc
   112 0000028D 7402                <1> 	JZ	W6		; jump if no break key
   113 0000028F EB72                <1> 	JMP	W17		; jump if break key hit
   114                              <1> 
   115                              <1> W6:
   116 00000291 3CFF                <1> 	CMP	AL,0FFH		; leader byte?
   117 00000293 7505                <1> 	JNE	W7		; try again if not found
   118                              <1> 	
   119 00000295 4A                  <1> 	DEC	DX		; yes, a leader byte
   120 00000296 75E7                <1> 	JNZ	W4		; find another leader byte
   121 00000298 EB05                <1> 	JMP	W8		; jump if at least 16 found
   122                              <1> 
   123                              <1> W7:
   124 0000029A 4E                  <1> 	DEC	SI		; no leader byte...try again
   125 0000029B 7466                <1> 	JZ	W17		; ran out of retries
   126 0000029D EBE0                <1> 	JMP	W4		; loop
   127                              <1> 		
   128                              <1> W8:				; 16 bytes of leader found
   129 0000029F F606710080          <1> 	TEST	byte [break_flag],80h	; test for break key   jrc
   130 000002A4 755D                <1> 	JNZ	W17		; jump if break key hit
   131                              <1> 
   132                              <1> W9:				; loop until start and sync byte
   133 000002A6 E8F200              <1> 	CALL	READ_BYTE
   134 000002A9 3C3C                <1> 	CMP	AL,03CH		; start byte
   135 000002AB 75F9                <1> 	JNE	W9
   136                              <1> 	
   137 000002AD E8EB00              <1> 	CALL	READ_BYTE
   138 000002B0 3CE6                <1> 	CMP	AL,0E6H		; sync byte
   139 000002B2 754F                <1> 	JNE	W17		; error
   140                              <1> 	
   141                              <1> ; start and sync found, start reading data blocks
   142 000002B4 5E                  <1> 	POP	SI
   143 000002B5 59                  <1> 	POP	CX
   144 000002B6 5B                  <1> 	POP	BX
   145                              <1> 
   146                              <1> ; read 1 or more 256-byte blocks
   147 000002B7 51                  <1> 	PUSH	CX		; save byte count
   148                              <1> 
   149                              <1> W10:
   150 000002B8 C706A200FFFF        <1> 	MOV	word [crc_reg],0FFFFH	; initialize CRC
   151 000002BE BA0001              <1> 	MOV	DX,256		; for 256 byte blocks
   152                              <1> 
   153                              <1> W11:
   154 000002C1 F606710080          <1> 	TEST	byte [break_flag],80h	; test for break key   jrc
   155 000002C6 7523                <1> 	JNZ	W13		; jump if break key hit
   156 000002C8 E8D000              <1> 	CALL	READ_BYTE	; get a byte from cassette
   157 000002CB 721E                <1> 	JC	W13		; CY set indicates no data
   158 000002CD E305                <1> 	JCXZ	W12		; reached end of buffer; skip block
   159                              <1> 	
   160 000002CF 268807              <1> 	MOV	[ES:BX],AL	; save to memory
   161 000002D2 43                  <1> 	INC	BX		; increment memory pointer
   162 000002D3 49                  <1> 	DEC	CX		; decrement count
   163                              <1> 
   164                              <1> W12:
   165 000002D4 4A                  <1> 	DEC	DX		; decrement block count
   166 000002D5 7FEA                <1> 	JG	W11		; read more
   167 000002D7 E8C100              <1> 	CALL	READ_BYTE	; read two CRC bytes
   168 000002DA E8BE00              <1> 	CALL	READ_BYTE
   169 000002DD 28E4                <1> 	SUB	AH,AH
   170 000002DF 813EA2000F1D        <1> 	CMP	word [crc_reg],1d0fh	; correct CRC?		jrc
   171 000002E5 7506                <1> 	JNE	W14		; if not equal, CRC bad
   172 000002E7 E306                <1> 	JCXZ	W15		; if byte count is 0, we've read enough so exit
   173 000002E9 EBCD                <1> 	JMP	W10		; read more
   174                              <1> 	
   175                              <1> W13:				; error 1 CRC
   176 000002EB B401                <1> 	MOV	AH,01H		; 
   177                              <1> 	
   178                              <1> W14:
   179 000002ED FEC4                <1> 	INC	AH		; +1 error 2 
   180                              <1> 
   181                              <1> W15:
   182 000002EF 5A                  <1> 	POP	DX		; calculate count of bytes actually read
   183 000002F0 29CA                <1> 	SUB	DX,CX		; in DX
   184 000002F2 50                  <1> 	PUSH	AX		; save return code
   185 000002F3 F6C403              <1> 	TEST	AH,03H		; test for errors
   186 000002F6 7513                <1> 	JNZ	W18		; jump if error detected
   187 000002F8 E8A000              <1> 	CALL	READ_BYTE	; read trailer
   188 000002FB EB0E                <1> 	JMP	W18		; skip to turn off motor
   189                              <1> 
   190                              <1> W16:				; bad leader
   191 000002FD 4E                  <1> 	DEC	SI		; check retries
   192 000002FE 7403                <1> 	JZ	W17		; jump if too many retries
   193 00000300 E97CFF              <1> 	JMP	W4		; go back if not too many
   194                              <1> 	
   195                              <1> W17:				; no data from cassette error
   196 00000303 5E                  <1> 	POP	SI
   197 00000304 59                  <1> 	POP	CX
   198 00000305 5B                  <1> 	POP	BX
   199 00000306 29D2                <1> 	SUB	DX,DX		; 0 bytes read
   200 00000308 B404                <1> 	MOV	AH,04H		; time out error (no leader)
   201 0000030A 50                  <1> 	PUSH	AX
   202                              <1> 
   203                              <1> W18:
   204 0000030B E856FF              <1> 	CALL	fn01		; turn off motor
   205 0000030E 58                  <1> 	POP	AX		; restore return code
   206 0000030F 894602              <1> 	mov	word [bp+offset_AX],ax	; return error code to caller	
   207                              <1> 
   208 00000312 83F800              <1> 	CMP	AX,0
   209 00000315 7403                <1> 	je	W19
   210 00000317 E949FD              <1> 	jmp	set_carry
   211                              <1> 
   212                              <1> W19:
   213 0000031A E950FD              <1> 	jmp	clear_carry
   214                              <1> 
   215                              <1> 
   216                              <1> ;--------------------------------------------
   217                              <1> ;  WRITE 1 OR MORE 256 BYTE BLOCKS FROM CASSETTE
   218                              <1> ;
   219                              <1> ; ON ENTRY:
   220                              <1> ;  ES IS SEGMENT FOR MEMORY BUFFER (FOR COMPACT CODE)
   221                              <1> ;  BX POINTS TO START OF MEMORY BUFFER
   222                              <1> ;  CX CONTAINS NUMBER OF BYTES TO READ
   223                              <1> ; ON EXIT:
   224                              <1> ;  BX POINTS 1 BYTE PAST LAST BYTE PUT IN MEM
   225                              <1> ;  CX CONTAINS DECREMENTED BYTE COUNT
   226                              <1> ;  DX CONTAINS NUMBER OF BYTES ACTUALLY READ
   227                              <1> ;--------------------------------------------
   228                              <1> fn03:
   229                              <1> WRITE_BLOCK:
   230 0000031D 53                  <1> 	PUSH	BX		; used by BEGIN_OP
   231 0000031E 51                  <1> 	PUSH	CX		; used in W23
   232                              <1> ;jrc	STD			; always count down 
   233 0000031F 802671007F          <1> 	and	byte [break_flag],07FH	; turn off break flag  jrc
   234 00000324 E89400              <1> 	CALL	BEGIN_OP	; uses BX
   235 00000327 B0FF                <1> 	MOV	AL,0FFH		; write leader 256 dup FF
   236 00000329 B9FF00              <1> 	MOV	CX,00FFH	; leader count
   237                              <1> 	
   238                              <1> W23:
   239 0000032C E87B00              <1> 	CALL	WRITE_BYTE	; output leader byte to cassette
   240 0000032F E2FB                <1> 	LOOP	W23		; write a 256-byte leader
   241                              <1> 
   242 00000331 59                  <1> 	POP	CX		; restore CX
   243 00000332 5B                  <1> 	POP	BX		; balance the stack
   244 00000333 B03C                <1> 	MOV	AL,3CH		; get start byte
   245 00000335 E87200              <1> 	CALL	WRITE_BYTE	; output start byte to cassette
   246                              <1> 	
   247 00000338 B0E6                <1> 	MOV	AL,0E6H		; get sync byte
   248 0000033A E86D00              <1> 	CALL	WRITE_BYTE	; output sync byte to cassette
   249                              <1> 
   250                              <1> WR_BLOCK:
   251 0000033D C706A200FFFF        <1> 	MOV	word [crc_reg],0FFFFH	; initialize CRC     jrc
   252 00000343 BA0001              <1> 	MOV	DX,256		; for 256 byte blocks
   253                              <1> 
   254                              <1> W24:	
   255 00000346 268A07              <1> 	MOV	AL,[ES:BX]	; get a data byte from memory
   256 00000349 E85E00              <1> 	CALL	WRITE_BYTE	; output data byte to cassette
   257 0000034C E302                <1> 	JCXZ	W25		; unlexx CX=0, decrement counters
   258 0000034E 43                  <1> 	INC	BX		; increment buffer ptr
   259 0000034F 49                  <1> 	DEC	CX		; decrement byte count
   260                              <1> 
   261                              <1> W25:
   262 00000350 4A                  <1> 	DEC	DX		; decrement block count
   263 00000351 7FF3                <1> 	JG	W24		; loop until 256-byte block is written
   264                              <1> 
   265 00000353 A1A200              <1> 	MOV	AX,[crc_reg]	; otherwise, get checksum
   266 00000356 F7D0                <1> 	NOT	AX	
   267 00000358 50                  <1> 	PUSH	AX		; save it
   268 00000359 86E0                <1> 	XCHG	AH,AL		; write MS byte first
   269 0000035B E84C00              <1> 	CALL	WRITE_BYTE	; and output it
   270 0000035E 58                  <1> 	POP	AX		; get it back
   271 0000035F E84800              <1> 	CALL	WRITE_BYTE	; now write LS byte
   272 00000362 09C9                <1> 	OR	CX,CX		; is byte count 0?
   273 00000364 75D7                <1> 	JNZ	WR_BLOCK	; jump if not done yet
   274                              <1> 
   275                              <1> ; write trailer 4 bytes of FF
   276 00000366 51                  <1> 	PUSH	CX
   277 00000367 B8FF00              <1> 	MOV	AX,0FFH
   278 0000036A B90400              <1> 	MOV	CX,4
   279                              <1> W26:
   280 0000036D E83A00              <1> 	CALL	WRITE_BYTE
   281 00000370 E2FB                <1> 	LOOP	W26
   282                              <1> 
   283                              <1> W31:
   284 00000372 B9C002              <1> 	MOV	CX,2C0H		; slight delay to settle
   285                              <1> ;jrc might use int 15h, fn86
   286 00000375 E2FB                <1> 	LOOP	W31
   287                              <1> 
   288 00000377 59                  <1> 	POP	CX
   289 00000378 E8E9FE              <1> 	CALL	fn01		; turn off motor
   290 0000037B C746020000          <1> 	mov	word [bp+offset_AX],0000h	; return error code to caller
   291 00000380 E9EAFC              <1> 	jmp	clear_carry
   292                              <1> 
   293                              <1> 
   294                              <1> ;--------------------------------------------------------
   295                              <1> ; PURPOSE:
   296                              <1> ;  TO TURN CASSETTE GPIO2 ON
   297                              <1> ;  16550 I/O pins are active low so we need to add
   298                              <1> ;  an inverter (7400) before the 75452 to make this work.
   299                              <1> ;  GPIO2 is OUT2* on 16550, which is bit3 of MCR.
   300                              <1> ;--------------------------------------------------------
   301                              <1> fn04:
   302 00000383 BA8404              <1> 	mov	dx,cuart_mcr			; get device code
   303 00000386 EC                  <1> 	in	al,dx   			;read cassette uart mcr
   304 00000387 0C08                <1> 	or	al,08h				; set bit to turn on
   305 00000389 EE                  <1> W40:	out	dx,al				;write it out
   306 0000038A C746020000          <1> 	mov	word [bp+offset_AX],0000h	; signal success to caller
   307 0000038F E9DBFC              <1> 	jmp	clear_carry
   308                              <1> 
   309                              <1> 
   310                              <1> ;----------------------------------
   311                              <1> ; PURPOSE:
   312                              <1> ;  TO TURN CASSETTE GPIO2 OFF
   313                              <1> ;-----------------------------------
   314                              <1> fn05:
   315 00000392 BA8404              <1> 	mov	dx,cuart_mcr			; get device code
   316 00000395 EC                  <1> 	in	al,dx				;read cassette uart mcr
   317 00000396 24F7                <1> 	and	al,~08h				; clear bit to turn off motor
   318 00000398 E9E4FE              <1> 	jmp	W4				;write it, clear error, return
   319                              <1> 	
   320                              <1> 
   321                              <1> 
   322                              <1> 
   323                              <1> 
   324                              <1> 
   325                              <1> READ_BYTE:
   326                              <1> ; Borrowed from INT16 code
   327                              <1> ; returns with AL=char
   328                              <1> 
   329                              <1> .1:
   330 0000039B 52                  <1> 	push	dx
   331 0000039C BA8504              <1> 	mov	dx,cuart_lsr
   332 0000039F EC                  <1> 	in	al,dx
   333 000003A0 2401                <1> 	and	al,01h		; do we have any data in receive buffer?
   334 000003A2 7404                <1> 	jz	.exit
   335                              <1> 
   336 000003A4 BA8004              <1> 	mov	dx,cuart_rbr
   337 000003A7 EC                  <1> 	in	al,dx		; get next character
   338                              <1> 	
   339                              <1> .exit:						; jrc
   340 000003A8 5A                  <1> 	pop	dx
   341 000003A9 C3                  <1> 	ret
   342                              <1> 	
   343                              <1> 	
   344                              <1> WRITE_BYTE:
   345                              <1> ; Borrowed from INT10 code
   346 000003AA 52                  <1> 	push	dx
   347 000003AB 50                  <1> 	push	ax
   348                              <1> 
   349 000003AC BA8504              <1> 	mov	dx,cuart_lsr
   350                              <1> .1:
   351 000003AF EC                  <1> 	in	al,dx
   352 000003B0 A820                <1> 	test	al,20h		; THRE is empty
   353 000003B2 74FB                <1> 	jz	.1
   354 000003B4 58                  <1> 	pop	ax
   355 000003B5 BA8004              <1> 	mov	dx,cuart_thr
   356 000003B8 EE                  <1> 	out	dx,al		; write character
   357 000003B9 5A                  <1> 	pop	dx
   358 000003BA C3                  <1> 	RET			; return from COUT
   359                              <1> 
   360                              <1> 
   361                              <1> BEGIN_OP:
   362                              <1> ; start the motor and delay
   363                              <1> ; need to adjust loop due to processor
   364                              <1> ; being 3.4x faster than PC??
   365                              <1> ; original BL == 42h
   366                              <1> ;
   367 000003BB E892FE              <1> 	CALL	fn00		; turn on motor
   368                              <1> ;jrc might use int 15h, fn86
   369 000003BE B3E0                <1> 	MOV	BL,0E0H		; delay for tape drive to reach speed (1/2s)
   370                              <1> W33:
   371 000003C0 B90007              <1> 	MOV	CX,700H		; inner loop approx 10ms
   372 000003C3 E2FE                <1> W34:	LOOP	W34
   373 000003C5 FECB                <1> 	DEC	BL
   374 000003C7 75F7                <1> 	JNZ	W33
   375 000003C9 C3                  <1> 	RET
   376                              <1> 
   377                              <1> 
   378                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   379                              <1> ; end CASSETTE.ASM
   380                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   381                              <1> 
   230                                  %if 0
   231                                  ;--------------------------------------------------------
   232                                  ; Cassette support routines
   233                                  ;	(AH) = 0 TURN CASSETTE MOTOR ON
   234                                  ;	(AH) = 1 TURN CASSETTE MOTOR OFF
   235                                  ;	(AH) = 2 READ 1 OR MORE 256 BYTE BLOCKS FROM CASSETTE
   236                                  ;		(ES,BX) = POINTER TO DATA BUFFER
   237                                  ;		(CX) = COUNT OF BYTES TO READ
   238                                  ;		ON EXIT:
   239                                  ;  		(ES,BX) = POINTER TO LAST BYTE READ + 1
   240                                  ;  		(DX) = COUNT OF BYTES ACTUALLY READ
   241                                  ;  		(CY) = 0 IF NO ERROR OCCURRED
   242                                  ;  		     = 1 IF ERROR OCCURRED
   243                                  ;  		(AH) = ERROR RETURN IF (CY)= 1
   244                                  ;  			= 01 IF CRC ERROR WAS DETECTED
   245                                  ;  			= 02 IF DATA TRANSITIONS ARE LOST
   246                                  ;  			= 04 IF NO DATA WAS FOUND
   247                                  ;  	(AH) = 3 WRITE 1 OR MORE 256 BYTE BLOCKS TO CASSETTE
   248                                  ;  		(ES,BX) = POINTER TO DATA BUFFER
   249                                  ;  		(CX) = COUNT OF BYTES TO WRITE
   250                                  ;  		ON EXIT:
   251                                  ;		(EX,BX) = POINTER TO LAST BYTE WRITTEN + 1
   252                                  ;		(CX) = 0
   253                                  ;	(AH) = 4 TURN GPIO2 ON
   254                                  ;	(AH) = 5 TURN GPIO2 OFF
   255                                  ;	(AH) = ANY OTHER THAN ABOVE VALUES CAUSES (CY)= 1
   256                                  ;		AND (AH)= 80 TO BE RETURNED (INVALID COMMAND).
   257                                  ;--------------------------------------------------------
   258                                  ; PURPOSE:
   259                                  ;  TO TURN ON CASSETTE MOTOR
   260                                  ;  16550 I/O pins are active low so we need to add
   261                                  ;  an inverter (7400) before the 75452 to make this work.
   262                                  ;  Cassette motor connected to OUT1* on 16550, which is
   263                                  ;  bit2 of MCR.
   264                                  ;--------------------------------------------------------
   265                                  fn00:
   266                                  	mov	dx,cuart_mcr			; get device code
   267                                  	in	al,dx				;read cassette uart mcr
   268                                  	or	al,04H				; SET BIT TO TURN ON
   269                                  W3:	out	dx,al				;WRITE IT OUT
   270                                  	mov	word [bp+offset_AX],0000h	; signal success to caller
   271                                  	jmp	clear_carry
   272                                  
   273                                  
   274                                  ;----------------------------------
   275                                  ; PURPOSE:
   276                                  ;  TO TURN CASSETTE MOTOR OFF
   277                                  ;-----------------------------------
   278                                  fn01:
   279                                  	mov	dx,cuart_mcr			; get device code
   280                                  	in	al,dx				;read cassette uart mcr
   281                                  	and	al,~04h				; clear bit to turn off motor
   282                                  	jmp	W3				;write it, clear error, return
   283                                  
   284                                  
   285                                  ;--------------------------------------------
   286                                  ; PURPOSE:
   287                                  ;  TO READ 1 OR MORE 256 BYTE BLOCKS FROM CASSETTE
   288                                  ;
   289                                  ; ON ENTRY:
   290                                  ;  ES IS SEGMENT FOR MEMORY BUFFER (FOR COMPACT CODE)
   291                                  ;  BX POINTS TO START OF MEMORY BUFFER
   292                                  ;  CX CONTAINS NUMBER OF BYTES TO READ
   293                                  ; ON EXIT:
   294                                  ;  BX POINTS 1 BYTE PAST LAST BYTE PUT IN MEM
   295                                  ;  CX CONTAINS DECREMENTED BYTE COUNT
   296                                  ;  DX CONTAINS NUMBER OF BYTES ACTUALLY READ
   297                                  ;
   298                                  ;  CARRY FLAG IS CLEAR IF NO ERROR DETECTED
   299                                  ;  CARRY FLAG IS SET IF CRC ERROR DETECTED
   300                                  ;--------------------------------------------
   301                                  fn02:
   302                                  	mov	word [bp+offset_AX],80ffh	; return error code to caller
   303                                  	jmp	set_carry
   304                                  
   305                                  
   306                                  ;--------------------------------------------
   307                                  ;  READ 1 OR MORE 256 BYTE BLOCKS FROM CASSETTE
   308                                  ;
   309                                  ; ON ENTRY:
   310                                  ;  ES IS SEGMENT FOR MEMORY BUFFER (FOR COMPACT CODE)
   311                                  ;  BX POINTS TO START OF MEMORY BUFFER
   312                                  ;  CX CONTAINS NUMBER OF BYTES TO READ
   313                                  ; ON EXIT:
   314                                  ;  BX POINTS 1 BYTE PAST LAST BYTE PUT IN MEM
   315                                  ;  CX CONTAINS DECREMENTED BYTE COUNT
   316                                  ;  DX CONTAINS NUMBER OF BYTES ACTUALLY READ
   317                                  ;--------------------------------------------
   318                                  fn03:
   319                                  	mov	word [bp+offset_AX],80ffh	; return error code to caller
   320                                  	jmp	set_carry
   321                                  
   322                                  
   323                                  ;--------------------------------------------------------
   324                                  ; PURPOSE:
   325                                  ;  TO TURN CASSETTE GPIO2 ON
   326                                  ;  16550 I/O pins are active low so we need to add
   327                                  ;  an inverter (7400) before the 75452 to make this work.
   328                                  ;  GPIO2 is OUT2* on 16550, which is bit3 of MCR.
   329                                  ;--------------------------------------------------------
   330                                  fn04:
   331                                  	mov	dx,cuart_mcr			; get device code
   332                                  	in	al,dx   			;read cassette uart mcr
   333                                  	or	al,08h				; set bit to turn on
   334                                  W4:	out	dx,al				;write it out
   335                                  	mov	word [bp+offset_AX],0000h	; signal success to caller
   336                                  	jmp	clear_carry
   337                                  
   338                                  
   339                                  ;----------------------------------
   340                                  ; PURPOSE:
   341                                  ;  TO TURN CASSETTE GPIO2 OFF
   342                                  ;-----------------------------------
   343                                  fn05:
   344                                  	mov	dx,cuart_mcr			; get device code
   345                                  	in	al,dx				;read cassette uart mcr
   346                                  	and	al,~08h				; clear bit to turn off motor
   347                                  	jmp	W4				;write it, clear error, return
   348                                  %endif	
   349                                  
   350                                  
   351                                          SEGMENT CONST
   352                                  env_table:
   353 00000025 0800                            dw      len_env_table
   354 00000027 FE                      	db	MODEL_BYTE	; PC/XT
   355 00000028 00                      	db	SUBMODEL_BYTE	; rev 1		CPUREGS.ASM
   356 00000029 03                      	db	VERSION_MAJOR	; BIOS revision level  DATE.ASM
   357 0000002A 34                              db      00100100b | (CVDU_8242 << 4)
   358                                  				; DMA ch 3 used = 0             7
   359                                                                  ; slave 8259 present = 0        6
   360                                                                  ; RTC available = 1             5
   361                                                                  ; KBD intercept available (int 15h, fn4F) = 0
   362                                                                  ; Wait for Event avail. = 0     3
   363                                                                  ; Extended BIOS data area alloc. = 1   (FPEM will use)
   364                                                                  ; Micro Channel = 0             1
   365                                                                  ; reserved bit = 0              0
   366 0000002B 00                              db      0       ; unknown usage
   367 0000002C 00                              db      0       ; unknown usage
   368                                  len_env_table   equ     $-env_table
   369 0000002D 0000                            db      0,0     ; just in case
   370                                  
   371                                  
   372                                  	SEGMENT	_TEXT
   373                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   374                                  ; Get System Environment
   375                                  ;   Input:
   376                                  ;	AH = 0C0h	function code
   377                                  ;   Returns:
   378                                  ;	ES:BX		pointer to the environment table above
   379                                  ;	Carry clear	success
   380                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   381                                  fnC0:
   382 000003CA C74604[2500]                    mov     word [bp+offset_BX],env_table
   383 000003CF 68[0000]                        push    DGROUP
   384 000003D2 07                              popm    es                              ; return ES:BX
   385                                  ;;;	mov     byte [bp+offset_AH],0           ; signal no error
   386 000003D3 E997FC                          jmp     clear_carry
   387                                  
   388                                  
   389                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   390                                  ; Get Extended BIOS Data Area Address
   391                                  ;   Input:
   392                                  ;	AH = 0C1h	function code
   393                                  ;   Returns:
   394                                  ;	ES		set to the EBDA segment address
   395                                  ;	Carry clear	success
   396                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   397                                  fnC1:
   398 000003D6 6A40                            push    bios_data_seg
   399 000003D8 1F                              popm    ds
   400 000003D9 8E06F200                        mov     es,[EBDA_paragraph]
   401 000003DD E98DFC                          jmp     clear_carry
   402                                  
   403                                  
   404                                  ; Disable timer1 interrupts
   405                                  ;
   406                                  ;	uses AX & DX
   407                                  ;	exits with AX=0
   408                                  ;
   409                                  timer_disable:
   410 000003E0 BA5EFF                  	mov	dx,timer1+TCON	
   411 000003E3 ED                      	in	ax,dx		; get control register
   412 000003E4 25FF7F                  	and	ax,(~tc_EN)&0FFFFh  ; disable timer
   413 000003E7 0D0040                  	or	ax,tc_nINH		; change enable flag
   414 000003EA EF                      	out	dx,ax		; disable the timer
   415                                  	
   416 000003EB 31C0                    	xor	ax,ax
   417 000003ED BA58FF                  	mov	dx,timer1+TCNT		; zero the count
   418 000003F0 EF                      	out	dx,ax
   419 000003F1 C3                       	ret
   420                                  
   421                                  ; Enable timer1 interrupts
   422                                  ;
   423                                  ;	uses AX & DX
   424                                  ;
   425                                  timer_enable:
   426 000003F2 BA5EFF                  	mov	dx,timer1+TCON	
   427 000003F5 ED                      	in	ax,dx		; get control register
   428 000003F6 0D00E0                  	or	ax,tc_EN+tc_nINH+tc_INT		; enable timer & interrupts
   429 000003F9 EF                      	out	dx,ax		; enable the timer
   430 000003FA C3                       	ret	
   431                                  
   432                                  	global set_count
   433                                  set_count:
   434 000003FB 31DB                    	xor	bx,bx
   435                                  ; wait in microseconds in BX:CX:DX
   436                                  
   437                                  ;  to divide by 976 microseconds, the resolution of the timer
   438                                  ;  we divide by 1000000/1024 == 15625/16
   439                                  ;  OR we multiply by 16, then divide by 15625
   440                                  
   441 000003FD 51                      	pushm	cx
   442 000003FE 89C8                    	mov	ax,cx		; BX:AX:DX is microsecond count
   443 00000400 B90400                  	mov	cx,4
   444 00000403 D1E2                    .4:	shl	dx,1		; * 16 is left shift by 4
   445 00000405 D1D0                    	rcl	ax,1
   446 00000407 D1D3                    	rcl	bx,1
   447 00000409 E2F8                    	loop	.4
   448 0000040B B9093D                  	mov	cx,15625	; divisor
   449 0000040E 87DA                    	xchg	bx,dx		; DX:AX:BX is count
   450 00000410 F7F1                    	div	cx
   451 00000412 A39E00                  	mov	word [rtc_count+2],ax	; AX is high quotient
   452 00000415 93                      	xchg	ax,bx		; and DX is remainder
   453 00000416 F7F1                    	div	cx		; DX:AX is low dividend
   454 00000418 59                      	popm	cx
   455                                  
   456                                  %if 0
   457                                  ; since count goes to -1, there will always be at least 1 tick
   458                                  	or	bx,ax		; test for zero tick count
   459                                  	jnz	.5
   460                                  	inc	ax		; wait at least 1 tick
   461                                  .5:
   462                                  %endif
   463 00000419 A39C00                  	mov	word [rtc_count],ax	; AX is final low quotient
   464 0000041C C3                      	ret
   465                                  
   466                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   467                                  ; fn83 -- Event Wait
   468                                  ;   Input:
   469                                  ;	AH = 83h
   470                                  ;
   471                                  ;   Subfucntion:
   472                                  ;	AL = 01h	Cancel event wait
   473                                  ;   Output:
   474                                  ;	nothing
   475                                  ;
   476                                  ;   Subfunction:
   477                                  ;	AL = 00h	Request Event Wait
   478                                  ;	CX:DX = delay in microseconds
   479                                  ;	ES:BX = address of semaphore byte
   480                                  ;		the semaphore bit 7 is set at the end of the inverval
   481                                  ;   Output:
   482                                  ;	Carry flag clear if timer started
   483                                  ;	Carry flag set if function unsuccessful (event wait already active)
   484                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   485                                  fn83:		; BP,AX,BX,DX,DS already saved
   486 0000041D 6A40                    	push	bios_data_seg
   487 0000041F 1F                      	popm	ds
   488 00000420 08C0                    	or	al,al		; test for zero
   489 00000422 741C                    	jz	.set_wait
   490                                  
   491 00000424 FEC8                    	dec	al		; test for one
   492 00000426 7403E938FC              	jnz	set_carry	; error on illegal subfunction
   493                                  ; cancel wait
   494 0000042B E8B2FF                  	call	timer_disable
   495                                  ;	xor	ax,ax		; side effect of 'timer_disable'
   496 0000042E A2A000                  	mov	byte [rtc_wait_active],al
   497 00000431 A39E00                  	mov	word [rtc_count+2],ax
   498 00000434 A39C00                  	mov	word [rtc_count],ax
   499 00000437 A39A00                  	mov	word [user_semaphore+2],ax
   500 0000043A A39800                  	mov	word [user_semaphore],ax
   501 0000043D E92DFC                  	jmp	clear_carry
   502                                  
   503                                  .set_wait:
   504 00000440 F606A00001              	test	byte [rtc_wait_active],01h	; any wait in progress
   505 00000445 7403E919FC              	jnz	set_carry
   506                                  
   507 0000044A 8B5E04                  	mov	bx,[offset_BX+bp]	; restore BX
   508 0000044D 8C069A00                	mov	word [user_semaphore+2],es
   509 00000451 891E9800                	mov	word [user_semaphore],bx
   510                                  
   511 00000455 E8A3FF                  	call	set_count	
   512                                  	
   513 00000458 E897FF                  	call	timer_enable
   514 0000045B C606A00001              	mov	byte [rtc_wait_active],01h	; flag wait active
   515 00000460 B80083                  	mov	ax,8300h
   516 00000463 E907FC                  	jmp	clear_carry
   517                                  
   518                                  
   519                                  
   520                                  
   521                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   522                                  ; fn86 -- Delay
   523                                  ;   Input:
   524                                  ;	AH = 86h
   525                                  ;	CX:DX = delay in microseconds
   526                                  ;
   527                                  ;   Output:
   528                                  ;	Carry flag clear if delay occurred
   529                                  ;	Carry flag set if timer busy; no delay occurred
   530                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   531                                  fn86:		; BP,AX,BX,DX,DS already saved
   532 00000466 6A40                    	push	bios_data_seg
   533 00000468 1F                      	popm	ds
   534 00000469 F606A00001              	test	byte [rtc_wait_active],01h	; is a wait active?
   535 0000046E 7403E9F0FB              	jnz	set_carry		; perform no wait, we're busy
   536                                  
   537 00000473 E885FF                  	call	set_count
   538 00000476 C606A00001              	mov	byte [rtc_wait_active],01h		; mark timer active
   539                                  
   540 0000047B 31DB                    	xor	bx,bx
   541 0000047D 891E9800                	mov	word [user_semaphore],bx
   542 00000481 891E9A00                	mov	word [user_semaphore+2],bx
   543                                  
   544 00000485 E86AFF                  	call	timer_enable
   545 00000488 FB                      	sti					; don't forget to enable interrupts
   546 00000489 EB01                    	jmp	.3
   547                                  
   548                                  
   549 0000048B F4                      .wait:	hlt
   550 0000048C F606A00080              .3:	test	byte [rtc_wait_active],80h		; wait for posting
   551 00000491 74F8                    	jz	.wait
   552                                  
   553 00000493 C606A00000              	mov	byte [rtc_wait_active],0		; mark not in use
   554 00000498 E9D2FB                  	jmp	clear_carry
   555                                  
   556                                  	
   557                                  	global	rtc_interrupt
   558                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   559                                  ;  rtc_interrupt             (timer0, if NEED_TIMER_FIX)
   560                                  ;
   561                                  ;       This is the 1024 Hz timer tick from INT 70h
   562                                  ;
   563                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   564                                  rtc_interrupt:
   565 0000049B 1E565250                	pushm	ax,dx,si,ds
   566                                  
   567 0000049F 6A40                    	push	bios_data_seg
   568 000004A1 1F                      	popm	ds
   569                                  
   570 000004A2 F606A00001              	test	byte [rtc_wait_active],01h	; test active bit
   571 000004A7 7421                    	jz	.dismiss
   572                                  
   573 000004A9 832E9C0001              	sub	word [rtc_count],1
   574 000004AE 831E9E0000              	sbb	word [rtc_count+2],0
   575 000004B3 7315                    	jnc	.dismiss		; counted down by 1
   576                                  
   577                                  ; counted down to -1, post the event
   578 000004B5 C606A00080              	mov	byte [rtc_wait_active],80h	; mark posted, inactive
   579 000004BA C5369800                	lds	si,[user_semaphore]
   580 000004BE 8CD8                    	mov	ax,ds			; check for null pointer
   581 000004C0 09F0                    	or	ax,si			; **
   582 000004C2 7403                    	jz	.2
   583 000004C4 800C80                  	or	byte [si],80h			; post event
   584 000004C7 E816FF                  .2:	call	timer_disable
   585                                  
   586                                  .dismiss:
   587                                  ; signal EOI (End of Interrupt)
   588 000004CA BA22FF                          mov     dx,PIC_EOI              ; EOI register
   589 000004CD B80080                          mov     ax,EOI_NSPEC            ; non-specific
   590 000004D0 EF                              out     dx,ax                   ; signal it
   591                                  
   592 000004D1 585A5E1F                	popm	ax,dx,si,ds
   593 000004D5 CF                              iret
   594                                  
