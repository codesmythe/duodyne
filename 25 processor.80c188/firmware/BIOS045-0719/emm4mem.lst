     1                                  ;========================================================================
     2                                  ; emm4mem.asm
     3                                  ;
     4                                  ;  LIM EMS 3.2 driver for the N8VEM 4MEM board used with the SBC-188
     5                                  ;
     6                                  ; This program is free software: you can redistribute it and/or modify
     7                                  ; it under the terms of the GNU General Public License as published by
     8                                  ; the Free Software Foundation, either version 3 of the License, or
     9                                  ; (at your option) any later version.
    10                                  ;
    11                                  ; This program is distributed in the hope that it will be useful,
    12                                  ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    13                                  ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    14                                  ; GNU General Public License for more details.
    15                                  ;
    16                                  ; You should have received a copy of the GNU General Public License
    17                                  ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    18                                  ;
    19                                  ;========================================================================
    20                                  ;
    21                                  %define MAJOR_VERSION 2
    22                                  %define MINOR_VERSION 0
    23                                  %define VERSION_SUFFIX ""
    24                                  %define DATE "30-Jan-2013"
    25                                  ;
    26                                  ;
    27                                  %ifndef SOFT_DEBUG
    28                                  %define SOFT_DEBUG 0
    29                                  %endif
    30                                  %ifndef TRACE
    31                                  %define TRACE 0
    32                                  %endif
    33                                  %include "config.asm"
     1                              <1> ;/*
     2                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     3                              <1> ; VGA3.CFG
     4                              <1> ;   Copied to CONFIG.ASM for general release.
     5                              <1> ;
     6                              <1> ;       Modify the parameters below to reflect your system
     7                              <1> ;
     8                              <1> ;
     9                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    10                              <1> ;
    11                              <1> ;   Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    12                              <1> ;   Provided for hobbyist use on the N8VEM SBC-188 board.
    13                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    14                              <1> ;
    15                              <1> ; Define the serial terminal that the Video BIOS must emulate
    16                              <1> ; Set one of the following to 1
    17                              <1> ; If you have no idea what to choose, set TTY to 1
    18                              <1> TTY     equ     0       ; hardcopy -- cannot position the cursor
    19                              <1> DUMB    equ     0       ; dumb CRT -- ^H, ^J, ^K, ^L can move the cursor
    20                              <1> ANSI    equ     1       ; very smart, like a VT-100
    21                              <1> WYSE    equ     0       ; very smart Wyse series (30, 50, ...)
    22                              <1> ; others may get added in the future
    23                              <1> ;  ONE OF THE ABOVE must BE SET TO 1!!!!!
    24                              <1> ;
    25                              <1> ; Does the hardware configuration contain the Color Video Display Unit?
    26                              <1> ; Both the 8563 and the 8242 are used.  The default is CVDU=0
    27                              <1> CVDU	equ	0	; system does not have the CVDU
    28                              <1> ;
    29                              <1> ; Does the hardware configuration contain the VGA3 a/n Video card?
    30                              <1> ; The 8563 will be disabled, but the 8242 code is shared with the CVDU
    31                              <1> ; The default is VGA3=0
    32                              <1> VGA3   equ     1       ; system has the VGA3
    33                              <1> ;
    34                              <1> ; Does the hardware configuration contain the front panel card?
    35                              <1> ; The default is FRONT_PANEL=0
    36                              <1> ;
    37                              <1> FRONT_PANEL   equ     1       ; system has the VGA3
    38                              <1> %if 0
    39                              <1> 	*/
    40                              <1> #define VGA3 1
    41                              <1> /*
    42                              <1> %endif
    43                              <1> ;
    44                              <1> ; Boot up keyboard mode:  20h for NumLock on
    45                              <1> ;CVDU_KEYBOARD_STATUS	equ	0	; NumLock OFF
    46                              <1> CVDU_KEYBOARD_STATUS	equ	20h	; NumLock ON
    47                              <1> 
    48                              <1> ; Define the UART startup bit rate - 1200-19200 are most common
    49                              <1> ;UART_RATE	equ	0		; 1200
    50                              <1> ;UART_RATE	equ	1		; 2400
    51                              <1> ;UART_RATE	equ	2		; 4800
    52                              <1> ;UART_RATE	equ	3		; 9600
    53                              <1> ;UART_RATE	equ	4		; 19200
    54                              <1> UART_RATE	equ	5		; 38400
    55                              <1> ;UART_RATE	equ	6		; 57600
    56                              <1> ;UART_RATE	equ	7		; 115200
    57                              <1> 
    58                              <1> ; Does the serial terminal use the DSR/DTR protocol for flow control?
    59                              <1> ;UART_DSR_PROTOCOL	equ		1	; Yes!
    60                              <1> UART_DSR_PROTOCOL       equ             WYSE    ; Wyse always uses it
    61                              <1> 						; but not ANSI
    62                              <1> ; Define the size of the ROM image on the system in Kilobytes
    63                              <1> ; It may be smaller than the actual EPROM in use.
    64                              <1> ; The following sizes are supported:  32, 64, 128, and 256
    65                              <1> %ifndef ROM
    66                              <1> ROM             equ     32              ; 64 is the default
    67                              <1> %endif
    68                              <1> 
    69                              <1> ; Define the number of Wait States at which the ROM operates
    70                              <1> ROM_WS          equ     1               ; 0..3  (1 is the default)
    71                              <1> 
    72                              <1> ; Define the size in Kilobytes of DOS RAM (low SRAM plus EMM allocate RAM)
    73                              <1> ; This is a desired size and will only be present if a 4MEM board is added
    74                              <1> RAM_DOS         equ     640
    75                              <1> 
    76                              <1> ; Define the size of the low SRAM on the system in Kilobytes
    77                              <1> ; the default is 512 kilobytes
    78                              <1> RAM             equ     512             ; (512 is the default)
    79                              <1> 
    80                              <1> ; Define the number of Wait States at which the RAM operates
    81                              <1> RAM_WS          equ     0               ; 0..3  (0 is the default)
    82                              <1> 
    83                              <1> ; Define the number of Wait States for Local Peripheral devices (600-7FF)
    84                              <1> LCL_IO_WS       equ     1               ; 0..3  (1 is the default)
    85                              <1> 
    86                              <1> ; Define the number of Wait States for ECB BUS peripheral devices (4xx)
    87                              <1> BUS_IO_WS       equ     3               ; 0..3  (3 is the default)
    88                              <1> 
    89                              <1> ; Define the time zone in which we build the Relocatable BIOS
    90                              <1> %ifndef TIMEZONE
    91                              <1> %define TIMEZONE "CDT"
    92                              <1> %endif
    93                              <1> 
    94                              <1> ; Has the REDBUG debugger been loaded?
    95                              <1> %ifndef SOFT_DEBUG
    96                              <1> %define SOFT_DEBUG 0
    97                              <1> %endif
    98                              <1> 
    99                              <1> ; Should the BIOS include "Tiny BASIC" in the image?
   100                              <1> %ifndef TBASIC
   101                              <1> TBASIC          equ     1		; default is 1
   102                              <1> %endif
   103                              <1> 
   104                              <1> ; Should the BIOS include the Floating Point Emulator?  The 80188 does
   105                              <1> ; not allow a floating point co-processor, so this is probably a good idea.
   106                              <1> %ifndef FPEM
   107                              <1> FPEM            equ     1               ; default is 1
   108                              <1> %endif
   109                              <1> 
   110                              <1> ; Define the maximum number of EMM (4MEM) boards supported
   111                              <1> EMM_BOARDS      equ     4
   112                              <1> 
   113                              <1> ; Should the Floating Point Emulator use temporary storage in the EBDA
   114                              <1> ; or at locations 0280h..3FFh in low memory?
   115                              <1> %if SOFT_DEBUG
   116                              <1> FPEM_USE_EBDA   equ     FPEM            ; default is 0
   117                              <1> %else
   118                              <1> FPEM_USE_EBDA   equ     0; FPEM            ; default is 0
   119                              <1> %endif
   120                              <1> 
   121                              <1> ; Define the size of the EPROM that is to be installed on the system
   122                              <1> ; It may be larger than the actual ROM image to be generated.
   123                              <1> %ifndef CHIP
   124                              <1> CHIP            equ     64
   125                              <1> %endif
   126                              <1> 
   127                              <1> ; Does the SBC-188 00.4 board have the LS138/LS08 piggyback fix
   128                              <1> ; Set to 1 for the SBC-188 v1.0 and later production boards
   129                              <1> FDC_PIGGYBACK_FIX       equ     0       ; Fix not installed
   130                              <1> ;FDC_PIGGYBACK_FIX       equ     1       ; fix  IS  installed
   131                              <1> 
   132                              <1> ; On SBC-188 rev 00.4 board, there is a published hardware fix (2010-09-18).
   133                              <1> ; If the wiring update is installed, or you have a later board, then
   134                              <1> ; set this to 0.  If you are using the software workaround, then set this
   135                              <1> ; to 1.  The rev 1.0 board has this fix already.
   136                              <1> NEED_TIMER_FIX  equ     0               ; have revised hardware
   137                              <1> ;NEED_TIMER_FIX  equ     1               ; use workaround
   138                              <1> 
   139                              <1> ; Define the UART oscillator speed
   140                              <1> UART_OSC        equ     1843200         ; 1.8432 Mhz is specified
   141                              <1> 
   142                              <1> 
   143                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   144                              <1> ; end of the User configuration
   145                              <1> ;       Do Not modify anything below this point
   146                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   147                              <1> 
   148                              <1> CVDU_8563	equ	CVDU		; separate inits
   149                              <1> CVDU_8242	equ	CVDU|VGA3 	; separate inits
   150                              <1> VGA3_6445       equ     VGA3            ; separate inits
   151                              <1> ; Suppress all UART output in color video Mode 3
   152                              <1> ;UART_MODE3_SUPPRESS	equ	0
   153                              <1> UART_MODE3_SUPPRESS	equ	CVDU_8563 | VGA3_6445
   154                              <1> CVDU_USE_MSDOS_KLUDGE	equ	0; CVDU_8242	; bad, bad MSDOS
   155                              <1> CVDU_USE_KBD_HOOK		equ	CVDU_8242
   156                              <1> 
   157                              <1> ; Define existence of any uart chip
   158                              <1> UART		equ	TTY+DUMB+ANSI+WYSE
   159                              <1> startuplength   equ     128                     ; may be up to 1024
   160                              <1> startseg        equ     0FFFFh - (ROM*64) + 1
   161                              <1> highrom         equ     (ROM*400h)&0FFFFh
   162                              <1> startupseg      equ     0FFFFh - (startuplength>>4) + 1
   163                              <1> bios_data_seg   equ     040h            ; segment of BIOS data area
   164                              <1> 
   165                              <1> 
   166                              <1> %define ARG(n) [bp+2+(n)*2]
   167                              <1> 
   168                              <1> %macro  check   1.nolist
   169                              <1>  %if (%1)
   170                              <1>    %error Check Failure: %1
   171                              <1>  %endif
   172                              <1> %endm
   173                              <1> %macro  range   3.nolist
   174                              <1>  %if (%1)<(%2)
   175                              <1>    %error Out of Range: %1
   176                              <1>  %elif (%1)>(%3)
   177                              <1>    %error Out of Range: %1
   178                              <1>  %endif
   179                              <1> %endm
   180                              <1> _terminal equ UART+CVDU
   181                              <1>  check   RAM_DOS&15
   182                              <1>  check   RAM&(RAM-1)
   183                              <1>  check   ROM&(ROM-1)
   184                              <1>  range   RAM,32,512
   185                              <1>  range   ROM,32,256
   186                              <1>  range   RAM_WS,0,3
   187                              <1>  range   ROM_WS,0,3
   188                              <1>  range   RAM_DOS,RAM,(1024-ROM)
   189                              <1>  range   LCL_IO_WS,0,3
   190                              <1>  range   BUS_IO_WS,0,3
   191                              <1>  range   UART_OSC,500000,16000000
   192                              <1>  range   UART_RATE,0,7
   193                              <1>  range	 UART,0,1
   194                              <1>  range	 _terminal,1,2
   195                              <1> 
   196                              <1> %ifndef SOFT_DEBUG
   197                              <1> %define SOFT_DEBUG 0
   198                              <1> %endif
   199                              <1> 
   200                              <1> %ifndef TRACE
   201                              <1> %define TRACE 0
   202                              <1> %endif
   203                              <1> 
   204                              <1> %ifdef MAKE_OBJECT_FILE
   205                              <1>         segment _DATA WORD PUBLIC CLASS=DATA
   206                              <1>         export _ROMsize
   207                              <1>         export _CHIPsize
   208                              <1> _ROMsize        dw      ROM
   209                              <1> _CHIPsize       dw      CHIP
   210                              <1> %endif
   211                              <1> ; end of the Hardware configuration file
   212                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   213                              <1> ;*/
    34                                  %include "cpuregs.asm"
     1                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     2                              <1> ; CPUREGS.ASM
     3                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     4                              <1> ;
     5                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
     6                              <1> ;
     7                              <1> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
     8                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
     9                              <1> ;
    10                              <1> ; This program is free software: you can redistribute it and/or modify
    11                              <1> ; it under the terms of the GNU General Public License as published by
    12                              <1> ; the Free Software Foundation, either version 3 of the License, or
    13                              <1> ; (at your option) any later version.
    14                              <1> ;
    15                              <1> ; This program is distributed in the hope that it will be useful,
    16                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    17                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    18                              <1> ; GNU General Public License for more details.
    19                              <1> ;
    20                              <1> ; You should have received a copy of the GNU General Public License
    21                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    22                              <1> ;
    23                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    24                              <1>         cpu     186
    25                              <1> ;
    26                              <1> ;
    27                              <1> ; IBM model byte -- must be less than a 286
    28                              <1> ;
    29                              <1> ;MODEL_BYTE		equ	0FEh	; PC-XT
    30                              <1> ;SUBMODEL_BYTE		equ	0FFh	; not used
    31                              <1> 
    32                              <1> MODEL_BYTE		equ	0FEh	; PC-XT
    33                              <1> SUBMODEL_BYTE		equ	00h	;  "
    34                              <1> 
    35                              <1> 
    36                              <1> ; 80188 peripheral control register block address
    37                              <1> CPU_CSCR	        equ	0FF00h
    38                              <1> 
    39                              <1> ; Compatible Mode registers
    40                              <1> 
    41                              <1> cpu_relocation          equ     CPU_CSCR+0FEh
    42                              <1> 
    43                              <1> ; The memory and peripheral chip select register offsets from 0FF00h
    44                              <1> 
    45                              <1> cpu_umcs                equ     CPU_CSCR+0A0h          ; Upper memory select
    46                              <1> cpu_lmcs                equ     CPU_CSCR+0A2h          ; Lower memory select
    47                              <1> cpu_pacs                equ     CPU_CSCR+0A4h          ; Peripheral select
    48                              <1> cpu_mmcs                equ     CPU_CSCR+0A6h          ; Middle memory base
    49                              <1> cpu_mpcs                equ     CPU_CSCR+0A8h          ; Mid mem. & peripherals
    50                              <1> 
    51                              <1> ; Enhanced Mode registers
    52                              <1> 
    53                              <1> cpu_mdram               equ     CPU_CSCR+0E0h          ; memory partition reg.
    54                              <1> cpu_cdram               equ     CPU_CSCR+0E2h          ; clock prescaler
    55                              <1> cpu_edram               equ     CPU_CSCR+0E4h          ; Enable refresh reg.
    56                              <1> cpu_pdcon               equ     CPU_CSCR+0F0h          ; Power-Save control
    57                              <1> 
    58                              <1> 
    59                              <1> ; On-board internal peripheral equates
    60                              <1> ; Programmable Interrupt Controller
    61                              <1> PIC	        equ	CPU_CSCR+020H
    62                              <1> PIC_EOI	        equ	PIC+2           ; End Of Interrupt
    63                              <1> PIC_POLLR	equ	PIC+4
    64                              <1> PIC_POLLSR	equ	PIC+6
    65                              <1> PIC_IMASK	equ	PIC+8
    66                              <1> PIC_PMREG	equ	PIC+0AH
    67                              <1> PIC_SRVR	equ	PIC+0CH
    68                              <1> PIC_IRQR	equ	PIC+0EH
    69                              <1> PIC_IRQSR	equ	PIC+10H
    70                              <1> PIC_TCR	        equ	PIC+12H
    71                              <1> PIC_DMA0CR	equ	PIC+14H
    72                              <1> PIC_DMA1CR	equ	PIC+16H
    73                              <1> PIC_I0CON	equ	PIC+18H
    74                              <1> PIC_I1CON	equ	PIC+1AH
    75                              <1> PIC_I2CON	equ	PIC+1CH
    76                              <1> PIC_I3CON	equ	PIC+1EH
    77                              <1> 
    78                              <1> EOI_NSPEC       equ     8000h           ; Non-Specific EOI
    79                              <1> 
    80                              <1> ; Interrupt masks (Master Mode)
    81                              <1> ;
    82                              <1> mask_timer_all          equ     0001h
    83                              <1> mask_dma0               equ     0004h
    84                              <1> mask_dma1               equ     0008h
    85                              <1> mask_int0               equ     0010h
    86                              <1> mask_int1               equ     0020h
    87                              <1> mask_int2               equ     0040h
    88                              <1> mask_int3               equ     0080h
    89                              <1> 
    90                              <1> 
    91                              <1> 
    92                              <1> ; Timers
    93                              <1> TIM0	        equ	CPU_CSCR+050H
    94                              <1> TIM1	        equ	CPU_CSCR+058H
    95                              <1> TIM2	        equ	CPU_CSCR+060H
    96                              <1> 
    97                              <1> TCNT	        equ	0	; count register
    98                              <1> CMPA	        equ	2	; max count A
    99                              <1> CMPB	        equ	4	; max count B (not present on TIM2)
   100                              <1> TCON	        equ	6	; mode/control word
   101                              <1> 
   102                              <1> ; Timer control bits:
   103                              <1> tc_EN           equ     8000h   ; Enable bit
   104                              <1> tc_nINH         equ     4000h   ; not Inhibit Enable
   105                              <1> tc_INT          equ     2000h   ; Interrupt Enable
   106                              <1> tc_RIU          equ     1000h   ; Register A/B (0/1) in Use
   107                              <1> tc_MC           equ     0020h   ; Maximum Count reached
   108                              <1> tc_RTG          equ     0010h   ; Retrigger (internal source)
   109                              <1> tc_P            equ     0008h   ; Prescale internal clock (timers 0 & 1 only)
   110                              <1> tc_EXT          equ     0004h   ; External clock
   111                              <1> tc_ALT          equ     0002h   ; Alternate between A & B max count registers
   112                              <1> tc_CONT         equ     0001h   ; Continuous: continue after max count
   113                              <1> 
   114                              <1> 
   115                              <1> 
   116                              <1> 
   117                              <1> ; DMA
   118                              <1> DMA0	        equ	CPU_CSCR+0C0H
   119                              <1> DMA1	        equ	CPU_CSCR+0D0H
   120                              <1> DMASPL	        equ	0	; source pointer low
   121                              <1> DMASPU	        equ	2	; source pointer high
   122                              <1> DMADPL	        equ	4	; destination pointer low
   123                              <1> DMADPU	        equ	6	; destination pointer high
   124                              <1> DMATC	        equ	8	; terminal count
   125                              <1> DMACW	        equ	0AH	; control word
   126                              <1> 
   127                              <1> 
   128                              <1> 
   129                              <1> 
   130                              <1> 
   131                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   132                              <1> ;
   133                              <1> ;       SBC-188 external devices
   134                              <1> ;
   135                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   136                              <1> 
   137                              <1> IO_BASE			equ	0400h
   138                              <1> 
   139                              <1> 
   140                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   141                              <1> ; The UART registers
   142                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   143                              <1> uart_base               equ     IO_BASE+0280h
   144                              <1> uart_rbr                equ     uart_base       ;Rcvr Buffer / read only
   145                              <1> uart_thr                equ     uart_base       ;Transmit Holding / write only
   146                              <1> uart_ier                equ     uart_base+1     ;Interrupt Enable
   147                              <1> uart_iir                equ     uart_base+2     ;Interrupt Ident / read only
   148                              <1> uart_fcr                equ     uart_base+2     ;FIFO Control / write only
   149                              <1> uart_lcr                equ     uart_base+3     ;Line Control
   150                              <1> uart_mcr                equ     uart_base+4     ;Modem Control
   151                              <1> uart_lsr                equ     uart_base+5     ;Line Status
   152                              <1> uart_msr                equ     uart_base+6     ;Modem Status
   153                              <1> uart_sr			equ	uart_base+7	;Scratch
   154                              <1> 
   155                              <1> uart_dll                equ     uart_base       ;Divisor Latch LS Byte
   156                              <1> uart_dlm                equ     uart_base+1     ;Divisor Latch MS Byte
   157                              <1> 
   158                              <1> 
   159                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   160                              <1> ; Floppy controller
   161                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   162                              <1> FDC	        equ	IO_BASE+0200H
   163                              <1> FDC_MSR         equ     FDC
   164                              <1> FDC_DATA        equ     FDC_MSR+1
   165                              <1> FDC_DACK        equ	FDC+10H
   166                              <1> FDC_LDOR	equ	FDC+20H
   167                              <1> FDC_LDCR	equ	FDC+30H
   168                              <1> FDC_TC	        equ	FDC+40H
   169                              <1> FDC_DACK_TC     equ     FDC_DACK | FDC_TC
   170                              <1> 
   171                              <1> 
   172                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   173                              <1> ;DS1302 RTC
   174                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   175                              <1> RTC	equ	IO_BASE+0300H
   176                              <1> 
   177                              <1> 
   178                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   179                              <1> ; PIO 82C55 I/O 
   180                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   181                              <1> PPI	        equ	IO_BASE+0260H
   182                              <1> PIO_A	        equ	PPI+0	; (OUTPUT)
   183                              <1> PIO_B	        equ	PPI+1	; (INPUT)
   184                              <1> PIO_C	        equ	PPI+2	; (CENTRONICS control low nibble)  
   185                              <1> PIO_CTRL	equ	PPI+3	; CONTROL BYTE PIO 82C55
   186                              <1> 
   187                              <1> portA           equ     PPI+0   ;
   188                              <1> portB           equ     PPI+1   ;     LITES uses this for output
   189                              <1> portC           equ     PPI+2   ;
   190                              <1> 
   191                              <1> 
   192                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   193                              <1> ; Dual [DMA] IDE devices
   194                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   195                              <1> DIDE		equ	IO_BASE + 20H	; range 0x20..0x3F
   196                              <1> 
   197                              <1> DIDE0		equ	DIDE		; first interface (master & slave)
   198                              <1> DIDE1		equ	DIDE+10h	; second interface (master & slave)
   199                              <1> 
   200                              <1> 
   201                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   202                              <1> ; Cassette I/O
   203                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   204                              <1> cuart_base	EQU 	IO_BASE+80H	; BASE IO ADDRESS OF CASSETTE UART
   205                              <1> cuart_rbr	equ     cuart_base	;Rcvr Buffer / read only
   206                              <1> cuart_thr	equ     cuart_base	;Transmit Holding / write only
   207                              <1> cuart_ier	equ     cuart_base+1	;Interrupt Enable
   208                              <1> cuart_iir	equ     cuart_base+2	;Interrupt Ident / read only
   209                              <1> cuart_fcr	equ     cuart_base+2	;FIFO Control / write only
   210                              <1> cuart_lcr	equ     cuart_base+3	;Line Control
   211                              <1> cuart_mcr	equ     cuart_base+4	;Modem Control
   212                              <1> cuart_lsr	equ     cuart_base+5	;Line Status
   213                              <1> cuart_msr	equ     cuart_base+6	;Modem Status
   214                              <1> cuart_sr	equ	cuart_base+7	;Scratch
   215                              <1> 
   216                              <1> cuart_dll	equ     cuart_base	;Divisor Latch LS Byte
   217                              <1> cuart_dlm	equ	cuart_base+1	;Divisor Latch MS Byte
   218                              <1> 
   219                              <1> 
   220                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   221                              <1> ;
   222                              <1> ;       4MEM control registers
   223                              <1> ;
   224                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   225                              <1> EMM_addr        equ     1               ; high 6 bits of 20-bit address
   226                              <1> EMM_page        equ     0               ; 4MEM page in [0..254]
   227                              <1> 
   228                              <1> EMM_BASE        equ     IO_BASE + 000h          ; first EMM (4MEM) board
   229                              <1> EMM_unmapped    equ     255             ; unmapped 4MEM page
   230                              <1> 
   231                              <1> EMM0            equ     EMM_BASE        ; first  EMM board
   232                              <1> EMM1            equ     EMM0 + 2        ; second EMM board
   233                              <1> EMM2            equ     EMM1 + 2        ; third  EMM board
   234                              <1> EMM3            equ     EMM2 + 2        ; fourth EMM board
   235                              <1> 
   236                              <1> 
   237                              <1> 
   238                              <1> 
   239                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   240                              <1> ;
   241                              <1> ;	ColorVDU devices
   242                              <1> ;
   243                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   244                              <1> ;
   245                              <1> ;	major select on the Z80 bus
   246                              <1> ;
   247                              <1> devCVDU_8bit	equ	0xE0		; this may change to 0x10
   248                              <1> 
   249                              <1> devCVDUbase 	equ	IO_BASE + devCVDU_8bit
   250                              <1> 
   251                              <1> M8563status	equ	devCVDUbase + 4		; 4 == bitrev(2)
   252                              <1> M8563register	equ	devCVDUbase + 4
   253                              <1> M8563data	equ	devCVDUbase + 12	; 12 == bitrev(3)
   254                              <1> 
   255                              <1> %if CVDU_8563
   256                              <1> I8242status	equ	devCVDUbase + 10	; 10 == bitrev(5)
   257                              <1> I8242command	equ	devCVDUbase + 10
   258                              <1> I8242data	equ	devCVDUbase + 2		; 2 == bitrev(4)
   259                              <1> %endif
   260                              <1> 
   261                              <1> 
   262                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   263                              <1> ;
   264                              <1> ;	VGA3 devices
   265                              <1> ;
   266                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   267                              <1> ;
   268                              <1> ;	major select on the Z80 bus
   269                              <1> ;
   270                              <1> devVGA3_8bit    equ     0xE0                    ; same as CVDU
   271                              <1> 
   272                              <1> devVGA3base       equ     IO_BASE + devVGA3_8bit
   273                              <1> 
   274                              <1> %if VGA3_6445
   275                              <1> I8242status	equ	devVGA3base + 1
   276                              <1> I8242command	equ	devVGA3base + 1
   277                              <1> I8242data	equ	devVGA3base + 0
   278                              <1> %endif
   279                              <1> HD6445addr	equ	devVGA3base + 2		; to address the HD6445 registers
   280                              <1> HD6445reg	equ	devVGA3base + 3		; to r/w a register on the CRTC
   281                              <1> 
   282                              <1> vga3cfg		equ	devVGA3base + 4
   283                              <1> ; the following are probably not used on the SBC-188, except for testing/checking
   284                              <1> vga3adhi	equ	devVGA3base + 5
   285                              <1> vga3adlo	equ	devVGA3base + 6
   286                              <1> vga3data	equ	devVGA3base + 7
   287                              <1> 
   288                              <1> 
   289                              <1> 
   290                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   291                              <1> ;
   292                              <1> ;	Front Panel devices
   293                              <1> ;
   294                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   295                              <1> ;
   296                              <1> ; Front Panel 82C55 I/O 
   297                              <1> FPPPI	        equ	IO_BASE+0A0H
   298                              <1> FPPORTA         equ     FPPPI+0   	;
   299                              <1> FPPORTB         equ     FPPPI+1   	;    
   300                              <1> FPPORTC         equ     FPPPI+2   	;
   301                              <1> FPPIOCONT       equ     FPPPI+3   	;
   302                              <1> 
   303                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   304                              <1> ; debug port -- JRC only
   305                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   306                              <1> portD		equ	IO_BASE + 0FFh		; 0x04FF
   307                              <1> ;portD		equ	portB		     ; older 8255 output on PPI
   308                              <1> 
   309                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   310                              <1> ;
   311                              <1> ; some useful macros:
   312                              <1> ;
   313                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   314                              <1> ;
   315                              <1> 
   316                              <1> %imacro setloc  1.nolist
   317                              <1>  times   (%1-($-$$)) db 0FFh
   318                              <1> %endm
   319                              <1> 
   320                              <1> %imacro db_lo   1
   321                              <1>  db (%1)&255
   322                              <1> %endm
   323                              <1> 
   324                              <1> %imacro cnop    0.nolist
   325                              <1> %if SOFT_DEBUG
   326                              <1>         nop
   327                              <1> %endif
   328                              <1> %endm
   329                              <1> 
   330                              <1> %imacro popm 1-*.nolist
   331                              <1> %rep %0
   332                              <1> %ifidni %1,ALL
   333                              <1>  popa
   334                              <1> %elifidni %1,F
   335                              <1>  popf
   336                              <1> %else
   337                              <1>  pop %1
   338                              <1> %ifidni %1,DS
   339                              <1>  cnop
   340                              <1> %elifidni %1,ES
   341                              <1>  cnop
   342                              <1> %endif
   343                              <1> %endif
   344                              <1> %rotate 1
   345                              <1> %endrep
   346                              <1> %endm
   347                              <1> 
   348                              <1> %imacro pushm 1-*.nolist
   349                              <1> %rep %0
   350                              <1> %rotate -1
   351                              <1> %ifidni %1,ALL
   352                              <1>  pusha
   353                              <1> %elifidni %1,F
   354                              <1>  pushf
   355                              <1> %else
   356                              <1>  push %1
   357                              <1> %endif
   358                              <1> %endrep
   359                              <1> %endm
   360                              <1> 
   361                              <1> ; end CPUREGS.ASM
   362                              <1> 
    35                                  
    36                                  FRAME0          equ     (0F000h - (ROM<<6))          ; default Frame segment
    37                                  NUM_HANDLES     equ     16      ; number of Handles
    38                                  HANDLE_BASE     equ     3456h   ; base handle #
    39                                  NUM_MAP_BLKS    equ     32      ; number of memory manager blocks
    40                                  
    41                                  
    42                                  ;
    43                                  ;
    44                                  ; The request block structure
    45                                                  struc   rq_block
    46 00000000 <res 00000001>          rq_length       resb    1       ; length of request block
    47 00000001 <res 00000001>          rq_unit         resb    1       ; unit number (block devices)
    48 00000002 <res 00000001>          rq_command      resb    1       ; command code
    49 00000003 <res 00000002>          rq_status       resw    1       ; return status
    50 00000005 <res 00000008>          rq_reserved05   resb    8       ; reserved for DOS
    51 0000000D <res 00000001>          rq_ret_units    resb    1       ; number of units (returned)
    52 0000000E <res 00000004>          rq_ret_freemem  resd    1       ; seg:offset of top of free memory
    53 00000012 <res 00000004>          rq_config_sys   resd    1       ; seg:offset of CONFIG.SYS
    54                                  rq_ret_BPB      equ     rq_config_sys
    55 00000016 <res 00000001>          rq_first_unit   resb    1       ; first unit number
    56 00000017 <res 00000009>          rq_reserved17   resb    9       ; fill to 32 bytes
    57                                                  endstruc
    58                                  
    59                                  
    60                                  ; The EMM map structure
    61                                                  struc   emm_map
    62 00000000 <res 00000001>          map_count       resb    1       ; count of contiguous blocks
    63 00000001 <res 00000001>          map_start       resb    1       ; block number of first block
    64 00000002 <res 00000002>          map_link        resw    1       ; index of next block in chain (FFFF=end)
    65                                  map_board       equ     map_link+1      ; high 4 bits contain board #
    66                                  map_length      equ     $
    67                                                  endstruc
    68                                  
    69                                  
    70                                  
    71                                  DONE    equ     0100h           ; DONE bit
    72                                  CR      equ     0Dh
    73                                  LF      equ     0Ah
    74                                  NUL     equ     00h
    75                                  
    76                                  
    77                                  ; Standard int 13h stack frame layout is 
    78                                  ; created by:   PUSHM  ALL,DS,ES
    79                                  ;               MOV    BP,SP
    80                                  ;
    81                                  offset_DI       equ     0
    82                                  offset_SI       equ     offset_DI+2
    83                                  offset_BP       equ     offset_SI+2
    84                                  offset_SP       equ     offset_BP+2
    85                                  offset_BX       equ     offset_SP+2
    86                                  offset_DX       equ     offset_BX+2
    87                                  offset_CX       equ     offset_DX+2
    88                                  offset_AX       equ     offset_CX+2
    89                                  offset_DS       equ     offset_AX+2
    90                                  offset_ES       equ     offset_DS+2
    91                                  offset_IP       equ     offset_ES+2
    92                                  offset_CS       equ     offset_IP+2
    93                                  offset_FLAGS    equ     offset_CS+2
    94                                  
    95                                  ; The byte registers in the stack
    96                                  offset_AL       equ     offset_AX
    97                                  offset_AH       equ     offset_AX+1
    98                                  offset_BL       equ     offset_BX
    99                                  offset_BH       equ     offset_BX+1
   100                                  offset_CL       equ     offset_CX
   101                                  offset_CH       equ     offset_CX+1
   102                                  offset_DL       equ     offset_DX
   103                                  offset_DH       equ     offset_DX+1
   104                                  
   105                                  
   106                                  ; EMS int 67h error codes
   107                                  ;
   108                                  FN_GOOD         equ     0
   109                                  
   110                                  FN_INTERNAL_ERR equ     80h     ; internal software error
   111                                  FN_HARDWARE_ERR equ     81h     ; EMS hardware error
   112                                  FN_INVALID_HANDLE  equ  83h     ; invalid handle
   113                                  FN_UNDEFINED    equ     84h     ; undefined function
   114                                  FN_NO_HANDLE    equ     85h     ; no more handles available
   115                                  FN_SAVE_RESTORE equ     86h     ; error in save or restore of mapping context
   116                                  FN_NO_PHYS_PAGES   equ  87h     ; requested more physical pages than available; none allocated
   117                                  FN_NO_LOG_PAGES equ     88h     ; requested more logical pages than available; none allocated
   118                                  FN_ZERO_REQUEST equ     89h     ; zero pages requested
   119                                  FN_LOG_PAGE_ERR equ     8Ah     ; logical page not assigned to this handle
   120                                  FN_PHYS_PAGE_ERR   equ  8Bh     ; physical page number invalid
   121                                  FN_SAVE_AREA_FULL  equ  8Ch     ; mapping hardware state save area full
   122                                  FN_SAVE_FAILED  equ     8Dh     ; save context failed because context already associated with
   123                                                                  ;  the current handle
   124                                  FN_RESTORE      equ     8Eh     ; restore failed; save area has no context for the handle
   125                                  FN_SUBFN_UNDEF  equ     8Fh     ; sub-function undefined
   126                                  
   127                                  
   128                                  
   129                                  
   130                                  
   131                                  ; beginning of Driver
   132                                  
   133                                  ; The driver Header:
   134 00000000 FFFFFFFF                        dd      -1
   135 00000004 0080                            dw      8000h                   ; flag as character device
   136 00000006 [1A04]                          dw      strategy
   137 00000008 [2504]                          dw      interrupt
   138 0000000A 454D4D5858585830                db      "EMMXXXX0"
   139                                  
   140                                  
   141                                  dispatch:
   142 00000012 [5400]                          dw      fn40    ; Get Manager Status
   143 00000014 [5F00]                          dw      fn41    ; Get Page Frame Segment
   144 00000016 [6800]                          dw      fn42    ; Get Number of Pages
   145 00000018 [7600]                          dw      fn43    ; Get Handle and Allocate Memory
   146 0000001A [2901]                          dw      fn44    ; Map Memory
   147 0000001C [C501]                          dw      fn45    ; Release Handle and Memory
   148 0000001E [1702]                          dw      fn46    ; Get EMM Version
   149 00000020 [1E02]                          dw      fn47    ; Save Mapping Context
   150 00000022 [3502]                          dw      fn48    ; Restore Mapping Context
   151 00000024 [5000]                          dw      fn49    ; reserved -- old get h/w array
   152 00000026 [5000]                          dw      fn4A    ; reserved -- old get log. to phys. array map
   153 00000028 [9102]                          dw      fn4B    ; Get Number of EMS Handles
   154 0000002A [5000]                          dw      fn4C    ; Get Pages Owned by Handle
   155 0000002C [5000]                          dw      fn4D    ; Get Pages for All Handles
   156 0000002E [AB02]                          dw      fn4E    ; Get/Set Page Map
   157                                  
   158                                  ndispatch       equ     ($-dispatch)/2
   159                                  
   160                                  
   161                                  
   162                                  bios_call_67h:
   163                                  ;       sti                     ; interrupts on/off        
   164                                  %if TRACE
   165                                          pushm   all,ds,es
   166                                          mov     al,'c'
   167                                          call    putchar
   168                                          mov     al,ah
   169                                          call    bout
   170                                          popm    all,ds,es
   171                                  %endif
   172 00000030 061E60                          pushm   all,ds,es
   173 00000033 89E5                            mov     bp,sp           ; standard BIOS stack frame
   174 00000035 FC                              cld
   175 00000036 0E                              pushm   cs
   176 00000037 1F                              popm    ds              ; address the Data Base from
   177                                  
   178 00000038 89C6                            mov     si,ax           ; save AX
   179 0000003A 80EC40                          sub     ah,40h          ; base function codes at zero
   180 0000003D 80FC0F                          cmp     ah,ndispatch    ; check for valid code
   181 00000040 730E                            jae     undefined
   182                                  
   183 00000042 88E0                            mov     al,ah           ; zero based index to AL
   184 00000044 98                              cbw                     ; zap high byte
   185 00000045 96                              xchg    si,ax           ; restore AX, SI is index
   186 00000046 01F6                            add     si,si           ; index*2 for word table
   187 00000048 FFA4[1200]                      jmp     [dispatch + si] ; dispatch to function
   188                                  
   189                                  
   190                                  
   191                                  internal_error:
   192 0000004C B480                            mov     ah,FN_INTERNAL_ERR      ; internal software error
   193 0000004E EB06                            jmp     error_exit
   194                                  undefined:
   195 00000050 B484                            mov     ah,FN_UNDEFINED         ; undefined function
   196 00000052 EB02                            jmp     error_exit
   197                                  good_exit:
   198 00000054 30E4                            xor     ah,ah
   199                                  error_exit:
   200 00000056 88660F                          mov     [bp+offset_AH],ah       ; return error code
   201                                  %if TRACE
   202                                          pushm   ax
   203                                          mov     al,ah
   204                                          call    bout
   205                                          mov     al,'r'
   206                                          call    putchar
   207                                          popm    ax
   208                                  %endif
   209 00000059 89EC                            mov     sp,bp                   ; restore SP
   210 0000005B 611F07                          popm    all,ds,es
   211 0000005E CF                              iret
   212                                  
   213                                  
   214                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   215                                  ; function 40h -- Get EMM Manager Status
   216                                  ;
   217                                  ;  Enter With:
   218                                  ;       AH = function code 40h
   219                                  ;
   220                                  ;  Exit With:
   221                                  ;       AH = 0          good return
   222                                  ;;
   223                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   224                                  fn40    equ     good_exit
   225                                  
   226                                  
   227                                  
   228                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   229                                  ; function 41h -- Get Page Frame Segment
   230                                  ;
   231                                  ;  Enter With:
   232                                  ;       AH = function code 41h
   233                                  ;
   234                                  ;  Exit With:
   235                                  ;       AH = 0          good return
   236                                  ;;
   237                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   238                                  fn41:
   239 0000005F 8B1E[D802]                      mov     bx,[frame]
   240 00000063 895E08                          mov     [bp+offset_BX],bx
   241 00000066 EBEC                            jmp     good_exit
   242                                  
   243                                  
   244                                  
   245                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   246                                  ; function 42h -- Get Number of Pages
   247                                  ;
   248                                  ;  Enter With:
   249                                  ;       AH = function code 42h
   250                                  ;
   251                                  ;  Exit With:
   252                                  ;       AH = 0          good return
   253                                  ;       BX = number of unallocated pages
   254                                  ;       DX = total number of pages in system
   255                                  ;
   256                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   257                                  fn42:
   258 00000068 A1[6403]                        mov     ax,[npages]
   259 0000006B 89460A                          mov     [bp+offset_DX],ax
   260 0000006E E8D503                          call    count_avail
   261 00000071 894608                          mov     [bp+offset_BX],ax
   262 00000074 EBDE                            jmp     good_exit
   263                                  
   264                                  
   265                                  
   266                                  
   267                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   268                                  ; function 43h -- Get Handle and Allocate Memory
   269                                  ;
   270                                  ;  Enter With:
   271                                  ;       AH = function code 43h
   272                                  ;       BX = number of logical pages to allocate
   273                                  ;
   274                                  ;  Exit With:
   275                                  ;       AH = 0          good return
   276                                  ;       DX = handle     
   277                                  ;
   278                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   279                                  fn43:
   280 00000076 3B1E[6403]                      cmp     bx,[npages]     ; check against total pages
   281 0000007A B487                            mov     ah,FN_NO_PHYS_PAGES     ; 
   282 0000007C 77D8                            ja      error_exit      ; RQ more that physically present
   283                                  
   284 0000007E E8C503                          call    count_avail     ; count pages available
   285 00000081 39D8                            cmp     ax,bx
   286 00000083 B488                            mov     ah,FN_NO_LOG_PAGES
   287 00000085 72CF                            jb      error_exit      ; RQ more that currently available
   288                                          
   289 00000087 09DB                            or      bx,bx
   290 00000089 B489                            mov     ah,FN_ZERO_REQUEST
   291 0000008B 74C9                            jz      error_exit      ; RQ zero pages ????
   292                                  
   293                                  ; find a handle
   294 0000008D B91000                          mov     cx,NUM_HANDLES
   295 00000090 31F6                            xor     si,si
   296                                  .1:
   297 00000092 83BC[7203]FF            	cmp	word [handle_list + si], -1
   298 00000097 7409                    	je	.2			; available if == -1
   299                                  
   300 00000099 83C602                          add     si,size_handle
   301 0000009C E2F4                            loop    .1
   302                                  ; error, no handles are available
   303 0000009E B485                            mov     ah,FN_NO_HANDLE
   304 000000A0 EBB4                            jmp     error_exit
   305                                  
   306                                  .2: ; found an available handle; index*2 is in SI
   307 000000A2 89F7                            mov     di,si                   ; zap the save area
   308 000000A4 C1E702                          shl     di,2                    ; index*8 is in DI
   309 000000A7 8DBD[9A03]                      lea     di,[handle_save_area + di]      ; prepare to zap the save area
   310 000000AB B8FFFF                          mov     ax,-1                   ; empty value for save area
   311 000000AE 1E                              pushm   ds
   312 000000AF 07                              popm    es              ; will use ES:DI for the save area pointer
   313 000000B0 AB                              stosw
   314 000000B1 AB                              stosw                   ; clear 4 words
   315 000000B2 AB                              stosw
   316 000000B3 AB                              stosw
   317                                  
   318                                  ;  index*2 is still in SI
   319 000000B4 89F0                            mov     ax,si                   ; index*2 in AX
   320 000000B6 D1E8                            shr     ax,1                    ; index*1 of handle
   321 000000B8 055634                          add     ax,HANDLE_BASE          ; make the funny Handle
   322 000000BB 89460A                          mov     [bp+offset_DX],ax       ; return handle
   323                                  
   324 000000BE FF0E[7003]                      dec     word [handle_count]     ; count the handle
   325                                  
   326                                      ; allocate any memory loop
   327                                  allocate_more:
   328 000000C2 09DB                            or      bx,bx
   329 000000C4 748E                            jz      good_exit
   330                                  
   331 000000C6 8B3E[DC02]                      mov     di,[map_avail]          ; get index of available memory
   332 000000CA 81E7FF0F                        and     di,0FFFh
   333 000000CE C1E702                          shl     di,2                    ; index*4
   334 000000D1 8A85[DE02]                      mov     al,[map_block_list + di + map_count]
   335 000000D5 30E4                            xor     ah,ah
   336 000000D7 39D8                            cmp     ax,bx                   ; in block :: request remaining
   337 000000D9 7204                            jb      .4
   338 000000DB 89D9                            mov     cx,bx
   339 000000DD EB02                            jmp     .41
   340 000000DF 89C1                    .4:     mov     cx,ax
   341                                  .41:            ;               ; CX is the smaller of the two
   342 000000E1 29CB                            sub     bx,cx		; BX is what remains to be allocated (or 0)
   343 000000E3 29C8                            sub     ax,cx           ; AX is remainder on avail list
   344 000000E5 8AAD[DF02]                      mov     ch,[map_block_list + di + map_start]
   345 000000E9 8B95[E002]                      mov     dx,[map_block_list + di + map_link]
   346 000000ED 741B                            jz      got_it_all
   347                                  ; avail list entry has some memory remaining
   348 000000EF 008D[DF02]                      add     [map_block_list + di + map_start],cl    ; increment start by count
   349 000000F3 8885[DE02]                      mov     [map_block_list + di + map_count],al    ; remaining count
   350                                  ; CH:CL is memory to put on the Handle's chain
   351 000000F7 8BBC[7203]                      mov     di,[handle_list + si]
   352 000000FB E8A903                          call    add_to_list2     ; DH was set above, CX is good
   353 000000FE 83FFFF                          cmp     di,-1
   354 00000101 7404                            je      .5
   355 00000103 89BC[7203]                      mov     [handle_list + si],di
   356                                  .5:
   357 00000107 E94AFF                          jmp     good_exit
   358                                  
   359                                  ; all of the memory in the block at the head of the avail list is needed
   360                                  got_it_all:
   361 0000010A 80E60F                          and     dh,0Fh
   362 0000010D 8916[DC02]                      mov     [map_avail],dx          ; new head of the avail list
   363                                  ; DI is index*4 of the allocated memory piece
   364 00000111 8B84[7203]                      mov     ax,[handle_list + si]
   365 00000115 3385[E002]                      xor     ax,[map_block_list + di + map_link]
   366 00000119 25FF0F                          and     ax,0FFFh
   367 0000011C 3185[E002]                      xor     [map_block_list + di + map_link],ax ; link DI at head of chain
   368 00000120 C1EF02                          shr     di,2
   369 00000123 89BC[7203]                      mov     [handle_list + si],di
   370 00000127 EB99                            jmp     allocate_more
   371                                  
   372                                  
   373                                  
   374                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   375                                  ; function 44h -- Map Memory
   376                                  ;
   377                                  ;  Enter With:
   378                                  ;       AH = function code 44h
   379                                  ;       AL = physical page [0..3]
   380                                  ;       BX = logical page number:  0...
   381                                  ;       DX = handle
   382                                  ;
   383                                  ;  Exit With:
   384                                  ;       AH = 0          good return
   385                                  ;
   386                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   387                                  fn44:
   388 00000129 B48B                            mov     ah,FN_PHYS_PAGE_ERR
   389 0000012B 3C04                            cmp     al,4
   390 0000012D 7203E924FF                      jae     error_exit
   391                                  
   392 00000132 E84500                          call    unmap           ; use AL as page to unmap
   393                                  
   394 00000135 B483                            mov     ah,FN_INVALID_HANDLE
   395 00000137 81EA5634                        sub     dx,HANDLE_BASE          ; unbias the handle
   396 0000013B 83FA10                          cmp     dx,NUM_HANDLES
   397 0000013E 7203E913FF                      jae     error_exit
   398                                  
   399 00000143 89D6                            mov     si,dx           ; SI is the unbiased handle index
   400 00000145 01F6                            add     si,si           ; 
   401 00000147 8BBC[7203]                      mov     di,[handle_list + si]   ; get memory chain index
   402                                  
   403                                  .1:                     ; validate that the chain continues
   404 0000014B C1E704                          shl     di,4
   405 0000014E 7903E903FF                      js      error_exit
   406                                  
   407 00000153 B48A                            mov     ah,FN_LOG_PAGE_ERR    ; logical page not assigned to this handle
   408 00000155 C1EF02                          shr     di,2            ; DI is index*4 into the map_block_list
   409                                  
   410 00000158 8A8D[DE02]                      mov     cl,[map_block_list + di + map_count]
   411 0000015C 30ED                            xor     ch,ch
   412 0000015E 39CB                            cmp     bx,cx           ; compare count to length of chain
   413 00000160 7208                            jb      .4              ; less than, good map
   414                                  
   415 00000162 29CB                            sub     bx,cx           ; BX is remaining count
   416 00000164 8BBD[E002]                      mov     di,[map_block_list + di + map_link]     ; get link index
   417 00000168 EBE1                            jmp     .1
   418                                  
   419                                  .4:                     ; BL is displacement into page chain
   420 0000016A 8AB5[E102]                      mov     dh,[map_block_list + di + map_board]
   421 0000016E 029D[DF02]                      add     bl,[map_block_list + di + map_start]    ; form logical page #
   422 00000172 88DC                            mov     ah,bl
   423                                  
   424 00000174 E82600                          call    remap           ; DH is set; AL is phys page# 0..3
   425                                                                  ; AH is logical page  (HW page)
   426 00000177 E9DAFE                          jmp     good_exit
   427                                  
   428                                  
   429                                  ; Unmap the present page in physical page in AL
   430                                  ;
   431                                  unmap:
   432 0000017A 525350                          pushm   ax,bx,dx
   433 0000017D 8B16[D802]                      mov     dx,[frame]      ; form the block # in DL
   434 00000181 C1EA0A                          shr     dx,10
   435 00000184 00C2                            add     dl,al           ; DL is physical page
   436 00000186 89C3                            mov     bx,ax
   437 00000188 30FF                            xor     bh,bh           ; BX in index into the map
   438 0000018A 01DB                            add     bx,bx           ; index*2
   439 0000018C 8AB7[9303]                      mov     dh,[map + bx + 1]   ; get the physical board
   440 00000190 B0FF                            mov     al,255          ; make it invalid
   441 00000192 8887[9203]                      mov     [map + bx],al
   442 00000196 E8CE02                          call    put
   443 00000199 585B5A                          popm    ax,bx,dx
   444 0000019C C3                              ret
   445                                  
   446                                  
   447                                  ; Set and record the map
   448                                  ;       AH = hardware page # 0..254
   449                                  ;       AL = physical slot # 0..3
   450                                  ;       DH = board number in high 4 bits
   451                                  ;
   452                                  remap:
   453 0000019D 525350                          pushm   ax,bx,dx
   454 000001A0 8B1E[D802]                      mov     bx,[frame]
   455 000001A4 C1EB0A                          shr     bx,10           ; get board address reg. value
   456 000001A7 88DA                            mov     dl,bl
   457 000001A9 00C2                            add     dl,al           ; offset physical 
   458 000001AB 80E6F0                          and     dh,0F0h         ; mask off high 4 bits
   459 000001AE 89C3                            mov     bx,ax
   460 000001B0 30FF                            xor     bh,bh           ; BX is index into map array
   461 000001B2 01DB                            add     bx,bx
   462 000001B4 88E0                            mov     al,ah           ;
   463 000001B6 86C2                            xchg    al,dl
   464 000001B8 8997[9203]                      mov     [map + bx],dx   ; record DH (board#), DL page#(0..254)
   465 000001BC 86C2                            xchg    al,dl
   466 000001BE E8A602                          call    put             ; set the HW regs.
   467 000001C1 585B5A                          popm    ax,bx,dx
   468 000001C4 C3                              ret
   469                                  
   470                                  
   471                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   472                                  ; function 45h -- Release Handle and Memory
   473                                  ;
   474                                  ;  Enter With:
   475                                  ;       AH = function code 45h
   476                                  ;       DX = handle
   477                                  ;
   478                                  ;  Exit With:
   479                                  ;       AH = 0          good return
   480                                  ;
   481                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   482                                  fn45:
   483 000001C5 81EA5634                        sub     dx,HANDLE_BASE          ; unbias the handle
   484 000001C9 B483                            mov     ah,FN_INVALID_HANDLE
   485 000001CB 83FA10                          cmp     dx,NUM_HANDLES          ; validate handle
   486 000001CE 7203E983FE                      jae     error_exit
   487                                  
   488 000001D3 89D6                            mov     si,dx                   ; use SI as handle index
   489 000001D5 01F6                            add     si,si                   ; index*2
   490 000001D7 83BC[7203]FF                    cmp     word [handle_list + si], -1
   491 000001DC 7503E975FE                      je      error_exit              ; unallocated handle
   492                                  
   493 000001E1 89F7                            mov     di,si                   ; save pointer to DI
   494 000001E3 C1E702                          shl     di,2                    ; index*8
   495 000001E6 8DBD[9A03]                      lea     di,[handle_save_area + di]
   496 000001EA B8FFFF                          mov     ax,-1			;;; 01/12/2013 jrc
   497 000001ED 1E                      	pushm	ds			;;;
   498 000001EE 07                      	popm	es			;;; for the STOSW  ES:DI
   499 000001EF AB                              stosw
   500 000001F0 AB                              stosw                           ; clear the save area
   501 000001F1 AB                              stosw
   502 000001F2 AB                              stosw
   503                                  ;                               ; SI is still index*2
   504 000001F3 8784[7203]                      xchg    [handle_list + si],ax   ; clear the handle
   505                                  ;                               ; AX is now the index to the mem_block_list
   506                                  free_the_memory:
   507 000001F7 89C3                            mov     bx,ax           ; use it from BX        index*2
   508 000001F9 C1E004                          shl     ax,4            ; get sign bit
   509 000001FC 7812                            js      .9              ; end of chain
   510                                  ;  the continuation of the chain is in AX
   511                                  
   512 000001FE E89E03                  	call	free_node	; set up CH:CL, DH, with link in DX
   513                                  ; CX is the memory to free, DH has the board number
   514 00000201 89D0                    	mov	ax,dx		; save link (unmasked)
   515                                  
   516 00000203 8B3E[DC02]                      mov     di,[map_avail]
   517 00000207 E89D02                  	call    add_to_list2
   518 0000020A 893E[DC02]              	mov	[map_avail],di
   519                                  
   520 0000020E EBE7                            jmp     free_the_memory         ; loop back with AX
   521                                  
   522                                  .9:
   523 00000210 FF06[7003]                      inc     word [handle_count]     ; count the handle
   524 00000214 E93DFE                          jmp     good_exit
   525                                  
   526                                  
   527                                  
   528                                  
   529                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   530                                  ; function 46h -- Get EMM Version
   531                                  ;
   532                                  ;  Enter With:
   533                                  ;       AH = function code 46h
   534                                  ;
   535                                  ;  Exit With:
   536                                  ;       AH = 0          good return
   537                                  ;       AL = EMM version number in BCD  (this is LIM EMS 3.2)
   538                                  ;
   539                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   540                                  fn46:
   541 00000217 C6460E32                        mov     byte [bp+offset_AL],32h      ; version 3.2
   542 0000021B E936FE                          jmp     good_exit
   543                                  
   544                                  
   545                                  
   546                                  
   547                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   548                                  ; function 47h -- Save Mapping Context
   549                                  ;
   550                                  ;  Enter With:
   551                                  ;       AH = function code 47h
   552                                  ;       DX = handle
   553                                  ;
   554                                  ;  Exit With:
   555                                  ;       AH = 0          good return
   556                                  ;
   557                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   558                                  fn47:
   559 0000021E E83C00                          call    check_handle
   560                                  
   561 00000221 40                              inc     ax                      ; must become zero
   562 00000222 B48D                            mov     ah,FN_SAVE_FAILED
   563 00000224 7403E92DFE                      jnz     error_exit              ; can't do the save
   564                                  
   565 00000229 1E                              pushm   ds
   566 0000022A 07                              popm    es
   567 0000022B BE[9203]                        mov     si,map                  ; source pointer to SI
   568                                  ; DI points at the save area
   569 0000022E A5                              movsw
   570 0000022F A5                              movsw                           ; do the state save
   571 00000230 A5                              movsw
   572 00000231 A5                              movsw
   573                                  
   574 00000232 E91FFE                          jmp     good_exit
   575                                  
   576                                  
   577                                  
   578                                  
   579                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   580                                  ; function 48h -- Restore Mapping Context
   581                                  ;
   582                                  ;  Enter With:
   583                                  ;       AH = function code 48h
   584                                  ;       DX = handle
   585                                  ;
   586                                  ;  Exit With:
   587                                  ;       AH = 0          good return
   588                                  ;
   589                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   590                                  fn48:
   591 00000235 E82500                          call    check_handle
   592                                  
   593 00000238 40                              inc     ax                      ; must become zero
   594 00000239 B48E                            mov     ah,FN_RESTORE
   595 0000023B 7503E916FE                      jz      error_exit              ; can't do the save
   596                                  
   597 00000240 89FE                            mov     si,di                   ; restore save area pointer
   598 00000242 30C0                            xor     al,al
   599                                  .6:
   600 00000244 8B14                            mov     dx,[si]                 ; get context to restore
   601 00000246 C704FFFF                        mov     word [si],-1            ; zap the context
   602 0000024A 46                              inc     si
   603 0000024B 46                              inc     si
   604 0000024C 88D4                            mov     ah,dl                   ; physical page #
   605 0000024E E829FF                          call    unmap           ; uses only AL
   606 00000251 E849FF                          call    remap           ; uses AL,AH,DH
   607 00000254 FEC0                            inc     al
   608 00000256 3C04                            cmp     al,4            ; remap pages 0..3
   609 00000258 72EA                            jb      .6
   610                                  
   611 0000025A E9F7FD                          jmp     good_exit
   612                                  
   613                                  ;
   614                                  ;  Handle check for Save/Restore functions
   615                                  ;       Enter with biased handle in DX
   616                                  ;
   617                                  ;       Exit with And'ed save area contents in AX
   618                                  ;       Save pointer to Save Area is in DI
   619                                  ;
   620                                  check_handle:
   621 0000025D 81EA5634                        sub     dx,HANDLE_BASE          ; unbias the handle
   622 00000261 B483                            mov     ah,FN_INVALID_HANDLE
   623 00000263 83FA10                          cmp     dx,NUM_HANDLES          ; validate handle
   624 00000266 7203E9EBFD                      jae     error_exit
   625                                  
   626 0000026B 89D6                            mov     si,dx                   ; use SI as handle index
   627 0000026D 01F6                            add     si,si                   ; index*2
   628 0000026F BAFFFF                          mov     dx,-1
   629 00000272 3994[7203]                      cmp     [handle_list + si],dx
   630 00000276 7503E9DBFD                      je      error_exit              ; unallocated handle
   631                                  
   632 0000027B C1E603                          shl     si,3                    ; index*8
   633 0000027E 8DB4[9A03]                      lea     si,[handle_save_area + si]
   634 00000282 89F7                            mov     di,si                   ; save pointer to DI
   635                                  %rep 4
   636                                          lodsw                           ; get map word
   637                                          and     dx,ax                   
   638                                  %endrep
   638 00000284 AD                  <1>  lodsw
   638 00000285 21C2                <1>  and dx,ax
   638 00000287 AD                  <1>  lodsw
   638 00000288 21C2                <1>  and dx,ax
   638 0000028A AD                  <1>  lodsw
   638 0000028B 21C2                <1>  and dx,ax
   638 0000028D AD                  <1>  lodsw
   638 0000028E 21C2                <1>  and dx,ax
   639 00000290 C3                              ret
   640                                  
   641                                  
   642                                  
   643                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   644                                  ; function 49h -- Reserved
   645                                  ;
   646                                  ;  Enter With:
   647                                  ;       AH = function code 49h
   648                                  ;
   649                                  ;  Exit With:
   650                                  ;       AH = 84h        undefined function
   651                                  ;
   652                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   653                                  fn49    equ     undefined
   654                                  
   655                                  
   656                                  
   657                                  
   658                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   659                                  ; function 4Ah -- Reserved
   660                                  ;
   661                                  ;  Enter With:
   662                                  ;       AH = function code 4Ah
   663                                  ;
   664                                  ;  Exit With:
   665                                  ;       AH = 84h        undefined function
   666                                  ;
   667                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   668                                  fn4A    equ     undefined
   669                                  
   670                                  
   671                                  
   672                                  
   673                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   674                                  ; function 4Bh -- Get Number of Active EMS Handles
   675                                  ;
   676                                  ;  Enter With:
   677                                  ;       AH = function code 46h
   678                                  ;
   679                                  ;  Exit With:
   680                                  ;       AH = 0          good return
   681                                  ;       BX = number of active Handles (255 is max.)
   682                                  ;               (255 - BX must equal the number of available handles)
   683                                  ;
   684                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   685                                  fn4B:
   686 00000291 B91000                          mov     cx,NUM_HANDLES
   687 00000294 31DB                            xor     bx,bx
   688 00000296 BE[7203]                        mov     si,handle_list
   689                                  .1:
   690 00000299 833CFF                          cmp     word [si+0],-1
   691 0000029C 7401                            je      .2
   692 0000029E 43                              inc     bx
   693 0000029F 8D7402                  .2:     lea     si,[si+size_handle]
   694 000002A2 E2F5                            loop    .1
   695                                  
   696 000002A4 81C3EF00                        add     bx,255-NUM_HANDLES      ; 3.2 allows 255, so fake the count
   697 000002A8 E9A9FD                          jmp     good_exit
   698                                  
   699                                  
   700                                  
   701                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   702                                  ; function 4Ch -- Get Pages Owned by Handle
   703                                  ;
   704                                  ;  Enter With:
   705                                  ;       AH = function code 4Ch
   706                                  ;       DX = handle
   707                                  ;
   708                                  ;  Exit With:
   709                                  ;       AH = 0          good return
   710                                  ;       BX = number of logical pages
   711                                  ;
   712                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   713                                  fn4C    equ     undefined
   714                                  
   715                                  
   716                                  
   717                                  
   718                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   719                                  ; function 4Dh -- Get Pages for All Handles
   720                                  ;
   721                                  ;  Enter With:
   722                                  ;       AH = function code 4Dh
   723                                  ;
   724                                  ;  Exit With:
   725                                  ;       AH = 0          good return
   726                                  ;;
   727                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   728                                  fn4D    equ     undefined
   729                                  
   730                                  
   731                                  
   732                                  
   733                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   734                                  ; function 4Eh -- Get or Set Page Map
   735                                  ;
   736                                  ;  Enter With:
   737                                  ;       AH = function code 4Eh
   738                                  ;       AL = subfunction code
   739                                  ;               00h = get registers into array
   740                                  ;               01h = set registers from array
   741                                  ;               02h = get and set operation
   742                                  ;               03h = return size of page mapping array
   743                                  ;       DS:SI = array pointer from which to set registers
   744                                  ;       ES:DI = pointer to array to receive register information
   745                                  ;
   746                                  ;  Exit With:
   747                                  ;       AH = 0          good return
   748                                  ;       AL = #bytes in page mapping array (subfunction 3)
   749                                  ;
   750                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   751                                  fn4E:
   752 000002AB 8B7602                          mov     si,[bp + offset_SI]     ; restore SI
   753 000002AE E99FFD                          jmp     undefined
   754                                  
   755                                  
   756                                  
   757                                  ; Get the memory pointer to an empty map block from the empty list
   758                                  ;    Return in DI
   759                                  get_empty:
   760 000002B1 50                              pushm   ax
   761 000002B2 8B3E[DA02]                      mov     di,[map_empty]
   762 000002B6 83FFFF                          cmp     di,-1
   763 000002B9 7503E98EFD                      je      internal_error          ; error if no empty map block
   764 000002BE C1E702                          shl     di,2                    ; index into array
   765                                  check map_length-4
   766 000002C1 81C7[DE02]                      add     di,map_block_list
   767 000002C5 8B4502                          mov     ax,[di+map_link]
   768 000002C8 C1E004                          shl     ax,4
   769 000002CB C1F804                          sar     ax,4                    ; 0FFFh becomes -1
   770 000002CE A3[DA02]                        mov     [map_empty],ax          ; new head of empty list
   771 000002D1 C74502FFFF                      mov     word [di+map_link],-1   ; empty block not part of any chain
   772 000002D6 58                              popm    ax
   773 000002D7 C3                              ret                             ; return DI as memory pointer
   774                                  
   775                                  %if 0
   776                                  get_empty_index:
   777                                          call    get_empty
   778                                          sub     di,map_block_list
   779                                          ret
   780                                  %endif
   781                                  
   782                                          align   2
   783                                  ; The frame segment of physical EMM page 0
   784 000002D8 00E8                    frame:  dw      FRAME0          ; this may be modified during initialization
   785                                                                  ; of the driver
   786                                  
   787 000002DA 0000                    map_empty:      dw      0       ; first free map block
   788 000002DC FFFF                    map_avail:      dw      -1      ; first block of available memory
   789                                  
   790                                  
   791                                  ; The list of EMM map blocks
   792                                  %assign xemm 0
   793                                  map_block_list:
   794                                  %rep    NUM_MAP_BLKS-1
   795                                          dw      0,xemm+1
   796                                  %assign xemm (xemm+1)
   797                                  %endrep
   797 000002DE 00000100            <1>  dw 0,xemm+1
   797                              <1> %assign xemm (xemm+1)
   797 000002E2 00000200            <1>  dw 0,xemm+1
   797                              <1> %assign xemm (xemm+1)
   797 000002E6 00000300            <1>  dw 0,xemm+1
   797                              <1> %assign xemm (xemm+1)
   797 000002EA 00000400            <1>  dw 0,xemm+1
   797                              <1> %assign xemm (xemm+1)
   797 000002EE 00000500            <1>  dw 0,xemm+1
   797                              <1> %assign xemm (xemm+1)
   797 000002F2 00000600            <1>  dw 0,xemm+1
   797                              <1> %assign xemm (xemm+1)
   797 000002F6 00000700            <1>  dw 0,xemm+1
   797                              <1> %assign xemm (xemm+1)
   797 000002FA 00000800            <1>  dw 0,xemm+1
   797                              <1> %assign xemm (xemm+1)
   797 000002FE 00000900            <1>  dw 0,xemm+1
   797                              <1> %assign xemm (xemm+1)
   797 00000302 00000A00            <1>  dw 0,xemm+1
   797                              <1> %assign xemm (xemm+1)
   797 00000306 00000B00            <1>  dw 0,xemm+1
   797                              <1> %assign xemm (xemm+1)
   797 0000030A 00000C00            <1>  dw 0,xemm+1
   797                              <1> %assign xemm (xemm+1)
   797 0000030E 00000D00            <1>  dw 0,xemm+1
   797                              <1> %assign xemm (xemm+1)
   797 00000312 00000E00            <1>  dw 0,xemm+1
   797                              <1> %assign xemm (xemm+1)
   797 00000316 00000F00            <1>  dw 0,xemm+1
   797                              <1> %assign xemm (xemm+1)
   797 0000031A 00001000            <1>  dw 0,xemm+1
   797                              <1> %assign xemm (xemm+1)
   797 0000031E 00001100            <1>  dw 0,xemm+1
   797                              <1> %assign xemm (xemm+1)
   797 00000322 00001200            <1>  dw 0,xemm+1
   797                              <1> %assign xemm (xemm+1)
   797 00000326 00001300            <1>  dw 0,xemm+1
   797                              <1> %assign xemm (xemm+1)
   797 0000032A 00001400            <1>  dw 0,xemm+1
   797                              <1> %assign xemm (xemm+1)
   797 0000032E 00001500            <1>  dw 0,xemm+1
   797                              <1> %assign xemm (xemm+1)
   797 00000332 00001600            <1>  dw 0,xemm+1
   797                              <1> %assign xemm (xemm+1)
   797 00000336 00001700            <1>  dw 0,xemm+1
   797                              <1> %assign xemm (xemm+1)
   797 0000033A 00001800            <1>  dw 0,xemm+1
   797                              <1> %assign xemm (xemm+1)
   797 0000033E 00001900            <1>  dw 0,xemm+1
   797                              <1> %assign xemm (xemm+1)
   797 00000342 00001A00            <1>  dw 0,xemm+1
   797                              <1> %assign xemm (xemm+1)
   797 00000346 00001B00            <1>  dw 0,xemm+1
   797                              <1> %assign xemm (xemm+1)
   797 0000034A 00001C00            <1>  dw 0,xemm+1
   797                              <1> %assign xemm (xemm+1)
   797 0000034E 00001D00            <1>  dw 0,xemm+1
   797                              <1> %assign xemm (xemm+1)
   797 00000352 00001E00            <1>  dw 0,xemm+1
   797                              <1> %assign xemm (xemm+1)
   797 00000356 00001F00            <1>  dw 0,xemm+1
   797                              <1> %assign xemm (xemm+1)
   798 0000035A 0000FFFF                        dw      0,-1
   799                                  
   800                                  ; The driver request block pointer
   801                                  request:
   802 0000035E 00000000                        dw      0,0
   803                                  
   804 00000362 0400                    nboards:  dw      EMM_BOARDS
   805 00000364 0000                    npages:   dw      0
   806                                  
   807                                  %assign xemm 0
   808                                  board_dev_list:
   809                                  %rep    EMM_BOARDS
   810                                          dw      EMM0+xemm+EMM_addr
   811                                  %assign xemm (xemm+EMM1-EMM0)
   812                                  %endrep
   812 00000366 0104                <1>  dw EMM0+xemm+EMM_addr
   812                              <1> %assign xemm (xemm+EMM1-EMM0)
   812 00000368 0304                <1>  dw EMM0+xemm+EMM_addr
   812                              <1> %assign xemm (xemm+EMM1-EMM0)
   812 0000036A 0504                <1>  dw EMM0+xemm+EMM_addr
   812                              <1> %assign xemm (xemm+EMM1-EMM0)
   812 0000036C 0704                <1>  dw EMM0+xemm+EMM_addr
   812                              <1> %assign xemm (xemm+EMM1-EMM0)
   813 0000036E FFFF                            dw      -1
   814                                  
   815 00000370 1000                    handle_count:   dw      NUM_HANDLES
   816                                  handle_list:
   817                                  %rep    NUM_HANDLES
   818                                          dw      -1
   819                                  %endrep
   819 00000372 FFFF                <1>  dw -1
   819 00000374 FFFF                <1>  dw -1
   819 00000376 FFFF                <1>  dw -1
   819 00000378 FFFF                <1>  dw -1
   819 0000037A FFFF                <1>  dw -1
   819 0000037C FFFF                <1>  dw -1
   819 0000037E FFFF                <1>  dw -1
   819 00000380 FFFF                <1>  dw -1
   819 00000382 FFFF                <1>  dw -1
   819 00000384 FFFF                <1>  dw -1
   819 00000386 FFFF                <1>  dw -1
   819 00000388 FFFF                <1>  dw -1
   819 0000038A FFFF                <1>  dw -1
   819 0000038C FFFF                <1>  dw -1
   819 0000038E FFFF                <1>  dw -1
   819 00000390 FFFF                <1>  dw -1
   820                                  size_handle     equ     2       ; for now
   821                                  
   822                                  
   823                                  map:    
   824 00000392 FF00                            dw      00FFh   ; hi 4 bits = board number @ frame0
   825 00000394 FF00                            dw      00FFh
   826 00000396 FF00                            dw      00FFh
   827 00000398 FF00                            dw      00FFh
   828                                  size_save_area  equ     $-map
   829                                  
   830                                  handle_save_area:
   831                                  %rep    NUM_HANDLES
   832                                          dw      -1, -1, -1, -1
   833                                  %endrep
   833 0000039A FFFFFFFFFFFFFFFF    <1>  dw -1, -1, -1, -1
   833 000003A2 FFFFFFFFFFFFFFFF    <1>  dw -1, -1, -1, -1
   833 000003AA FFFFFFFFFFFFFFFF    <1>  dw -1, -1, -1, -1
   833 000003B2 FFFFFFFFFFFFFFFF    <1>  dw -1, -1, -1, -1
   833 000003BA FFFFFFFFFFFFFFFF    <1>  dw -1, -1, -1, -1
   833 000003C2 FFFFFFFFFFFFFFFF    <1>  dw -1, -1, -1, -1
   833 000003CA FFFFFFFFFFFFFFFF    <1>  dw -1, -1, -1, -1
   833 000003D2 FFFFFFFFFFFFFFFF    <1>  dw -1, -1, -1, -1
   833 000003DA FFFFFFFFFFFFFFFF    <1>  dw -1, -1, -1, -1
   833 000003E2 FFFFFFFFFFFFFFFF    <1>  dw -1, -1, -1, -1
   833 000003EA FFFFFFFFFFFFFFFF    <1>  dw -1, -1, -1, -1
   833 000003F2 FFFFFFFFFFFFFFFF    <1>  dw -1, -1, -1, -1
   833 000003FA FFFFFFFFFFFFFFFF    <1>  dw -1, -1, -1, -1
   833 00000402 FFFFFFFFFFFFFFFF    <1>  dw -1, -1, -1, -1
   833 0000040A FFFFFFFFFFFFFFFF    <1>  dw -1, -1, -1, -1
   833 00000412 FFFFFFFFFFFFFFFF    <1>  dw -1, -1, -1, -1
   834                                  check $-handle_save_area - NUM_HANDLES*size_save_area
   835                                  
   836                                  strategy:
   837 0000041A 2E891E[5E03]               cs   mov     [request],bx
   838 0000041F 2E8C06[6003]               cs   mov     [request+2],es
   839 00000424 CB                              retf
   840                                  
   841                                  interrupt:
   842 00000425 061E609C                        pushm   f,all,ds,es
   843 00000429 FC                              cld
   844 0000042A 0E                              push    cs
   845 0000042B 1F                              pop     ds
   846 0000042C C41E[5E03]                      les     bx,[request]            ; get request pointer
   847 00000430 26807F0200                  es  cmp     byte [bx+rq_command],0  ; support only "init" command
   848 00000435 7503E9D101                      jz      initialization
   849 0000043A B80C80                          mov     ax,800Ch                ; general error
   850                                  finish:
   851 0000043D 26894703                    es  mov     [bx+rq_status],ax
   852 00000441 9D611F07                        popm    f,all,ds,es
   853 00000445 CB                              retf
   854                                  
   855                                  
   856                                  ; Return the number of available pages by counting the [map_avail] list
   857                                  ;       AX = pages available
   858                                  ;
   859                                  count_avail:
   860 00000446 5153                            pushm   bx,cx
   861 00000448 31C0                            xor     ax,ax           ; clear the result
   862 0000044A 31C9                            xor     cx,cx           ; zero CH
   863 0000044C 8B1E[DC02]                      mov     bx,[map_avail]
   864                                  .1:
   865 00000450 C1E304                          shl     bx,4
   866 00000453 780F                            js      .9
   867 00000455 C1EB02                          shr     bx,2
   868 00000458 8A8F[DE02]                      mov     cl,[map_block_list + bx + map_count]
   869 0000045C 01C8                            add     ax,cx           ; add to the count
   870 0000045E 8B9F[E002]                      mov     bx,[map_block_list + bx + map_link]
   871 00000462 EBEC                            jmp     .1
   872                                  .9:
   873 00000464 5B59                            popm    bx,cx
   874 00000466 C3                              ret
   875                                  
   876                                  
   877                                  
   878                                  ; put
   879                                  ;       DH = board # in hi 4 bits
   880                                  ;       DL = addr [0..3F]
   881                                  ;       AL = page# [0..FE,FF]
   882                                  ;
   883                                  put:
   884 00000467 56                              push    si              ; SI is where we generate the device code
   885 00000468 89D6                            mov     si,dx
   886 0000046A C1EE0C                          shr     si,12           ; SI is board #
   887 0000046D D1E6                            shl     si,1            ; index words
   888 0000046F 8BB4[6603]                      mov     si,[board_dev_list+si]  ; assume DS==CS
   889 00000473 83FEFF                          cmp     si,-1           ; bad device code
   890 00000476 7503E9D1FB                      je      internal_error
   891 0000047B 50                              push    ax              ; save page frame
   892 0000047C 88D0                            mov     al,dl
   893 0000047E 87D6                            xchg    dx,si
   894 00000480 EE                              out     dx,al           ; put out the address
   895 00000481 4A                              dec     dx
   896 00000482 58                              pop     ax
   897 00000483 EE                              out     dx,al
   898 00000484 89F2                            mov     dx,si
   899 00000486 5E                              pop     si
   900 00000487 C3                              ret
   901                                  
   902                                  
   903                                  
   904                                  
   905                                  ; get
   906                                  ;       DH = board # in hi 4 bits
   907                                  ;       DL = addr [0..3F]
   908                                  ;   Returns:
   909                                  ;       AL = page# [0..FE,FF]
   910                                  ;
   911                                  get:
   912 00000488 56                              push    si              ; SI is where we generate the device code
   913 00000489 89D6                            mov     si,dx
   914 0000048B C1EE0C                          shr     si,12           ; SI is board #
   915 0000048E D1E6                            shl     si,1            ; index words
   916 00000490 8BB4[6603]                      mov     si,[board_dev_list+si]  ; assume DS==CS
   917 00000494 83FEFF                          cmp     si,-1           ; bad device code
   918 00000497 7503E9B0FB                      je      internal_error
   919 0000049C 88D0                            mov     al,dl
   920 0000049E 87D6                            xchg    dx,si
   921 000004A0 EE                              out     dx,al           ; put out the address
   922 000004A1 4A                              dec     dx
   923 000004A2 EC                              in      al,dx
   924 000004A3 89F2                            mov     dx,si
   925 000004A5 5E                              pop     si
   926 000004A6 C3                              ret
   927                                  
   928                                  
   929                                  %if 1
   930                                  ; Add a memory chunk (not part of a node) to a list
   931                                  ;   Input:
   932                                  ;	CH:CL	start ; count
   933                                  ;	DH	board number	(in the hi 4 bits)
   934                                  ;	DI	list to scan	(may be null; i.e., 0FFFh)
   935                                  ;   Returns:
   936                                  ;	DI	is new head of list
   937                                  ;
   938                                  ;	AX & BX are preserved
   939                                  ;
   940                                  add_to_list2:
   941 000004A7 5350                    	pushm	ax,bx
   942                                  
   943 000004A9 80E6F0                  	and	dh,0F0h			; mask to board # only
   944 000004AC 81E7FF0F                	and	di,0FFFh		; mask to index only
   945                                  
   946 000004B0 81FFFF0F                	cmp	di,0FFFh		; check for NULL list
   947 000004B4 7503E9B600              	je	.new_list
   948                                  	
   949 000004B9 C1E702                  	shl	di,2			; DI = index*4
   950 000004BC 8AA5[E102]              	mov	ah,[map_block_list + di + map_board]	; get board number
   951 000004C0 80E4F0                  	and	ah,0F0h			; make to only board number
   952 000004C3 38E6                    	cmp	dh,ah			; arg : board on list
   953 000004C5 721E                    	jb	.make_new		; below
   954 000004C7 7435                    	je	.may_combine		; equal board numbers
   955                                  ; above, we fit in list later
   956 000004C9 89FB                    	mov	bx,di			; save index*4 in BX
   957 000004CB 8BBD[E002]              	mov	di,[map_block_list + di + map_link]	; get rest of chain in DI
   958 000004CF E8D5FF                  	call	add_to_list2		; recursively add to the list
   959 000004D2 33BF[E002]              	xor	di,[map_block_list + bx + map_link]	; store DI index only
   960 000004D6 81E7FF0F                	and	di,0FFFh		; **
   961 000004DA 31BF[E002]              	xor	[map_block_list + bx + map_link],di	; **
   962 000004DE C1EB02                  	shr	bx,2			; make index*1
   963 000004E1 89DF                    	mov	di,bx			; return head of list unaltered
   964 000004E3 EB16                    	jmp	.atl_exit		; **
   965                                  
   966                                  .make_new:
   967 000004E5 E88E00                  	call	get_node
   968 000004E8 C1EF02                  	shr	di,2			; DI = index*1
   969 000004EB C1E302                  	shl	bx,2			; BX = index*4
   970 000004EE 21BF[E002]              	and	[map_block_list + bx + map_link],di	; link is FFF, so AND stores link
   971 000004F2 08B7[E102]              	or	[map_block_list + bx + map_board],dh	; board is 0FFF, so OR stores board
   972 000004F6 C1EB02                  	shr	bx,2			; BX = index*1
   973 000004F9 89DF                    	mov	di,bx
   974                                  .atl_exit:
   975 000004FB 585B                    	popm	ax,bx			; return
   976 000004FD C3                      	ret				; new head of list returned
   977                                  
   978                                  ; board numbers are the same
   979                                  ;  CH:CL memory piece may combine with node in DI
   980                                  ;  DI is index*4 of possible combining point
   981                                  .may_combine:
   982 000004FE 8B85[DE02]              	mov	ax,[map_block_list + di + map_count]	; AH:AL is  start : count  of node
   983 00000502 00E0                    	add	al,ah			; AH:AL is  start : end+1  of node
   984 00000504 00E9                    	add	cl,ch			; CH:CL is  start : end+1  of chunk
   985 00000506 38E1                    	cmp	cl,ah			; end chunk <> start node
   986 00000508 724F                    	jb	.before
   987 0000050A 750D                    	jne	.mc2
   988                                  
   989                                  ; end chunk == start node	node grows at the head
   990 0000050C 88EC                    	mov	ah,ch			; start node <-- start chunk
   991                                  ;.mc1:
   992 0000050E 28E0                    	sub	al,ah			; AH:AL is  start : count of node
   993 00000510 8985[DE02]              	mov	[map_block_list + di + map_count],ax	; update the node
   994 00000514 C1EF02                  	shr	di,2			; DI is index*1
   995                                  ;;;	xor	cx,cx			; destroy CX, no mem to return
   996 00000517 EBE2                    	jmp	.atl_exit
   997                                  
   998                                  ; check for combining at the end
   999 00000519 38E8                    .mc2:	cmp	al,ch			; end node <> start chunk
  1000 0000051B 721E                    	jb	.after
  1001 0000051D 7519                    	jne	.mc4
  1002                                  ; end node == start chunk
  1003 0000051F 88C8                    	mov	al,cl			; end node <-- start chunk
  1004                                  ;;;;;	jmp	.mc1
  1005 00000521 28E0                    	sub	al,ah			; AH:AL is  start : count of node
  1006 00000523 8985[DE02]              	mov	[map_block_list + di + map_count],ax	; update the node
  1007 00000527 8B9D[E002]              	mov	bx,[map_block_list + di + map_link]	; get link
  1008 0000052B C1EF02                  	shr	di,2			; DI is index*1
  1009 0000052E 87DF                    	xchg	bx,di			; BX is combined node, DI is end of list
  1010 00000530 E86C00                  	call	free_node		; free up BX; sets DH, CH:CL
  1011 00000533 E871FF                  	call	add_to_list2		; add to the DI list
  1012                                  				; and return the new DI
  1013 00000536 EBC3                    	jmp	.atl_exit
  1014                                  
  1015                                  ; chunk and node did not combine, nor were before or after determined
  1016 00000538 E911FB                  .mc4:	jmp	internal_error
  1017                                  
  1018                                  ; memory chunk fits in after the current node
  1019                                  .after:
  1020 0000053B 28E9                    	sub	cl,ch			; CH:CL  start : count  restored
  1021 0000053D 89FB                    	mov	bx,di			; node pointer to BX  index*4
  1022 0000053F 8BBF[E002]              	mov	di,[map_block_list + bx + map_link]	; node link to DI  index*1
  1023 00000543 E861FF                  	call	add_to_list2
  1024 00000546 33BF[E002]              	xor	di,[map_block_list + bx + map_link]	; store link index*1
  1025 0000054A 81E7FF0F                	and	di,0FFFh				; **
  1026 0000054E 31BF[E002]              	xor	[map_block_list + bx + map_link],di	; **
  1027 00000552 89DF                    	mov	di,bx			; DI <-- BX   == index*4
  1028 00000554 C1EF02                  	shr	di,2			; make index*1
  1029 00000557 EBA2                    	jmp	.atl_exit
  1030                                  
  1031                                  ;memory chunk fits in before the current node
  1032                                  .before:
  1033 00000559 28E9                    	sub	cl,ch			; CH:CL  start : count  restored
  1034 0000055B E81800                  	call	get_node		; allocate and fill in node
  1035 0000055E C1EF02                  	shr	di,2			; make DI index*1
  1036 00000561 C1E302                  	shl	bx,2			; new node index*4
  1037 00000564 21BF[E002]              	and	[map_block_list + bx + map_link],di	; link is 0FFF, so this stores it
  1038 00000568 C1EB02                  	shr	bx,2			; index*1
  1039 0000056B 89DF                    	mov	di,bx			; return new node as head
  1040 0000056D EB8C                    	jmp	.atl_exit
  1041                                  
  1042                                  ; null list, create a list
  1043                                  .new_list:
  1044 0000056F E80400                  	call	get_node		; get a memory node (CH:CL, DH)
  1045 00000572 89DF                    	mov	di,bx			; return new index in DI
  1046 00000574 EB85                    	jmp	.atl_exit
  1047                                  
  1048                                  
  1049                                  ; Get a memory node and fill it in from CH:CL, and DH
  1050                                  ;	return index in BX	(index * 1)
  1051                                  ;
  1052                                  ;	uses AX
  1053                                  ;
  1054                                  get_node:
  1055 00000576 50                      	pushm	ax
  1056                                  
  1057 00000577 8B1E[DA02]              	mov	bx,[map_empty]
  1058 0000057B 83FBFF                  	cmp	bx,-1			; check for none available
  1059 0000057E 7503E9C9FA              	je	internal_error
  1060                                  
  1061 00000583 C1E302                  	shl	bx,2			; make index * 4
  1062 00000586 8B87[E002]              	mov	ax,[map_block_list + bx + map_link]
  1063 0000058A A3[DA02]                	mov	[map_empty],ax		; new head of list
  1064 0000058D 898F[DE02]              	mov	[map_block_list + bx + map_count],cx	; save CH:CL in start : count
  1065 00000591 88F4                    	mov	ah,dh			; board # to AH
  1066 00000593 0DFF0F                  	or	ax,0FFFh		; terminate as a single node
  1067 00000596 8987[E002]              	mov	[map_block_list + bx + map_link],ax
  1068 0000059A C1EB02                  	shr	bx,2			; make BX an index
  1069                                  
  1070 0000059D 58                      	popm	ax
  1071 0000059E C3                      	ret				; AX was destroyed
  1072                                  
  1073                                  
  1074                                  ; Free the memory node indexed by BX
  1075                                  ;   setting CH:CL and DX in the process
  1076                                  ;
  1077                                  free_node:
  1078 0000059F 81E3FF0F                	and	bx,0FFFh		; mask index
  1079 000005A3 C1E302                  	shl	bx,2			; make into  index*4
  1080 000005A6 31C9                    	xor	cx,cx
  1081 000005A8 878F[DE02]              	xchg	cx,[map_block_list + bx + map_count]
  1082 000005AC 8B16[DA02]              	mov	dx,[map_empty]		; get head of empty list
  1083 000005B0 C1E204                  	shl	dx,4
  1084 000005B3 C1FA04                  	sar	dx,4		; mask, but keep -1
  1085 000005B6 8797[E002]              	xchg	dx,[map_block_list + bx + map_link]
  1086 000005BA C1EB02                  	shr	bx,2
  1087 000005BD 891E[DA02]              	mov	[map_empty],bx
  1088 000005C1 C3                      	ret
  1089                                  
  1090                                  
  1091                                  %endif
  1092                                  
  1093                                          align   2                
  1094                                  ;;;***
  1095                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1096                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1097                                  ;  All memory below this point is released after initialization
  1098                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1099                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1100                                  %if TRACE==0
  1101                                  free_below_here:
  1102                                  %endif
  1103                                  ; Add to list
  1104                                  ;   Input:
  1105                                  ;       CH:CL = start page# : number of pages
  1106                                  ;       DH = board number in high 4 bits
  1107                                  ;
  1108                                  ;       DI = index of list to scan in low 12 bits (or -1)
  1109                                  ;
  1110                                  ;    Return:
  1111                                  ;       DI = -1 if no new head of list
  1112                                  ;       DI = index & 0FFFh of new head of list
  1113                                  ;
  1114                                  %if 0
  1115                                  add_to_list:
  1116                                          pushm   ax,bx,cx,dx,si
  1117                                          and     dh,0F0h         ; mask to 4 bits == board #
  1118                                          mov     si,-1           ; former list pointer
  1119                                          add     cl,ch           ; CL = page beyond end
  1120                                  
  1121                                  ;  DI is index in low 12 bits
  1122                                  atl_loop:
  1123                                          cmp     di,-1           ; 
  1124                                          je      new_entry
  1125                                  ; 
  1126                                          and     di,0FFFh
  1127                                          shl     di,2            ; index into array
  1128                                          mov     al,[map_block_list + di + map_board]
  1129                                          and     al,0F0h
  1130                                          cmp     al,dh
  1131                                          ja      new_entry
  1132                                  ;;;        je      atl_compare
  1133                                          jb      atl_next
  1134                                  atl_compare:
  1135                                          mov     ax,[map_block_list + di + map_count]
  1136                                          add     al,ah           ; AL is one beyond end
  1137                                          cmp     ah,cl           ; begin == end
  1138                                          jne     .1
  1139                                  ; tag it at the beginning
  1140                                          mov     ah,ch
  1141                                          jmp     .3
  1142                                  .1:     cmp     al,ch           ; end == begin
  1143                                          jne     atl_next
  1144                                  ; tag it onto the end
  1145                                          mov     al,cl
  1146                                  .3:     ; combining occurred
  1147                                          sub     al,ah           ; AL = new count
  1148                                  %if TRACE
  1149                                          call    wout
  1150                                          call    crlf
  1151                                  %endif
  1152                                          mov     [map_block_list + di + map_count],ax
  1153                                          mov     di,-1
  1154                                          jmp     atl_done
  1155                                  atl_next:
  1156                                          mov     si,di           ; SI = former index*4
  1157                                          mov     di,[map_block_list + di + map_link]
  1158                                          shl     di,4
  1159                                          sar     di,4
  1160                                          jmp     atl_loop
  1161                                  
  1162                                  
  1163                                          mov     ax,[map_block_list + di + map_count]
  1164                                          add     al,ah           ; AL = page beyond end
  1165                                  
  1166                                  ; insert a new entry between SI (lower*4) and DI (higher*4)
  1167                                  new_entry:
  1168                                          mov     bx,di           ; save in BX
  1169                                          call    get_empty
  1170                                          sub     cl,ch           ; CL = count
  1171                                          mov     [di+map_count],cx       ; save count & start
  1172                                          sar     bx,2            ; -1 -> -1  or  index*4 -> index
  1173                                          and     bh,0Fh          ; clear board #
  1174                                          or      bh,dh           ; include board number
  1175                                          mov     [di+map_link],bx
  1176                                          sub     di,map_block_list       ; make into index*4
  1177                                          shr     di,2            ; make index*1
  1178                                          cmp     si,-1
  1179                                          je      .3
  1180                                          xor     di,[map_block_list + si + map_link]
  1181                                          and     di,0FFFh
  1182                                          xor     [map_block_list + si + map_link],di
  1183                                          mov     di,-1           ; list is linked, and no new head
  1184                                  .3:
  1185                                  atl_done:
  1186                                          popm    ax,bx,cx,dx,si
  1187                                          ret
  1188                                  %endif
  1189                                  %if 1
  1190                                  dout:
  1191 000005C2 5250                            pushm   ax,dx
  1192 000005C4 31D2                            xor     dx,dx
  1193 000005C6 F736[D905]                      div     word [dout_ten]
  1194 000005CA 09C0                            or      ax,ax
  1195 000005CC 7403                            jz      .1
  1196 000005CE E8F1FF                          call    dout
  1197 000005D1 89D0                    .1:     mov     ax,dx
  1198 000005D3 E81400                          call    nout
  1199 000005D6 585A                            popm    ax,dx
  1200 000005D8 C3                              ret
  1201 000005D9 0A00                    dout_ten:   dw      10
  1202                                  %endif
  1203                                  wout:
  1204 000005DB 86E0                            xchg    ah,al
  1205 000005DD E80200                          call    bout
  1206 000005E0 86E0                            xchg    ah,al
  1207                                  bout:
  1208 000005E2 50                              push    ax
  1209 000005E3 C1E804                          shr     ax,4
  1210 000005E6 E80100                          call    nout
  1211 000005E9 58                              pop     ax
  1212                                  nout:
  1213 000005EA 50                              push    ax
  1214 000005EB 240F                            and     al,00Fh          ; mask 4bits
  1215 000005ED 27                              daa
  1216 000005EE 04F0                            add     al,0F0h
  1217 000005F0 1440                            adc     al,040h
  1218 000005F2 E80200                          call    putchar
  1219 000005F5 58                              pop     ax
  1220 000005F6 C3                              ret
  1221                                  
  1222                                  putchar:
  1223 000005F7 5250                            pushm   ax,dx
  1224 000005F9 88C2                            mov     dl,al
  1225 000005FB B402                            mov     ah,2
  1226 000005FD CD21                            int     21h
  1227 000005FF 585A                            popm    ax,dx
  1228 00000601 C3                              ret
  1229                                  
  1230                                  crlf:
  1231 00000602 68[C908]                        push    fmt_NL
  1232 00000605 E8C301                          call    fprint
  1233 00000608 44                              inc     sp
  1234 00000609 44                              inc     sp
  1235 0000060A C3                              ret
  1236                                  
  1237                                  %if 0
  1238                                  dot:
  1239                                          pushm   all
  1240                                          mov     al,'.'
  1241                                          call    putchar
  1242                                          popm    all
  1243                                          ret
  1244                                  %endif
  1245                                  
  1246                                  %if TRACE>0
  1247                                  free_below_here:
  1248                                  %endif
  1249                                  initialization:
  1250                                  %if 0
  1251                                          mov     dx,hello
  1252                                          mov     ah,9            ; DOS write string
  1253                                          int     21h
  1254                                  %else
  1255 0000060B 6A00                            push    MINOR_VERSION
  1256 0000060D 6A02                            push    MAJOR_VERSION
  1257 0000060F 68[1508]                        push    fmt1
  1258 00000612 E8B601                          call    fprint
  1259 00000615 83C406                          add     sp,6
  1260                                  %endif
  1261                                  %if TRACE
  1262                                          pushm   ds
  1263                                      es  lds     si,[bx+rq_config_sys]
  1264                                  .1:
  1265                                          lodsb
  1266                                          cmp     al,20h          ; compare to SPACE
  1267                                          jb      .2
  1268                                          call    putchar
  1269                                          jmp     .1
  1270                                  .2:
  1271                                          popm    ds
  1272                                  
  1273                                  %if 0
  1274                                          mov     dx,double_space
  1275                                          mov     ah,9            ; DOS write string
  1276                                          int     21h
  1277                                  %else
  1278                                  	push	double_space
  1279                                  	call	fprint
  1280                                  	pop	ax
  1281                                  %endif
  1282                                  %endif
  1283                                  
  1284                                  ; compute the frame segment from the 18h interrupt vector
  1285                                  
  1286                                  get_frame_segment:
  1287 00000618 1E                      	pushm	ds
  1288 00000619 6A00                    	push	0
  1289 0000061B 1F                      	pop	ds
  1290 0000061C A16200                  	mov	ax,[18h*4+2]	; get BIOS segment
  1291 0000061F 2D0010                  	sub	ax,1000h
  1292 00000622 1F                      	popm	ds	  	; assume DS==CS
  1293 00000623 A3[D802]                	mov	word [frame],ax
  1294                                  
  1295                                  ; find the boards that are present
  1296                                  
  1297                                  prescence_test:
  1298 00000626 B600                            mov     dh,0
  1299 00000628 31F6                            xor     si,si
  1300 0000062A BF[6603]                        mov     di,board_dev_list
  1301                                  .3:
  1302                                  TEST_FRAME      equ     0A000h
  1303                                  TEST_PAGE1      equ     5Ch
  1304                                  TEST_PAGE2      equ     0F0h
  1305 0000062D 833DFF                          cmp     word [di],-1
  1306 00000630 747A                            je      .7
  1307                                  
  1308 00000632 B228                            mov     dl,TEST_FRAME>>10
  1309 00000634 E851FE                          call    get
  1310 00000637 88C1                            mov     cl,al
  1311 00000639 B05C                            mov     al,TEST_PAGE1
  1312 0000063B E829FE                          call    put
  1313                                  
  1314 0000063E FEC2                            inc     dl
  1315 00000640 E845FE                          call    get
  1316 00000643 88C5                            mov     ch,al
  1317 00000645 B0F0                            mov     al,TEST_PAGE2
  1318 00000647 E81DFE                          call    put
  1319                                  
  1320 0000064A FECA                            dec     dl
  1321 0000064C E839FE                          call    get
  1322 0000064F 2C5C                            sub     al,TEST_PAGE1
  1323 00000651 88C4                            mov     ah,al
  1324 00000653 88C8                            mov     al,cl
  1325 00000655 E80FFE                          call    put
  1326                                  
  1327 00000658 FEC2                            inc     dl
  1328 0000065A E82BFE                          call    get
  1329 0000065D 2CF0                            sub     al,TEST_PAGE2
  1330 0000065F 08C4                            or      ah,al
  1331 00000661 88E8                            mov     al,ch
  1332 00000663 E801FE                          call    put
  1333                                  
  1334 00000666 08E4                            or      ah,ah
  1335 00000668 7535                            jnz     .4
  1336                                  
  1337                                  ; Found a board, add all of its pages to the available list
  1338 0000066A E8D300                          call    size_board
  1339 0000066D 726D                            jc      init_error
  1340 0000066F 53                              push    bx
  1341 00000670 89C3                            mov     bx,ax
  1342                                  
  1343 00000672 81C3[DE02]                      add     bx,map_block_list       ; make into actual pointer
  1344                                  %if TRACE
  1345                                          call    crlf
  1346                                          mov     ax,[bx+map_count]
  1347                                          call    wout
  1348                                          call    crlf
  1349                                  %endif
  1350                                  
  1351 00000676 8A07                            mov     al,[bx+map_count]
  1352 00000678 30E4                            xor     ah,ah
  1353 0000067A 50                              push    ax
  1354 0000067B 8A4703                          mov     al,[bx+map_board]
  1355 0000067E C1E804                          shr     ax,4
  1356 00000681 50                              push    ax
  1357 00000682 68[9B08]                        push    fmt2
  1358 00000685 E84301                          call    fprint
  1359 00000688 83C406                          add     sp,6
  1360                                  
  1361 0000068B E85E00                          call    reduce_board            ; nop if not board 0
  1362                                  
  1363 0000068E 8A07                            mov     al,[bx+map_count]
  1364 00000690 30E4                            xor     ah,ah
  1365 00000692 50                              push    ax
  1366 00000693 68[BD08]                        push    fmt2a
  1367 00000696 E83201                          call    fprint
  1368 00000699 83C404                          add     sp,4
  1369                                  
  1370                                  %if TRACE
  1371                                          call    crlf
  1372                                          mov     ax,[bx+map_count]
  1373                                          call    wout
  1374                                          call    crlf
  1375                                  %endif
  1376                                  
  1377 0000069C 5B                              pop     bx
  1378 0000069D EB05                            jmp     .5
  1379                                  
  1380                                  .4:   ; failure to match
  1381 0000069F 4E                              dec     si              ; undo the inc. below
  1382 000006A0 C705FFFF                        mov     word [di],-1    ; wipe out the device code
  1383                                  .5: 
  1384 000006A4 46                              inc     si              ; count board prescence
  1385 000006A5 47                              inc     di              ; update pointer
  1386 000006A6 47                              inc     di
  1387 000006A7 80C610                          add     dh,10h          ; increment the board number
  1388 000006AA EB81                            jmp     .3
  1389                                  .7:
  1390 000006AC 89F0                            mov     ax,si
  1391                                  %if TRACE
  1392                                          call    bout
  1393                                          call    crlf
  1394                                  %endif
  1395 000006AE 8936[6203]                      mov     [nboards],si
  1396 000006B2 09F6                            or      si,si
  1397 000006B4 7426                            jz      init_error
  1398                                  
  1399 000006B6 FF36[7003]                      push    word [handle_count]
  1400 000006BA FF36[D802]                      push    word [frame]
  1401 000006BE 68[CC08]                        push    fmt3
  1402 000006C1 E80701                          call    fprint
  1403 000006C4 83C406                          add     sp,6
  1404                                  
  1405 000006C7 B80001                          mov     ax,DONE
  1406 000006CA BA[C205]                        mov     dx,free_below_here                      ; address of driver end
  1407                                  
  1408                                  ; DS will not be used beyond this point in the code
  1409                                  ; Use DS to set the int 67h vector
  1410 000006CD 6A00                            push    0
  1411 000006CF 1F                              popm    ds
  1412 000006D0 C7069C01[3000]                  mov     word [67h*4],bios_call_67h
  1413 000006D6 8C0E9E01                        mov     word [67h*4 + 2],cs
  1414 000006DA EB05                            jmp     save_it
  1415                                  
  1416                                  init_error:
  1417 000006DC B80C80                          mov     ax,800Ch        ; general failure
  1418 000006DF 31D2                            xor     dx,dx           ; don't install the driver
  1419                                  save_it:
  1420 000006E1 2689570E                    es  mov     word [bx+rq_ret_freemem],dx             ; **
  1421 000006E5 268C4F10                    es  mov     word [bx+rq_ret_freemem+2],cs           ; **
  1422 000006E9 E951FD                          jmp     finish          ; exit
  1423                                  ; note:  DS is not referenced any more at 'finish'
  1424                                  
  1425                                  
  1426                                  ; reduce the size of board 0
  1427                                  ;       DH = board number in high 4 bits
  1428                                  ;       BX = pointer to the map_block
  1429                                  ;
  1430                                  reduce_board:
  1431 000006EC F6C6F0                          test    dh,0F0h         ; is it board 0
  1432 000006EF 754E                            jnz     .99
  1433                                  
  1434 000006F1 515250                          pushm   ax,dx,cx
  1435 000006F4 30D2                            xor     dl,dl           ; start at address 0
  1436                                  .1:
  1437 000006F6 E88FFD                          call    get             ; get the mapping
  1438                                  %if TRACE
  1439                                          call    bout
  1440                                          cmp     dl,32-1
  1441                                          jne     .11
  1442                                          call    crlf
  1443                                  .11:
  1444                                  %endif
  1445 000006F9 3CFF                            cmp     al,255
  1446 000006FB 740A                            je      .4
  1447 000006FD 3A4701                          cmp     al,[bx+map_start]       ; is it allocated
  1448 00000700 7505                            jne     .4
  1449 00000702 FE4701                          inc     byte [bx+map_start]     ; remove block from available
  1450 00000705 FE0F                            dec     byte [bx+map_count]     ; it is allocated
  1451 00000707 FEC2                    .4:     inc     dl
  1452 00000709 80FA40                          cmp     dl,64           ; 64 memory map slots
  1453 0000070C 72E8                            jb      .1
  1454                                  
  1455                                  %if TRACE
  1456                                          call    crlf
  1457                                  %endif
  1458                                  
  1459                                  %if 1
  1460 0000070E A1[D802]                        mov     ax,[frame]
  1461 00000711 C1E802                          shr     ax,10-8           ; get start in AH
  1462 00000714 88E2                            mov     dl,ah
  1463 00000716 80C203                          add     dl,3            ; last slot in frame
  1464                                  .6:
  1465 00000719 E86CFD                          call    get             ; get mapping
  1466 0000071C 3CFF                            cmp     al,255          ; is it unassigned
  1467 0000071E 7416                            je      .7
  1468 00000720 88C5                            mov     ch,al           ; page#
  1469 00000722 B0FF                            mov     al,255
  1470 00000724 E840FD                          call    put             ; make it unavailable
  1471 00000727 B101                            mov     cl,1            ; count
  1472                                  %if 0
  1473                                  	mov     di,[map_avail]  ; add to list of available pages
  1474                                          call    add_to_list
  1475                                          mov     al,ch
  1476                                          cmp     di,-1
  1477                                  %else
  1478 00000729 8B3E[DC02]              	mov     di,[map_avail]  ; add to list of available pages
  1479 0000072D 88E8                            mov     al,ch	      	; save page # in AL
  1480 0000072F E875FD                          call    add_to_list2
  1481 00000732 893E[DC02]              	mov     [map_avail],di  ; add to list of available pages
  1482                                  %endif
  1483                                  ;;;        jne     init_error
  1484 00000736 FECA                    .7:     dec     dl
  1485                                  
  1486                                  %if 0
  1487                                          xchg    ah,dl
  1488                                          call    wout
  1489                                          xchg    ah,dl
  1490                                          call    wout
  1491                                          call    crlf
  1492                                  %endif
  1493 00000738 38E2                            cmp     dl,ah           ; compare to beginning
  1494 0000073A 73DD                            jae     .6
  1495                                  %endif
  1496                                  
  1497 0000073C 585A59                          popm    ax,dx,cx
  1498                                  .99:
  1499 0000073F C3                              ret
  1500                                  
  1501                                  
  1502                                  ; figure the size of the board (known to be present)
  1503                                  ;       DH = board number in the high 4 bits
  1504                                  ;
  1505                                  ;       C = 0 means no error
  1506                                  ;       C = 1 means an error occurred
  1507                                  ;
  1508                                  ;       AX = index of the memory block (0 .. NUM_MAP_BLKS-1)
  1509                                  ;
  1510                                  size_board:
  1511 00000740 5157                            pushm   di,cx
  1512 00000742 B0FF                            mov     al,255                  ; highest page number
  1513 00000744 B900FF                          mov     cx,0FF00h               ; 
  1514                                  .1:
  1515 00000747 FEC8                            dec     al
  1516 00000749 E82400                          call    page_present            ; is page present
  1517 0000074C 73F9                            jnc     .1
  1518                                  ;;;        call    dot
  1519 0000074E FEC1                            inc     cl
  1520 00000750 FF06[6403]                      inc     word [npages]   ; count total pages
  1521 00000754 88C5                            mov     ch,al
  1522                                  
  1523 00000756 08C0                            or      al,al           ; set C=0
  1524 00000758 75ED                            jnz     .1              ; loop through all of them
  1525 0000075A F5                              cmc                     ; set C=1
  1526 0000075B F5                      .6:     cmc
  1527 0000075C 19C0                            sbb     ax,ax           ; save the Carry
  1528 0000075E 8B3E[DC02]                      mov     di,[map_avail]
  1529                                  %if 0
  1530                                          push    ax
  1531                                          mov     ax,di
  1532                                          call    wout
  1533                                          pop     ax
  1534                                  %endif
  1535                                  %if 0
  1536                                          call    add_to_list
  1537                                  %if 0
  1538                                          push    ax
  1539                                          mov     ax,di
  1540                                          call    wout
  1541                                          pop     ax
  1542                                  %endif
  1543                                          cmp     di,-1
  1544                                          je      .8
  1545                                          mov     [map_avail],di  ;
  1546                                  .8:
  1547                                  %else
  1548 00000762 E842FD                          call    add_to_list2
  1549 00000765 893E[DC02]                      mov     [map_avail],di  ;
  1550                                  %endif
  1551 00000769 D1E8                            shr     ax,1            ; restore the Carry
  1552 0000076B 89F8                            mov     ax,di           ; compute the index
  1553 0000076D 5F59                            popm    di,cx
  1554 0000076F C3                              ret
  1555                                  
  1556                                  ; Return Page Present flag (Carry==1)
  1557                                  ;       DH = board number in the high 4 bits
  1558                                  ;       AL = page number (0..FE)
  1559                                  ;
  1560                                  page_present:
  1561 00000770 515250                          pushm   ax,dx,cx
  1562 00000773 1E                              pushm   ds
  1563                                  %if 0
  1564                                          push    ax
  1565                                          mov     al,dh
  1566                                          call    bout
  1567                                          pop     ax
  1568                                          call    bout
  1569                                  %endif
  1570 00000774 88C4                            mov     ah,al                   ; save the page to be tested
  1571 00000776 B228                            mov     dl,TEST_FRAME>>10
  1572 00000778 E80DFD                          call    get
  1573 0000077B 86E0                            xchg    ah,al                   ; save present setting in AH
  1574 0000077D E8E7FC                          call    put                     ; set the map
  1575 00000780 6800A0                          push    TEST_FRAME
  1576 00000783 1F                              popm    ds
  1577                                  .1:
  1578 00000784 8B0E0000                        mov     cx,word [0]     ; save contents
  1579 00000788 C70600006CA5                    mov     word [0],0a56ch ; addressing is [DS:0]
  1580 0000078E 89DB                            mov     bx,bx
  1581 00000790 89C0                            mov     ax,ax           ; waste time
  1582 00000792 813E00006CA5                    cmp     word [0],0a56ch ; see if it is the same
  1583 00000798 7521                            jne     .8
  1584 0000079A 890E0000                        mov     word [0],cx     ; restore
  1585 0000079E 8B0EFC03                        mov     cx,word [1020]
  1586 000007A2 C706FC03325A                    mov     word [1020],05a32h  ; address [DS:1020]
  1587 000007A8 89C0                            mov     ax,ax
  1588 000007AA 89DB                            mov     bx,bx
  1589 000007AC 813EFC03325A                    cmp     word [1020],05a32h
  1590 000007B2 7507                            jne     .8
  1591 000007B4 890EFC03                        mov     word [1020],cx  ; restore
  1592                                  ;  if words are equal, the carry is clear because there was no borrow
  1593 000007B8 F8                              clc
  1594 000007B9 EB01                            jmp     .9
  1595                                  
  1596                                  ; Memory test succeeded at the address
  1597                                  .8:
  1598 000007BB F9                              stc             ; flag not present (C=1; will be complemented C=0)
  1599                                  .9:
  1600 000007BC F5                              cmc             ; zero Carry on equal (memory present) made C=1
  1601 000007BD 1F                              popm    ds
  1602 000007BE 19C9                            sbb     cx,cx
  1603 000007C0 86E0                            xchg    ah,al
  1604 000007C2 E8A2FC                          call    put
  1605 000007C5 D1E9                            shr     cx,1
  1606 000007C7 585A59                          popm    ax,dx,cx
  1607 000007CA C3                              ret
  1608                                  
  1609                                  ;  Formatted string print
  1610                                  ;       C-calling convention
  1611                                  ;               fprint(fmt, ...)
  1612                                  ;       String is NUL terminated
  1613                                  ;       Escape character is '$'
  1614                                  ;               Escapes are:    $d      decimal value
  1615                                  ;                               $X      hex word
  1616                                  ;                               $x      hex byte
  1617                                  ;                               none others at this time
  1618                                  fprint:
  1619 000007CB 55                              push    bp
  1620 000007CC 89E5                            mov     bp,sp
  1621 000007CE 565350                          pushm   ax,bx,si
  1622                                  
  1623 000007D1 8B7604                          mov     si,[bp+4]       ; get format string pointer
  1624 000007D4 8D5E06                          lea     bx,[bp+6]       ; get argument pointer pointer
  1625                                  .1:
  1626 000007D7 AC                              lodsb                   ; get byte
  1627 000007D8 08C0                            or      al,al           ; test for end of string
  1628 000007DA 7434                            jz      .9
  1629 000007DC 3C24                            cmp     al,'$'          ; test for escape
  1630 000007DE 752B                            jne     .7
  1631                                  
  1632 000007E0 AC                              lodsb                   ; get format character
  1633 000007E1 3C64                            cmp     al,'d'          ; decimal value
  1634 000007E3 750A                            jne     .2
  1635                                  ; print a decimal value
  1636 000007E5 368B07                      ss  mov     ax,word [bx]
  1637 000007E8 43                              inc     bx
  1638 000007E9 43                              inc     bx
  1639 000007EA E8D5FD                          call    dout            ; decimal value
  1640 000007ED EBE8                            jmp     .1
  1641                                  .2:
  1642 000007EF 3C58                            cmp     al,'X'          ; hexadecimal word?
  1643 000007F1 750A                            jne     .3
  1644 000007F3 368B07                      ss  mov     ax,word [bx]
  1645 000007F6 43                              inc     bx
  1646 000007F7 43                              inc     bx
  1647 000007F8 E8E0FD                          call    wout            ; hex word printed
  1648 000007FB EBDA                            jmp     .1
  1649                                  .3:
  1650 000007FD 3C78                            cmp     al,'x'          ; hexadecimal byte?
  1651 000007FF 750A                            jne     .4
  1652 00000801 368B07                      ss  mov     ax,word [bx]
  1653 00000804 43                              inc     bx
  1654 00000805 43                              inc     bx
  1655 00000806 E8D9FD                          call    bout            ; hex byte printed
  1656 00000809 EBCC                            jmp     .1
  1657                                  .4:
  1658                                  .7:
  1659 0000080B E8E9FD                          call    putchar         ; not special, put out the character
  1660 0000080E EBC7                            jmp     .1
  1661                                  .9:
  1662 00000810 585B5E                          popm    ax,bx,si
  1663 00000813 C9                              leave
  1664 00000814 C3                              ret
  1665                                  
  1666 00000815 0D0A                    fmt1:   db      CR,LF
  1667 00000817 344D65676162797465-             db      "4Megabyte Expanded Memory (4MEM / LIM EMS 3.2) manager for the SBC-188"
  1667 00000820 20457870616E646564-
  1667 00000829 204D656D6F72792028-
  1667 00000832 344D454D202F204C49-
  1667 0000083B 4D20454D5320332E32-
  1667 00000844 29206D616E61676572-
  1667 0000084D 20666F722074686520-
  1667 00000856 5342432D313838     
  1668 0000085D 0D0A                            db      CR,LF
  1669 0000085F 202020202020202020-             db      "             driver version $d.$d", VERSION_SUFFIX
  1669 00000868 202020206472697665-
  1669 00000871 722076657273696F6E-
  1669 0000087A 2024642E2464       
  1670                                  %ifdef __DATE__
  1671                                  %ifdef __TIME__
  1672 00000880 2028323031372D3037-             db      " (",__DATE__," ",__TIME__,")"
  1672 00000889 2D30332031313A3430-
  1672 00000892 3A343229           
  1673                                  %endif
  1674                                  %else
  1675                                          db      "  (",DATE,")"
  1676                                  %endif
  1677                                  double_space:
  1678 00000896 0D0A                            db      CR,LF
  1679 00000898 0D0A00                          db      CR,LF,NUL
  1680                                  
  1681 0000089B 344D454D20626F6172-     fmt2:   db      "4MEM board[$d]   $d pages total, ",NUL
  1681 000008A4 645B24645D20202024-
  1681 000008AD 642070616765732074-
  1681 000008B6 6F74616C2C2000     
  1682 000008BD 246420617661696C61-     fmt2a:  db      "$d available"
  1682 000008C6 626C65             
  1683 000008C9 0D0A00                  fmt_NL: db      CR,LF,NUL
  1684                                  
  1685 000008CC 4672616D6520617420-     fmt3:   db      "Frame at $X with $d handles"
  1685 000008D5 245820776974682024-
  1685 000008DE 642068616E646C6573 
  1686 000008E7 0D0A00                          db      CR,LF,NUL
  1687                                  
  1688                                  
  1689                                  
